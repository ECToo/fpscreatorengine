{\rtf1\ansi\ansicpg1252\deff0\deflang2057\deflangfe2057{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}{\f1\fmodern\fprq1\fcharset0 Courier New;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sa200\sl276\slmult1\ul\f0\fs22 Addendum\ulnone\par
This document supplements the original manual and provides additional information on the latest features of FPS Creator.\par
\ul FPI Actions\par
\ulnone Below is a full list of the additional actions and conditions that extend the original version of the FPI script system. Many thanks go to the endeavours of the FPSC community who took the original FPSC source code and added their own cool features over the years:\par
Actions\par
\pard globalvar\par
localvar\par
setvar\par
incvar\par
decvar\par
selectshadervariable\par
setshadervariable\par
incshadervariable\par
decshadervariable\par
freeze\par
animationnormal\par
animationreverse\par
plrfreeze\par
plrdisable\par
talk\par
shapedecal\par
newjumpheight\par
musicoverride\par
weblink\par
setifused\par
setusekey\par
resetplrweapons\par
backdropvideo\par
bloodspurt\par
nobulletcol\par
isaltammo\par
bloodsplash\par
camshake\par
camfov\par
camfovinc\par
hideplrweapon\par
showplrweapon\par
plrpointatobject\par
fpgcrawtextr\par
fpgcrawtextg\par
fpgcrawtextb\par
fpgcrawtextx\par
fpgcrawtexty\par
fpgcrawtextsize\par
fpgcrawtextfont\par
fpgcrawtextoff\par
fpgcrawtext\par
etimerstart\par
addaiteam\par
allyfollow\par
aisettarget\par
aimoverandom\par
killally\par
killenemy\par
allowmove\par
setaiactive\par
alwaysactive\par
addzombie\par
aiaction\par
aifollowplr\par
aimovetosound\par
aimoveawayfromsound\par
aiaddpoint\par
aigotopoint\par
aicallteam\par
airespondtocall\par
aimovetocover\par
aimovetotarget\par
aistop\par
aiusemelee\par
aisetmeleedamage\par
airotatetotarget\par
airotatetosound\par
aiplrcallteam\par
aisetspeed\par
airespondtoplrcall\par
aiattackawareness\par
aicleartarget\par
aiusefullaim\par
aiseteyelevel\par
aiaddally\par
aiaddenemy\par
aiaddneutral\par
aiautofactionoff\par
\pard\sa200\sl276\slmult1 Conditions\par
\pard Plrblocking : true if player is performing a block action\par
inview : true if entity is within the current view of the camera\par
pickobject : true if entity is immediately in front of camera (centre screen)\par
velocitygreater : true if physics based entity velocity greater than value\par
etimergreater : true if entity timer greater than value\par
keypressed : true if value representing key is pressed\par
hasweapon : true if entity has a weapon\par
strafingleft : true if DarkAI entity is strafing left\par
strafingright : true if DarkAI entity is strafing right\par
movingforwards : true if DarkAI entity is moving forwards\par
movingbackwards : true if DarkAI entity is moving backwards\par
idle : true if DarkAI entity is in an idle state\par
aicanshoot : true if DarkAI entity can shoot its target\par
ducking : true if DarkAI entity is ducking\par
aiheardsound : true if DarkAI entity has heard a sound\par
aiaction : true if DarkAI entity is performing the action specified by value\par
isdarkai : true if entity is a DarkAI entity\par
aiteam : true if DarkAI entity belongs to team specified by value\par
aiatpoint : true if DarkAI entity is at a specific point\par
aicalled : true if DarkAI entity has been called\par
aitargetdistwithin : true if DarkAI entity target is within the range specified by value\par
aitargetdistfurther : true if DarkAI entity target is further than the range specified by value\par
aiatcover : true if DarkAI entity is in cover\par
aicalledbyplr : true if DarkAI entity has been called by the player\par
aihastarget : true if DarkAI entity has a target lock\par
runningforwards : true if DarkAI entity is running forwards\par
\par
\pard\sa200\sl276\slmult1\ul Particle Decal System\par
\ulnone Built on the foundation of the existing decal system, a new type of decal allows the spawning of particles and those particle properties can be changed to suit your game. Below is a step by step guide to creating your own particle effects:\par
\pard\fi-360\li720\sa200\sl276\slmult1 1.\tab Start the software with a blank level and create a simple floor\par
2.\tab Go to Add New Entity and select GENERIC  / DECALS / DUSTPUFF\par
3.\tab Add this decal to the scene, then right click it to enter the properties dialog\par
4.\tab Change the main AI script from DECAL.FPI to DECALPARTICLE.FPI\par
5.\tab Leave CUSTOM SETTINGS to YES\par
6.\tab Change the values in the Decal Particles group then run test game to see results\par
\pard\sa200\sl276\slmult1\i Decal Particle Properties\par
\pard\i0 offsety : Vertical adjustment of the start position\par
scale : A value from 0 to 100, denoting size of particle\par
randomstartx : Random start area\par
randomstarty : Random start area\par
randomstartz : Random start area\par
linearmotionx : Constant motion direction\par
linearmotiony : Constant motion direction\par
linearmotionz : Constant motion direction\par
randommotionx : Random motion direction\par
randommotiony : Random motion direction\par
randommotionz : Random motion direction\par
mirrormode : Set to one to reverse the particle\par
camerazshift : Shift particle towards camera\par
scaleonlyx : Percentage X over Y scale\par
lifeincrement : Control lifespan of particle\par
alphaintensity : Control alpha percentage of particle\par
\pard\sa200\sl276\slmult1\ul\par
Bloom and Depth of Field\par
\ulnone A new post processing system has been integrated to allow the final game screen to be processed through a final screen shader to create various visual effects. The default effect is Bloom which will saturate the screen with a soft glow around those areas of the screen which are bright. A second effect called Depth of Field is also available which blurs distant parts of the scene to bring objects in the foreground to greater focus. You can also switch off the post processing effect entirely to save performance for older systems. You can change this mode by opening the SETUP.INI file located alongside the main FPSCreator.exe and changing the field called POSTPROCESSING.\par
\ul The SETUP.INI File\par
\ulnone There are many aspects of the editor and game that can be tweaked outside of the design of the level and the FPI scripts. The SETUP.INI file contains numerous flags which you can change to alter the behaviour of the software. A full description of the flags can be found in the associated file SETUPDESCRIPTION.TXT.\par
\ul Virtual Memory Cap\par
\ulnone A new memory readout and cap has been added to the test and build process to give you a greater understanding about how much system memory your level is consuming. A larger level requires more memory to store all the textures, level data and sounds and at some point this inevitably runs out. In order to gracefully report when this memory is exceeded, a cap has been introduced which warns you when your level consumes more than 1.8GB of virtual address space.  As the engine is based on 32-bit code, any level cannot consume more than this amount irrespective of the actual amount of memory available to the system. To ensure you never reach the cap, a new resource panel  is been provided in the test game which you can call up by pressing the TAB key. The bottom bar shows the amount of virtual address space being used at that moment, so when the bar nears full start thinking about creating a second level to progress your game.\par
\ul Getting Characters To Think\par
\ulnone Characters have new powers of intellect thanks to the introduction of DarkAI into FPSC, and with a few tweaks to their properties can become allies, enemies, neutral or grouped into factions. They also have enhanced path finding skills and an increased sense of survival and combat. Below is a step by step procedure to activating a character to use the new DarkAI system:\par
\pard\fi-360\li720\sa200\sl276\slmult1 1.\tab Start the software with a blank level with a simple floor\par
2.\tab Click Add New Entity and select SCIFI / CHARACTERS / AI (Shotgun)\par
3.\tab Add this character to your level twice, some distance from each other\par
4.\tab Right click the first character and change the appear AI script from \b appear1.fpi\b0  to \b Dark AI/ appear-ally-team1.fpi\b0  and change the main AI script from \b People/Pace10.fpi\b0  to \b Dark AI/ main-weapon.fpi \b0\par
5.\tab Also delete the shoot AI script entry as this is not used by the above scripts\b\par
\b0 6.\tab Finally click Apply Changes to finish configuring this new AI Ally character\b\par
\b0 7.\tab Repeat steps 4-6 with the second character, but instead of choosing \b appear-ally-team1.fpi\b0  you chose \b appear-enemy-team1.fpi\par
\b0 8.\tab You can now run the test game, run up to the Ally, press G to recruit and attack the enemy\b\par
\pard\sa200\sl276\slmult1\ul\b0 Getting Characters To Climb Stairs\par
\ulnone Now your character is running around happily, you will soon realise they are not following you up and down stairs as the original characters once did. This default behaviour was intended, allowing you control over whether characters could follow you into new sections of your level. Granting the ability of characters to move up and down stairs is relatively simple by following the steps below:\par
\pard\fi-360\li720\sa200\sl276\slmult1 1.\tab Follow the steps outlined in \lquote Getting Characters To Think\rquote  to create a simple A vs E level\par
2.\tab Click Add New Segment and select SCIFI / PLATFORMS / STAIRCASE METAL\par
3.\tab Add a staircase in the centre of the level floor you created earlier\par
4.\tab Move up one layer by pressing the PLUS [+] key and then select the GROUND segment\par
5.\tab Paint a second floor that meets the top of the staircase with enough room to run around\par
6.\tab Now click the \lquote Create New Waypoint\rquote  icon (third from the right in the toolbar)\par
7.\tab This will create a waypoint node. Click and hold the node and drag it to the centre of the segment that meets the top of the staircase (do not place it right on the edge at the top of the stairs as you want the node to represent the floor segment, not the staircase)\par
8.\tab Hold down SHIFT key and then left click on the node you just dragged\par
9.\tab It will create a second node linked to the first. As before, click and hold this second node and then (without releasing the left mouse button), press the MINUS [-] key.\par
10.\tab Whilst still dragging the second node, position it in the centre of the segment that represents the bottom of the stairs (not on the stairs, or below the stairs, but the floor segment that the player would stand on once they have fully descended the stairs)\par
11.\tab Now click the test game, recruit the ally (by pressing G) and run up the stairs. Your ally should follow you, and if the enemy catches sight of you, so should he!\par
\pard\sa200\sl276\slmult1\ul Getting Characters To Go Through Certain Doors\par
\ulnone Now your new DarkAI character is following you almost everywhere, you may have noticed that they stop at certain door segments and proceed no further.  This is the intended behaviour, and is the result of the way the stock doors have been designed. By default most stock doors will allow the character to pass though, but some doors will prevent entrance.  If you are a designer of your own door segments, you must bear in mind that only doors that use a CSG punch mesh that starts with the four letters \ldblquote door\rdblquote  will instruct the DarkAI obstacle system to recognise the segment as a door and allow characters to pass though. In the segment FPS file, here is an example of a correctly named CSG punch mesh which allows DarkAI to recognise this door:\par
\f1 partmode2       = 1\par
meshname2       = meshbank\\scifi\\scenery\\doors\\door_b\\\ul\b\i door\ulnone\b0\i0 _b_punch.x\par
\ul\f0 Getting Characters To Talk\par
\ulnone 1. Locate this folder - files/audiobank/darkvoices. This has a converter app in it called ConvertAllWAVFiles.exe\par
2. Now place all of your wav files you wish to convert to lipsync files inside this folder\par
3. Execute the convert app\par
4. All of the wave files will now have an associated lipsync file for it\par
5. Place the wav files along with the lipsync files wherever you want to access them\par
6. Now open up your talking characters fpe file. You will see the following\par
\f1 ;ai\par
aiinit\tab    = appear1.fpi\par
aimain\tab    = behaviours\\greet player.fpi\par
aidestroy     = destroy\\fadecorpse.fpi\par
soundset      = male\par
soundset1     = audiobank\\darkvoices\\canihelpu.wav\par
\f0 7. Point soundset1 to the talking wav file you wish to use\par
8. Use the fpi file that is in scriptbank/behaviours folder. This is just a generic (template) fpi for talking characters. You will probably want to edit it for your own use of the character\par
\pard 9. If you are having problems generating a LIPSYNC file, try downloading the SAPI SDK from Microsoft at: {\field{\*\fldinst{HYPERLINK "http://download.microsoft.com/download/B/4/3/B4314928-7B71-4336-9DE7-6FA4CF00B7B3/SpeechSDK51.exe"}}{\fldrslt{\ul\cf1 http://download.microsoft.com/download/B/4/3/B4314928-7B71-4336-9DE7-6FA4CF00B7B3/SpeechSDK51.exe}}}\f0\fs22\par
\pard\sa200\sl276\slmult1 10. Be aware that only characters from the default stock character which are entitled (Talker) can use the lipsync data to animate the mouth, older stock characters cannot as they would require extra bone data in the head of the character model.  Assume that all FPSC characters cannot use the lipsync data unless they have been expressly designed with the additional mouth bone system in mind.  For reference, all characters in model packs 44 and 45 allow full lipsync control.\par
\ul Getting A Crate To Spawn On A Trigger\par
\ulnone 1. Create a floor, a light source, a trigger zone and crateA from the scifi entity category\par
2. Change the trigger zone main script to PLRINZONEACTIVATEUSED.FPI and add crateA to the IFUSED field\par
3. Edit the RESPAWN details of the crateA entity to the following; \par
\f1 No, 99, 99, Yes, No, 50, 0, 1, 0, 0, 0, 90, 0, 0\par
\f0 4. Remember to APPLY CHANGES after editing the entity properties and run test game\par
5. As soon as the player steps into the trigger zone, the crate should slowly spawn 99 crates\par
\ul Crash when use POSTPROCESSING=2 with some HUD models\par
\ulnone From V117, a new post processing mode (2) allows depth of field effects in the final game render, but has the side effect of being incompatible with some graphics systems when using certain HUD models. If this crash occurs for you, simply change the postprocessing=1.\par
Automated feature -Some characters, most notable Bond1's excellent models often include hard modelled melee weapons. The code automatically detects if you want the model to use another weapon and hides the melee weapon. Models must however use the \par
default FPSC limb naming convention: MELEE-WEAPON-LEFT or MELEE-WEAPON-RIGHT.\par
\ul Video Splash\ulnone\par
Added Splash.avi video option.\par
\ul Additional FPI actions and conditions\par
\ulnone playfullvideo=x \endash  X=1, plays the full version of the next video called by video=x, preventing the player interrupting the playback.\par
plrwobble=x \endash  sets the amount of 'wobble' affecting the player as they move around.\par
plrdeath=x \endash where X equal the direction of fall for the player\par
X=1 Fall left\par
X=2 Fall right\par
X=3 Fall forward\par
X=4 Fall backwards\par
X=5 Fall randomly\par
plrdeathspeed=x where x is the speed of the players fall.\par
plrdeathbounce=x where x is the amount of 'shake' when the player hits the floor.\par
plraction=X \endash  Forces a one off player action\par
X=1 Fires current weapon\par
X=2 Zooms current weapon\par
X=3 Reloads current weapon\par
X=4 Crouches player\par
X=5 Jumps player\par
X=6 Peeks player left\par
X=7 Peeks player right\par
X=8 Forces \ldblquote use\rdblquote  key\par
X=9 Forces left mouse click\par
X=10 Forces right mouse click\par
X=11 Forces current weapon jam\par
plrforcemove=X \endash  if positive, turns on auto move forward for player, a negative value forces an auto move backwards as if the appropriate movement key had been pressed. A setting of 0 (the default) disables auto move\par
Emitforce=x emits X amount of force from the current entity as a pulse. In a range of 0.0+ (default 1.0)\par
Forcedamageon=x 1=allows force damage (the default) any other number prevents damage\par
mousesclick=x (condition) \endash  Returns the current mousestate.\par
X=1 returns true if left button is depressed\par
X=2 returns true if right button is depressed\par
X=3 returns true if both left and right buttons are depressed\par
crosshair=x, where 1 displays a crosshair if available and x=0 disables them. The default is on\par
weapontoslot=x where X is the next weapon slot to be used, X=0, use next free slot.\par
Armon = x 1=Turn on body armour, 0=No body armour, damage\par
is deducted from armour before health.\par
SetArmx=x, X cord of the armour display\par
SetArmy=x, Y cord of the armour display\par
SetArm=x, Sets body armour value to X\par
ArmInc=X, add X to your current body armour\par
ArmDec=X, subtract X from your current armour.\par
Airon=X - X=0 is off, X=1 acts like an aqualung. X=2 acts like lungs, restoring air to the amount set by SetAirMax when you surface.\par
Addair=X - Add x to air\par
Setair=X - Sets air to X\par
Setairx=X - Sets air display X cord to X\par
Setairy=X \endash  Sets air display Y cord to X\par
Setairmax=X \endash  sets the maximum air allowed.\par
Setair=X - Sets air to X\par
Setairtime=X \endash  Where X is the number of milliseconds underwater before air is reduced\par
Setdrowntime=X - Where X is the number of milliseconds underwater before drowning damage occurs.\par
Instantdrown=x \endash  If X=1 (default) running out of air results ininstant death, otherwise x=0 reduces heath.\par
AirGreater=x (condition) - returns true if air is greater than X.\par
AirLesser=x (condition) - returns true if air is less than X.\par
AirEqual=x (condition) - returns true if air equals X.\par
Samefloorasplr(condition)  - returns true if the entity is on the same floor as the player.\par
Entityfloorequal=x - returns true if the entity is on floor X\par
plrfloorequal=x - returns true if the player is on floor X\par
plrsetimmune=x, when set the anything other than 0, player is immune from all damage!\par
plrisimmune (condition)\endash  returns true if the player is immune from damage.\par
Arrowkeys=X - toggles use of the arrow keys for movement\par
Peekkey= X - toggles use of the the peek keys\par
Crouchkey= X - toggles use of the crouch key\par
Jumpkey= X - toggles use of the jump key\par
Walkkey=X - toggles use of the walk key for movement\par
Runkey=x - toggles use of the walk key for movement\par
Setforcedamage \endash  Sets the amount of damage the next force burst will cause.\par
Compasson = Turns on the compass\par
Compassoff= Turns off the compass\par
CompassX = Compass x coordinate on screen\par
CompassY = Compass y coordinate on screen\par
Compassspin = Sets the compass to spin rather than the needle\par
Needlespin = Sets the needle to spin rather than the compass.\par
radaron=x, where 1 turns on the dark radar feature, using blip1.png,blip2.png, etc, stored in databank to represent teams (1-10)  non Dark AI's blips show as enemy (blip2)\par
radarx=x the radar x cord of the radar centre\par
radary=x the radar y cord of the radar centre\par
rotateblip=x, 1= enables radar blip to show entity facing\par
radarrange=x the range that entities show on the radar in segments\par
plrspeedmod=x where x adjusts the player speed by X%\par
AddRawText = String, Adds the string to the current RawText text.\par
Setisobjective, the object is set as the objective. A pointer, using the same format as the radar and the compass will point in the direction of the objective. Entities and Characters can all be\par
set as objectives. This is NOT the same as the isobjective in an objects settings.\par
setobjectivex=x. Where x= the x coordinate of the centre of the objective pointer\par
setobjectivey=x. Where x= the y coordinate of the centre of the objective pointer\par
setobjectivemode=x where x=0 hide objective set objective, x=1 always show, x=2 show on same floor only.\par
setvarrnd=x or setvarrnd=var x. sets system variable or named var to a random value between 0 and x\par
Randomize - resets the rnd seed to the timer\par
Emptyreloadonly (gunspec) - Won't allow reload until weapon is empty. E.g. M1 Garand, flintlock, etc.\par
setmaxweapons=x - sets the maximum number of weapons allowed in the players inventory. Exceeding X prevents pick up.\par
plrweaponsgreater=x (condition) - returns true if weapons in inventory is greater than X\par
plrweaponslesser=x (condition) -  returns true if weapons in inventory is less than X\par
plrweaponsequal=x (condition) - returns true if weapons in inventory is equal to X\par
$ARM = system variable armour\par
$AIR = system variable air\par
$FPS = system variable FPS\par
$WAT = system variable water height\par
$MAX = system variable maximum weapons slots\par
entitydamagemult=x multiplies the entities damage by x%\par
weaponinslot=x (condition) - returns true if slot X contains a weapon\par
playerstrength=x - multiplies the players strength by X%\par
currentweapon=x (condition) - returns true if the currently held weapon is in slot X\par
cullmode=X - 0=Legacy culling, 1=Legacy+dynamic entity cull based on entity size- default, x=1 and system calculated cull range\par
cullrange=X - when cullmode=1 sets the range the entity will be culled at, overriding system defaults\par
hide - hides the current entity\par
show - shows the current entity\par
cullmod=x - where x is the multiplier for the new culling - x=default 400, while entity size dependant 100=approximately 1 segment.\par
$DIS - returns the current entities distance from the player.\par
Increased maximum radar blips to 20 to bring in line with maximum AI teams.\par
Changes to cull system to improve performance and added entity fade for smoother appearence.\par
plrisrunning=x (condition) - X=1 returns true if the player is running, x=0 returns true if player not running.\par
plriszoomed=x (condition) - X=1 returns true if player weapon currently zoomed, X=0, returns true if weapon not zoomed\par
plrisusingreload=X (condition) -  returns true if reload pressed\par
plriscrouching=x (condition) - X=1. returns true if player crouched, x=0 returns true if player not crouching\par
plrisonground=x (condition) - X=1 and player is on ground returns true, X=0 and player is not on ground returns true.\par
plrisjumping=x (condition) x=1 returns true if player is jumping, x=0 returns true if player is not jumping.\par
swaptoalt - swaps to alt fire on the current weapon\par
firemode=x (condition) - returns true if current firemode=x, 0=normal, 1=alt fire mode\par
plrrotatex=x - rotate camera angle x to X\par
plrrotatey=x - rotate camera angle y to X\par
entrotatex=x - rotate entity angle x to x\par
entrotatey=x - rotate entity angle y to x\par
entrotatez=x - rotate entity angle z to x\par
moveplrx=x - adds a one off X to players X velocity\par
moveplry=x - adds a one off X to players Y velocity\par
moveplrz=x - adds a one off X to players Z velocity\par
$DIF - returns the current entities real world distance in feet from the player.\par
$DIM - returns the current entities real world distance in metres from the player.\par
onradar=x (condition) returns true if character on radar and x=1, else returns true if x=0 and character not on the radar.\par
scale=x or scale=x y - scales characters to scale X or scale X+ a value between 0-Y\par
plrlastfired=x (condition) returns true if weapon path X is the last player weapon fired or x=the slot the weapon is carried in.\par
radargreater=x y (condition) returns true is an entites range on the radar is greater (in segment size) than x and Y=1, else returns true if range less than x and Y=0\par
radarequal=x y (condition) returns true is an entites range on the radar is equal (in segment size) to x and Y=1, else returns true if range does not equal x and Y=0\par
holster=x where x=1, player can swap/holster weapons as normal, x=0, player cannot holster or swap weapons.\par
globalnoair=x where X=1 set a global zero air, and x=0 sets air on. uses standard air settings otherwise.\par
setnoairdamage=x where x is the about of health lost when player has no air left.\par
gravitygun=x (gunspec) - turns weapon into gravity gun, allow plr to pick up an object with right click within range X, right click again, drops, left click throws\par
magnet=x (gunspec) - turns gravity gun into magnet, left click hurls held object towards player\par
gravitystrength=x (gunspec) - sets the psyhics weight the gravity gun will handle\par
magnetstrength=x (gunspec)  - sets the psyhics weight the magnet will handle\par
entityishigher=x (condition) - returns true if the entity is X units higher than the player\par
entityislower=x (condition) - returns true if the entity is X units lower than the player\par
entityfloorhigher=x (condition) - returns true if the entity is X floors higher than the player\par
entityfloorlower=x (condition) - returns true if the entity is X floors lower than the player\par
plrpickon=x, x=1 then allow player pick up with right click\par
plrpickrange=x, sets the range at which the player can pick up an entity with right click\par
emitflash - Emits a flash from an entity\par
setflashred=x - sets the next flashes red element\par
setflashgreen=x - sets the next flashes green element\par
setflashblue=x - sets the next flashes blue element\par
setflashrange=x - sets the flash range of the next flash emitted, default=600\par
flashing=x (condition) returns true if a spotflash is in process and x=1 or returns true if no spotflash is in process and x=0\par
logicburst - give entity temporary logic burst, effectively setting to always active for a few moments.\par
spawnsleft=x y (condition) returns true if spawnsleft=x and y=1 or returns true if spawnsleft<>x and y=0\par
spawnsgreater=x y (condition) returns true if spawns are greater than x and y=1 or returns true if spawns are less than x and y=0\par
damageby=X (condition) where X is either a weapon path (e.g. ww2/colt45)\par
 or the string "collision", "melee", "indirect", "flak" or "falling".\par
 or X= the slot number the weapon is carried in.\par
plrdamagemult=x where x is a multiplier for the current damage caused by the player.\par
plrnotzoomed (condition) - returns true if player is not zoomed\par
plrnotrunning (condition) - returns true if player is not running\par
plrnotjumping (condition) - returns true if player is not jumping\par
plrnotcrouched (condition) - returns true if player is not crouched\par
plrnotusingreload (condition) - returns true if player is not pressing reload\par
notonradar (condition) - returns true if entity is not on the radar\par
setlistkey=x y - X from list below, Y=new scan code\par
X= 1 = plrkeyW\par
x= 2 = plrkeyS\par
x= 3 = plrkeyA\par
x= 4 = plrkeyD\par
x= 5 = plrkeySpace\par
x= 6 = plrkeyC\par
x= 7 = plrkeyReturn\par
X= 8 = plrkeyR\par
X= 9 = plrkeyQ\par
x= 10= plrkeyE\par
X= 11= plrkeyShift\par
addrawvar=X where X=var name or number. Adds the named variable to the current rawtext string.\par
Added blood of floor for character V character\par
sin=x y - set variable X to sin of Y\par
cos=x y - set variable X to cos of Y\par
damagetimegreater=x - returns true of last entity damage time greater than X\par
scalehudx=X Y - rescales hud named X's X scale to Y\par
scalehudy=X Y - rescales hud named X's Y scale to Y\par
changehudalpha=X Y - changes hud X to alpha Y\par
jamchance=X.0 (gunspec) = percentage chance of a gun jammed due to overheat (Reloading clears jam)\par
overheatafter=x (gunspec) = the number of shots fired before the chance of jamming becomes active.\par
cooldown=x (gunspec) = time in millisecs between shots to completely prevent jamming\par
currentweaponjammed (condition) = returns true if the current weapon is jammed.\par
nosubmergedfire=x (gunspec) - prevents the weapon firing while underwater.\par
waterflow=x - sets the force of water flow effecting the player and entities if in water\par
watercurrent=x - sets the direction in angles of the water flow.\par
removeplrweapon=x where x is either the slot number or the weapon path e.g. scifi\\autoslug - removes the weapon from the player, freeing the slot.\par
giveplrweapon=x where x is the path of the weapon e.g. scifi\\autoslug. The weapon must exist somewhere in the level or will fail silently.\par
entitysetimmune=x - where x=1 set the entity to be immune from damage, x=0 set to receive damage\par
isentityimmune (condition) - returns true if current entity is immune\par
isentitynotimmune (condition)- returns true if current entity is not immune\par
resetglobalsonreload=x - x=0, carries default global variables over to the next level. X=1 resets default global variables on loading.\par
entitycam - moves camera to entity position, using entities rotation.\par
playercam - restores camera to player\par
lastcam - swaps to previous camera.\par
playgunanimation=x y - where x is the animation start frame and y is the animation end frame.\par
camrotationon=x if x=0 the camera uses the entities rotation, x=1 use user set rotation\par
setcamoffsetx=x - X offset for entity camera\par
setcamoffsety=x  - Y offset for entity camera\par
setcamoffsetz=x  - Z offset of entity camera\par
setcamrotx=x - X entity camera rotation if cam rotation on\par
setcamroty=x - Y entity camera rotation if cam rotation on\par
setcamrotz=x - Z entity camera rotation if cam rotation on\par
scalelimb=x y - scales limb X to scale y\par
1 = head\par
2 = left clavicle\par
3 = right clavicle\par
4 = left foot\par
5 = right foot\par
6 = left thigh\par
7 = right thigh\par
8 = left hand\par
9 = right hand\par
10 = left fore arm\par
11 = right fore arm\par
12 = left upper arm\par
13 = right upper arm\par
14 = spine base\par
15 = spine middle\par
16 = spine top\par
17 = neck\par
hidelimb=x - hides limb X\par
showlimb=x - shows limb x\par
\par
}
 