rem
rem FPS CREATOR GAME ENGINE - V1.07
rem Copyright (c) The Game Creators Ltd 2005-2008
rem
rem Used Under Public License:
rem  1. You CANNOT make 'game creation' or 'level editor' software with this code
rem  2. You CANNOT make a 'game engine' for the purpose of selling it as an engine
rem  3. You CAN make a GAME with this source code for the purpose of selling it
rem
rem Requires DBPro Upgrade 6.6 and the DarkLIGHTS Product (license purchased from www.thegamecreators.com)
rem Also requires that you overwrite plugin DLLs with the following:
rem plugins-licensed\EnhancementsFREE.dll
rem plugins-licensed\LightMapper.dll
rem plugins-user\DBProMultiplayerPlusDebug.dll
rem plugins-user\DBProODEDebug.dll
rem
rem To produce a smaller, faster EXE, change the SETUP.INI in the Compiler folder to:
rem [DIRECTIVES]
rem RemoveSafetyCode=Yes
rem SafeArrays=No
rem
rem DBPro: http://darkbasicpro.thegamecreators.com
rem FPSC: http://www.fpscreator.com
rem

rem App Independent Data
dim filecollection$()

rem Time stamp outside level scope reset
global timestampactivitymax=0
global timestampactivityflagged=0
global timestampactivityindex=0
dim timestampactivity$(1000)

rem FPSCV104RC9 - loading time readout to file
global gloadreportstate : gloadreportstate=0
global gloadreporttime : gloadreporttime=0
global gloadreportlasttime : gloadreportlasttime=0
global gloadreportindex : gloadreportindex=0
dim loadreport$(100000)

rem Data structure to old player save data
type saveplayerstatetype
 lives as integer
 health as integer
 weaponindexholding as integer
endtype
saveplayerstate as saveplayerstatetype
global hudhaveplayername as integer : hudhaveplayername=0
global localipaddress$ : localipaddress$=""
global serveripaddress$ : serveripaddress$=""
global playername$ : playername$=""

` FPSCV10X SAVE LOAD Data Structures
type saveloadtype
 saveloaddir$
 slothighlight
 saveloadimg
 saveloadx
 saveloady
 liney
 slotselected
 areyousure
 loadswitch
endtype
saveload as saveloadtype
dim saveloadslot$(9)
gosub _saveload_savebox_init

` FPSCV10X Game Position Data Structure
type saveloadgamepositiontype
 level
 playerx
 playery
 playerz
 playerry
 playerhealth
 playerlives
 playerinventorymax
 missiongoaltotal
endtype
type saveloadgamepositionentitytype
 spawnleaderid as integer
 ailibindex as integer
 aistate as integer
 aioldstate as integer
 active as integer
 dormant as integer
 beenkilled as integer
 x as float
 y as float
 z as float
 rx as float
 ry as float
 rz as float
 floorposy as float
 animset as integer
 animdo as integer
 currentammo as integer
 health as integer
 collected as integer
 activated as integer
 collisionactive as integer
endtype
type saveloadgamepositionweaponslottype
 pref got invpos
 weaponammo
 weaponclipammo
 weaponhud
endtype
saveloadgameposition as saveloadgamepositiontype
dim saveloadgamepositionplayerinventory(100) as inventorytype
dim saveloadgamepositionplayerobjective(99) as integer
dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
dim saveloadgamepositionweaponslot(10) as saveloadgamepositionweaponslottype
global gsaveloadobjectivesloaded : gsaveloadobjectivesloaded=0

rem Init FPSC then leap to SETUP.INI loader
leavegamedataalone=0
gosub _FPSC_Full_Data_Init
goto _FPSC_Setup

rem Subroutine to completely construct FPSCData
_FPSC_Full_Data_Init:

`
` Performance globals
`

rem performance counters
global gprogressmax as integer
global dim perf(20) as DWORD
global gameperftimetracker as DWORD
global gameperftimestamp as DWORD
global gameperftimestamp2 as DWORD
global gameperftimestamplocal as DWORD
global gameperftotalcountTOP as DWORD
global gameperftotalcount as DWORD
global gameperflighting as DWORD
global gameperfplayer as DWORD
global gameperfentities1 as DWORD
global gameperfentities2 as DWORD
global gameperfentities3 as DWORD
global gameperfentities4 as DWORD
global gameperfentities5 as DWORD
global gameperfentities as DWORD
global gameperfgun as DWORD
global gameperfmisc as DWORD
global gameperfdebug as DWORD
global gameperfresttosync as DWORD
global gameperfphysics as DWORD
global gameperfsync as DWORD
global deactivatecollision=0
global entitysystemdisabled=0
global lightingsystemdisabled=0
gameperftimetracker=timer()

rem logic control
global logicprioritycount=0
global logicprioritymax#=0.0

rem memory counters
dim mshot(500)
global mshoti=0
global mshotmem=0
global mshotfirst=0
global mshotmemlargest=0
global lastmshoti=0
global lastmshotmem=0

rem workload counters
dim wshot(400,4)
dim wshotmax(4)
global wshoti=0


`
` Editors Data
`

rem Input Control System Data Structure
type inputsystemtype
 activemouse as integer
 xmouse as integer
 ymouse as integer
 xmousemove as integer
 ymousemove as integer
 wheelmousemove as integer
 mclick as integer
 lockdown as integer
 k$ as string
 mmx as integer
 mmy as integer
 localx# as float
 localy# as float
 kscancode as integer
 keypress as integer
 keycontrol as integer
 keyreturn as integer
 keyshift as integer
 keyleft as integer
 keyright as integer
 keyup as integer
 keydown as integer
 keyspace as integer
 constructselection as integer
 dorotation as integer
 domirror as integer
 doflip as integer
 doload as integer
 dosave as integer
 doopen as integer
 donew as integer
 donewarena as integer
 dosaveas as integer
 dosaveandrun as integer
 domodepaint as integer
 domodeselect as integer
 domodeart as integer
 domodeentity as integer
 domodewaypoint as integer
 dowaypointview as integer
 doentityrotate as integer
 dozoomin as integer
 dozoomout as integer
 doshrouddecrease as integer
 doshroudincrease as integer
 doshroudfull as integer
 doscrollleft as integer
 doscrollright as integer
 doscrollup as integer
 doscrolldown as integer
 domapresize as integer
 dolayerchange as integer
 dogroundmode as integer
 doundo as integer
 doredo as integer
 domapview as integer
 dozoomview as integer
 doautozoomview as integer
 dozoomviewmovex as integer
 dozoomviewmovey as integer
 dozoomviewmovez as integer
 dozoomviewrotatex as integer
 dozoomviewrotatey as integer
 dozoomviewrotatez as integer
 dosinglelayer as integer
 dopickmapid as integer
 doartresize as integer
 undoredoevent as integer
 undokeypress as integer
 tselcontrol as integer
 tselcut as integer
 tselcopy as integer
 tselfloor as integer
 tselpaste as integer
 tseldelete as integer
 tselwipe as integer
 tselsaveselection as integer
endtype
inputsys as inputsystemtype

rem UndoRedo list data structure
type undoredotype
 event as integer
 x as integer
 y as integer
 z as integer
 a as integer
 b as integer
endtype

rem Empty list with a single null event
dim undoredolist(0) as undoredotype
empty array undoredolist(0)
array insert at top undoredolist()

rem Browser Folder History
dim browserfolderhistory$(10)
global localdesc$=""

rem Globals for FPG handling
global currentSMFPGtype as integer : currentSMFPGtype=1
global currentSMFPG$ : currentSMFPG$="mygame.fpg"
global currentAMFPGtype as integer : currentAMFPGtype=2
global currentAMFPG$ : currentAMFPG$="myarena.fpg"
global currentFPGtype as integer : currentFPGtype=currentSMFPGtype
global currentFPG$ : currentFPG$=currentSMFPG$

rem Other structres
dim gunslots$ ( 10 )
dim listkey ( 32 )
dim list$( 100 )

rem Level handling
type leveltype
 fpm$ as string
 fpi$ as string
endtype

rem Project working on
global projectfilename$ : projectfilename$=""
global projectmodified : projectmodified=0

rem File List Buffer Array (multipurpose)
dim filelist$(0)

`
` Global Data and Arrays
`

rem Resource Banks
global meshbankmax=0
global meshbankoffset=1000
dim meshbank$(100)
global texturebankmax=0
global texturebankoffset=1000
dim texturebank$(100)
global effectbankmax=0
global effectbankoffset=1000
dim effectbank$(100)
dim soundbank$(10)
global soundbankmax=0
global soundbankoffset=1
global materialsoundoffset=10001
global materialsoundmax=0
global explodesoundoffset=11001
global explodesoundmax=0
dim prefabbank$(100)
dim prefabbanklocal$(100)
global prefabbankmax=100
dim selectionbank$(100)
dim selectionbanklocal$(100)
global entitybankmax=100
dim entitybank$(entitybankmax)
global particlebankmax=0
global particlebankoffset=1
dim gunbank$(100)
global gunbankmax=0
dim muzzlebank$(100)
global muzzlebankmax=0
dim brassbank$(100)
global brassbankmax=0
dim smokebank$(100)
global smokebankmax=0
dim flakbank$(100)
global flakbankmax=0
`
rem Image order important for texture order
global imagebankmax=0
global muzzlebankoffset=500
global imagebankoffset=550
dim imagebank$(500)
`
rem Object Resource Offsets (COMMON)
global realviewobjectoffset=1000
global realviewobjectoffsetend=0
global entityattachmentsoffset=8900 : rem FPSCV104 - changed from 9900 - extra 1000 for guns/shadows
global entityattachmentindex=0
global entityworkobjectoffset=10099
global entityobjectoffset=10100
global hudbankoffset=16050
global gunbankoffset=16100
global brassbankoffset=16150
global smokebankoffset=16200
global flakbankoffset=16300
global flakelementoffset=16350
global decalbankoffset=16450
global decalelementoffset=16500
global fragmentobjectoffset=17000
global fragmentobjectoffsetmax
global explodedecalobjstart=17500
global explodedecalobjmax
global explosionscorch
global explosionstressed
global editorwaypointoffset=18000
global editorwaypointoffsetmax=18499
global debugobjectoffset=18500
global editormarkeroffset=19000
`global editormarkeroffsetmax=19999
global editormarkeroffsetmax=19200
global gamdebugobjoffset=19300
global selectionbankoffset=20000
global entitybankoffset=30000
global gamehudimagesoffset=64500
global editorimagesoffset=65000
global physicsuniverseobj=65533
global physicsplayerborble=65534
rem Universe Builing Object Resources for entire universe
global universebuildobjstartoffset=70001
global universebuildobjendoffset=166000
global endofallobjectsoffset=166001

`
` Segment Data
`

rem Segment Profile Data Structure
type segmentprofileheadertype
 partmax as integer
 lastmeshmax as integer
endtype
type segmentprofilevistype overlay f r wb wr wf wl owb owr owf owl ctl ctr cbr cbl octl octr ocbr ocbl endtype
type segmentprofileblueprinttype
 mode as integer
 symbol as integer
 floorsizey as integer
 sidesizex as integer
 sidesizey as integer
 sidesizez as integer
endtype
type segmentprofileproperties
 groundmode as integer
 kindof as integer
endtype
type materialtype
 index as integer
endtype
type segmentprofiletype
 partmode as integer
 meshname$ as string
 meshid as integer
 actuallimb as integer
 offx as float
 offy as float
 offz as float
 rotx as float
 roty as float
 rotz as float
 tex$ as string
 texd$ as string
 texn$ as string
 texs$ as string
 effect$ as string
 texid as integer
 texdid as integer
 texiid as integer
 texnid as integer
 texsid as integer
 effectid as integer
 transparency as integer
 colmode as integer
 vis as segmentprofilevistype
 blueprint as segmentprofileblueprinttype
 properties as segmentprofileproperties
 csgmesh$ as string
 csgmode as integer
 csgimmune as integer
 lightmode as integer
 multimeshmode as integer
 multimeshstart as integer
 material as materialtype
endtype
global segobjusedformapeditor=0
global segobjusedforsegeditor=0
global segidmastermax : segidmastermax=100
dim segmentprofileheader(segidmastermax) as segmentprofileheadertype
dim segmentprofile(segidmastermax,64) as segmentprofiletype

`
` Map Data
`

rem Prepare map data and texture
layermax=20 : maxx=40 : maxy=40
dim map(layermax,maxx,maxy)
mapid as DWORD
mapselection as DWORD
mapscaler as DWORD
mapground as DWORD
maprotate as DWORD
maporient as DWORD
mapsymbol as DWORD
maptile as DWORD

rem Visible-Col-Map used for per-cycle quick entity collision checks
viscolx=160 : viscoly=20 : viscolz=160
dim viscolmap(viscolx,viscoly,viscolz)

rem Prepare entity reference map (references entityelementlist indexes)
dim refmap(layermax,maxx,maxy) as DWORD
newptrbase as DWORD
refptrbase as DWORD
ptrbase as DWORD
refptr as DWORD
ptr as DWORD

rem Map Overlay (stacked segment list)
dim mapolay(layermax,maxx,maxy)
global olaylistmax : olaylistmax=100
dim olaylist(olaylistmax,50) as DWORD

rem Default settings
gridzoom#=1.0
shroudsize=5
gridground=0
gridselection=1
nogridsmart=-1
gridlayer=5
bufferlayer=-1
gridlayershowsingle=0
grideditartwidth=1
grideditartwidthx=1
grideditartwidthy=1
locallibrarysegidmaster=0
locallibraryentidmaster=0
locallibraryentindex=0
dim locallibraryent(locallibraryentindex)

rem Grid Entity globals
gridentitylight as entitylighttype
gridentitytrigger as entitytriggertype

rem Master Mesh Data Structure
type mapentriestype vertmax1 vertmax2 indexmax1 indexmax2 endtype
type mastermeshtype obj buffer layer worldx worldy endtype

rem Create master mesh array
mastermeshmax=0
mastermeshsize=1
mastermeshsets=1
firstmeshobject=101
currentmeshobject=firstmeshobject
dim mapentries(mastermeshsize,mastermeshsets,40,40) as mapentriestype
dim mastermesh(mastermeshsize,mastermeshsets) as mastermeshtype

`
` Entity Data
`

rem Entity Profile Data Structure
type entityprofileheadertype
 desc$ as string
endtype
type entityanimtype
 start as integer
 finish as integer
endtype
type entitylighttype
 index as integer
 islit as integer
 color as DWORD
 range as integer
endtype
type entitytriggertype
 areax1 as integer
 areax2 as integer
 areay1 as integer
 areay2 as integer
 areaz1 as integer
 areaz2 as integer
endtype
type entityprofiletype
 aiinit$ as string
 aimain$ as string
 aidestroy$ as string
 aishoot$ as string
 soundset$ as string
 soundset1$ as string
 usekey$ as string
 ifused$ as string
 ifusednear$ as string
 spawnatstart as integer
 spawnmax as integer
 spawnupto as integer
 spawnafterdelay as integer
 spawnwhendead as integer
 spawndelay as integer
 spawnqty as integer
 spawndelayrandom as integer
 spawnqtyrandom as integer
 spawnvel as integer
 spawnvelrandom as integer
 spawnangle as integer
 spawnanglerandom as integer
 spawnlife as DWORD
 model$ as string
 offx as float
 offy as float
 offz as float
 rotx as float
 roty as float
 rotz as float
 scale as float
 fixnewy as float
 forwardfacing as integer
 defaultheight as float
 defaultstatic as integer
 collisionmode as integer
 materialindex as integer
 debrisshapeindex as integer
 coneheight as float
 coneangle as float
 hurtfall as integer
 texpath$ as string
 texd$ as string
 texdid as integer
 texaltd$ as string
 texaltdid as integer
 tex1id as integer
 tex2id as integer
 tex3id as integer
 tex4id as integer
 texidmax as integer
 effect$ as string
 usingeffect as integer
 castshadow as integer
 transparency as integer
 reducetexture as integer
 strength as integer
 lives as integer
 speed as integer
 isimmobile as integer
 ischaracter as integer
 cantakeweapon as integer
 isweapon$ as string
 isweapon as integer
 isammo as integer
 hasweapon$ as string
 hasweapon as integer
 ishealth as integer
 isflak as integer
 limbmax as integer
 headlimb as integer
 firespotlimb as integer
 animmax as integer
 quantity as integer
 ismarker as integer
 markerindex as integer
 isobjective as integer
 light as entitylighttype
 trigger as entitytriggertype
 decalmax as integer
 bloodscorch as integer
 rateoffire as integer
 damage as integer
 accuracy as integer
 reloadqty as integer
 fireiterations as integer
 lifespan as integer
 throwspeed as float
 throwangle as float
 bounceqty as integer
 explodeonhit as integer
 weaponisammo as integer
 spare1 as DWORD
 physics as integer
 phyalways as integer
 phyweight as integer
 phyfriction as integer
 phyforcedamage as integer
 rotatethrow as integer
 explodable as integer
 explodedamage as integer
endtype
global animmax=200
global entidmastermax=100
dim entitybodypart(100,100) as integer
dim entityanim(100,animmax) as entityanimtype
dim entityprofileheader(100) as entityprofileheadertype
dim entityprofile(100) as entityprofiletype
dim entitydecal$(100,100) as string
dim entitydecal(100,100) as integer

rem Waypoint Component of entity element
type aiwaypointtype
 state as integer
 current as integer
 tracker as integer
 direction as integer
 timefrom as DWORD
 xstart as float
 ystart as float
 zstart as float
 xinc as float
 yinc as float
 zinc as float
 timeslice as DWORD
endtype

rem AI Component of entity element
type aistatustype
 libinit as integer
 libmain as integer
 libdestroy as integer
 libshoot as integer
 libindex as integer
 state as integer
 alphafade as integer
 destalphafade as integer
 alphafadeupdate as integer
 headangle as float
 headdestangle as float
 waypoint as aiwaypointtype
 usinginternalai as integer
 oldstate as integer
 oldalphafade as integer
 oldwaypointstate as integer
endtype

rem SPAWN Component of entity element
type spawntype
 atstart as integer
 max as integer
 delay as integer
 qty as integer
 upto as integer
 afterdelay as integer
 whendead as integer
 delayrandom as integer
 qtyrandom as integer
 vel as integer
 velrandom as integer
 angle as integer
 anglerandom as integer
 life as DWORD
 leader as integer
 leadercount as integer
 leaderid as integer
 x as float
 y as float
 z as float
endtype

rem FORCE Component of entity element
type forcetype
 active as integer
 ix as float
 iy as float
 iz as float
endtype

rem MOVEMENT Component of entity element
type movertype
 moved as integer
 stepcount as float
 dx as float
 dy as float
 dz as float
 da as float
 ix as float
 iy as float
 iz as float
 grav as float
 gravlasty as float
 inmotion as integer
 viewconeused as float
 run as integer
 strafe as integer
 slidevel as float
endtype

rem Entity Element Custom Profile Data
type entityeleproftype
 name$ as string
 aiinit$ as string
 aiinit as integer
 aimain$ as string
 aimain as integer
 aidestroy$ as string
 aidestroy as integer
 aishoot$ as string
 aishoot as integer
 usekey$ as string
 ifused$ as string
 ifusednear$ as string
 scale as float
 coneheight as float
 coneangle as float
 uniqueelement as integer
 texd$ as string
 texdid as integer
 texaltd$ as string
 texaltdid as integer
 tex1id as integer
 tex2id as integer
 tex3id as integer
 tex4id as integer
 texidmax as integer
 effect$ as string
 usingeffect as integer
 transparency as integer
 strength as integer
 isimmobile as integer
 cantakeweapon as integer
 hasweapon$ as string
 hasweapon as integer
 quantity as integer
 isobjective as integer
 lives as integer
 markerindex as integer
 light as entitylighttype
 trigger as entitytriggertype
 basedecal$ as string
 soundset$ as string
 soundset1$ as string
 spawnatstart as integer
 spawnmax as integer
 spawnupto as integer
 spawnafterdelay as integer
 spawnwhendead as integer
 spawndelay as integer
 spawnqty as integer
 spawndelayrandom as integer
 spawnqtyrandom as integer
 spawnvel as integer
 spawnvelrandom as integer
 spawnangle as integer
 spawnanglerandom as integer
 spawnlife as DWORD
 hurtfall as integer
 castshadow as integer
 reducetexture as integer
 speed as integer
 rateoffire as integer
 damage as integer
 accuracy as integer
 reloadqty as integer
 fireiterations as integer
 lifespan as integer
 throwspeed as float
 throwangle as float
 bounceqty as integer
 explodeonhit as integer
 weaponisammo as integer
 spare1 as DWORD
 physics as integer
 phyalways as integer
 phyweight as integer
 phyfriction as integer
 phyforcedamage as integer
 rotatethrow as integer
 explodable as integer
 explodedamage as integer
 phydw3 as DWORD
 phydw4 as DWORD
 phydw5 as DWORD
endtype
rem Entity Elements Data
type entitytype
 editorfixed as integer
 servercontrolled as integer
 fakeplrindex as integer
 active as integer
 dormant as integer
 eleprof as entityeleproftype
 mover as movertype
 ai as aistatustype
 spawn as spawntype
 force as forcetype
 maintype as integer
 bankindex as integer
 profileobj as integer
 staticflag as integer
 obj as integer
 attachmentobj as integer
 attachmentbaseobj as integer
 attachmentweapontype as integer
 attachmentobjfirespotlimb as integer
 attachmentblobobj as integer
 x as float
 y as float
 z as float
 rx as float
 ry as float
 rz as float
 norotate as integer
 nogravity as integer
 dry as float
 floorposy as float
 colr as integer
 colg as integer
 colb as integer
 limbslerp as integer
 logiccount as float
 logiccountburst as integer
 logictimestamp as DWORD
 priorityai as integer
 priorityduration as integer
 raycastcount as integer
 raycastlaststate as integer
 nofloorlogic as integer
 crouchprofile as integer
 plrdist as float
 decalindex as integer
 decalmode as integer
 decalloop as integer
 decalslotused as integer
 decalsizex as float
 decalsizey as float
 animset as integer
 animdir as integer
 animdo as integer
 animtime as integer
 animframe as float
 animspeed as float
 animonce as integer
 destanimframe as float
 animframeupdate as integer
 spinrate as integer
 spinvalue as float
 floatrate as integer
 floatvalue as float
 possibletarget as integer
 actualtarget as integer
 losttargetcount as integer
 actualtargetx as float
 actualtargety as float
 actualtargetz as float
 plrtrailindex as integer
 fakeplayerid as integer
 strafemode as integer
 currentweapon as integer
 currentclipammo as integer
 currentammo as integer
 fireweapon as integer
 firestrength as integer
 firesoundloop as integer
 firesoundloopremote as integer
 firesoundlooptime as DWORD
 health as integer
 lifecode as integer
 beenkilled as integer
 shotdamage as integer
 shotdamagesource as integer
 delaydamagecount as integer
 delaydamagesource as integer
 delaydamage as integer
 delayimpact as integer
 delaydamagex# as float
 delaydamagey# as float
 delaydamagez# as float
 delaydir as integer
 collected as integer
 activated as integer
 collisionactive as integer
 invincibleactive as integer
 blockedby as integer
 blockedtox as integer
 blockedtoy as integer
 blockedtoz as integer
 soundset as integer
 soundset1 as integer
 soundlooping as integer
endtype
rem Entity Breadcrumbs Data
type entitybreadcrumbstype
 x as float
 y as float
 z as float
endtype
global entityelementlist=0
global entityelementmax=100
grideleprof as entityeleproftype
dim entityelement(entityelementmax) as entitytype
dim entitybreadcrumbs(entityelementmax,50) as entitybreadcrumbstype
dim entitydebug$(entityelementmax)

rem Segment and EntityProfile/EntityelementList Vars
global preidmaster : preidmaster=0
global segidmaster : segidmaster=0
global entidmaster : entidmaster=0
global entityelementlist : entityelementlist=0
global aiindexmaster : aiindexmaster=0
global waypointmax : waypointmax=0
global wayppointoneonlyflaw : wayppointoneonlyflaw=0

`
` Artificial Intelegence Data
`

rem AI constants
#constant AICONDNEVER 1
#constant AICONDALWAYS 2
#constant AICONDSTATE 3
#constant AICONDRANDOM 4
#constant AICONDHEALTH 5
#constant AICONDHEALTHLESS 6
#constant AICONDQUANTITY 7
#constant AICONDSPEED 8
#constant AICONDRATEOFFIRE 9
#constant AICONDPLRHEALTHLESS 21
#constant AICONDPLRHEALTHGREATER 22
#constant AICONDASSOCIATED 51
#constant AICONDPLRDISTWITHIN 101
#constant AICONDPLRDISTFURTHER 102
#constant AICONDPLRHIGHER 103
#constant AICONDANYWITHIN 104
#constant AICONDANYFURTHER 105
#constant AICONDPLRELEVWITHIN 106
#constant AICONDPLRELEVFURTHER 107
#constant AICONDPLRALIVE 111
#constant AICONDSHOTDAMAGE 121
#constant AICONDIFWEAPON 122
#constant AICONDCANTAKE 131
#constant AICONDPLRCANBESEEN 151
#constant AICONDPLRCANNOTBESEEN 152
#constant AICONDPLRHASKEY 153
#constant AICONDPLRUSINGACTION 154
#constant AICONDACTIVATED 155
#constant AICONDPLRWITHINZONE 156
#constant AICONDENTITYWITHINZONE 157
#constant AICONDPLRINGUNSIGHT 158
#constant AICONDNEARACTIVATABLE 159
#constant AICONDNEWWEAPONCANBESEEN 161
#constant AICONDNOISEHEARD 171
#constant AICONDANYWITHINZONE 191
#constant AICONDANYKEYWITHINZONE 192
#constant AICONDRAYCAST 201
#constant AICONDRAYCASTUP 202
#constant AICONDRAYCASTBACK 203
#constant AICONDNORAYCASTUP 204
#constant AICONDFRAMEATEND 301
#constant AICONDFRAMEATSTART 302
#constant AICONDFRAMEWITHIN 303
#constant AICONDFRAMEBEYOND 304
#constant AICONDANIMATIONOVER 305
#constant AICONDREACHTARGET 351
#constant AICONDLOSETARGET 352
#constant AICONDHEADANGLEGREATER 401
#constant AICONDHEADANGLELESS 402
#constant AICONDALPHAFADEEQUAL 471
#constant AICONDWAYPOINTSTATE 501
#constant AICONDIFMARKER 551
#constant AICONDIFPLRTRAIL 552
#constant AICONDHUDSELECTIONMADE 801
#constant AICONDTIMERGREATER 811
#constant AICONDESCAPEKEYPRESSED 821
#constant AICONDHUDEDITDONE 822
#constant AICONDHUDHAVENAME 823
#constant AICONDSCANCODEKEYPRESSED 824
#constant AICONDLAST 900

#constant AIACTNONE 0
#constant AIACTDESTROY 1
#constant AIACTSUSPEND 2
#constant AIACTFLOORLOGIC 11
#constant AIACTNOGRAVITY 12
#constant AIACTRUNFPIDEFAULT 51
#constant AIACTRUNFPI 52
#constant AIACTSTATE 101
#constant AIACTINCSTATE 102
#constant AIACTMOVEUP 201
#constant AIACTMOVEFORE 202
#constant AIACTMOVEBACK 203
#constant AIACTFREEZE 204
#constant AIACTRUNFORE 205
#constant AIACTROTATEY 226
#constant AIACTROTATETOPLR 227
#constant AIACTROTATEIY 228
#constant AIACTNOROTATE 229
#constant AIACTRESETHEAD 231
#constant AIACTROTATEHEAD 232
#constant AIACTROTATEHEADRANDOM 233
#constant AIACTFORCEBACK 251
#constant AIACTFORCEFORE 252
#constant AIACTFORCELEFT 253
#constant AIACTFORCERIGHT 254
#constant AIACTFORCEBOUNCE 255
#constant AIACTSPINRATE 281
#constant AIACTFLOATRATE 282
#constant AIACTSETFRAME 301
#constant AIACTINCFRAME 302
#constant AIACTDECFRAME 303
#constant AIACTANIMATE 304
#constant AIACTADVFRAME 305
#constant AIACTSETTARGET 351
#constant AIACTROTATETOTARGET 352
#constant AIACTLOOKATTARGET 353
#constant AIACTMOVETOTARGET 354
#constant AIACTCOLLECTTARGET 355
#constant AIACTCHOOSESTRAFE 356
#constant AIACTSTRAFE 357
#constant AIACTPIVOTRANDOM 358
#constant AIACTLOOKATPLR 359
#constant AIACTSETTARGETNAME 360
#constant AIACTPLRASS 401
#constant AIACTPLRNOASS 402
#constant AIACTPLRMOVEUP 403
#constant AIACTPLRMOVEDOWN 404
#constant AIACTPLRMOVEEAST 405
#constant AIACTPLRMOVEWEST 406
#constant AIACTPLRMOVENORTH 407
#constant AIACTPLRMOVESOUTH 408
#constant AIACTPLRMOVETO 409
#constant AIACTPLRMOVEIFUSED 410
#constant AIACTACTIVATEIFUSED 421
#constant AIACTACTIVATEIFUSEDNEAR 422
#constant AIACTACTIVATETARGET 423
#constant AIACTACTIVATE 424
#constant AIACTACTIVATEALLINZONE 425
#constant AIACTPLRADDHEALTH 431
#constant AIACTSOUND 451
#constant AIACT3DSOUND 452
#constant AIACTLOOPSOUND 453
#constant AIACTSTOPSOUND 454
#constant AIACTALTTEXTURE 461
#constant AIACTSETALPHAFADE 471
#constant AIACTINCALPHAFADE 472
#constant AIACTDECALPHAFADE 473
#constant AIACTRUNDECAL 481
#constant AIACTSHAPEDECAL 482
#constant AIACTTRIGGERFORCE 491
#constant AIACTWAYPOINTSTART 501
#constant AIACTWAYPOINTSTOP 502
#constant AIACTWAYPOINTREVERSE 503
#constant AIACTWAYPOINTNEXT 504
#constant AIACTWAYPOINTPREV 505
#constant AIACTWAYPOINTRANDOM 506
#constant AIACTDROPMARKER 551
#constant AIACTNEXTMARKER 552
#constant AIACTRESETMARKERS 553
#constant AIACTFOLLOWPLR 554
#constant AIACTPLRTAKE 601
#constant AIACTPLRDROP 602
#constant AIACTSHOOTPLR 701
#constant AIACTUSEWEAPON 711
#constant AIACTRELOADWEAPON 712
#constant AIACTCOLOFF 751
#constant AIACTCOLON 752
#constant AIACTSPAWNON 761
#constant AIACTSPAWNOFF 762
#constant AIACTAMBIENCE 821
#constant AIACTAMBIENCERED 822
#constant AIACTAMBIENCEGREEN 823
#constant AIACTAMBIENCEBLUE 824
#constant AIACTFOG 831
#constant AIACTFOGRED 832
#constant AIACTFOGGREEN 833
#constant AIACTFOGBLUE 834
#constant AIACTSKY 841
#constant AIACTSKYSCROLL 842
#constant AIACTBACKDROP 1001
#constant AIACTMUSIC 1011
#constant AIACTMUSICVOLUME 1012
#constant AIACTSOUNDSCALE 1013
#constant AIACTVIDEO 1021
#constant AIACTLIGHTON 1051
#constant AIACTLIGHTOFF 1052
#constant AIACTLIGHTRED 1053
#constant AIACTLIGHTGREEN 1054
#constant AIACTLIGHTBLUE 1055
#constant AIACTLIGHTRANGE 1056
#constant AIACTHUDRESET 1100
#constant AIACTHUDX 1101
#constant AIACTHUDY 1102
#constant AIACTHUDZ 1103
#constant AIACTHUDSIZEX 1104
#constant AIACTHUDSIZEY 1105
#constant AIACTHUDSIZEZ 1106
#constant AIACTHUDRED 1107
#constant AIACTHUDGREEN 1108
#constant AIACTHUDBLUE 1109
#constant AIACTHUDIMAGE 1110
#constant AIACTHUDIMAGEFINE 1111
#constant AIACTHUDFONT 1112
#constant AIACTHUDSIZE 1113
#constant AIACTHUDTEXT 1114
#constant AIACTHUDTYPE 1115
#constant AIACTHUDHIDE 1116
#constant AIACTHUDSHOW 1117
#constant AIACTHUDUNSHOW 1118
#constant AIACTHUDNAME 1119
#constant AIACTHUDANIM 1120
#constant AIACTHUDFADEOUT 1121
#constant AIACTHUDMAKE 1199
#constant AIACTNEWGAME 1201
#constant AIACTLOADGAME 1202
#constant AIACTSAVEGAME 1203
#constant AIACTCONTINUEGAME 1204
#constant AIACTQUITGAME 1205
#constant AIACTPAUSEGAME 1206
#constant AIACTRESUMEGAME 1207
#constant AIACTHOSTGAME 1208
#constant AIACTJOINGAME 1209
#constant AIACTREPEATGAME 1210
#constant AIACTTIMERSTART 1211
#constant AIACTQUICKLOADGAME 1212
#constant AIACTQUICKSAVEGAME 1213
#constant AIACTLAST 1300

rem AI Counters
global actstringmax=0
global conindexcount=0
global aicondseqcount=0
global actindexcount=0
global aiactseqcount=0
global hudmax=0
global hudfadeoutoneatatime=0
global internalloaderhud=0
global internaleyehud=0
global internalfaderhud=0

rem AI BC Sound
global bcsoundstrength#
global bcsoundx#
global bcsoundy#
global bcsoundz#

rem AI actions
type aiactiontype
 type as integer
 value as float
 filename as string
endtype
dim aiactionseq(10000) as aiactiontype
type aiactionitemtype
 first last
endtype
dim aiaction(500) as aiactionitemtype
dim actstring$(actstringmax)

rem AI conditions
type aiconditiontype
 type as integer
 valuea as float
 valueb as float
 valuec as float
endtype
dim aiconditionseq(10000) as aiconditiontype
type aiconditionitemtype
 first last
 action as integer
endtype
dim aicond(500) as aiconditionitemtype

rem AI Library List
type ailiblisttype
 loaded as integer
 file$ as string
 desc$ as string
 conditionfirst as integer
 conditionlast as integer
endtype
dim ailist(200) as ailiblisttype

rem AI Library Count
if leavegamedataalone=0
 dim scriptbank$(100)
 aiindexmaster=0
endif

`
` Waypoint Data Structures
`

rem Waypoint data structure
type waypointtype
 count as integer
 start as integer
 finish as integer
endtype
type waypointcoordtype
 x as float
 y as float
 z as float
 link as integer
 index as integer
endtype
dim waypointcoord(1000) as waypointcoordtype
dim waypoint(10) as waypointtype
global waypointeditheight#=0
global waypointcoordmax=0
global waypointmax=0
`
` Global Particle and Debris Data Structures
`
dim debris(32)


`
` Gun Data Structures
`

rem Gun Sounds Data Structure
type gunsoundbanktype
 name$ as string
 soundid as integer
endtype
type gunsoundbankcompaniontype
 soundid as integer
endtype
type gunsounditemtype
 keyframe as integer
 playsound as integer
 lastplay as integer
endtype
type gunsoundstype
 soundframes as integer
 fireloopend as integer
endtype

rem Gun Settings Data Structure
type gunsettingstype
 muzzleflash as integer
 muzzlex# as float
 muzzley# as float
 muzzlez# as float
 muzzlesize# as float
 muzzlecolorr as integer
 muzzlecolorg as integer
 muzzlecolorb as integer
 brass as integer
 smoke as integer
 flashlimb as integer
 brasslimb as integer
 smokelimb as integer
 flashlimb2 as integer
 brasslimb2 as integer
 smokelimb2 as integer
 handlimb as integer
 flashimg as integer
 brassobjmaster as integer
 smokeimg as integer
 crosshairimg as integer
 flakname$ as string
 flakindex as integer
 seconduse as integer
 damage as integer
 damagetype as integer
 scorchtype as integer
 reloadqty as integer
 weaponisammo as integer
 iterate as integer
 accuracy as integer
 zoommode as integer
 zoomaccuracy as integer
 range as integer
 smokespeed as integer
 smokedecal$ as string
endtype

rem Gun Actions Data Structure
type gunanimtype
 s as integer
 e as integer
endtype
type gunactionstype
 show as gunanimtype
 idle as gunanimtype
 move as gunanimtype
 start as gunanimtype
 automatic as gunanimtype
 finish as gunanimtype
 startreload as gunanimtype
 reloadloop as gunanimtype
 endreload as gunanimtype
 cock as gunanimtype
 hide as gunanimtype
endtype

rem Gun Data Structure (is 10 our maximum for the entire game, ie weapon slots max?)
type guntype
 activeingame as integer
 obj as integer
 secondobj as integer
 name$ as string
 weapontype as integer
 texd$ as string
 effect$ as string
 zoomscope$ as string
 zoomscope as integer
 decal$ as string
 decalid as integer
 effectidused as integer
 transparency as integer
 settings as gunsettingstype
 sound as gunsoundstype
 action as gunactionstype
 hudimage as integer
 horiz# as float
 vert# as float
 forward# as float
endtype
dim gun(100) as guntype
dim gunsound(100,5) as gunsoundbanktype
dim gunsoundcompanion(100,5,2) as gunsoundbankcompaniontype
dim gunsounditem(100,50) as gunsounditemtype
dim brassfallcount(30)
global autoloadgun=0
global gunslotmax=0
global gunmax

rem Flak Profile Structure
type flakprofiletype
 lifespan as integer
 xinc as float
 yinc as float
 zinc as float
 xspeed as float
 yspeed as float
 zspeed as float
 weight as float
 spinx as float
 bounceonhit as integer
 explodeonhit as integer
 damage as integer
endtype

rem Flak Sound Data Structure
type flaksoundtype
 sndbounce$ as string
 sndbounceid as integer
 sndexplode$ as string
 sndexplodeid as integer
endtype

rem Flak Data Structure
type flaktype
 obj as integer
 name$ as string
 exponfloor$ as string
 exponfloorid as integer
 expinair$ as string
 expinairid as integer
 profile as flakprofiletype
 sound as flaksoundtype
 throwangle as integer
 throwforward as integer
 throwheight as integer
endtype
dim flak(10) as flaktype
global flakmax=0

rem Flak Elements Data Structure
type flakelementtype
 flakid as integer
 profile as flakprofiletype
 active as integer
 range as integer
 obj as integer
 xpos as float
 ypos as float
 zpos as float
 owner as integer
endtype
global flakelementmax=100
dim flakelement(flakelementmax) as flakelementtype

rem Decal Structure (explosions, lightdlare, smoke, steam, plasma)
type decaltype
 active as integer
 imageid as integer
 name$ as string
 across as integer
 down as integer
 offsety as float
 framemax as integer
 scale as integer
endtype
global decalmax=10
dim decal(decalmax) as decaltype

rem Decal Element Structure (reusable instances)
type decalelementtype
 decalid as integer
 active as integer
 obj as integer
 xpos as float
 ypos as float
 zpos as float
 frame as integer
 framedelay as integer
 orient as integer
 originator as integer
 scalemodx as float
 scalemody as float
endtype
global decalelementmax=100
dim decalelement(decalelementmax) as decalelementtype

`
` Players Data
`

rem Input Command Structure
type inputcommandtype
 take drop newweapon
endtype
type playerstatetype
 moving firingmode
endtype

rem Weapon Data Structure
type weaponslottype
 pref got invpos
endtype
if leavegamedataalone=0
 dim weaponslot(10) as weaponslottype
 dim weaponammo(10) as integer
 dim weaponclipammo(10) as integer
 for ws=1 to 10 : weaponslot(ws).pref=0 : next ws
endif
dim weaponhud(10) as integer

rem Inventory Data Structure
type inventorytype
 new as integer
 drop as integer
 index as integer
endtype

rem Players Data Structure
type playertype
 serverplayer as integer
 command as inputcommandtype
 state as playerstatetype
 x as float
 y as float
 z as float
 envstate as integer
 envassociatedentity as integer
 recovershield as integer
 health as integer
 lives as integer
 inventorymax as integer
 usingaction as integer
endtype
type playertrailtype
 time as DWORD
 x as float
 y as float
 z as float
endtype
global playermax=1
global playertrailmax=0
dim player(playermax) as playertype
dim playersound(playermax,520) as integer
dim playersoundtimeused(playermax,520) as DWORD
dim playersoundset$(playermax) as string
dim playermovementstep(playermax) as float
dim playerinventory(playermax,100) as inventorytype
dim playertrial(100) as playertrailtype
playersoundset$(1)=""

rem Player Mission
global missiongoaltotal as integer
dim playerobjective(99) as integer

rem Player+Multiplayer Related Data
global multiplayeridlinkmax : multiplayeridlinkmax=0
dim multiplayeridlink(16) as DWORD
dim multiplayername$(16) as string
dim multiplayerisnew(16) as integer
dim multiplayerplrindex(16) as integer
dim multiplayeri(16) as integer

rem Infini-Light Data Structure
type colrgbtype
 r g b
endtype
type infinilighttype
 used as integer
 type as integer
 x as float
 y as float
 z as float
 range as float
 id as integer
 dist as float
 colrgb as colrgbtype
 islit as integer
endtype
dim infinilight(0) as infinilighttype
empty array infinilight(0)
dim infinilightshortlist(0)
empty array infinilightshortlist(0)

rem Shadow Lights Data Structure
type shadowlighttype
 x# y# z# range#
endtype
dim shadowlight(0) as shadowlighttype

rem Light Table used to accelerate lighting of entities
type lighttabletype
 r as float
 g as float
 b as float
 x as float
 y as float
 z as float
endtype
dim lighttable(viscolx,viscoly,viscolz) as lighttabletype

rem Material settings
type materialsettingstype
 name$ as string
 tred0$ as string
 tred1$ as string
 tred2$ as string
 tred3$ as string
 noise as integer
 scrape$ as string
 scrapeid as integer
 impact$ as string
 impactid as integer
 destroy$ as string
 destroyid as integer
 freq as integer
 decal$ as string
 decalid as integer
endtype
dim material(100) as materialsettingstype
global gmaterialmax=0

rem Data structure for Bit-Fragments
type bitdetailstype
 max as integer
 file$ as string
 collisionmode as integer
 fragmentobjstart as integer
 choice as integer
 sizex as float
 sizey as float
 sizez as float
endtype
type bitoffsettype
 x# y# z#
endtype
dim bitdetails(10) as bitdetailstype
dim bitoffset(10,8) as bitoffsettype

rem Explosion Data Structure
type explodetype
 obj as integer
 explode as integer
 explodesound as integer
 dist# as float
 smoke# as float
 fade# as float
 x as float
 y as float
 z as float
endtype
global explodermax=4
dim exploder(explodermax) as explodetype

rem GUI Visual Settings
type guivisualsettingstype
 updateflag as integer
 ambience as integer
 shadows as integer
 shadowstrength as integer
 shadowshades as integer
 dynamiclightcount as integer
endtype
guivisualsettings as guivisualsettingstype

rem HUD structure
type hudtype
 name$ as string
 maintype as integer
 typemode as integer
 posx as float
 posy as float
 posz as float
 sizex as integer
 sizey as integer
 sizez as integer
 red as integer
 green as integer
 blue as integer
 fadeout as integer
 baseanim as integer
 image as integer
 font$ as string
 fontsize as integer
 text$ as string
 hide as integer
 hidedelay as integer
 highlighted as integer
 width as integer
 height as integer
endtype
dim hud(10) as hudtype

rem Setup work floats (for HUD decimal detail)
value1 as float
value2 as float
value3 as float
workhudx as float
workhudy as float
workhudz as float

rem FPSCV104 Fog globals
hudfogon as integer
hudfoglaston as integer
hudfognear as float
hudfogfar as float
hudfogred as float
hudfoggreen as float
hudfogblue as float

rem World Physics Settings
global physicson=1
global physicsdebug=0 : rem gdebugphysicsstate will set this to one!
global physicsgravx#=0.0
global physicsgravy#=0 : physicsgravy#=-40.0
global physicsgravz#=0.0
global physicsplayerweight# : physicsplayerweight#=500.0
global grav# as float : grav#=0
global camerapositionx as float : camerapositionx=0
global camerapositiony as float : camerapositiony=0
global camerapositionz as float : camerapositionz=0
global cameraspeed as float : cameraspeed=0
global camerapickup as integer : camerapickup=1
global cameraholding as integer : cameraholding=0
global camerapickupkeyrelease : camerapickupkeyrelease=0
global camerareach# as float : camerareach#=0
global camerareachatrun# as float : camerareachatrun#=0
global camerareachmax# as float : camerareachmax#=75
global camerapickedangle# as float : camerapickedangle#=0
global camerapicked as integer : camerapicked=0
global camerapickede as integer : camerapickede=0
global camerapickeddrop as integer : camerapickeddrop=0
global camerapickedthrown as integer : camerapickedthrown=0
global camerathrow# as float : camerathrow#=100.0
global camerathrowelev# as float : camerathrowelev#=0.0
global cameradampen# : cameradampen#=1.0
global cameradampenactive : cameradampenactive=0
global cameracarryweight# : cameracarryweight#=4000
dim phyobjvelocity#(1)
dim phylasttravelled#(1)
dim phylastfloorstop#(1)
dim phyobjsounding(1)
dim phyobjremove(1)
dim phyobjele(1)
dim shadowobj(1)

rem Respawn array for arena game
type respawntype
 e as integer
 x as float
 y as float
 z as float
 ry as float
endtype
dim respawn(16) as respawntype
global respawnmax : respawnmax=0

rem Multiplayer globals and structures
global hudiplistmax : hudiplistmax=-1
dim hudiplist$(20,1)
global repeatsamelevel : repeatsamelevel=0
global winnersname$ as string : winnersname$=""
global servername$ : servername$="FPSC Creator Portal"
global ipaddress$
global multiplayerinitialised as integer
global createorjoin as integer
global lagmon# as float
global startofrecording as DWORD
global dwBurstTime as DWORD
global dwStartTime as DWORD
global dwStartJoinTime as DWORD
global dwPlayerID as DWORD
global timestampforlagtest as DWORD
global locallagtime as DWORD
global dwMessageCode as DWORD
global dwCode as DWORD
global dwLocalPlayerID as DWORD
global iLocalEL as integer
global PlayerCanStart as integer
global Servergameisfull as integer
global gterminationcountdown as integer
global tenminutetimer as DWORD
global cameratimeslice as DWORD
rem talktoaster arrays
dim talkscript$(10)
dim talkscriptcount(10)
dim talkscriptwho(10)
global talkindex as integer
global gtalkytoaster as integer
global talkpingsound as integer
rem Characters (chosen is indexed by iLocalEL, list is flaglist of used identities)
global multiplayermax : multiplayermax=16
dim characterchosen(multiplayermax)
dim characterchoiceentityindex(multiplayermax)
dim characterlist$(multiplayermax) as string
dim characterlist(multiplayermax)
dim characterlistentity(multiplayermax)
rem Dead reckoning temp arrays
dim cpx#(4)
dim cpy#(4)
dim cpz#(4)
dim stategetready(multiplayermax)
dim statex(multiplayermax)
dim statey(multiplayermax)
dim statez(multiplayermax)
dim statea(multiplayermax)
dim stateanim(multiplayermax)
dim stateanimdir(multiplayermax)
dim statecolmaterialtype(multiplayermax)
dim stateanimwait(multiplayermax)
dim statewhodidit(multiplayermax)
dim stateplayagain(multiplayermax)
dim stateviewy(multiplayermax) as float
dim statesviewdy(multiplayermax) as float
dim stateweapon(multiplayermax)
dim stateannounce(multiplayermax)
dim statesx(multiplayermax)
dim statesy(multiplayermax)
dim statesz(multiplayermax)
dim statesa(multiplayermax)
dim statesvel(multiplayermax) as float
dim statetx(multiplayermax)
dim statety(multiplayermax)
dim statetz(multiplayermax)
dim statedx(multiplayermax)
dim statedy(multiplayermax)
dim statedz(multiplayermax)
dim statemove(multiplayermax)
dim statelag(multiplayermax) as float
dim statemsgap(multiplayermax) as float
dim statemytimer(multiplayermax) as DWORD
dim statecodeupdate(multiplayermax,4)
dim stateraycastpace(multiplayermax)

rem Server Scores
dim frags(multiplayermax) as integer

rem End of FULL-DATA-INIT Subroutine
return


`
` Initialise using SETUP.INI
`

_FPSC_Setup:

rem Very first task is find and load BUILD.INI (if flagged)
global gcompilestandaloneexe : gcompilestandaloneexe=0
global gbuildpath$ as string
global gbuildname$ as string

rem Find and load SETUP.INI settings as global states
global grealgameviewstate : grealgameviewstate=0
global gmultiplayergame : gmultiplayergame=0
global gdebugreportmodestate : gdebugreportmodestate=0
global gexitpromptreportmodestate : gexitpromptreportmodestate=0
global gdebugphysicsstate : gdebugphysicsstate=0
global gdebugreportstepthroughstate : gdebugreportstepthroughstate=0
global gshowentitygameinfostate : gshowentitygameinfostate=0
global gshowdebugtextingamestate : gshowdebugtextingamestate=0
global gincludeonlyvideo : gincludeonlyvideo=0
global gincludeonlyname$ : gincludeonlyname$=""
global gignorefastbone : gignorefastbone=0
global glightmappingstate : glightmappingstate=0
`global glightmapsize : glightmapsize=8 `preV104RC8
`global glightmapquality : glightmapquality=100
global glightmappingold : glightmappingold=0
global glightshadowsstate : glightshadowsstate=0
global glightambientr : glightambientr=0
global glightambientg : glightambientg=0
global glightambientb : glightambientb=0
global glightsunx : glightsunx=0
global glightsuny : glightsuny=-1
global glightsunz : glightsunz=0
global glightsunr : glightsunr=0
global glightsung : glightsung=0
global glightsunb : glightsunb=0
global glightzerorange : glightzerorange=2000
global glightatten : glightatten=16000
global glightmaxsize : glightmaxsize=-1
global glightboost : glightboost=4
global glighttexsize : glighttexsize=1024
global glightquality : glightquality=40
global glightblurmode : glightblurmode=1
global glightthreadmax : glightthreadmax=4
global gdynamiclightingstate : gdynamiclightingstate=0
global gdynamicshadowsstate : gdynamicshadowsstate=1
global guseeffectstate : guseeffectstate=0
global guseeffectongunsstate : guseeffectongunsstate=0
global guseeffectonscenesstate : guseeffectonscenesstate=0
global guseeffectonentitiesstate : guseeffectonentitiesstate=0
global gdividetexturesize : gdividetexturesize=0
global goptimizemode : goptimizemode=0
global ghsrmode : ghsrmode=0
global guseskystate : guseskystate=0
global gusefloorstate : gusefloorstate=0
global guseenvsoundsstate : guseenvsoundsstate=0
global guseweaponsstate : guseweaponsstate=0
global gindieditorstate : gindieditorstate=0
global gdisplaywidth : gdisplaywidth=1024
global gdisplayheight : gdisplayheight=768
global gdisplaydepth : gdisplaydepth=32
global guniquesignature as DWORD : guniquesignature=0
global ggameobjectivetype : ggameobjectivetype=0
global ggameobjectivevalue : ggameobjectivevalue=0
global goneshotkills : goneshotkills=0
global numberofplayers : numberofplayers=8
global gspawnrandom : gspawnrandom=0
global guniquegamecode$ : guniquegamecode$=""
global guseuniquelynamedentities : guseuniquelynamedentities=0
global gexportassets : gexportassets=0
global gproducelogfiles : gproducelogfiles=0
global ggodmodestate : ggodmodestate=0
global glevelmax : glevelmax=1
global level : level=1
global glocalserveroverride$ : glocalserveroverride$=""

rem Version Control - TEST GAME Mode
global gtestgamemodefromeditor : gtestgamemodefromeditor=0
global gtestgamemodefromeditorokaypressed : gtestgamemodefromeditorokaypressed=0
gosub _version_commandlineprompt

rem Default, unless overridden by BUILD -B
global setupfilename$
setupfilename$="setup.ini"

rem COMMANDLINE Info
if lower$(cl$())="-b"
 `
 rem BUILD settings
 gcompilestandaloneexe=1
 setupfilename$="buildsetup.ini"
 tfile$="build.ini"
 if file exist(tfile$)=1
  dim data$(99)
  load array tfile$,data$()
  for l=0 to 99
   line$=data$(l)
   if len(line$)>0
    if lower$(left$(line$,4))=";end" then exit
    if left$(line$,1)<>";"
     `
     rem take fieldname and values
     for c=0 to len(line$)
      if mid$(line$,c)="=" then mid=c : exit
     next c
     field$=lower$(removeedgespaces(left$(line$,mid-1)))
     value$=removeedgespaces(right$(line$,len(line$)-mid))
     for c=0 to len(value$)
      if mid$(value$,c)="," then mid=c : exit
     next c
     value1=val(removeedgespaces(left$(value$,mid-1)))
     value2$=removeedgespaces(right$(value$,len(value$)-mid))
     if len(value2$)>0 then value2=val(value2$) else value2=-1
     `
     rem collect data from fields in setup file
     tryfield$="path" : if field$=tryfield$ then gbuildpath$=value$
     tryfield$="name" : if field$=tryfield$ then gbuildname$=value$
     `
    endif
   endif
  next l
  undim data$()
 endif
 `
endif

rem RESTORE MAP Mode
global grestoreeditorsettings : grestoreeditorsettings=0
if lower$(cl$())="-r"
 grestoreeditorsettings=1
endif

rem SETUP Info`
tfile$=setupfilename$
if file exist(tfile$)=1
 `
 rem Load Data from file
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem collect data from fields in setup file
    tryfield$="realgameview" : if field$=tryfield$ then grealgameviewstate=value1
    tryfield$="multiplayergame" : if field$=tryfield$ then gmultiplayergame=value1
    tryfield$="debugreport" : if field$=tryfield$ then gdebugreportmodestate=value1
    tryfield$="exitpromptreport" : if field$=tryfield$ then gexitpromptreportmodestate=value1
    tryfield$="debugphysics" : if field$=tryfield$ then gdebugphysicsstate=value1
    tryfield$="debugreportstepthrough" : if field$=tryfield$ then gdebugreportstepthroughstate=value1
    tryfield$="showentitygameinfo" : if field$=tryfield$ then gshowentitygameinfostate=value1
    tryfield$="showdebugtextingame" : if field$=tryfield$ then gshowdebugtextingamestate=value1
    tryfield$="includeonlyvideo" : if field$=tryfield$ then gincludeonlyvideo=value1
    tryfield$="includeonlyname" : if field$=tryfield$ then gincludeonlyname$=value$
    tryfield$="ignorefastbone" : if field$=tryfield$ then gignorefastbone=value1
    tryfield$="loadreport" : if field$=tryfield$ then gloadreportstate=value1
    `
    tryfield$="optimizemode" : if field$=tryfield$ then goptimizemode=value1
    tryfield$="hsrmode" : if field$=tryfield$ then ghsrmode=value1
    tryfield$="lightmapping" : if field$=tryfield$ then glightmappingstate=value1
    `tryfield$="lightmapsize" : if field$=tryfield$ then glightmapsize=value1
    `tryfield$="lightmapquality" : if field$=tryfield$ then glightmapquality=value1
    tryfield$="lightmapold" : if field$=tryfield$ then glightmappingold=value1
    tryfield$="lightmapshadows" : if field$=tryfield$ then glightshadowsstate=value1
    tryfield$="lightmapambientr" : if field$=tryfield$ then glightambientr=value1
    tryfield$="lightmapambientg" : if field$=tryfield$ then glightambientg=value1
    tryfield$="lightmapambientb" : if field$=tryfield$ then glightambientb=value1
    tryfield$="lightmapsunx" : if field$=tryfield$ then glightsunx=value1
    tryfield$="lightmapsuny" : if field$=tryfield$ then glightsuny=value1
    tryfield$="lightmapsunz" : if field$=tryfield$ then glightsunz=value1
    tryfield$="lightmapsunr" : if field$=tryfield$ then glightsunr=value1
    tryfield$="lightmapsung" : if field$=tryfield$ then glightsung=value1
    tryfield$="lightmapsunb" : if field$=tryfield$ then glightsunb=value1
    tryfield$="lightmapzerorange" : if field$=tryfield$ then glightzerorange=value1
    tryfield$="lightmapatten" : if field$=tryfield$ then glightatten=value1
    tryfield$="lightmapmaxsize" : if field$=tryfield$ then glightmaxsize=value1
    tryfield$="lightmapboost" : if field$=tryfield$ then glightboost=value1
    tryfield$="lightmaptexsize" : if field$=tryfield$ then glighttexsize=value1
    tryfield$="lightmapquality" : if field$=tryfield$ then glightquality=value1
    tryfield$="lightmapblurmode" : if field$=tryfield$ then glightblurmode=value1
    tryfield$="lightmapthreadmax" : if field$=tryfield$ then glightthreadmax=value1

    tryfield$="dynamiclighting" : if field$=tryfield$ then gdynamiclightingstate=value1
    tryfield$="dynamicshadows" : if field$=tryfield$ then gdynamicshadowsstate=value1
    tryfield$="useeffects" : if field$=tryfield$ then guseeffectstate=value1
    tryfield$="useeffectsonguns" : if field$=tryfield$ then guseeffectongunsstate=value1
    tryfield$="useeffectsonscene" : if field$=tryfield$ then guseeffectonscenesstate=value1
    tryfield$="useeffectsonentities" : if field$=tryfield$ then guseeffectonentitiesstate=value1
    tryfield$="dividetexturesize" : if field$=tryfield$ then gdividetexturesize=value1
    `
    tryfield$="usesky" : if field$=tryfield$ then guseskystate=value1
    tryfield$="usefloor" : if field$=tryfield$ then gusefloorstate=value1
    tryfield$="useenvsounds" : if field$=tryfield$ then guseenvsoundsstate=value1
    tryfield$="useweapons" : if field$=tryfield$ then guseweaponsstate=value1
    `
    tryfield$="indieditor" : if field$=tryfield$ then gindieditorstate=value1
    tryfield$="godmode" : if field$=tryfield$ then ggodmodestate=value1
    `
    tryfield$="width" : if field$=tryfield$ then gdisplaywidth=value1
    tryfield$="height" : if field$=tryfield$ then gdisplayheight=value1
    tryfield$="depth" : if field$=tryfield$ then gdisplaydepth=value1
    `
    tryfield$="uniquesignature" : if field$=tryfield$ then guniquesignature=value1
    tryfield$="gameobjectivetype" : if field$=tryfield$ then ggameobjectivetype=value1
    tryfield$="gameobjectivevalue" : if field$=tryfield$ then ggameobjectivevalue=value1
    tryfield$="oneshotkills" : if field$=tryfield$ then goneshotkills=value1
    tryfield$="maxplayers" : if field$=tryfield$ then numberofplayers=value1
    tryfield$="spawnrandom" : if field$=tryfield$ then gspawnrandom=value1
    tryfield$="uniquegamecode" : if field$=tryfield$ then guniquegamecode$=value$
    `
    tryfield$="useuniquelynamedentities" : if field$=tryfield$ then guseuniquelynamedentities=value1
    tryfield$="producelogfiles" : if field$=tryfield$ then gproducelogfiles=value1
    tryfield$="exportassets" : if field$=tryfield$ then gexportassets=value1
    tryfield$="localserver" : if field$=tryfield$ then glocalserveroverride$=value$
    `
    rem all FPI screens
    tryfield$="title" : if field$=tryfield$ then titlefpi$=value$
    tryfield$="global" : if field$=tryfield$ then setupfpi$=value$
    tryfield$="gamewon" : if field$=tryfield$ then gamewonfpi$=value$
    tryfield$="gameover" : if field$=tryfield$ then gameoverfpi$=value$
    tryfield$="levelfpi1" : if field$=tryfield$ then loadingfpi$=value$
    `
    rem Levels
    if field$="levelmax" then glevelmax=value1
    if glevelmax>0
     for v=1 to glevelmax
      tryfield$="levelfpm"+str$(v)
      if field$=tryfield$ then levelfpm$=value$
      tryfield$="levelfpi"+str$(v)
      if field$=tryfield$
       levelfpi$=value$
       dim level$(v) as leveltype
       level$(v).fpm$=levelfpm$
       level$(v).fpi$=levelfpi$
      endif
     next l
    endif
    `
    rem all key actions
    for num=1 to 11
     tryfield$="key"+str$(num)
     if field$=tryfield$ then listkey(num)=value1
    next num
    `
    rem all gun slots
    for num=1 to 9
     tryfield$="slot"+str$(num)
     if field$=tryfield$ then gunslots$(num)=value$
    next num
    `
    rem localization data
    tryfield$="language" : if field$=tryfield$ then language$=value$
    `
   endif
  endif
 next l
 undim data$()
 `
else
 `
 rem No SETUP.INI, default is a standalone game
 grealgameviewstate=1
 gdynamiclightingstate=1
 guseeffectstate=0
 guseeffectongunsstate=0
 guseeffectonscenesstate=0
 guseeffectonentitiesstate=0
 guseskystate=1
 gusefloorstate=0
 guseenvsoundsstate=1
 guseweaponsstate=1
 `
endif

rem USERDETAILS Info`
global language$ : language$=""
tfile$="userdetails.ini"
if file exist(tfile$)=1
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem localization data
    tryfield$="language" : if field$=tryfield$ then language$=value$
    `
   endif
  endif
 next l
 undim data$()
endif

rem One flag that controls many
if guseeffectstate=0
 guseeffectongunsstate=0
 guseeffectonscenesstate=0
 guseeffectonentitiesstate=0
endif

rem Physics debug mode 9to see all collision shapes)
if gdebugphysicsstate=1 then physicsdebug=1

rem Forced switches
if gcompilestandaloneexe=1
 rem Cannot be real game, must optimize
 grealgameviewstate=0
 goptimizemode=1
 rem Wipe any imported unique code (generate when build EXE)
 guniquegamecode$=""
endif
if gtestgamemodefromeditor=1
 grealgameviewstate=0
endif

rem The MyGames folder precedes Files\
global exedir$ : exedir$=get dir$()+"\MyGames\"
rem Vista Alert!
`global usersdocumentsfolder$ : usersdocumentsfolder$="?"
`global exedirmaster$ : exedir$=usersdocumentsfolder$+"\MyGames\"
`global exedir$ : exedir$=exedirmaster$

rem First task for any program is to enter the Files Folder
tnopathprotomode=0
if path exist("Files")=1
 set dir "Files"
else
 tnopathprotomode=1
` distinquish between runtime final exe and proto
` print "No Files!"
` wait key
` end
endif

rem Basic globals for all programs
global gmapeditmode : gmapeditmode=0

rem Establish global files and folders
global imgext$ : imgext$="tga"
global rootdir$ : rootdir$=get dir$()+"\"
global browserexe$ : browserexe$="FPSC-Browser.exe"
global browsername$ : browsername$="FPSC TEST Browser"
global segeditexe$ : segeditexe$="FPSC-Segments.exe"
global segeditname$ : segeditname$="FPSC TEST Segment Editor"
global gameexe$ : gameexe$="FPSC-Game.exe"
global gamename$ : gamename$="FPSC Game"

rem Default directories
global currentmeshdir$ : currentmeshdir$=rootdir$+"meshbank\"
global currententitydir$ : currententitydir$=rootdir$+"entitybank\"
global currenttexdir$ : currenttexdir$=rootdir$+"texturebank\"
global currentfxdir$ : currentfxdir$=rootdir$+"effectbank\"
global currentpredir$ : currentpredir$=rootdir$+"prefabs\"
global currentsegdir$ : currentsegdir$=rootdir$+"segments\"

rem And finally switch the resolution if different from default
if tnopathprotomode=0
 if gdisplaywidth<>1024 or gdisplayheight<>768 or gdisplaydepth<>32
  set display mode gdisplaywidth,gdisplayheight,gdisplaydepth
 endif
endif
global gratiox# : gratiox#=gdisplaywidth : gratiox#=gratiox#/1024.0
global gratioy# : gratioy#=gdisplayheight : gratioy#=gratioy#/768.0

rem Indicate a time stamp for app start time
timestampactivity(0,"Time Stamp Activity Started")

rem Translation Component (load strarr data)
if tnopathprotomode=0
 stdir$=get dir$()
 if language$="" then language$="english"
 set dir "languagebank\"+language$+"\textfiles\"
 global wordlibmax
 if file exist("fpsc-050.ini")=1
  open to read 1,"fpsc-050.ini"
  read string 1,wordlibmax$ : wordlibmax=val(wordlibmax$)
  close file 1
  strarrmax=1
  dim strarr$(wordlibmax)
  dim wordlib$(wordlibmax)
  load array "fpsc-050.txt",wordlib$()
  for n=0 to wordlibmax
   for c=1 to len(wordlib$(n))
    if mid$(wordlib$(n),c)="="
     strarri=val(left$(wordlib$(n),c-1))
     strarr$(strarri)=right$(wordlib$(n),len(wordlib$(n))-c)
     if strarri>strarrmax then strarrmax=strarri
     exit
    endif
   next c
  next n
  undim wordlib$()
 else
  rem language file missing
  exit prompt "FAIL","CANNOT FIND LANGUAGE FILE!"
  end
 endif
 set dir stdir$
endif

rem Version control on EXE Building
gosub _version_endofinit

rem
rem GAME MAIN
rem

rem Create controls for debug view
global gamedebugrefresh : gamedebugrefresh=0
global gamedebugviewtime : gamedebugviewtime=0
global gamedebugviewmem : gamedebugviewmem=GET MEMORY AVAILABLE(0)
global gamedebugviewlastmem : gamedebugviewlastmem=0
global gamedebugview$ : debugviewactivate(1)
global debugviewmode
global debugviewtog

rem For status text if any
set text font "Verdana"

rem Init app
sync on : sync rate 30 : autocam off : disable systemkeys
hide mouse : backdrop off : disable escapekey

rem If Game is NOT IN TEST MODE, default is full screen shown
if gtestgamemodefromeditor=0 and gcompilestandaloneexe=0
 `
 rem Show window
 timestampactivity(0,"Start Fullscreen")
 gosub _main_game_showwindownow
 `
 `rem If FREEWARE PROMPT tampered, exit (EA ONLY VERSION)
 `if grealgameviewstate=1
 ` filename$="languagebank\"+language$+"\gamecore\huds\freeware.jpg"
 ` fsize=file size(filename$)
 ` if fsize=47319
 `  load image filename$,1
 `  if image exist(1)=1
 `   delete image 1
 `  else
 `   fsize=0
 `  endif
 ` endif
 ` if fsize<>47319
 `  screenprompt(img,strarr$(121))
 `  timestampactivity(0,strarr$(122))
 `  sleep 5000
 `  end
 ` endif
 `endif
 `
 rem optional splash or blank screen at Very Start of Execution
 cls 0 : sync : cls 0 : sync
 if file exist("..\splash.bmp")=1
  rem perhaps publisher splash optional here (finds a specific file name)
  load image "..\splash.bmp",1
  if image exist(1)=1
   set sprite 1,0,1
   sprite 1,0,0,1
   set sprite alpha 1,0
   size sprite 1,1024,768
   for f=0 to 255 step 10
    cls 0 : set sprite alpha 1,f : sync
   next f
   set sprite alpha 1,255
   cls 0 : sync : cls 0 : sync
  endif
 endif
 rem get the actual server IP for information purposes
 if gmultiplayergame=1
  `
  rem connection check and IP gathering
  show mouse
  `
  rem FPSCV105 - 090307 - check FIREWALL
  rem FPSCV105RC2 - 100307 - AND puts the actual HOSTable IP address in serveripaddress$
  gosub _ai_gamelist_checkforfirewall
  `
  rem FPSCV105RC3 - 140307 - also gather the local IP (in case they want a LAN game) ;localipaddress$;
  MULTIPLAYER CREATE TCP SERVER servername$
  localipaddress$=MULTIPLAYER GET IP ADDRESS()
  if left$(localipaddress$,8)<>"192.168." then localipaddress$=""
  for c=1 to len(serveripaddress$)
   if mid$(localipaddress$,c)=":" then localipaddress$=left$(localipaddress$,c-1) : exit
  next c
  MULTIPLAYER DISCONNECT
  `
  rem OLD WAY
  remstart
  rem get IP
  timestampactivity(0,"Getting serveripaddress$..")
  if serveripaddress$=""
   MULTIPLAYER CREATE TCP SERVER servername$
   if len(glocalserveroverride$)=0
    serveripaddress$=MULTIPLAYER GET IP ADDRESS()
    for c=1 to len(serveripaddress$)
     if mid$(serveripaddress$,c)=":" then serveripaddress$=left$(serveripaddress$,c-1) : exit
    next c
   else
    serveripaddress$=glocalserveroverride$
   endif
   MULTIPLAYER DISCONNECT
  endif
  timestampactivity(0,"serveripaddress$="+serveripaddress$)
  remend
  `
  rem done with network stuff for now
  hide mouse
  `
 endif
 if image exist(1)=1
  for f=255 to 0 step -20
   cls 0 : set sprite alpha 1,f : sync
  next f
  set sprite alpha 1,0
  cls 0 : sync : cls 0 : sync
  delete sprite 1
  delete image 1
 endif
 `
endif

rem Reset file collector
resetfilecollection()

rem Add localisation text to final game
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.ini")
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.txt")
endif

rem Add ODE licenses text files to final game
if gcompilestandaloneexe=1
 addfiletocollection("License\LICENSE-BSD.TXT")
endif

rem Add SAVELOAD mandatory media
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\saveload-base.tga")
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\areyousure.tga")
endif

rem Forced 'Shader Compatibility Warning' PROMPT
if gcompilestandaloneexe=1 or grealgameviewstate=1
 filename$="languagebank\"+language$+"\gamecore\huds\noshader.tga"
 img=loadinternalimagecompressquality(filename$,5,1)
endif
if grealgameviewstate=1
 tneed#=0.0
 if guseeffectstate=1
  tneed#=1.0
  if guseeffectonscenesstate=1
   tneed#=2.0
  endif
 endif
 tpsv#=get maximum pixel shader version()
 timestampactivity(0,"Shaders - Need:"+str$(tneed#)+" Got:"+str$(tpsv#))
 if tneed#>tpsv#
  screenprompt(img,strarr$(123))
 endif
endif

rem Run gameflow default screen path
timestampactivity(0,"Game Flow Started..")
gosub _gameflow_default

`rem Forced FREEWARE PROMPT (EA ONLY PROMPT)
`if gcompilestandaloneexe=1 or grealgameviewstate=1
` filename$="languagebank\"+language$+"\gamecore\huds\freeware.jpg"
` img=loadinternalimagecompressquality(filename$,5,1)
`endif
`if grealgameviewstate=1
` screenprompt(img,strarr$(124))
`endif

rem Export game as standalone if -B used
if gcompilestandaloneexe=1
 rem Generate unique code
 guniquegamecode$=genuniqueservercode(gbuildname$)
 rem Build Executable Game Mode
 gosub _main_game_buildexe
 rem close dialog (cannot reload data into it when RELOAD MAPEDITOR)
 open file map 1, "FPSBUILDGAME"
 set file map dword 1, 24, 1
 wait for file map event 1
 close file map 1
 rem call map editor back
 open file map 1, "FPSEXCHANGE"
 set file map string$ 1, 1000, "FPSC-MapEditor.exe"
 set file map string$ 1, 1256, "-r"
 set file map dword 1, 994, 0
 set file map dword 1, 924, 1
 wait for file map event 1
 close file map 1
 rem FPSXV10X - time for CPU(FPSCreator.exe) to conduct filemap scan
 `if gexitpromptreportmodestate<>0
 ` backdrop off
 ` show window
 ` position camera 0,50000,0
 ` while shiftkey()=0
 `  cls 0
 `  ink rgb(rnd(255),rnd(255),rnd(255)),0
 `  center text screen width()/2,(screen height()/2)-20,"USE 'FPSCREATORDUMPMEM.EXE' NOW!"
 `  center text screen width()/2,(screen height()/2)+00,"USE PROCESS VIEW TO SEE IF FPSC-MAPEDITOR.EXE APPEARS (give it one minute)"
 `  center text screen width()/2,(screen height()/2)+20,"PRESS SHIFT WHEN TESTS COMPLETE"
 `  sleep 1
 `  sync
 ` endwhile
 `endif
endif

rem End executable
if gexitpromptreportmodestate<>0 then exit prompt "Terminated Game Exe","FPSCV10X Debug Report"
timestampactivity(0,strarr$(125))
end

`
` EXE Building Subroutines
`

_main_game_buildexe:
 `
 rem Version control on EXE Building
 gosub _version_main_game_buildexe
 `
return

`
` MAIN GAME SUBROUTINES
`

_main_game_loadgamedata:
 `
 rem Display game loading/creating-game backdrop
 if gdebugreportmodestate=1
  if gtestgamemodefromeditor=0
   for s=0 to 1
    cls rgb(255,255,0)
    ink rgb(0,0,255),0 : center text screen width()/2,screen height()/2,"DEBUG REPORT MODE ACTIVE"
    ink rgb(255,255,255),0
    sync
   next s
  endif
 endif
 debugviewprogressmax(330)
 `
 rem Place camera faw away (effectively hide all 3D)
 realrange#=9000.0
 set camera range 2.0,realrange#
 position camera -50000,50000,50000
 point camera -50000,50010,50000
 `
 rem Load segment banks
 segobjusedforfinalgame=1 : segnoeffects=gsegnoeffectstate
 `
 rem Load AI Scripts (can be done in elements process-only load as needed)
 debugviewtext(30,strarr$(126)) : gosub _ai_loadallscripts
 debugviewtext(60,strarr$(127)) : gosub _decal_init
 if gmultiplayergame=0 then debugviewtext(70,strarr$(128)) : gosub _flak_init
 debugviewtext(75,strarr$(129)) : gosub _gun_init
 debugviewtext(80,strarr$(130)) : gosub _gun_setup
 `
return

_main_game_freeleveldata:
 `
 rem only for final game run ( not test game ) - uses leavegamedataalone in last part
 if grealgameviewstate=1 or gcompilestandaloneexe=1
  `
  rem Free multiplayer resources
  gosub _multi_free
  `
  rem Free fragments
  if gmultiplayergame=0 then gosub _part_free
  `
  rem Free the old gun
  gosub _gun_freeafterlevel
  `
  rem Place camera faw away (effectively hide all 3D)
  position camera -50000,50000,50000
  point camera -50000,50010,50000
  `
  rem Remove universe (so camera can reset to no-3D-view)
  gosub _universe_destruct
  `
  rem Physics cleanup
  gosub _ode_cleanup
  `
  rem Remove all images
  deleteallinternalimages()
  `
  rem FREE REST OF GAME RESOURCES
  for p=1 to 65535 : if particles exist(p)=1 : delete particles p : endif : next p
  for e=1 to 65535 : if effect exist(e)=1 : delete effect e : endif : next e
  for s=1 to 65535 : if sound exist(s)=1 : delete sound s : endif : next s
  delete objects 1,endofallobjectsoffset
  `
  rem FREE ANY DATA
  undim undoredolist()
  undim meshbank$()
  undim texturebank$()
  undim effectbank$()
  undim soundbank$()
  undim prefabbank$()
  undim selectionbank$()
  undim entitybank$()
  undim gunbank$()
  undim muzzlebank$()
  undim brassbank$()
  undim smokebank$()
  undim flakbank$()
  undim decalbank$()
  undim imagebank$()
  undim segmentprofileheader()
  undim segmentprofile()
  undim map()
  undim viscolmap()
  undim lighttable()
  undim refmap()
  undim mapolay()
  undim olaylist()
  undim mapentries()
  undim mastermesh()
  undim entitybodypart()
  undim entityanim()
  undim entityprofileheader()
  undim entityprofile()
  undim entityelement()
  undim entitydebug$()
  undim aiactionseq()
  undim aiaction()
  undim aiconditionseq()
  undim aicond()
  undim ailist()
  undim waypointcoord()
  undim waypoint()
  undim debris()
  undim gun()
  undim gunsound()
  undim gunsoundcompanion()
  undim gunsounditem()
  undim flak()
  undim flakelement()
  undim decal()
  undim decalelement()
  undim player()
  undim playersound()
  undim playerinventory()
  undim infinilight()
  undim infinilightshortlist()
  undim shadowlight()
  undim hud()
  `
  rem Ensure loader HUD is not used if resources removed
  internalloaderhud=0
  `
  rem Special exception as only arrays that need carrying to new levels
  if leavegamedataalone=0
   undim scriptbank$()
   undim weaponslot()
   undim weaponammo()
   undim weaponclipammo()
  endif
  undim weaponhud()
  `
  rem Recreate all data for new level (uses leavegamedataalone)
  gosub _FPSC_Full_Data_Init
  `
 endif
 `
return

_main_game_core:
 `
 rem Transition
 if gamewarmupcount=0
  if gametransitionscreen=1
   dec gametransitionscreencount,30
   if gametransitionscreencount<=0
    set camera view 0,0,screen width(),screen height()
    gametransitionscreen=0 : gametransitionscreencount=0
    rem Handle Hosting/Joining (multiplayer) when 3D starts
    if gmultiplayergame=1 and multiplayerinitialised=0 then gosub _multi_start
   else
    if gametransitionscreencount<(screen height()/2)-30
     position camera lastcamx#,lastcamy#,lastcamz#
     color backdrop rgb(0,0,64)
    endif
    set camera view 0,gametransitionscreencount,screen width(),gametransitionscreencount+(screen height()-(gametransitionscreencount*2))
   endif
  endif
 else
  rem the warmup allows decals to form, player start gravity to settle, etc
  cls 0 : dec gamewarmupcount : if gamewarmupcount<0 then gamewarmupcount=0
  if gamewarmupcount=0 then cleardelta=mousemovex() : cleardelta=mousemovey()
 endif
 `
 rem Sky stays with camera
 if object exist(65123)=1
  position object 65123,camera position x(0),camera position y(0),camera position z(0)
 endif
 if object exist(65124)=1
  position object 65124,camera position x(0),camera position y(0)+1000,camera position z(0)
  scroll object texture 65124,0.0004,0.0005
 endif
 `
 rem Control main game
 gosub _main_game_corecontrol
 `
 rem Get time from last sample to SYNC command (rest)
 inc gameperfresttosync, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem Update physics
 gosub _ode_update
 `
 rem Count physics time
 inc gameperfphysics, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem Measure overall performance counts
 inc gameperftotalcount, perftimer()-gameperftotalcountTOP
 gameperftotalcountTOP=perftimer()
 `
 rem Update screen
 sync
 `
 rem Can intercept to grab screen
 if keystate(plrkeyF12)=1
  tnum=1
  repeat
   snapshotfile$="..\snapshot"+str$(tnum)+".bmp"
   inc tnum
  until file exist(snapshotfile$)=0
  get image 21000000,0,0,screen width(),screen height(),1
  if image exist(21000000)=1
   save image snapshotfile$,21000000,1
   delete image 21000000
  endif
  while keystate(plrkeyF12)=1
  endwhile
 endif
 `
 rem Sync Performance check
 gameperfsync=gameperfsync+(perftimer()-gameperftimestamp)
 gameperftimestamp=perftimer()
 gamedebugviewtime=timer()
 `
 rem Exit Conditions for test game
 if grealgameviewstate=0
  if escapekey()=1 then continueokay=1 : levelwon=2 : rem QUIT
 endif
 `
return



rem
rem LEES Game Runner Code
rem

_load_game_scene:

rem Loading Screen
if gdebugreportmodestate=0 then set camera view 0,0,1,1

rem Direct to realgame or testgame
if grealgameviewstate=1
 `
 rem Set realgame level path
 levelmapptah$="levelbank\testlevel\"
 `
 rem load the FPL file which populates testlevel for current level to play (level var)
 gosub _mapfile_load_fpl
 `
else
 `
 rem During test map this path can be used (map edit files)
 levelmapptah$="mapbank\testmap\"
 `
 rem Load the FPM data to mapbank\testmap (level var)
 if gcompilestandaloneexe=1
  gosub _mapfile_loadgamemap_fpm
  elementsfilename$=""
 endif
 `
endif

rem Free any old player resources
debugviewtext(120,strarr$(131)) : gosub _player_free

rem Flush video for new graphics usages
debugviewtext(130,strarr$(132)) : flush video memory

rem Free old resources first
debugviewtext(140,strarr$(133)) : gosub _entity_deleteelements

rem Load waypoints
if gshowdebugtextingamestate=0 then gdontcreatewaypointobjects=1
debugviewtext(150,strarr$(134)) : gosub _waypoint_loaddata
if gshowdebugtextingamestate=1 then gosub _waypoint_createallobjs

rem Ensure segments are loaded (not for final game though - universe dbo does this)
if grealgameviewstate=0 then debugviewtext(160,strarr$(135)) : gosub _segment_loadbank

rem Ensure segments and entities are up to date
debugviewtext(170,strarr$(136)) : gosub _entity_loadbank

rem Load individual-elements
debugviewtext(180,strarr$(137)) : gosub _entity_loadelementsdata
debugviewtext(185,strarr$(137)) : gosub _entity_switchtostaticformultiplayer

rem Load map (with any segment entitiy-elements)
debugviewtext(200,strarr$(138)) : gosub _game_loadmap

rem Finally create and attach elements to map
if gmultiplayergame=0 then debugviewtext(299,strarr$(626)) : gosub _part_init
debugviewtext(300,strarr$(139)) : gosub _entity_createelements
debugviewtext(310,strarr$(140)) : gosub _entity_attachelementstogame
debugviewtext(311,strarr$(141)) : gosub _ai_createentityreferences

rem Load material list and sounds
debugviewtext(312,strarr$(142)) : gosub _ode_loadmateriallist

rem Entities can intropduce fake players, init all
debugviewtext(312,strarr$(142)) : gosub _player_startgun
debugviewtext(313,strarr$(143)) : gosub _gun_loadonlypresent
debugviewtext(314,strarr$(144)) : gosub _decal_loadonlyactivedecals

rem Entities can intropduce fake players, init all
debugviewtext(318,strarr$(145)) : gosub _player_init : gosub _player_resetobjectives
debugviewtext(320,strarr$(146)) : gosub _entity_startentitiesoff

rem Okay for start of game, can skip for exe construction
if gcompilestandaloneexe=0
 `
 rem Physics init of universe and entities (321,322,323)
 debugviewtext(321,strarr$(627)) : gosub _ode_init
 `
 rem Setup camera (player)
 debugviewtext(324,strarr$(628)) : gosub _player_setup
 `
 rem Reset multiplayer state (multiplayer)
 if gmultiplayergame=1
  gosub _multi_restartprepare
  multiplayerinitialised=0
 endif
 `
 rem Starting main loop
 debugviewtext(329,strarr$(629))
 `
endif

rem TestGameFromEditor Mode
if gtestgamemodefromeditor=1
 `
 rem Activate OK button
 open file map 1, "FPSTESTGAMEDIALOG"
 set file map dword 1, 12, 1
 set file map string$ 1, 1000, strarr$(147)
 set file map dword 1, 8, 100
 wait for file map event 1
 close file map 1
 while 1
  open file map 1, "FPSEXCHANGE"
  wait for file map event 1
  rem Wait for Test Game Dialog OK button pressed
  if get file map dword( 1, 974 ) = 1 then exit
  if get file map dword( 1, 994 ) = 1
   rem terminate test game mid-build
   set file map string$ 1, 1000, "FPSC-MapEditor.exe"
   set file map string$ 1, 1256, "-r"
   set file map dword 1, 994, 2
   set file map dword 1, 924, 1
   wait for file map event 1
   close file map 1
   rem Terminate
   end
  else
   close file map 1
  endif
  sync
 endwhile
 close file map 1
 `
 rem make sure the cancel code is not detected for anymore in debug function
 gtestgamemodefromeditorokaypressed=1
 `
 rem Version Control - possible logo use
 gosub _version_onscreenlogos
 `
 rem Show Test Game Window
 gosub _main_game_showwindownow
 `
endif

rem Sample transition IN
gametransitionscreen=1 : gametransitionscreencount=600/2

return

_main_game_showwindownow:
 set window layout 0,0,0
 maximize window
 show window
 window to front
return

_main_game_corecontrol:

rem Stamp time for performance meter
if showgamemenu=0 then position mouse screen width()/2,screen height()/2

rem STATUS AND HUD GRAPHICS
if gamewarmupcount=0
 gosub _screen_control
endif

rem FPSCV104RC4 - i want to see this
`if grealgameviewstate=0
if gdebugreportmodestate=1 or grealgameviewstate=0
 `
 rem Debug info
 debuggameoverlaysystem(0)
 inc gameperfdebug, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
else
 `
 rem Ingame debug FPS
 if keystate(15)=0 then keystate15pressed=0
 if keystate(15)=1 and keystate15pressed=0
  inc showfpsinrealgame
  if ggodmodestate=0
   if showfpsinrealgame>1 then showfpsinrealgame=0
  else
   if showfpsinrealgame>2 then showfpsinrealgame=0
  endif
  keystate15pressed=1
 endif
 if showfpsinrealgame=1 then set cursor 0,0 : print screen fps()
 `
 rem suicide key
 if gmultiplayergame=1
  if lower$(inkey$())="i" and gtalkytoaster=0
   tdamage=10 : e=characterchoiceentityindex(iLocalEL)
   if entityelement(e).health>0
    gosub _multi_dealentityedamage
   endif
  endif
 endif
 `
 rem Talk system
 if gmultiplayergame=1
  tylinevalue=screen height()-20
  if lower$(inkey$())="t" and gtalkytoaster=0
   gtalkytoaster=1 : clear entry buffer
  endif
  if gtalkytoaster=1
   set cursor 0,tylinevalue
   print "TALK>";entry$();
  endif
  if returnkey()=1 and gtalkytoaster=1
   rem send message to all
   gtalkytoaster=0
   tmessage$=entry$()
   MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
   MULTIPLAYER SEND MESSAGE STRING ">>"+tmessage$,0x0080
   clear entry buffer
   rem see own message (only if server)
   if createorjoin=1
    talkscript$(talkindex)=">>"+tmessage$
    talkscriptcount(talkindex)=200
    talkscriptwho(talkindex)=iLocalEL
    inc talkindex : if talkindex>10 then talkindex=0
   endif
  endif
 endif
 `
 rem Ingame debug SPEEDTESTS
 if showfpsinrealgame=2
  rem multiplayer data
  if gmultiplayergame=1
   if timer()-totalbytestime>1000
    totalbytestime=timer()
    totalguarenteedbytes=guarenteedbytes
    totalunreliablebytes=unreliablebytes
    guarenteedbytes=0
    unreliablebytes=0
   endif
   tt$="GD="+str$(totalguarenteedbytes)
   text (screen width()/2)-75,screen height()-80,tt$
   tt$="UD="+str$(totalunreliablebytes)
   text (screen width()/2)+00,screen height()-80,tt$
   tt$="QUEUE="+str$(multiplayer get queue size(0))+","+str$(multiplayer get queue size(1))
   text (screen width()/2)+75,screen height()-80,tt$
  endif
  rem regular stats
  debugviewmode=0
  debuggameoverlaysystem(0)
  inc gameperfdebug, perftimer()-gameperftimestamp
  gameperftimestamp=perftimer()
 endif
 `
endif

rem Dynamic lighting control
gosub _lighting_ambientcontrol
if (gdynamiclightingstate=1 and lightingsystemdisabled=0) or forceambientlightsetting>0
 gosub _lighting_control
 gosub _lighting_managedynamiclights
 gosub _lighting_managegloballighting
 gosub _lighting_applyplayerlighting
 gosub _lighting_applytoscene
endif
gosub _lighting_controlupdate
inc gameperflighting, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Game Active
if gamewarmupcount=0
 `
 rem Skip input (if not multiplayer ready or talkmode on)
 tokay=1
 if gmultiplayergame=1 and PlayerCanStart=0 then tokay=0
 if gtalkytoaster=1 then tokay=0
 if tokay=1
  `
  rem Player management
  gosub _player_input
  gosub _player_manager
  gosub _player_itemmanager
  gosub _player_mission
  `
  rem The Player Camera
  gosub _player_camera
  gosub _gun_update_hud
  `
 endif
 `
endif

rem Measure plr calcs time
inc gameperfplayer, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Entity Control Handling Here
gosub _entity_controlelements
inc gameperfentities, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Control multiplayer communicaions (multiplayer)
if gmultiplayergame=1 and multiplayerinitialised=1 and multiplayersystemdisabled=0
 gosub _multi_control
endif

rem Game Active
if gamewarmupcount=0
 `
 rem After AutoCol (after plr move and entity push-back, use autocol so stay in walls)
 gosub _ode_playeraftermove
 gosub _ode_playerpickup
 `
 rem The Gun Manager after new camera pos/rot
 gosub _gun_manager
 inc gameperfgun, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
endif

rem Flak in-game handling
gosub _particles_control
if gmultiplayergame=0 then gosub _flakelement_control
if supportsystemdisabled=0
 gosub _decalelement_control
endif
gosub _part_controlexploders
gosub _gun_update_overlay
inc gameperfmisc, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

return

function screenprompt(img,desc$)
 backdrop off : position camera -50000,-50000,-50000 : point camera -550000,-550000,-550000
 ink rgb(255,255,255),0 : set text font "Verdana" : set text size 24
 cls 0 : sync : cls 0 : sync
 for s=1 to 20
  center text screen width()/2,(screen height()/2)-16,desc$
  if img>0
   if image exist(img)=1
    paste image img,(screen width()-512)/2,(screen height()-384)/2
   endif
  endif
  sync : sleep 200
 next s
endfunction

function timestampactivity(i,desc$)
 if gproducelogfiles=1
  if i=0
   inc timestampactivityindex
   timestampactivityflagged=1
   i=timestampactivityindex
  else
   timestampactivityindex=i
  endif
  if i>timestampactivitymax
   timestampactivitymax=i
  endif
  dim timestampactivity$(timestampactivitymax)
  timestampactivity$(i)=str$(timer())+" : "+desc$
  file$="..\FPSC-Game.log" : if file exist(file$)=1 then delete file file$
  open to write 1,file$
   for t=1 to timestampactivitymax
    write string 1,timestampactivity$(t)
   next t
  close file 1
 endif
endfunction

rem Function to use anywhere
function genuniqueservercode(name$)
 date$=get date$()
 time$=get time$()
 code$=""
 for index=0 to 10
  ci1=index mod len(name$) : c1$=mid$(name$,1+ci1) : if c1$="," then c1$="."
  ci2=index mod len(date$) : c2$=mid$(date$,1+ci2) : if c2$="," then c2$="."
  ci3=index mod len(time$) : c3$=mid$(time$,1+ci3) : if c3$="," then c3$="."
  code$=code$+c1$+c2$+c3$
 next index
 code$=right$(code$,32)
endfunction code$

`
` TO resolve share issue with new version attachment
`

_interface_openbuildgame:
_interface_handlebuildgame:
_interface_closebuildgame:
return


rem
rem GAME
rem

`
` Game Core Functions
`
_game_loadmap:

rem Load map data (in real mode, we ignore what the header gmultiplayergame flag is)
storegmultiplayergame=gmultiplayergame : gosub _mapfile_loadmap
if grealgameviewstate=1 then gmultiplayergame=storegmultiplayergame

rem Setup lighting
gosub _lighting_init

rem V106 Can skip universe construction if flagged
rem do not call skip code if real game or build game
rem compare MAP arrays with last saved copy
rem compare static lights to last saved copy
rem compare static entities to last saved copy
if gcompilestandaloneexe=1 or grealgameviewstate=1
 if grealgameviewstate=1 then tperformuniverseconstruction=0
 if gcompilestandaloneexe=1 then tperformuniverseconstruction=1
else
 rem only in test game scenario should this check be made
 tperformuniverseconstruction=1
 gosub _universe_construct_skip : rem sets universeconstructskip flag
 if universeconstructskip=1 then tperformuniverseconstruction=0
endif

rem If universe.dbo not present, construct it
universefile$="levelbank\testlevel\universe.dbo"
if tperformuniverseconstruction=0
 `
 rem sneak automatic floor texture into data!
 thorizonplanes$=""
 `
 rem Load effects (as some scene geometry needs setting changes)
 debugviewtext(195,strarr$(115))
 filename$="levelbank\testlevel\universe.eff"
 open to read 1,filename$
  read file 1,teffectbankmax
  for eff=1 to teffectbankmax
   read string 1,tfile$
   teffectid=loadinternaleffect(tfile$)
  next eff
  read string 1,thorizonplanes$
 close file 1
 `
 rem load pre-created universe for level
 debugviewtext(200,strarr$(116))
 load static objects universefile$,gdividetexturesize
 `
 rem Load elements list (that includes scene dynamic entities)
 if grealgameviewstate=1 or gcompilestandaloneexe=1
  rem V106 RC4 only for final game loading and construction
  debugviewtext(201,strarr$(117))
  elementsfilename$="levelbank\testlevel\universe.ele" : gosub _entity_loadelementsdata
 endif
 `
 rem Load infinity lights data
 debugviewtext(202,strarr$(118))
 filename$="levelbank\testlevel\universe.lgt"
 open to read 1,filename$
  read file 1,tinfinimax
  dim infinilight(tinfinimax) as infinilighttype
  for i=0 to tinfinimax
   read file 1,infinilight(i).used
   read file 1,infinilight(i).type
   read float 1,infinilight(i).x
   read float 1,infinilight(i).y
   read float 1,infinilight(i).z
   read float 1,infinilight(i).range
   read file 1,infinilight(i).id
   read float 1,infinilight(i).dist
   read file 1,infinilight(i).colrgb.r
   read file 1,infinilight(i).colrgb.g
   read file 1,infinilight(i).colrgb.b
   read file 1,infinilight(i).islit
  next i
 close file 1
 `
 rem count dynamic lights for the counter that controls this activity
 activatedynamiclightscount=0
 if gdynamiclightingstate=1
  for i=0 to tinfinimax
   if infinilight(i).type=1
    inc activatedynamiclightscount
   endif
  next i
 endif
 `
 rem create horizon planes
 segobjstart=universebuildobjstartoffset
 segobj=segobjstart
 if gusefloorstate=1
  rem load in the texture used by the horizon polys (from filename got from above)
  mapselection=1 : dim segmentprofile(mapselection,64) as segmentprofiletype
  if thorizonplanes$="" then thorizonplanes$="texturebank\common\ground_D2.tga"
  segmentprofile(mapselection,0).texdid=loadinternalimage(thorizonplanes$)
  rem create the edge of universe polys
  gosub _universe_createhorizonplanes
 endif
 lastsegobj=segobj
 `
else
 `
 rem construct universe for level
 segobjstart=universebuildobjstartoffset
 gosub _universe_construct
 `
endif

rem Opportunity for ambience to be adjusted based on number of lights
gosub _lighting_postdefaults

rem Use mapdata to build viscolmap data
gosub _entity_fillviscolmap

rem setup scorch texture
if guseweaponsstate=1
 debugviewtext(280,strarr$(119))
 tbullethole=loadinternalimage("gamecore\Bulletholes\bulletholes.tga")
 debugviewtext(290,strarr$(120))
 set static scorch tbullethole,4,4
endif

return

`
` SUPPORT SUBROUTINES FOR GRIDEDIT CODE
`

_gridedit_getmapvalues:
 `
 rem mapid in
 mapselection    = ( mapid && %11111111111100000000000000000000 ) >> 20
 mapscaler       = ( mapid && %00000000000011110000000000000000 ) >> 16
 mapground       = ( mapid && %00000000000000001100000000000000 ) >> 14
 maprotate       = ( mapid && %00000000000000000011000000000000 ) >> 12
 maporient       = ( mapid && %00000000000000000000110000000000 ) >> 10
 mapsymbol       = ( mapid && %00000000000000000000001111110000 ) >> 4
 maptile         = ( mapid && %00000000000000000000000000001111 )
 `
return

_gridedit_makemapvalues:
 `
 mapid = 0
 mapid = mapid + ( ( mapselection && %111111111111 ) << 20 )
 mapid = mapid + ( ( mapscaler && %1111 ) << 16 )
 mapid = mapid + ( ( mapground && %11 ) << 14 )
 mapid = mapid + ( ( maprotate && %11 ) << 12 )
 mapid = mapid + ( ( maporient && %11 ) << 10 )
 mapid = mapid + ( ( mapsymbol && %111111 ) << 4 )
 mapid = mapid + ( ( maptile && %1111 ) )
 rem mapid out
 `
return

rem
rem SEGMENTS
rem

_segment_validatearraysize:
 `
 rem ensure enough space in arrays
 if segidmaster+32>segidmastermax
  segidmastermax=segidmaster+32
  dim selectionbank$(segidmastermax)
  dim selectionbanklocal$(segidmastermax)
  dim segmentprofileheader(segidmastermax) as segmentprofileheadertype
  dim segmentprofile(segidmastermax,64) as segmentprofiletype
 endif
 `
return

_segment_shufflebank:

rem FPSCV104RC6 - scan entire map data, delete all segment entries not used
if segidmaster>0
 dim segmentbankused(segidmaster)
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 rem segs in map
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0 then segmentbankused(tttsegid)=1
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0 then segmentbankused(tttsegid)=1
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 for tttsegid=1 to segidmaster
  if segmentbankused(tttsegid)=0
   selectionbank$(tttsegid)=""
  endif
 next tttsegid
 rem shuffle to remove empties
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 treadsegid=1 : tlargest=0
 for tttsegid=1 to segidmaster
  if treadsegid<=segidmaster
   while selectionbank$(treadsegid)=""
    inc treadsegid : if treadsegid>segidmaster then exit
   endwhile
   if treadsegid<=segidmaster
    selectionbank$(tttsegid)=selectionbank$(treadsegid)
    selectionbanklocal$(tttsegid)=selectionbanklocal$(treadsegid)
    segmentprofileheader(tttsegid)=segmentprofileheader(treadsegid)
    for tt=0 to 64 : segmentprofile(tttsegid,tt)=segmentprofile(treadsegid,tt) : next tt
    segmentbankused(treadsegid)=tttsegid
    tlargest=tttsegid
   else
    selectionbank$(tttsegid)=""
   endif
  else
   selectionbank$(tttsegid)=""
  endif
  inc treadsegid
 next tttsegid
 rem new list size
 if segidmaster<>tlargest
  segidmaster=tlargest
  entityorsegmententrieschanged=1
 endif
 rem update bank index numbers in mapdata
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0
      rem new segment entry place index
      newtttsegid = segmentbankused(tttsegid)
      tttmapid = tttmapid && %00000000000011111111111111111111
      tttmapid = tttmapid || ( newtttsegid << 20 )
      map(tttl,tttx,ttty)=tttmapid
     endif
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0
        newtttsegid = segmentbankused(tttsegid)
        tttmapid = tttmapid && %00000000000011111111111111111111
        tttmapid = tttmapid || ( newtttsegid << 20 )
        olaylist(ttto,tt)=tttmapid
       endif
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 undim segmentbankused()
endif

return

_segment_savebank:

rem Save segment bank
if file exist("mapbank\testmap\map.seg")=1 then delete file "mapbank\testmap\map.seg"
open to write 1,"mapbank\testmap\map.seg"
 write file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   write string 1,selectionbank$(segid)
  next segid
 endif
close file 1

return

_segment_deletebank:

rem Destroy old segments
if segidmastermax>0
 rem changed from segidmaster
 for segid=1 to segidmastermax
  segobj=selectionbankoffset+segid
  if object exist(segobj)=1 then delete object segobj
  selectionbank$(segid)=""
 next segid
endif
segidmaster=0

return

_segment_loadbank:

rem If seg file exists
if file exist("mapbank\testmap\map.seg")=1

rem Destroy old segments
gosub _segment_deletebank

rem Load segment bank
open to read 1,"mapbank\testmap\map.seg"
 read file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 1,selectionbank$(segid)
  next segid
 endif
close file 1

rem Load segments specified by bank
segdir$="segments\"
if segidmaster>0
 for segid=1 to segidmaster
  seg$=selectionbank$(segid)
  if seg$<>""
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   gosub _segment_load
   if segmentprofileheader(segid).partmax=-1
    selectionbank$(segid)=""
   endif
  else
   segmentprofileheader(segid).partmax=-1
  endif
 next segid
endif

rem No file
endif

return

_segment_updatebank:

rem If seg file exists
if file exist("mapbank\testmap\map.seg")=1

rem Clear non-present entries
for segid=segidmaster+1 to segidmastermax
 selectionbank$(segid)=""
next segid

rem Update segment bank
segdir$="segments\"
open to read 2,"mapbank\testmap\map.seg"
 read file 2,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 2,tseg$
   if tseg$<>selectionbank$(segid)
    selectionbank$(segid)=tseg$
    seg$=selectionbank$(segid)
    segcategory$=getfirstdir(seg$)
    segpath$=getseconddir(seg$)
    gosub _segment_load
   endif
  next segid
 endif
close file 2

rem No file
endif

return

_segment_preloadtextures:

rem Load textures for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 `
 rem RADICAL change - D2 only required texture - rest generated here D.I.N.S
 `
 rem Can use multi-texture
 if segobjusedforfinalgame=1
  if segmentprofile(segid,p).multimeshmode=1
   extralimbp=segmentprofile(segid,p).multimeshstart
   if extralimbp>0
    rem points to two new meshes which may have _02 and _03 textures associated
    ttfile$=segmentprofile(segid,p).tex$
    tfilecheck$=left$(ttfile$,len(ttfile$)-4)
    if lower$(right$(tfilecheck$,6))="_01_d2"
     rem generate _02 and _03 textures in correct part of segment (mesh)
     tfile$=ttfile$ : tfile$=left$(tfile$,len(tfile$)-len("_NN_D2.TGA"))
     segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_D2.TGA"
     if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
      segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_D2.DDS"
      if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
       segmentprofile(segid,extralimbp+0).tex$=ttfile$
      endif
     endif
     segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_D2.TGA"
     if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
      segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_D2.DDS"
      if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
       segmentprofile(segid,extralimbp+1).tex$=ttfile$
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem Load actual textures based on effect requirements
 segmentprofile(segid,p).texid=0
 segmentprofile(segid,p).texdid=0
 segmentprofile(segid,p).texnid=0
 segmentprofile(segid,p).texsid=0
 texdir$=segmentprofile(segid,p).tex$
 if texdir$<>""
  `
  rem Effect or No
  tfile$=segmentprofile(segid,p).effect$
  teffectuseslightmapstage=1 : gosub _common_makeeffecttextureset
  if tfile$<>"" and guseeffectonscenesstate=1
   `
   rem Load and apply MAIN texture directly
   tstage=0
   for tlayer=0 to 4
    if tlayer=0 then texfiletouse$=texdir1$
    if tlayer=1 then texfiletouse$=texdir2$
    if tlayer=2 then texfiletouse$=texdir3$
    if tlayer=3 then texfiletouse$=texdir4$
    if tlayer=4 then texfiletouse$=texdir5$
    texuseid=loadinternaltexture(texfiletouse$)
    if texuseid=0
     rem some effects need a blank texture if no file available
     if tlayer<=ensureclearlayermax
      rem black texture if no texture
      texuseid=loadinternalimagecompressquality("texturebank\common\black.tga",1,0)
     endif
    endif
    if texuseid>0
     if tstage=0 then segmentprofile(segid,p).texdid=texuseid : segmentprofile(segid,p).texid=texuseid
     if tstage=1 then segmentprofile(segid,p).texiid=texuseid
     if tstage=2 then segmentprofile(segid,p).texnid=texuseid
     if tstage=3 then segmentprofile(segid,p).texsid=texuseid
     if tstage=4 then segmentprofile(segid,p).texsid=texuseid
     inc tstage
    endif
   next tlayer
   `
  else
   rem Basic Texture (D2)
   tfile$=segmentprofile(segid,p).tex$
   segmentprofile(segid,p).texid=loadinternaltexture(tfile$)
   if segmentprofile(segid,p).multimeshmode=1
    textralimbp=segmentprofile(segid,p).multimeshstart
    if textralimbp>0
     segmentprofile(segid,textralimbp+0).texid=loadinternaltexture(segmentprofile(segid,textralimbp+0).tex$)
     segmentprofile(segid,textralimbp+1).texid=loadinternaltexture(segmentprofile(segid,textralimbp+1).tex$)
    endif
   endif
  endif
 endif
 `
next p

return

_segment_preloadeffects:

rem Load effect for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 if segmentprofile(segid,p).effect$<>"" and segnoeffects=0 and guseeffectonscenesstate=1
  tfile$=segmentprofile(segid,p).effect$
  gosub _common_wipeeffectifnotexist
  if tfile$<>""
   debugfilename(tfile$,"effect:"+seg$)
   segmentprofile(segid,p).effectid=loadinternaleffect(tfile$)
  else
   segmentprofile(segid,p).effectid=0
  endif
 else
  segmentprofile(segid,p).effectid=0
 endif
next p

return

_segment_load:

rem Segment Object Index
segobj=selectionbankoffset+segid

rem debug info
mytimer=timer()

rem Load segment profile data
segmentprofileheader(segid).partmax=-1
gosub _segment_loaddata
segpartmax=segmentprofileheader(segid).partmax

rem Only if profile exists
if segpartmax<>-1
 `
 rem Check if DBO version of segment obj exists
 tsegobjpreloaded=0
 if segobjusedforfinalgame=0
  tsegobjfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".dbo"
  if file exist(tsegobjfile$)=1 and segobjusedformapeditor=0
   load object tsegobjfile$,segobj
   tsegobjpreloaded=1
  endif
 endif
 `
 rem segment mesh max
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 `
 rem Load meshes for segment
 if tsegobjpreloaded=0
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    tmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).csgmesh$<>"" then tmeshname$=segmentprofile(segid,p).csgmesh$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,p).meshid=loadinternalmesh(tfile$)
    endif
   endif
  next p
 endif
 `
 rem Load multi-meshes for segment
 originalsegmeshpartmax=-1
 if segobjusedforfinalgame=1
  dim tempsegmentprofile(64) as segmentprofiletype
  tempp=0
  rem place where new limbs will be located (extralimbp) - we will move things like entitys/csgs to end
  extralimbp=segmeshpartmax+1
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    ttmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).multimeshmode=1
     if segmentprofile(segid,p).csgmesh$="" and ttmeshname$<>""
      if lower$(right$(ttmeshname$,3))="a.x"
       for ttwo=0 to 1
        tmeshname$=ttmeshname$
        tmeshname$=left$(tmeshname$,len(tmeshname$)-3)
        if ttwo=0 then tmeshname$=tmeshname$+"b.x"
        if ttwo=1 then tmeshname$=tmeshname$+"c.x"
        tfile$=tmeshname$
        debugfilename(tfile$,"mesh:"+seg$)
        tempsegmentprofile(tempp)=segmentprofile(segid,p)
        if ttwo=0 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        if ttwo=1 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        inc tempp
       next ttwo
      else
       rem not a.x, but can still habe multi-texture so use base mesh instead
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
      endif
      segmentprofile(segid,p).multimeshstart=extralimbp
      inc extralimbp,2
     endif
    endif
   endif
  next p
  rem multimesh entries made
  if tempp>0
   rem first copy non-mesh parts (entity/csg) to new end
   for p=segpartmax to segmeshpartmax+1 step -1
    segmentprofile(segid,p+tempp)=segmentprofile(segid,p)
   next p
   rem now copy accumilated multi-meshes to updated segment profile
   temppmax=tempp : tempp=0
   for p=segmeshpartmax+1 to segmeshpartmax+temppmax
    segmentprofile(segid,p)=tempsegmentprofile(tempp) : inc tempp
   next p
   rem update max values
   segmentprofileheader(segid).partmax=segpartmax+temppmax
   segpartmax=segmentprofileheader(segid).partmax
   originalsegmeshpartmax=segmeshpartmax
   segmentprofileheader(segid).lastmeshmax=segmeshpartmax+temppmax
   segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  endif
 endif
 `
 rem Load textures for segment
 gosub _segment_preloadtextures
 `
 rem Load effect for segment
 gosub _segment_preloadeffects
 `
 rem Build segment in object from segment profile
 if tsegobjpreloaded=0
  segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  tpstart=0 : tpend=segmeshpartmax
  for p=tpstart to tpend
   if object exist(segobj)=0
    make object segobj,segmentprofile(segid,p).meshid,0
   else
    add limb segobj,p,segmentprofile(segid,p).meshid
   endif
   offset limb segobj,p,segmentprofile(segid,p).offx,segmentprofile(segid,p).offy,segmentprofile(segid,p).offz
   rotate limb segobj,p,0,segmentprofile(segid,p).roty,0
  next p
 endif
 `
 rem load csg meshes for scene building
 if tsegobjpreloaded=0
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,tp).meshid=loadinternalmesh(tfile$)
     add limb segobj,p,segmentprofile(segid,tp).meshid
     offset limb segobj,p,segmentprofile(segid,tp).offx,segmentprofile(segid,tp).offy,segmentprofile(segid,tp).offz
     rotate limb segobj,p,0,segmentprofile(segid,tp).roty,0
     color limb segobj,p,rgb(0,255,0)
     segmentprofile(segid,tp).actuallimb=p
     inc p
    endif
   endif
  next tp
 else
  rem still need actuallimb data for CSG meshes
  p=segmeshpartmax+1
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>"" then segmentprofile(segid,tp).actuallimb=p : inc p
   endif
  next tp
 endif
 `
 rem Save DBO of segment if not exist
 if segobjusedforfinalgame=0
  if file exist(tsegobjfile$)=0
   save object tsegobjfile$,segobj
  endif
 endif
 `
 rem Texture segment in object from segment profile
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 for p=0 to segmeshpartmax
  if segmentprofile(segid,p).effectid=0
   texture limb segobj,p,segmentprofile(segid,p).texid
  else
   if segmentprofile(segid,p).texdid=0
    texture limb segobj,p,segmentprofile(segid,p).texid
   else
    texture limb segobj,p,0,segmentprofile(segid,p).texdid
    if segmentprofile(segid,p).texiid<>0 then texture limb segobj,p,1,segmentprofile(segid,p).texiid
    if segmentprofile(segid,p).texnid<>0 then texture limb segobj,p,2,segmentprofile(segid,p).texnid
    if segmentprofile(segid,p).texsid<>0 then texture limb segobj,p,3,segmentprofile(segid,p).texsid
   endif
   set limb effect segobj,p,segmentprofile(segid,p).effectid
  endif
 next p
 `
 rem Set any segment transparenct (always uses transparency TGA=alpha)
 set object transparency segobj,1
 `
 rem Hide object away
 position object segobj,100000,100000,100000
 `
 rem Ensure multimeshes are hidden from segment handling (only used in node tree creation)
 if segobjusedforfinalgame=1 and originalsegmeshpartmax<>-1
  segmentprofileheader(segid).lastmeshmax=originalsegmeshpartmax
  segmeshpartmax=originalsegmeshpartmax
 endif
 `
rem no profile exists endif
endif

rem debug info and timestamp (if logged)
debugviewtext(-1,"Built "+seg$+" in "+str$(timer()-mytimer)+"ms")
timestampactivity(0,"Loaded "+str$(segid)+":"+seg$)

return

_segment_cleardata:

rem Default mesh settings
segpartmax=64
for q=0 to segpartmax
 segmentprofile(segid,q).partmode=0
 segmentprofile(segid,q).tex$=""
 segmentprofile(segid,q).texid=0
 segmentprofile(segid,q).texdid=0
 segmentprofile(segid,q).texiid=0
 segmentprofile(segid,q).texnid=0
 segmentprofile(segid,q).texsid=0
` segmentprofile(segid,q).texd$=""
` segmentprofile(segid,q).texn$=""
` segmentprofile(segid,q).texs$=""
 segmentprofile(segid,q).effect$=""
 segmentprofile(segid,q).effectid=0
 segmentprofile(segid,q).csgmesh$=""
 segmentprofile(segid,q).csgmode=0
 segmentprofile(segid,q).csgimmune=0
 segmentprofile(segid,q).transparency=0
next q

rem Default hidden parts
segmentprofile(segid).vis.overlay=0
segmentprofile(segid).vis.f=-1
segmentprofile(segid).vis.r=-1
segmentprofile(segid).vis.wb=-1
segmentprofile(segid).vis.wr=-1
segmentprofile(segid).vis.wf=-1
segmentprofile(segid).vis.wl=-1
segmentprofile(segid).vis.owb=-1
segmentprofile(segid).vis.owr=-1
segmentprofile(segid).vis.owf=-1
segmentprofile(segid).vis.owl=-1
segmentprofile(segid).vis.ctl=-1
segmentprofile(segid).vis.ctr=-1
segmentprofile(segid).vis.cbr=-1
segmentprofile(segid).vis.cbl=-1
segmentprofile(segid).vis.octl=-1
segmentprofile(segid).vis.octr=-1
segmentprofile(segid).vis.ocbr=-1
segmentprofile(segid).vis.ocbl=-1

rem Default blueprint data
segmentprofile(segid).blueprint.mode=0
segmentprofile(segid).blueprint.symbol=0
segmentprofile(segid).blueprint.floorsizey=-1
segmentprofile(segid).blueprint.sidesizex=100
segmentprofile(segid).blueprint.sidesizey=100
segmentprofile(segid).blueprint.sidesizez=100

rem Default properties data
segmentprofile(segid).properties.groundmode=0
segmentprofile(segid).properties.kindof=0

return

_segment_loaddata:

rem Default Segment Data
gosub _segment_cleardata

rem Fill this last if not in filedata
segmentprofileheader(segid).lastmeshmax=-1

rem Ensure segment profile still exists
if file exist(segdir$+seg$)=1

rem Export entity FPE file if flagged
if gexportassets=1
 tthumbbmpfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bmp"
 addfiletocollection(segdir$+seg$) : addfiletocollection(tthumbbmpfile$)
endif

rem Check if binary version of segment profile exists
tprofile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bin"
if isbinaryfileolderthantxtfile(tprofile$,segdir$+seg$)=1 then delete file tprofile$
if file exist(tprofile$)=0

 rem Load Segment Data from file
 dim data$(999)
 load array segdir$+seg$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem HEADER
    if field$="partmax" then segmentprofileheader(segid).partmax=value1
    if field$="lastmeshmax" then segmentprofileheader(segid).lastmeshmax=value1
    `
    rem SEGMENT PARTS
    segpartmax=segmentprofileheader(segid).partmax
    for p=0 to segpartmax
     tryfield$="partmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).partmode=value1
     tryfield$="meshname"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).meshname$=value$
     tryfield$="offx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offx=value1
     tryfield$="offy"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offy=value1
     tryfield$="offz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offz=value1
     tryfield$="rotx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotx=value1
     tryfield$="roty"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).roty=value1
     tryfield$="rotz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotz=value1
     tryfield$="texture"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).tex$=value$
`     tryfield$="textured"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texd$=value$
`     tryfield$="texturen"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texn$=value$
`     tryfield$="textures"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texs$=value$
     tryfield$="transparency"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).transparency=value1
     tryfield$="effect"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).effect$=value$
     tryfield$="colmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).colmode=value1
     tryfield$="csgmesh"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmesh$=value$
     tryfield$="csgmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmode=value1
     tryfield$="csgimmune"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgimmune=value1
     tryfield$="lightmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).lightmode=value1
     tryfield$="multimeshmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).multimeshmode=value1
     tryfield$="materialindex"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).material.index=value1
    next p
    `
    rem SEGMENT VISIBILITY
    if field$="visoverlay" then segmentprofile(segid).vis.overlay=value1
    if field$="visfloor" then segmentprofile(segid).vis.f=value1
    if field$="visroof" then segmentprofile(segid).vis.r=value1
    if field$="viswallb" then segmentprofile(segid).vis.wb=value1 : segmentprofile(segid).vis.owb=value2
    if field$="viswallr" then segmentprofile(segid).vis.wr=value1 : segmentprofile(segid).vis.owr=value2
    if field$="viswallf" then segmentprofile(segid).vis.wf=value1 : segmentprofile(segid).vis.owf=value2
    if field$="viswalll" then segmentprofile(segid).vis.wl=value1 : segmentprofile(segid).vis.owl=value2
    if field$="viscornertl" then segmentprofile(segid).vis.ctl=value1 : segmentprofile(segid).vis.octl=value2
    if field$="viscornertr" then segmentprofile(segid).vis.ctr=value1 : segmentprofile(segid).vis.octr=value2
    if field$="viscornerbr" then segmentprofile(segid).vis.cbr=value1 : segmentprofile(segid).vis.ocbr=value2
    if field$="viscornerbl" then segmentprofile(segid).vis.cbl=value1 : segmentprofile(segid).vis.ocbl=value2
    `
    rem SEGMENT BLUEPRINT
    if field$="mode" then segmentprofile(segid).blueprint.mode=value1
    if field$="symbol" then segmentprofile(segid).blueprint.symbol=value1
    if field$="floorsizey" then segmentprofile(segid).blueprint.floorsizey=value1
    if field$="sidesizex" then segmentprofile(segid).blueprint.sidesizex=value1
    if field$="sidesizey" then segmentprofile(segid).blueprint.sidesizey=value1
    if field$="sidesizez" then segmentprofile(segid).blueprint.sidesizez=value1
    `
    rem SEGMENT PROPERTIES
    if field$="groundmode" then segmentprofile(segid).properties.groundmode=value1
    if field$="kindof" then segmentprofile(segid).properties.kindof=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Save segment profile as binary (and strings tagged to end)
 dim temp(64) as segmentprofiletype
 open to write 1,tprofile$
 write file 1,segmentprofileheader(segid).partmax
 write file 1,segmentprofileheader(segid).lastmeshmax
 segpartmax=segmentprofileheader(segid).partmax
 for p=0 to segpartmax : temp(p)=segmentprofile(segid,p) : next p
 if memblock exist(1)=1 then delete memblock 1
 for p=0 to segpartmax
  temp(p).meshname$=free string()
  temp(p).tex$=free string()
`  temp(p).texd$=free string()
`  temp(p).texn$=free string()
`  temp(p).texs$=free string()
  temp(p).effect$=free string()
  temp(p).csgmesh$=free string()
 next p
 make memblock from array 1,temp(0)
 write memblock 1,1
 for p=0 to segpartmax
  write string 1,segmentprofile(segid,p).meshname$
  write string 1,segmentprofile(segid,p).tex$
 ` write string 1,segmentprofile(segid,p).texd$
 ` write string 1,segmentprofile(segid,p).texn$
 ` write string 1,segmentprofile(segid,p).texs$
  write string 1,segmentprofile(segid,p).effect$
  write string 1,segmentprofile(segid,p).csgmesh$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
else
 `
 rem load binary version of segment profile file
 dim temp(64) as segmentprofiletype
 open to read 1,tprofile$
 read file 1,tval : segmentprofileheader(segid).partmax=tval
 read file 1,tval : segmentprofileheader(segid).lastmeshmax=tval
 segpartmax=segmentprofileheader(segid).partmax
 read memblock 1,1
 make array from memblock temp(0),1
 for p=0 to segpartmax : segmentprofile(segid,p)=temp(p) : next p
 for p=0 to segpartmax
  read string 1,tstr$ : segmentprofile(segid,p).meshname$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).tex$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texd$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texn$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texs$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).effect$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).csgmesh$=tstr$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
endif

rem If lastmesh not there, use partmax
if segmentprofileheader(segid).lastmeshmax=-1
 segmentprofileheader(segid).lastmeshmax=segmentprofileheader(segid).partmax
endif

rem File not exist endif
else
 rem File not exist, provide debug information
 debugfilename(segdir$+seg$,"")
endif

return

_segment_savedata:

rem Create seg file in string array (segid to savesegfile$)
dim data$(999) : l=-1

rem SEGMENT HEADER
inc l : data$(l)=";Segment Spec"
inc l : data$(l)=""
inc l : data$(l)=";Header"
inc l : data$(l)=""
inc l : data$(l)="partmax = "+str$(segmentprofileheader(segid).partmax)
inc l : data$(l)="lastmeshmax = "+str$(segmentprofileheader(segid).lastmeshmax)

rem SEGMENT PARTS
inc l : data$(l)=""
inc l : data$(l)=";Segment Parts"
inc l : data$(l)=""
for p=0 to segmentprofileheader(segid).partmax
 tryfield$=minstring("partmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).partmode)
 tryfield$=minstring("meshname"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).meshname$
 tryfield$=minstring("offx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offx)
 tryfield$=minstring("offy"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offy)
 tryfield$=minstring("offz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offz)
 tryfield$=minstring("rotx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotx)
 tryfield$=minstring("roty"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).roty)
 tryfield$=minstring("rotz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotz)
 tryfield$=minstring("texture"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).tex$
` tryfield$=minstring("textured"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texd$
` tryfield$=minstring("texturen"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texn$
` tryfield$=minstring("textures"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texs$
 tryfield$=minstring("transparency"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).transparency)
 tryfield$=minstring("effect"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).effect$
 tryfield$=minstring("colmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).colmode)
 tryfield$=minstring("csgmesh"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).csgmesh$
 tryfield$=minstring("csgmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgmode)
 tryfield$=minstring("csgimmune"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgimmune)
 tryfield$=minstring("lightmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).lightmode)
 tryfield$=minstring("multimeshmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).multimeshmode)
 tryfield$=minstring("materialindex"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).material.index)
 inc l : data$(l)=""
 `
 rem Ensure we never run out of array space
 if l>100 then array insert at bottom data$(),11
 `
next p

rem SEGMENT VISIBILITY
inc l : data$(l)=";Segment Visibility"
inc l : data$(l)=""
inc l : data$(l)=minstring("visoverlay",15)+" = "+str$(segmentprofile(segid).vis.overlay)
inc l : data$(l)=minstring("visfloor",15)+" = "+str$(segmentprofile(segid).vis.f)
inc l : data$(l)=minstring("visroof",15)+" = "+str$(segmentprofile(segid).vis.r)
try=segmentprofile(segid).vis.owb : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallb",15)+" = "+str$(segmentprofile(segid).vis.wb)+extra$
try=segmentprofile(segid).vis.owr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallr",15)+" = "+str$(segmentprofile(segid).vis.wr)+extra$
try=segmentprofile(segid).vis.owf : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallf",15)+" = "+str$(segmentprofile(segid).vis.wf)+extra$
try=segmentprofile(segid).vis.owl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswalll",15)+" = "+str$(segmentprofile(segid).vis.wl)+extra$
try=segmentprofile(segid).vis.octl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertl",15)+" = "+str$(segmentprofile(segid).vis.ctl)+extra$
try=segmentprofile(segid).vis.octr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertr",15)+" = "+str$(segmentprofile(segid).vis.ctr)+extra$
try=segmentprofile(segid).vis.ocbr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbr",15)+" = "+str$(segmentprofile(segid).vis.cbr)+extra$
try=segmentprofile(segid).vis.ocbl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbl",15)+" = "+str$(segmentprofile(segid).vis.cbl)+extra$

rem SEGMENT BLUEPRINT
inc l : data$(l)=""
inc l : data$(l)=";Segment Blueprint"
inc l : data$(l)=""
inc l : data$(l)=minstring("mode",15)+" = "+str$(segmentprofile(segid).blueprint.mode)
inc l : data$(l)=minstring("symbol",15)+" = "+str$(segmentprofile(segid).blueprint.symbol)
inc l : data$(l)=minstring("floorsizey",15)+" = "+str$(segmentprofile(segid).blueprint.floorsizey)
inc l : data$(l)=minstring("sidesizex",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizex)
inc l : data$(l)=minstring("sidesizey",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizey)
inc l : data$(l)=minstring("sidesizez",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizez)

rem SEGMENT PROPERTIES
inc l : data$(l)=minstring("groundmode",15)+" = "+str$(segmentprofile(segid).properties.groundmode)
inc l : data$(l)=minstring("kindof",15)+" = "+str$(segmentprofile(segid).properties.kindof)

rem END MARKER
inc l : data$(l)=""
inc l : data$(l)=";end"

rem Shorten array based on L
dim newdata$(l+1) : for t=0 to l : newdata$(t)=data$(t) : next t

rem Delet the short-load BIN and DBO files
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".bin"
if file exist(tprofile$)=1 then delete file tprofile$
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".dbo"
if file exist(tprofile$)=1 then delete file tprofile$

rem Save Segment Data to file
if file exist(savesegfile$)=1 then delete file savesegfile$
save array savesegfile$,newdata$()

rem Free usages
undim newdata$()
undim data$()

return

_segment_showallsegmentlimbs:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem force show all limbs for overlay
for tl=1 to 99
 if limb exist(obj,tl)=1
  show limb obj,tl
 endif
next tl

rem rotate object ro rotation
yrotate object obj,maporient*90

`rem Set any segment transparenct - many transparency values - use profileobj
`set object transparency obj,segmentprofile(seg).transparency

return

_segment_customisesinglesegment:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem scale any walls to scaler value (if any)
if segmentprofile(seg).blueprint.sidesizex>100
 if segmentprofile(seg).vis.wb<>-1
  if (mapscaler && %0001)
   show limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
  else
   hide limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then hide limb obj,segmentprofile(seg).vis.owb
  endif
 endif
 if segmentprofile(seg).vis.wr<>-1
  if (mapscaler && %0010)
   show limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
  else
   hide limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then hide limb obj,segmentprofile(seg).vis.owr
  endif
 endif
 if segmentprofile(seg).vis.wf<>-1
  if (mapscaler && %0100)
   show limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
  else
   hide limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then hide limb obj,segmentprofile(seg).vis.owf
  endif
 endif
 if segmentprofile(seg).vis.wl<>-1
  if (mapscaler && %1000)
   show limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
  else
   hide limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then hide limb obj,segmentprofile(seg).vis.owl
  endif
 endif
else
 if segmentprofile(seg).vis.wb<>-1
  show limb obj,segmentprofile(seg).vis.wb
  if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
 endif
 if segmentprofile(seg).vis.wr<>-1
  show limb obj,segmentprofile(seg).vis.wr
  if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
 endif
 if segmentprofile(seg).vis.wf<>-1
  show limb obj,segmentprofile(seg).vis.wf
  if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
 endif
 if segmentprofile(seg).vis.wl<>-1
  show limb obj,segmentprofile(seg).vis.wl
  if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
 endif
endif

rem default limbs states
if segmentprofile(seg).vis.f<>-1 then show limb obj,segmentprofile(seg).vis.f
if segmentprofile(seg).vis.r<>-1 then show limb obj,segmentprofile(seg).vis.r
if segmentprofile(seg).vis.ctl<>-1 then hide limb obj,segmentprofile(seg).vis.ctl
if segmentprofile(seg).vis.ctr<>-1 then hide limb obj,segmentprofile(seg).vis.ctr
if segmentprofile(seg).vis.cbr<>-1 then hide limb obj,segmentprofile(seg).vis.cbr
if segmentprofile(seg).vis.cbl<>-1 then hide limb obj,segmentprofile(seg).vis.cbl
if segmentprofile(seg).vis.octl<>-1 then hide limb obj,segmentprofile(seg).vis.octl
if segmentprofile(seg).vis.octr<>-1 then hide limb obj,segmentprofile(seg).vis.octr
if segmentprofile(seg).vis.ocbr<>-1 then hide limb obj,segmentprofile(seg).vis.ocbr
if segmentprofile(seg).vis.ocbl<>-1 then hide limb obj,segmentprofile(seg).vis.ocbl

rem apply side-maprotation for walls
twb=segmentprofile(seg).vis.wb : twr=segmentprofile(seg).vis.wr
twf=segmentprofile(seg).vis.wf : twl=segmentprofile(seg).vis.wl
towb=segmentprofile(seg).vis.owb : towr=segmentprofile(seg).vis.owr
towf=segmentprofile(seg).vis.owf : towl=segmentprofile(seg).vis.owl
if segmaprot=1
 twb=segmentprofile(seg).vis.wl :  twr=segmentprofile(seg).vis.wb
 twf=segmentprofile(seg).vis.wr :  twl=segmentprofile(seg).vis.wf
 towb=segmentprofile(seg).vis.owl :  towr=segmentprofile(seg).vis.owb
 towf=segmentprofile(seg).vis.owr :  towl=segmentprofile(seg).vis.owf
endif
if segmaprot=2
 twb=segmentprofile(seg).vis.wf :  twr=segmentprofile(seg).vis.wl
 twf=segmentprofile(seg).vis.wb :  twl=segmentprofile(seg).vis.wr
 towb=segmentprofile(seg).vis.owf :  towr=segmentprofile(seg).vis.owl
 towf=segmentprofile(seg).vis.owb :  towl=segmentprofile(seg).vis.owr
endif
if segmaprot=3
 twb=segmentprofile(seg).vis.wr :  twr=segmentprofile(seg).vis.wf
 twf=segmentprofile(seg).vis.wl :  twl=segmentprofile(seg).vis.wb
 towb=segmentprofile(seg).vis.owr :  towr=segmentprofile(seg).vis.owf
 towf=segmentprofile(seg).vis.owl :  towl=segmentprofile(seg).vis.owb
endif

rem eliminate external walls if blocked
if maprotate=0
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=1
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towr
endif
if maprotate=2
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=3
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towr
endif

rem inner wall to hide
if twr<>-1
 if maptile>=2 then hide limb obj,twr
endif
if twb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,twb
endif
if twl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,twl
endif
if twf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,twf
endif

rem outer wall to hide
if towr<>-1
 if maptile>=2 then hide limb obj,towr
endif
if towb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,towb
endif
if towl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,towl
endif
if towf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,towf
endif

rem symbol no floor hides floor/roof
if mapsymbol=1
 if segmentprofile(seg).vis.f<>-1 then hide limb obj,segmentprofile(seg).vis.f
 if segmentprofile(seg).vis.r<>-1 then hide limb obj,segmentprofile(seg).vis.r
endif

rem calculate actual corner before whole seg is rotated
ttoctl=segmentprofile(seg).vis.octl
ttoctr=segmentprofile(seg).vis.octr
ttocbr=segmentprofile(seg).vis.ocbr
ttocbl=segmentprofile(seg).vis.ocbl
toctl=-1 : toctr=-1 : tocbr=-1 : tocbl=-1
if segmaprot=0
 tctl=segmentprofile(seg).vis.ctl
 tctr=segmentprofile(seg).vis.ctr
 tcbr=segmentprofile(seg).vis.cbr
 tcbl=segmentprofile(seg).vis.cbl
 toctl=ttoctl
 toctr=ttoctr
 tocbr=ttocbr
 tocbl=ttocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then toctl=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then toctr=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then tocbr=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then tocbl=segmentprofile(seg).vis.ocbl
endif
if segmaprot=1
 tctl=segmentprofile(seg).vis.ctr
 tctr=segmentprofile(seg).vis.cbr
 tcbr=segmentprofile(seg).vis.cbl
 tcbl=segmentprofile(seg).vis.ctl
 toctl=ttoctr
 toctr=ttocbr
 tocbr=ttocbl
 tocbl=ttoctl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then toctl=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then toctr=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then tocbr=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then tocbl=segmentprofile(seg).vis.octl
endif
if segmaprot=2
 tctl=segmentprofile(seg).vis.cbr
 tctr=segmentprofile(seg).vis.cbl
 tcbr=segmentprofile(seg).vis.ctl
 tcbl=segmentprofile(seg).vis.ctr
 toctl=ttocbr
 toctr=ttocbl
 tocbr=ttoctl
 tocbl=ttoctr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then toctl=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then toctr=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then tocbr=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then tocbl=segmentprofile(seg).vis.octr
endif
if segmaprot=3
 tctl=segmentprofile(seg).vis.cbl
 tctr=segmentprofile(seg).vis.ctl
 tcbr=segmentprofile(seg).vis.ctr
 tcbl=segmentprofile(seg).vis.cbr
 toctl=ttocbl
 toctr=ttoctl
 tocbr=ttoctr
 tocbl=ttocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then toctl=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then toctr=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then tocbr=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then tocbl=segmentprofile(seg).vis.ocbr
endif

rem remove external corners if not needed
ttoctl=-1 : ttoctr=-1 : ttocbr=-1 : ttocbl=-1
if maprotate=0
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbl=tocbl
endif
if maprotate=1
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=2
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=3
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbl=tocbl
endif

rem inner corner limbs to show
if tctl<>-1
 if maptile>=7 and maptile<=11 then show limb obj,tctl
endif
if tctr<>-1
 if maptile=8 or maptile=10 or maptile=11 then show limb obj,tctr
endif
if tcbr<>-1
 if maptile=9 or maptile=10 or maptile=11 or maptile>=13 then show limb obj,tcbr
endif
if tcbl<>-1
 if maptile=11 or maptile=12 or maptile=14 then show limb obj,tcbl
endif

rem outer corner limbs to show
if ttoctl<>-1
 if maptile=1 then show limb obj,ttoctl
 if maptile=2 then show limb obj,ttoctl
 if maptile=3 then show limb obj,ttoctl
 if maptile=15 then show limb obj,ttoctl
endif
if ttoctr<>-1
 if maptile=1 then show limb obj,ttoctr
endif
if ttocbr<>-1
 if maptile=1 then show limb obj,ttocbr
endif
if ttocbl<>-1
 if maptile=1 then show limb obj,ttocbl
 if maptile=2 then show limb obj,ttocbl
endif

rem rotate object ro rotation
yrotate object obj,maporient*90

return

`
` Special Function for finding GROUNDMODE from NEIGHBOR MAP TILE (external wall removal)
`

function getgroundmodefrommap(mapatl,mapatx,mapaty)
 mapground=3
 if mapatx>=0
  if mapaty>=0
   if mapatx<=49
    if mapaty<=49
     mapid=map(mapatl,mapatx,mapaty)
     if mapid<>0
      mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
     else
      mapground = 3
     endif
    endif
   endif
  endif
 endif
endfunction mapground

_segment_scanfornewsegments:

rem Scan for segments
segdir$="segments\"
empty array filelist$()
buildfilelist(segdir$,"")

rem If segments exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem Segment name from folder
  seg$=filelist$(chkfile)
  if right$(seg$,4)=".fps"
  `
  rem Check segment exists in bank
  tokay=1
  if segidmaster>0
   for segid=1 to segidmaster
    if selectionbank$(segid)=seg$ then tokay=0
   next segid
  endif
  if tokay=1
   `
   rem Find Free Segment Index
   freesegid=-1
   if segidmaster>0
    for segid=1 to segidmaster
     if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
    next segid
   endif
   `
   rem New Segment or Free One
   if freesegid=-1
    inc segidmaster : gosub _segment_validatearraysize
    segid=segidmaster
   else
    segid=freesegid
   endif
   `
   rem Extract firstdir and path from seg$
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   `
   rem Load Segment
   selectionbank$(segid)=seg$
   gosub _segment_load
   `
  endif
  `
  endif
 next chkfile
endif

return

_segment_addtoworkspace:

rem If type valid
segnewloaded=0
if right$(seg$,4)=".fps"
 `
 rem Check segment exists in bank
 tokay=1
 if segidmaster>0
  for segid=1 to segidmaster
   if selectionbank$(segid)=seg$ then tokay=0 : tfoundid=segid : exit
  next segid
 endif
 if tokay=1
  `
  rem Find Free Segment Index
  freesegid=-1
  if segidmaster>0
   for segid=1 to segidmaster
    if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
   next segid
  endif
  `
  rem New Segment or Free One
  if freesegid=-1
   inc segidmaster : gosub _segment_validatearraysize
   segid=segidmaster
   segnewloaded=1
  else
   segid=freesegid
  endif
  `
  rem Extract firstdir and path from seg$
  segcategory$=getfirstdir(seg$)
  segpath$=getseconddir(seg$)
  `
  rem Load Segment
  selectionbank$(segid)=seg$
  gosub _segment_load
  `
  rem Localization Extra
  if localdesc$<>""
   selectionbanklocal$(segid)=localdesc$
  endif
  `
 else
  `
  rem already got, assign ID from existing
  segid=tfoundid
  `
 endif
 `
endif

return

_segment_addtoselection:

rem Load segment from file requester
set dir currentsegdir$
seg$=browseropen$(6)
segdir$="segments\"
seg$=right$(seg$,len(seg$)-len(rootdir$+segdir$))
currentsegdir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _segment_addtoworkspace

return

_segment_createnewselection:

rem Create new segment using SEGEDIT (indi-tool)
set dir currentsegdir$
segedit$(1)
set dir rootdir$

return

rem Add selected to workspace selection
_prefab_addtoworkspace:

rem If type valid
prenewloaded=0
if lower$(right$(prefab$,4))=".fpp"
 `
 rem Check prefab exists in bank
 tokay=1
 if preidmaster>0
  for preid=1 to preidmaster
   if prefabbank$(preid)=prefab$ then tokay=0 : exit
  next preid
 endif
 if tokay=1
  `
  rem Find Free prefab Index
  freepreid=-1
  if preidmaster>0
   for preid=1 to preidmaster
    if prefabbank$(preid)="" then freepreid=preid : exit
   next preid
  endif
  `
  rem New prefab or Free One
  if freepreid=-1
   inc preidmaster
   if preidmaster>=100
    dim prefabbank$(preidmaster)
    dim prefabbanklocal$(preidmaster)
   endif
   preid=preidmaster
  else
   preid=freepreid
  endif
  `
  rem Extract firstdir and path from prefab$
  preategory$=getfirstdir(prefab$)
  prepath$=getseconddir(prefab$)
  `
  rem Load Prefab
  prefabbank$(preid)=prefab$
  prenewloaded=1
  `
  rem Localization Extra
  if localdesc$<>""
   prefabbanklocal$(preid)=localdesc$
  endif
  `
 endif
 `
endif

return

_prefab_addtoselection:

rem Load segment from file requester
set dir currentpredir$
prefab$=browseropen$(7)
predir$="prefabs\"
prefab$=right$(prefab$,len(prefab$)-len(rootdir$+predir$))
currentpredir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _prefab_addtoworkspace

return

rem
rem SUBROUTINES AND FUNCTIONS FOR DEBUG ONLY
rem

rem FUNCTIONS

function hide3d()
 backdrop off : sync off
 set current bitmap 0
 for o=1 to 50000
  if object exist(o)=1
   hide object o
  endif
 next o
endfunction

function show3d()
 backdrop on : sync on
 for o=1 to 50000
  if object exist(o)=1
   show object o
  endif
 next o
endfunction

function debugfilename(tfile$,desc$)
 texit=0
 tryfile$=tfile$
 if lower$(right$(tfile$,3))="tga" then tryfile$=left$(tryfile$,len(tryfile$)-3)+imgext$
 if file exist(tfile$)=0 and file exist(tryfile$)=0
  timestampactivity(0,strarr$(53)+tfile$+") info:"+desc$)
  timestampactivityflagged=1
 endif
endfunction

function debugstring(tfile$,desc$)
 timestampactivity(0,strarr$(54)+tfile$+" - "+desc$+")")
endfunction

function debugseevar(var)
 timestampactivity(0,strarr$(55)+str$(var)+")")
endfunction

function debugpeek(desc$)
 set text opaque
 ink rgb(255,255,255),0
 while spacekey()=0
  set cursor 100,150
  print desc$
  sync
 endwhile
 while spacekey()=1 : sync : endwhile
 set text transparent
endfunction

`
` Progress Report Debug Function
`

function debugviewactivate(mode)
 `
 if gdebugreportmodestate=1
  if mode=1
   if bitmap exist(1)=0 then create bitmap 1,screen width(),150
  else
   if bitmap exist(1)=1 then delete bitmap 1
  endif
  set current bitmap 0
 endif
 `
endfunction

function debugviewprogressmax(progressmax)
 dim mshot(progressmax)
 lastmshotmem=0
 gprogressmax=progressmax
 gprogresscounter=0
endfunction

function debugviewtext(progress,gamedebugviewtext$)
 `
 rem leave immediately if mapeditor
 if gmapeditmode=1 then exitfunction
 `
 rem FPSCV104RC9 - loading time readout to file
 if gloadreportstate=1
  rem get time, distance from last time, description, etc..
  if gloadreporttime=0 then gloadreporttime=timer()
  thetime=timer()-gloadreporttime
  thetime$=right$(str$(1000000+thetime),6)
  thediff=timer()-gloadreportlasttime
  thediff$=right$(str$(1000000+thediff),6)
  gloadreportlasttime=timer()
  loadreport$(gloadreportindex)=thetime$+" : "+thediff$+" : "+gamedebugviewtext$
  inc gloadreportindex : if gloadreportindex>10000 then gloadreportindex=10000
  if progress>gprogressmax-10
   rem only save in last 10 counts before end of progress bar
   save array rootdir$+"\loadreport.txt",loadreport$()
  endif
 endif
 `
 rem progress bar based on progress/gprogressmax (some white and black)
 if progress<>-1
  rem Memory counters
  mshoti=progress
  gamedebugviewtext$="["+right$(str$(1000+mshoti),3)+"] "+gamedebugviewtext$
  mshotmem=GET MEMORY AVAILABLE(0)
  if lastmshotmem=0 then lastmshotmem=mshotmem : mshotfirst=GET MEMORY AVAILABLE(0)
  mshot(mshoti)=lastmshotmem-mshotmem
  if mshot(mshoti)>mshotmemlargest then mshotmemlargest=mshot(mshoti)
  if mshoti>lastmshoti
   rem deposit memory use result to report
   timestampactivity(0,strarr$(56)+str$(mshot(mshoti))+"K  "+gamedebugviewtext$)
   lastmshoti=mshoti
   lastmshotmem=mshotmem
  endif
  rem Game GUI Readout
  if progress>gprogressmax then progress=gprogressmax
  progress#=progress
  progress#=progress#/(gprogressmax+0.0001)
  if internalloaderhud>0 and internalloaderhud<=array count(hud())
   rem Image Expand Bar Progress
   t1=hud(internalloaderhud).width*progress#
   size sprite internalloaderhud,t1,hud(internalloaderhud).height
   paste sprite internalloaderhud,hud(internalloaderhud).posx,hud(internalloaderhud).posy
  else
   rem Default Bar Progress
   if gdebugreportmodestate=1
    progressx=54 : progressy=392 : progressh=18
    progressw=screen width()-100.0001
    if screen width()=800 then progressw=693
    t1=progressw*progress# : t2=progressx+t1
    ty=(screen height()-150)-(screen height()/10)
    if screen height()=600 then ty=progressy
    if t2>progressx then ink rgb(255,255,255),0 : box progressx,ty,t2,ty+progressh
    if t2<progressx+progressw then ink rgb(0,0,0),0 : box t2,ty,progressx+progressw,ty+progressh
   endif
  endif
 endif
 if gdebugreportmodestate=0 then sync
 `
 rem Report On Progress Percentage
 if progress<>-1
  if progress>gprogressmax then progress=gprogressmax
  progress#=progress : progress#=progress#/(gprogressmax+0.0001)
  progress#=progress#*100.0
 endif
 `
 rem TestGameFromEditor Mode
 if gtestgamemodefromeditor=1
  rem detect if CANCEL early (while building)
  if gtestgamemodefromeditorokaypressed=0
   open file map 2, "FPSEXCHANGE"
   wait for file map event 2
   if get file map dword( 2, 994 ) = 1
    `
    rem As can take time, tell user can take time
    open file map 3, "FPSTESTGAMEDIALOG"
    set file map dword 3, 12, 1
    set file map string$ 3, 1000, strarr$(630)
    wait for file map event 3
    while get file map dword ( 3, 12 ) = 1
     wait for file map event 3
    endwhile
    close file map 3
    `
    rem terminate test game mid-build
    set file map string$ 2, 1000, "FPSC-MapEditor.exe"
    set file map string$ 2, 1256, "-r"
    set file map dword 2, 994, 2
    set file map dword 2, 924, 1
    wait for file map event 2
    close file map 2
    rem Terminate
    if 1 then timestampactivity(0,strarr$(57))
    end
   else
    rem Update Test Game Dialog progress and status text
    open file map 1, "FPSTESTGAMEDIALOG"
    if progress<>-1
     set file map dword 1, 8, int(progress#)
    endif
    rem Display Status Text
    set file map string$ 1, 1000, gamedebugviewtext$
    set file map dword 1, 12, 1
    wait for file map event 1
    close file map 1
   endif
   close file map 2
  endif
 endif
 rem Build Executable Game Mode
 if gcompilestandaloneexe=1
  rem check if build cancelled
  tokay=0
  open file map 2, "FPSEXCHANGE"
  wait for file map event 2
  if get file map dword( 2, 994 ) = 1 then tokay=1
  close file map 2
  if tokay=1
   rem terminate build early
   open file map 1, "FPSBUILDGAME"
   set file map dword 1, 108, 1
   set file map dword 1, 112, 0
   rem close dialog (cannot reload data into it when RELOAD MAPEDITOR)
   set file map dword 1, 24, 1
   wait for file map event 1
   close file map 1
   rem call map editor back
   open file map 2, "FPSEXCHANGE"
   set file map string$ 2, 1000, "FPSC-MapEditor.exe"
   set file map string$ 2, 1256, "-r"
   set file map dword 2, 994, 0
   set file map dword 2, 924, 1
   wait for file map event 2
   close file map 2
   rem terminate
   if 1 then timestampactivity(0,strarr$(58))
   end
  else
   rem game build progress bar and text
   open file map 1, "FPSBUILDGAME"
   if progress<>-1
    set file map dword 1, 108, 1
    set file map dword 1, 112, int(progress#)
   endif
   set file map dword 1, 40, 12
   set file map dword 1, 44, 1
   if level>0 and level<=glevelmax
    set file map string$ 1, 1000, strarr$(59)+str$(level)+"\"+str$(glevelmax)+" : "+gamedebugviewtext$
   else
    set file map string$ 1, 1000, gamedebugviewtext$
   endif
   wait for file map event 1
   close file map 1
  endif
 endif
 `
 rem debug view text
 if gdebugreportmodestate=1 and gmapeditmode=0
  `
  thetime=timer()-gamedebugviewtime
  thetime$=right$(str$(1000000+thetime),6)
  themem=gamedebugviewmem-GET MEMORY AVAILABLE(0)
  themem$=right$(str$(10000000+themem),7)
  themem$=" [ "+themem$+" ] ("
  if (themem-gamedebugviewlastmem)>0 then themem$=themem$+"+"
  themem$=themem$+str$(themem-gamedebugviewlastmem)+")  :  "
  gamedebugview$=thetime$+themem$+gamedebugviewtext$+chr$(13)+chr$(10)+gamedebugview$
  gamedebugviewlastmem=themem
  gosub _gamemain_writetexttodebugview
  debugviewupdate(1)
  if gdebugreportstepthroughstate=1
   rem step through debugging
   wait key
  endif
  `
 endif
 exitfunction
 `
 _gamemain_writetexttodebugview:
  if gdebugreportmodestate=1
   if bitmap exist(1)=1
    set current bitmap 1
    cls rgb(0,48,0)
    ink rgb(255,255,255),0
    print gamedebugview$
    ink rgb(0,255,0),0
    gosub _gamemain_updatedebugviewstats
    set current bitmap 0
   endif
   gamedebugrefresh=1
  endif
 return
 `
 _gamemain_updatedebugviewstats:
  for stat=1 to 9
   if stat=1 then stat$=strarr$(60)
   if stat=2 then stat$=strarr$(61) : stat2=segidmaster
   if stat=3 then stat$=strarr$(62) : stat2=entidmaster
   if stat=4 then stat$=strarr$(63) : stat2=entityelementlist
   if stat=5 then stat$=strarr$(64) : stat2=aiindexmaster
   if stat=6 then stat$=strarr$(65) : stat2=texturebankmax
   if stat=7 then stat$=strarr$(66) : stat2=imagebankmax
   if stat=8 then stat$=strarr$(67) : stat2=effectbankmax
   if stat=9 then stat$=strarr$(68) : stat2=waypointmax
   if stat>1
    stat2$=str$(stat2) : stat3$="" : for st=1 to stat2 step 2 : stat3$=stat3$+"|" : next st
    stat1$=stat$ : stat2$=stat2$+space$(3-len(stat2$))+stat3$
   else
    stat1$=stat$ : stat2$=""
   endif
   text screen width()-(screen width()/4),(stat-1)*14,stat1$
   text screen width()-(screen width()/8),(stat-1)*14,stat2$
  next stat
 return
 `
endfunction

function debugviewupdate(doisync)
 `
 if gdebugreportmodestate=1 and gmapeditmode=0
  if gamedebugrefresh=1
   gamedebugrefresh=0
   if bitmap exist(1)=1
    set current bitmap 1
    get image editorimagesoffset+1,0,0,screen width(),150,1
   endif
  endif
  set current bitmap 0
  if doisync=0 and image exist(editorimagesoffset+1)=1 then paste image editorimagesoffset+1,0,screen height()-150
  if doisync=1 and image exist(editorimagesoffset+1)=1 then paste image editorimagesoffset+1,0,screen height()-150
  if doisync=1 then sync
 endif
 `
endfunction

function debuggameoverlaysystem(clearscr)
`
rem collect perf data
perf(1) = statistic(1)
perf(2) = screen fps()
if scancode()<>15
 inc wshoti : if wshoti>400 then wshoti=0
endif
wshot(wshoti,0)=perf(1) : if wshot(wshoti,0)>wshotmax(0) then wshotmax(0)=wshot(wshoti,0)
wshot(wshoti,1)=perf(2) : if wshot(wshoti,1)>wshotmax(1) then wshotmax(1)=wshot(wshoti,1)
wshot(wshoti,2)=statistic(8) : if wshot(wshoti,2)>wshotmax(2) then wshotmax(2)=wshot(wshoti,2)
wshot(wshoti,3)=perf(6) : if wshot(wshoti,3)>wshotmax(3) then wshotmax(3)=wshot(wshoti,3)
wshot(wshoti,4)=perf(7) : if wshot(wshoti,4)>wshotmax(4) then wshotmax(4)=wshot(wshoti,4)
`
rem uses perftimer now for cycle accuracy (once a second so I can read changes)
av#=20.0
inc gameperftimetracker
if gameperftimetracker>av#
 gameperftimetracker=0
 i=3 : perf(i) = gameperftotalcount/av# : gameperftotalcount=0
 i=4 : perf(i) = gameperflighting/av# : gameperflighting=0
 i=5 : perf(i) = gameperfplayer/av# : gameperfplayer=0
 i=6 : perf(i) = gameperfentities/av# : gameperfentities=0
 i=7 : perf(i) = gameperfgun/av# : gameperfgun=0
 i=8 : perf(i) = gameperfmisc/av# : gameperfmisc=0
 i=9 : perf(i) = gameperfdebug/av# : gameperfdebug=0
 i=10 : perf(i) = gameperfphysics/av# : gameperfphysics=0
 i=11 : perf(i) = gameperfsync/av# : gameperfsync=0
 i=12 : perf(i) = gameperfentities1/av# : gameperfentities1=0
 i=13 : perf(i) = gameperfentities2/av# : gameperfentities2=0
 i=14 : perf(i) = gameperfentities3/av# : gameperfentities3=0
 i=15 : perf(i) = gameperfentities4/av# : gameperfentities4=0
 i=16 : perf(i) = gameperfentities5/av# : gameperfentities5=0
endif

rem Optional additional statistics
if debugviewmode=0
 `
 rem Appreviated for game scene (temp)
 t$=""
 for i=1 to 11
  if i=1 then t$=t$+"P"
  if i=2 then t$=t$+"F"
  if i=3 then t$=t$+"#"
  if i=4 then t$=t$+"L"
  if i=5 then t$=t$+"P"
  if i=6 then t$=t$+"E"
  if i=7 then t$=t$+"G"
  if i=8 then t$=t$+"M"
  if i=9 then t$=t$+"D"
  if i=10 then t$=t$+"P"
  if i=11 then t$=t$+"S"
  t$=t$+":"+str$(perf(i))
  if i=6
   rem extra entity display
   t$=t$+" [SH:"+str$(logicprioritycount)+"/"+str$(int(logicprioritymax#))+"][1:"+str$(perf(12))+" 2:"+str$(perf(13))+" 3:"+str$(perf(14))+" 4:"+str$(perf(15))+" 5:"+str$(perf(16))+"]"
  endif
  t$=t$+"   "
 next i
 ink rgb(255,255,0),0
 center text screen width()/2,screen height()-16,t$
 `
else
 `
 rem Performance meter text
 sp=14 : spx=((screen width()-200)/2)-100 : spy=screen height()/2
 ink rgb(255,255,0),0
 sptop=sp+48 : spwidth=400 : spheight=400
 line spx-44,sptop+14,spx+40+spwidth,sptop+14
 line spx-44,(sptop+spheight)-4,spx+40+spwidth,(sptop+spheight)-4
 line spx-44,sptop+14,spx-44,(sptop+spheight)-4
 line spx+40+spwidth,sptop+14,spx+40+spwidth,(sptop+spheight)-4
 i=1 : text spx-40,sptop+(sp*i),strarr$(69)+str$(perf(i))
 ink rgb(255,0,0),0
 i=2 : text spx-40,sptop+(sp*i),strarr$(70)+str$(perf(i))
 ink rgb(255,255,0),0
 i=3 : text spx-40,sptop+(sp*i),strarr$(71)+str$(perf(i))
 i=4 : text spx-40,sptop+(sp*i),strarr$(72)+str$(perf(i))+"("+str$(lightingsystemdisabled)+")"
 i=5 : text spx-40,sptop+(sp*i),strarr$(73)+str$(perf(i))
 ink rgb(255,255,255),0
 i=6 : text spx-40,sptop+(sp*i),strarr$(74)+str$(perf(i))+"("+str$(entitysystemdisabled)+")"
 ink rgb(255,128,0),0
 i=7 : text spx-40,sptop+(sp*i),strarr$(75)+str$(perf(i))
 ink rgb(255,255,0),0
 i=8 : text spx-40,sptop+(sp*i),strarr$(76)+str$(perf(i))
 i=9 : text spx-40,sptop+(sp*i),strarr$(77)+str$(perf(i))
 i=10 : text spx-40,sptop+(sp*i),strarr$(78)+str$(perf(i))
 i=11 : text spx-40,sptop+(sp*i),strarr$(79)+str$(perf(i))
 i=12 : text spx-40,sptop+(sp*i),strarr$(80)+str$(int(camera position x()))+" Y:"+str$(int(camera position y()))+" Z:"+str$(int(camera position z()))+" COL:"+str$(deactivatecollision)
 `
 rem AREABOX MESH GROUP STATS
 ts1$=strarr$(81)+str$(statistic(3))+strarr$(82)+str$(statistic(4))
 ts2$=strarr$(83)+str$(statistic(1))+strarr$(84)+str$(statistic(5))
 ts3$=strarr$(85)+str$(statistic(6))+strarr$(86)+str$(statistic(7))
 i=13 : text spx-40,sptop+(sp*i),ts1$
 i=14 : text spx-40,sptop+(sp*i),ts2$
 i=15 : text spx-40,sptop+(sp*i),ts3$
 i=16 : text spx-40,sptop+(sp*i),strarr$(87)+str$(int(bcsoundstrength#))+strarr$(88)+str$(int(bcsoundx#))+" Y:"+str$(int(bcsoundy#))+" Z:"+str$(int(bcsoundz#))
 ink rgb(0,255,255),0
 i=17 : text spx-40,sptop+(sp*i),strarr$(89)+str$(wshot(wshoti,2))+strarr$(90)+str$(statistic(9))
 ink rgb(255,255,0),0
 `
 rem Extra for testgame
 if debugviewmode<>2
  `
  rem Memory chart of usage
  center text spx-4,(sptop+spheight)+0,str$(mshotmemlargest/1024)+strarr$(91)
  lock pixels
  line spx-4,(sptop+spheight)+110,spx+spwidth,(sptop+spheight)+110
  line spx-4,(sptop+spheight)+110,spx-4,(sptop+spheight)+14
  tlinex#=spx-4
  tliney#=(sptop+spheight)+110
  tlinexbit#=gprogressmax
  tlinexbit#=(spwidth+4.0)/tlinexbit#
  toldlinex#=tlinex#
  toldliney#=tliney#
  msratio#=mshotmemlargest
  msratio#=msratio#/100.0
  toggletext=0
  for tstep=1 to gprogressmax
   tperc#=mshot(tstep)/msratio#
   if mshot(tstep)>0
    line toldlinex#,toldliney#,tlinex#,tliney#-tperc#
    if mshot(tstep)>mshotmemlargest/4
     toggletext=1-toggletext
     center text tlinex#,(tliney#-tperc#)-10+(toggletext*10),str$(tstep)
    endif
    toldlinex#=tlinex#
    toldliney#=tliney#-tperc#
   endif
   tlinex#=tlinex#+tlinexbit#
  next tstep
  center text screen width()/2,(sptop+spheight)+114,strarr$(92)+str$(mshotfirst-GET MEMORY AVAILABLE(0))
  `
  rem Debug control keys
  t$=strarr$(94) : t$=t$+strarr$(95)
  center text screen width()/2,(sptop+spheight)-(sp*3),t$
  t$=strarr$(96) : t$=t$+strarr$(97)
  center text screen width()/2,(sptop+spheight)-(sp*2),t$
  `
  rem workload chart
  center text spx-4,(sptop+spheight)+116,"50k"
  ink rgb(0,255,0),0
  line spx-4,((sptop+spheight)+220)-32,spx+spwidth,((sptop+spheight)+220)-32
  ink rgb(255,255,0),0
  line spx-4,(sptop+spheight)+220,spx+spwidth,(sptop+spheight)+220
  line spx-4,(sptop+spheight)+220,spx-4,(sptop+spheight)+130
  tlinex#=(spx-4)+1
  tliney#=(sptop+spheight)+220
  toldlinex#=tlinex#
  toldliney#=tliney#
  tlinexbit#=((spwidth+4.0)/400.0)*4.0
  for tstep=0 to 400 step 4
   tperc#=wshot(tstep,0)/500.0
   tgap=wshoti-tstep : if tgap<0 then tgap=tgap+400
   tgap=tgap/2 : if tgap>255 then tgap=255
   ink rgb(255-tgap,0,0),0
   tlinescale#=55.0/wshotmax(1)
   line tlinex#,tliney#-1,tlinex#,(tliney#-1)-(wshot(tstep,1)*tlinescale#)
   ink rgb(0,255,255),0
   tlinescale#=55.0/wshotmax(2)
   line tlinex#,tliney#-33,tlinex#,(tliney#-33)-(wshot(tstep,2)*tlinescale#)
   ink rgb(255,128,0),0
   tlinescale#=55.0/wshotmax(4)
   line tlinex#,tliney#-33,tlinex#,(tliney#-33)-(wshot(tstep,4)*tlinescale#)
   ink rgb(255,255,255),0
   tlinescale#=55.0/wshotmax(3)
   line tlinex#,tliney#,tlinex#,tliney#-(wshot(tstep,3)*tlinescale#)
   ink rgb(255,255,0),0
   line toldlinex#,toldliney#,tlinex#,tliney#-tperc#
   toldlinex#=tlinex#
   toldliney#=tliney#-tperc#
   tlinex#=tlinex#+tlinexbit#
  next tstep
  unlock pixels
  ink rgb(255,255,0),0
  if perf(2)>0
   center text screen width()/2,(sptop+spheight)+224,strarr$(93)+str$(perf(1)/perf(2))
  endif
  `
 endif
 `
endif

rem Current keypress
if gtalkytoaster=0
 k$=inkey$()
else
 k$=""
endif

rem Portal Control
if k$="[" then g_iPortal = 1 : set static portals on : set static objects wireframe on
if k$="]" then g_iPortal = 0 : set static portals off : set static objects wireframe off

rem Restoration key
if k$="t" then sync rate 30 : entitysystemdisabled=0 : lightingsystemdisabled=0

rem Disable parts of engin
if k$="-" then entitysystemdisabled=1
if k$="=" then lightingsystemdisabled=1

rem Sync control
if k$="x" then sync rate 0
if k$="u" then sync rate 5

rem Collision control
if k$="m" then deactivatecollision=0
if k$="n" then deactivatecollision=1

rem glide for floating
if player(1).health>0
 if k$="z" then grav#=-2.0 : jumpaction=0
endif

rem Mouse control/pointer
if (scancode()<>15) and debugviewtog=1 then debugviewtog=0
if (scancode()=15 or triggerdebugview>0) and debugviewtog=0
 if triggerdebugview>0
  debugviewmode=triggerdebugview-1
  triggerdebugview=0
 else
  debugviewmode=1-debugviewmode
  debugviewtog=1
 endif
endif

endfunction



rem
rem ENTITY (Control)
rem

_entity_startentitiesoff:
 `
 rem Prepare entities for logical usage
 for e=1 to entityelementlist
  if entityelement(e).active=1 and entityelement(e).spawn.leader=0
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
   rem check if entity starts inside geometry
   entid=entityelement(e).bankindex
   if entityprofile(entid).ischaracter=1
    tettry=0 : tskip=0
    ttryy#=entityelement(e).y
    ellipseheight#=1.0
    if entityelement(e).obj
     if object exist(entityelement(e).obj)=1
      if object size y(entityelement(e).obj)<50
       tskip=1
      endif
     endif
    endif
    if tskip=0
     while tettry<25
      if static volume(entityelement(e).x,ttryy#+33,entityelement(e).z,entityelement(e).x,ttryy#+32,entityelement(e).z,ellipseheight#)=0 then exit
      ttryy#=ttryy#+1.0
      inc tettry
     endwhile
     if tettry>=25
      rem entity stuck - so make it immobile to shut down struggle!
      entityelement(e).eleprof.isimmobile=1
     else
      rem entities can find floor initially (not playerstart,trigger,light,emission)
      entityelement(e).y=ttryy#
      entityelement(e).mover.inmotion=1
      entityelement(e).mover.grav=0.0
     endif
    endif
   endif
  endif
 next e
 timestamp=timer()
 `
 rem Overwrite any GUN or FLAK settings with mods-from-entity-weapons
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  tgunid$=entityprofile(entid).isweapon$
  gosub _entity_getgunidandflakid
  if tgunid>0
   gun(tgunid).settings.accuracy=entityelement(e).eleprof.accuracy
   gun(tgunid).settings.reloadqty=entityelement(e).eleprof.reloadqty
   gun(tgunid).settings.iterate=entityelement(e).eleprof.fireiterations
   if tflakid=0
    gun(tgunid).settings.damage=entityelement(e).eleprof.damage
   else
    flak(tflakid).profile.damage=entityelement(e).eleprof.damage
    flak(tflakid).profile.lifespan=entityelement(e).eleprof.lifespan
    flak(tflakid).profile.bounceonhit=entityelement(e).eleprof.bounceqty
    flak(tflakid).profile.explodeonhit=entityelement(e).eleprof.explodeonhit
    `
    rem some assumptions over how FLAK settings affect flak itself
    flak(tflakid).profile.zinc=entityelement(e).eleprof.throwspeed
    flak(tflakid).profile.yinc=entityelement(e).eleprof.throwangle/10.0
    flak(tflakid).profile.yspeed=1+((entityelement(e).eleprof.throwangle/2.0)/1000.0)
    flak(tflakid).throwangle=entityelement(e).eleprof.throwangle
    if entityelement(e).eleprof.throwangle>0
     flak(tflakid).profile.weight=0.5
    else
     flak(tflakid).profile.weight=0.0
    endif
    `
   endif
  endif
 next e
 `
 rem also ensure entity characters have switched to their weapon (gundata not avail at createelements)
 for e=1 to entityelementlist
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  if obj>0 and entid>0
   if entityprofile(entid).ischaracter=1
    if object exist(obj)=1
     if entityprofile(entid).firespotlimb>-1
      rem spawn leaders do not require attached weapon
      if entityelement(e).spawn.leader=0
       tobj=obj : gosub _entity_switchattachment
      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_resetentitiestorestartstates:
 `
 rem uses tcopyorrestart (1-resttart)
 rem copy start-data-entity-backup to real entityelements
 if tcopyorrestart=0
  dim copyofentityelement(entityelementmax) as entitytype
  for e=1 to entityelementmax
   copyofentityelement(e)=entityelement(e)
  next e
 else
  for e=1 to entityelementmax
   entityelement(e)=copyofentityelement(e)
  next e
 endif
 `
return

_entity_resetentitiesifplrleaps:
 `
 rem Reset logic if player leaps from one location to another
 for e=1 to entityelementlist
  if entityelement(e).active=1
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
  endif
 next e
 `
return

_entity_addetoprioritylist:
 `
 rem add entity to prority status
 if entityelement(e).priorityai=0
  entityelement(e).priorityai=1
  inc logicprioritycount
 endif
 `
return

_entity_removeefromprioritylist:
 `
 rem remove entity from prority status
 if entityelement(e).priorityai=1
  if entityelement(e).priorityduration=0
   entityelement(e).losttargetcount=99999
   entityelement(e).priorityai=0
   if logicprioritycount>0
    dec logicprioritycount
   endif
  endif
 endif
 `
return

_entity_stealpriorityandgivetoe:
 `
 rem Steal from furthest, give to this one (E)
 if lastlogicpriorityfurtheste>0
  if entityelement(e).priorityai=0
   if entityelement(lastlogicpriorityfurtheste).priorityai=1
    if entityelement(lastlogicpriorityfurtheste).priorityduration=0
     tste=e : e=lastlogicpriorityfurtheste : gosub _entity_removeefromprioritylist
     e=tste : entityelement(e).logiccount=0
     gosub _entity_addetoprioritylist
    endif
   endif
  endif
 endif
 `
return

_entity_blastinitentities:
 `
 rem give entities a 10 cycle blast of logic (to set up things like decals and floating collectables)
 for tencycles=1 to 10
  for e=1 to entityelementlist
   if entityelement(e).active=1 and entityelement(e).spawn.leader=0
    entid=entityelement(e).bankindex
    if entid>0
     obj=entityelement(e).obj
     entityelement(e).logictimestamp=timer()
     gosub _entity_controlsingleai
     tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez# : tdy#=entityelement(e).y-mey#
     entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     if entityelement(e).plrdist<1000.0
      entityelement(e).logiccount=0
      entityelement(e).dormant=0
     else
      entityelement(e).logiccount=0
      entityelement(e).dormant=1
     endif
    endif
   endif
  next e
 next tencycles
 `
 rem Bring all entities alive quickly
 allentsfulllogicatstartcount=100
 `
 rem 030805 - and once call to entity control to start off visuals/decals/etc
 gosub _entity_controlelements
 `
return

_entity_showdebugstringinfo:
 `
 if e>0 and obj>0
  if entityelement(e).priorityai<>0 then ink rgb(255,255,255),0
  if entityelement(e).plrdist<500
   if object in screen(obj)=1
    `
    rem Entity Name and Debug string
    center text object screen x(obj),object screen y(obj)-60,entityelement(e).eleprof.name$
    center text object screen x(obj),object screen y(obj)-40,entitydebug$(e)
    `
    rem Entity Status Info
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).ischaracter<>0
     if entityelement(e).ai.libindex>=1 and entityelement(e).ai.libindex<=array count(scriptbank$(0))
      tainame$=scriptbank$(entityelement(e).ai.libindex)
     else
      tainame$=str$(entityelement(e).ai.libindex)
     endif
     center text object screen x(obj),object screen y(obj)-20,"A:"+tainame$+" S:"+str$(entityelement(e).ai.state)+" WS:"+str$(entityelement(e).ai.waypoint.state)+" L:"+str$(entityelement(e).eleprof.lives)+" H:"+str$(entityelement(e).health)+" LT:"+str$(entityelement(e).losttargetcount)+"("+str$(int(entityelement(e).actualtargetx))+","+str$(int(entityelement(e).actualtargety))+","+str$(int(entityelement(e).actualtargetz))+") RCC:"+str$(entityelement(e).raycastcount)
     if entityelement(e).currentweapon>0
      center text object screen x(obj),object screen y(obj),"WA:"+str$(entityelement(e).currentammo)+"\"+str$(entityelement(e).currentclipammo)
     endif
    else
     if entityprofile(tentid).isweapon<>0
      tgunid=entityprofile(tentid).isweapon
      center text object screen x(obj),object screen y(obj)-20," AI:"+str$(entityelement(e).ai.libindex)+" S:"+str$(entityelement(e).ai.state)+strarr$(99)+str$(gun(tgunid).settings.damage)+" H:"+str$(entityelement(e).health)
     else
      center text object screen x(obj),object screen y(obj)-20," AI:"+str$(entityelement(e).ai.libindex)+" S:"+str$(entityelement(e).ai.state)+" H:"+str$(entityelement(e).health)+" A:"+str$(entityelement(e).animframe)
     endif
    endif
    `
   endif
  endif
  if entityelement(e).priorityai<>0 then ink rgb(255,255,0),0
 endif
 `
return

_entity_controlelements:

rem FPSCV10X - solve slow life for entities at distance
if allentsfulllogicatstartcount>0
 dec allentsfulllogicatstartcount
endif

rem Entity Performance
gameperftimestamplocal=perftimer()

rem General data for control management
mex#=camerapositionx : mey#=camerapositiony : mez#=camerapositionz
meheight#=(ellipsevolumesize#-0.25)*30.0

rem handle AI sound
managebroadcastsound()

rem maintain constant game speed
timeelapsed#=(1.0/50.0)*(timer()-timestamp) : timestamp=timer()

rem maintain couner for any animspeed changes
inc timeelapsedrefreshentityanimspeeds
if timeelapsedrefreshentityanimspeeds>5
 timeelapsedrefreshentityanimspeeds=0
endif

rem Debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  set cursor 0,100
  ink rgb(128,255,128),0
  print strarr$(98)
  print
 endif
endif

rem Go through all entities for LOGIC
superstealpriority=0
tonestealperaiphase=0
tonestealperaiphasedist#=99999
logicpriorityfurthest#=0
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 obj=entityelement(e).obj

 rem find value from entity
 `if obj>0
 ` if object exist(obj)=1
 `  center text object screen x(obj),object screen y(obj),str$(entityelement(e).rx)+" "+str$(entityelement(e).rz)
 ` endif
 `endif

 if entityelement(e).active=1 and entityelement(e).dormant=0
  `
  rem only non-spawn-masters with valid profile indexes
  if entid>0 and entityelement(e).spawn.leader=0
   `
   rem reset kill flag
   tkillentitynow=0
   `
   rem always fade entity to lifespan no matter logic slice
   if entityelement(e).spawn.life>0
    if timer()>entityelement(e).spawn.life
     entityelement(e).spawn.life=0
     tkillentitynow=1
    endif
   endif
   `
   rem always kill an entity falling out of universe
   if entityelement(e).y<-100
    tkillentitynow=1
   endif
   `
   rem kill now
   if tkillentitynow=1
    tdamage=entityelement(e).health
    tdamagesource=0 : timpacttype=1
    tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
    ttodestroyevenifimmune=entityelement(e).eleprof.strength : rem store for later return
    if entityelement(e).eleprof.strength=0 then entityelement(e).eleprof.strength=1
    gosub _entity_deducthealth : entityelement(e).eleprof.strength=ttodestroyevenifimmune
    tkillentitynow=0
   endif
   `
   rem logic timeslice
   tlogic#=entityelement(e).logiccount-timeelapsed#
   entityelement(e).logiccount=tlogic#
   if entityelement(e).eleprof.phyalways<>0 then entityelement(e).logiccount=0
   if entityelement(e).logiccountburst>0 then entityelement(e).logiccountburst=entityelement(e).logiccountburst-1 : entityelement(e).logiccount=0
   if entityelement(e).logiccount>0.0
    `
    rem if player runs at entity quickly, entity AI should be ready with AI
    tdx#=entityelement(e).x-mex# : tdy#=entityelement(e).y-mey# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    if entityprofile(entid).ischaracter=0
     rem for doors and proximity AI
     if entityelement(e).plrdist<100
      entityelement(e).logiccount=0
     endif
    else
     rem characters can have a priority logic monopoly
     if logicprioritycount<int(logicprioritymax#)
      gosub _entity_addetoprioritylist
     else
      rem if this entity character is substantially closer that furthest priority entity, switch
      if entityelement(e).plrdist<lastlogicpriorityfurthest#+125.0
       rem switch priroity to this entity (priority entity characters are always the closest)
       if entityelement(e).plrdist<tonestealperaiphasedist#
        tonestealperaiphasedist#=entityelement(e).plrdist
        tonestealperaiphase=e
       endif
      endif
      rem hold character logic at bay - until logicpriority allows
      entityelement(e).logiccount=100
     endif
     if entityelement(e).priorityai=1
      entityelement(e).logiccount=0
     endif
    endif
    if entityelement(e).ai.libindex=entityelement(e).ai.libdestroy or entityelement(e).ai.libindex=entityelement(e).ai.libinit
     entityelement(e).logiccount=0
    endif
    if entityprofile(entid).ismarker<>0
     rem checkpoint, lights, triggers and emissions
     entityelement(e).logiccount=0
    endif
    `
   endif
   if entityelement(e).logiccount<=0
    `
    rem time slice of logic (...since entity last thought...)
    timeslice#=(1.0/50.0)*(timer()-entityelement(e).logictimestamp)
    entityelement(e).logictimestamp=timer()
    `
    rem logic control
    gosub _entity_controlsingleai
    `
    rem when move, sounds might also need moving
    if entityelement(e).eleprof.physics<=2
     for tsnd=0 to 2
      if tsnd=0 then ttsnd=entityelement(e).soundset
      if tsnd=1 then ttsnd=entityelement(e).soundset1
      if tsnd=2 then ttsnd=entityelement(e).soundlooping
      if ttsnd>0
       if sound exist(ttsnd)=1
        if sound looping(ttsnd)=1
         posinternal3dsound(ttsnd,entityelement(e).x,entityelement(e).y,entityelement(e).z)
        endif
       endif
      endif
     next tsnd
    endif
    `
    rem free up a counter for a new AI character to be selected
    if entityelement(e).priorityai=1
     tokay=0
     if entityelement(e).active=0 or entityelement(e).plrdist>1000
      entityelement(e).priorityduration=0
      tokay=1
     endif
     if tokay=1
      gosub _entity_removeefromprioritylist
     else
      rem work out which E is the furthest back
      tpridist#=entityelement(e).plrdist
      if tpridist#>logicpriorityfurthest#
       logicpriorityfurthest#=tpridist#
       logicpriorityfurtheste=e
      endif
     endif
     rem priority duration protects from being lost or stolen for a while (running away)
     if entityelement(e).priorityduration>0
      entityelement(e).priorityduration=entityelement(e).priorityduration-1
     else
      entityelement(e).priorityduration=0
     endif
    endif
    `
    rem calculate player activity distance
    tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
    `
    rem can I see checkpoints here
    if entityprofile(entid).ismarker=1 and entityprofile(entid).lives=0
     if entityelement(e).plrdist<120.0
      if checkpointentity<>e
       playinternal3dsound(entityelement(e).soundset,mex#,mey#,mez#)
       checkpointentity=e
      endif
     endif
    endif
    `
    rem logic count based on distance (cancelled for important AI above)
    if allentsfulllogicatstartcount>0
     rem FPSCV10X - all entities should have immediate burst of logic to get started
     entityelement(e).logiccount=0
    else
     entityelement(e).logiccount=entityelement(e).plrdist/5.0
    endif
    `
   endif
   `
  endif
  `
 else
  `
  rem only if not dormant
  if entityelement(e).dormant=0
   `
   rem Inactive entity, however characters have logic even when dead
   if entityprofile(entid).ischaracter=1
    if entityelement(e).eleprof.cantakeweapon=1
     tgunid=entityelement(e).currentweapon
     if tgunid>0
      rem calculate player activity distance (of the attached weapon point)
      if entityprofile(entid).firespotlimb>-1
       x1#=limb position x(obj,entityprofile(entid).firespotlimb)
       y1#=limb position y(obj,entityprofile(entid).firespotlimb)
       z1#=limb position z(obj,entityprofile(entid).firespotlimb)
      else
       x1#=entityelement(e).x
       y1#=entityelement(e).y
       z1#=entityelement(e).z
      endif
      tdx#=x1#-mex# : tdy#=y1#-mey# : tdz#=z1#-mez#
      entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
      if entityelement(e).plrdist<80
       rem player collects weapon from enemy (stores takeweaponammo in Quantity)
       weaponindex=tgunid
       weaponinvposition=pi : tgunid=weaponindex
       tqty=rnd(gun(tgunid).settings.reloadqty)
       gosub _player_addweapon
       rem for weapnisammo collections, add required ammo
       if gotweapon>0
        if gun(tgunid).settings.weaponisammo=0
         tqty=gun(tgunid).settings.reloadqty*entityelement(e).eleprof.quantity
         weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
        else
         if tqty=0 then tqty=1
         if weaponammo(gotweapon)=0
          weaponammo(gotweapon)=tqty
         else
          weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
         endif
        endif
       endif
       rem and play a reload sound from the gun (collection sound=reload)
       if gunsound(tgunid,2).soundid>0
        if sound exist(gunsound(tgunid,2).soundid)=1
         if sound playing(gunsound(tgunid,2).soundid)=0
          playinternalBC3dsound(gunsound(tgunid,2).soundid,camera position x(),camera position y(),camera position z(),1)
         endif
        endif
       endif
       rem and remove weapon from dead entity
       entityelement(e).currentweapon=0
       rem remove attached weapon from entity also
       tobj=entityelement(e).attachmentobj
       if tobj>0 then hide object tobj
      endif
     endif
    endif
   endif
  else
   `
   rem Entity is completely dormant (brand new or frozen by distance)
   if obj>0
    if object exist(obj)=1
     if object visible(obj)=1
      rem no longer dormant if revealed by areabox render
      entityelement(e).dormant=0
     endif
    endif
   else
    rem not dormant if close enough to be useful (trigger areas, emissions, non-objs)
    tdx#=entityelement(e).x-mex# : tdy#=entityelement(e).y-mey# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    if entityelement(e).plrdist<1000.0
     entityelement(e).dormant=0
    endif
   endif
   `
   rem Not dormant if always active
   if entityelement(e).eleprof.phyalways<>0 then entityelement(e).dormant=0
   `
  endif
  `
 endif
next e

rem end of debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  ink rgb(255,255,0),0
 endif
endif

rem Steal priority if new entity closer
if tonestealperaiphase>0
 e=tonestealperaiphase : gosub _entity_stealpriorityandgivetoe
endif

rem Drop a priority entity if need to get some AI speed back
if logicpriorityfurtheste>0
 lastlogicpriorityfurthest#=logicpriorityfurthest#
 lastlogicpriorityfurtheste=logicpriorityfurtheste
 if logicprioritycount>int(logicprioritymax#)
  e=logicpriorityfurtheste
  gosub _entity_removeefromprioritylist
 endif
endif

rem Entity Performance
inc gameperfentities1, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Go through all entities for MOVEMENT
for e=1 to entityelementlist
 if entityelement(e).dormant=0
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  gosub _entity_controlspawn
  if entityelement(e).spawn.leader=0
   if entityelement(e).active=1
    gosub _entity_controlwaypoints
    gosub _entity_controlforce
    gosub _entity_controlcollision
    inc gameperfentities2, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()
    gosub _entity_controlmovements
    inc gameperfentities3, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()
    gosub _entity_controldelayeddamage
   endif
  endif
 endif
next e

rem Entity Performance
inc gameperfentities4, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Calculate any logic drop increments/decrements
if screen fps()>=30
 if logicprioritymax#<10.0
  logicprioritymax#=logicprioritymax#+0.02
 endif
else
 logicprioritymax#=2.0
endif

rem Go through all entities for VISUAL
for e=1 to entityelementlist
 obj=entityelement(e).obj
 entid=entityelement(e).bankindex
 if entityelement(e).active=1 and entityelement(e).dormant=0
  if obj>0
   `
   if object exist(obj)=1 and entityelement(e).plrdist<2000
    `
    rem Operate spin and float system
    tspin#=0.0 : thover#=0.0
    if entityelement(e).spinrate<>0
     entityelement(e).spinvalue=entityelement(e).spinvalue+entityelement(e).spinrate
     tspin#=wrapvalue(entityelement(e).spinvalue)
    endif
    if entityelement(e).floatrate<>0
     entityelement(e).floatvalue=entityelement(e).floatvalue+4
     thover#=entityelement(e).floatrate+(cos(wrapvalue(entityelement(e).floatvalue))*entityelement(e).floatrate)
    endif
    `
    rem update entity object position (keep position for univese vis-culling)
    if entityelement(e).eleprof.physics=1
     rem regular physics driven
     entityelement(e).x=object position x(obj)
     entityelement(e).y=object position y(obj)
     entityelement(e).z=object position z(obj)
     entityelement(e).ry=object angle y(obj)
    else
     if entityelement(e).eleprof.physics=2
      rem entity driven physics (character)
      todee=e : gosub _ode_entitydrivenphysics
     else
      if entityelement(e).eleprof.physics=3
       rem entity is typically immobile (door/window)
       todee=e : gosub _ode_entitydrivenstaticphysics
      else
       rem no physics influences
       position object obj,entityelement(e).x,entityelement(e).y+thover#,entityelement(e).z
      endif
     endif
    endif
    `
    rem Animations need consistency when suddenly obj is visible
    gosub _entity_controlanim
    `
    rem if actually visible to camera
    if object visible(obj)=1
     `
     rem Only need decal creation if an existing obj is visible
     gosub _entity_controldecals
     `
     rem handle object rotation
     if entityelement(e).norotate=0
      yrotate object obj,entityelement(e).ry+tspin#
     endif
     `
     rem update animation frame of entity
     if entityelement(e).animframeupdate=1
       stop object obj : set object interpolation obj,100
       set object frame obj,entityelement(e).animframe
       entityelement(e).animframeupdate=0
     endif
     `
     rem Update head if available
     if entityprofile(entid).headlimb<>-1
      if limb exist(obj,entityprofile(entid).headlimb)=1
       rotate limb obj,entityprofile(entid).headlimb,curveangle(entityelement(e).ai.headangle,limb angle x(obj,entityprofile(entid).headlimb),3.0),limb angle y(obj,entityprofile(entid).headlimb),limb angle z(obj,entityprofile(entid).headlimb)
      endif
     endif
     `
     rem any visual overlay info
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
     rem update alpha fade value
     if gmultiplayergame=1
      rem multiplayer - bug in 5.8, characters cannot control alpha (seem to be influenced by other objects)
      set alpha mapping on obj,100
      if entityprofile(entid).ischaracter<>0
       if entityelement(e).invincibleactive<>0
        ghost object on obj
       else
        ghost object off obj
       endif
      endif
     else
      rem keep for single player
      if entityelement(e).invincibleactive<>0
       set alpha mapping on obj,50+rnd(25)
      else
       if entityelement(e).ai.alphafadeupdate=1
         set alpha mapping on obj,entityelement(e).ai.alphafade
         entityelement(e).ai.alphafadeupdate=0
       endif
      endif
     endif
     `
     rem handle any entity attachments (coneofsight)
     gosub _entity_controlattachments
     `
     rem control lighting of entities (and free at start also - get start lighting)
     if gdynamiclightingstate=1 or forceambientlightsetting>0
      if object in screen(obj)=1
       gosub _entity_controllighting
      endif
     endif
     `
`cone of sight debug not use dnow
`     rem if attachment not from debug mode, show when entityvisible
`     if gshowentitygameinfostate=0
     tobj=entityelement(e).attachmentobj
     if tobj>0
      if object exist(tobj)=1
       show object tobj
      endif
     endif
`     endif
     `
     rem blob shadow control (all other non local plrs) (might be performance issue here)
     if entityelement(e).attachmentblobobj>0
      if object exist(entityelement(e).attachmentblobobj)=1
       if (gmultiplayergame=0 and entityelement(e).health>0) or (gmultiplayergame=1 and entityelement(e).collisionactive<>0)
        dst#=static raycast(entityelement(e).x,entityelement(e).y+5,entityelement(e).z,entityelement(e).x,entityelement(e).y-50,entityelement(e).z)
       else
        dst#=0.0
       endif
       if dst#>0
        dst#=dst#-5.0
        tmvszy#=(object size y(obj)/2)*(entityprofile(entid).scale/100.0)
        tmvy#=object position y(obj)-tmvszy#
        position object entityelement(e).attachmentblobobj,object position x(obj),(tmvy#-dst#)+0.5,object position z(obj)
        show object entityelement(e).attachmentblobobj
        tsc#=(100.0-dst#) : scale object entityelement(e).attachmentblobobj,tsc#,tsc#,tsc#
       else
        hide object entityelement(e).attachmentblobobj
       endif
      endif
     endif
     `
    else
     `
     rem Limited debug info view of entities not visible (for spawn debugging)
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
     rem entity not visible by camera ny more
     tobj=entityelement(e).attachmentobj
     if tobj>0
      if object exist(tobj)=1
       hide object tobj
      endif
     endif
     `
    endif
    `
   endif
   `
  else
   `
   rem entity has no OBJ
   if entityprofile(entid).ismarker=4
    rem emission markers can emit decals of course
    gosub _entity_controldecals
   endif
   `
  endif
 endif
next e

rem Display vis col map (as radar test)
if entitysystemdisabled=0 and gshowentitygameinfostate=1
 lock pixels
 thorizpos=(screen width()-40)-40-10
 tvertpos=(screen height()-40)-511-10-20
 metx=camerapositionx/25 : mety=camerapositiony/100 : metz=camerapositionz/-25
 line thorizpos,470+tvertpos,thorizpos+82,470+tvertpos : line thorizpos,553+tvertpos,thorizpos+82,553+tvertpos
 line thorizpos,470+tvertpos,thorizpos,553+tvertpos : line thorizpos+82,470+tvertpos,thorizpos+82,553+tvertpos
 for tx=metx-20 to metx+20
  for ty=mety to mety
   for tz=metz-20 to metz+20
    tdot=0
    if tx>=0 and tx<=160 and ty>=0 and ty<=5 and tz>=0 and tz<=160
     if viscolmap(tx,ty,tz)<>0
      tdot=1
     endif
    else
     if (tx=-1 or tx=161) and tz>=0 and tz<=160
      tdot=1
     endif
     if (tz=-1 or tz=161) and tx>=0 and tx<=160
      tdot=1
     endif
    endif
    if tdot=1
     dot thorizpos+41+((tx-metx)*2),511+((tz-metz)*2)+tvertpos
     dot thorizpos+41+((tx-metx)*2),512+((tz-metz)*2)+tvertpos
     dot thorizpos+42+((tx-metx)*2),511+((tz-metz)*2)+tvertpos
     dot thorizpos+42+((tx-metx)*2),512+((tz-metz)*2)+tvertpos
    endif
   next tz
  next ty
 next tx
 unlock pixels
endif

rem Entity Performance
inc gameperfentities5, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

return

_entity_fillviscolmap:
 `
 rem Fill empty map tiles with no-walk id
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 4
    for tx=0 to 3
     for tz=0 to 3
      viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=0
     next tz
    next tx
   next tml
  next tmz
 next tmx
 `
 rem FPSCV104RC5 use map data to determine where layer holes are (so characters cannot fall off ledges)
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 19
    if map(tml,tmx,tmz)=0
     for tx=0 to 3
      for tz=0 to 3
       viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=-2
      next tz
     next tx
    endif
   next tml
  next tmz
 next tmx
 `
return

_entity_controlsingleai:

rem get functional overview
gosub _entity_controlrecalcdist

rem before any point of logic, if no health in main AI, die
if entityelement(e).ai.libindex=entityelement(e).ai.libmain
 if entityelement(e).health<=0
  entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.headangle=0
  entityelement(e).ai.state=0
 endif
endif

rem New AI Script flag
trundefaultscript=0
taddforcesphere=0

rem Get AI Script for Entity Element
aiindex=entityelement(e).ai.libindex
gosub _ai_control
`
rem Apply force if actioned
if taddforcesphere>0
 spherex#=entityelement(e).x
 spherey#=entityelement(e).y
 spherez#=entityelement(e).z
 sphereforce#=taddforcesphere/100.0
 gosub _entity_addforcesphere
endif
`
rem Weapon Control for entities
if entityelement(e).fireweapon=1
 tgunid=entityelement(e).currentweapon
 if tgunid>0
  `
  rem start of shot pos
  if entityprofile(entid).firespotlimb>-1
   x1#=limb position x(obj,entityprofile(entid).firespotlimb)
   y1#=limb position y(obj,entityprofile(entid).firespotlimb)
   z1#=limb position z(obj,entityprofile(entid).firespotlimb)
  else
   x1#=entityelement(e).x
   y1#=entityelement(e).y+45.0
   z1#=entityelement(e).z
  endif
  `
  rem weapon type
  flakid=gun(tgunid).settings.flakindex
  if flakid=0
   `
   rem BULLET
   rem initial shot creates light flash
   spotflash=100 : tx#=x1# : ty#=y1# : tz#=z1#
   tcolr=gun(tgunid).settings.muzzlecolorr
   tcolg=gun(tgunid).settings.muzzlecolorg
   tcolb=gun(tgunid).settings.muzzlecolorb
   gosub _lighting_spotflash
   `
   rem discharge sound (single fire, or automatic loop sound)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   if tsndid>0
    if gun(tgunid).action.automatic.s>0
     if entityelement(e).firesoundloop=0
      play sound tsndid,gun(tgunid).sound.fireloopend : rem some sound bug
      loop sound tsndid,0,gun(tgunid).sound.fireloopend
      entityelement(e).firesoundloop=tsndid
     endif
    else
     play sound tsndid
    endif
    posinternal3dsound(tsndid,x1#,y1#,z1#)
    broadcast3dsound(x1#,y1#,z1#,25.0)
   endif
   `
   rem gun data for accuracy
   trayaccuracy=gun(tgunid).settings.accuracy
   `
   rem project gun-line-for-shot (from raw-calc or target)
   if entityelement(e).actualtarget<>0
    rem no accuracy drift if close
    x2#=entityelement(e).actualtargetx
    y2#=entityelement(e).actualtargety
    z2#=entityelement(e).actualtargetz
    tdx#=abs(x2#-x1#)
    tdy#=abs(y2#-y1#)
    tdz#=abs(z2#-z1#)
    tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
    rem greater than 200 units add drift
    if tdd#>200.0
     rem add a basic distance drift to enemy shooing (human error)
     trayaccuracy=(trayaccuracy*5)+rnd((tdd#-200)*2)
     rem Work out final trajectory of shot
     x2#=entityelement(e).actualtargetx+trayaccuracy-rnd(trayaccuracy*2)
     y2#=entityelement(e).actualtargety+trayaccuracy-rnd(trayaccuracy*2)
     z2#=entityelement(e).actualtargetz+trayaccuracy-rnd(trayaccuracy*2)
    endif
   else
    position object hudbankoffset+3,x1#,y1#,z1#
    rotate object hudbankoffset+3,0,entityelement(e).mover.da,0
    move object hudbankoffset+3,gun(tgunid).settings.range
    disable object zdepth hudbankoffset+3
    x2#=object position x(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
    y2#=object position y(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
    z2#=object position z(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   endif
   `
   rem had bulletray hit anything solid
   tbullethit=0 : tbullethitstatic=0
   tbullethitmaterial=0 : tbullethitflesh=0
   entityelement(e).raycastcount=0
   dst#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
   if dst#<>0
    x#=checklist fvalue a(6) : x2#=x#
    y#=checklist fvalue b(6) : y2#=y#
    z#=checklist fvalue c(6) : z2#=z#
    tbullethitstatic=1 : tbullethit=1
    tcolmaterial=get static collision value()-1
    `if tcolmaterial>=0 and tcolmaterial<=8 then tbullethitmaterial=tcolmaterial : rem FPSCV101 - fix
    if tcolmaterial>=0 and tcolmaterial<=99 then tbullethitmaterial=tcolmaterial
   endif
   `
   rem if it hits player before wall, hurt player
   if entityelement(e).actualtarget=1
    dst#=intersect object(hudbankoffset+2,x1#,y1#,z1#,x2#,y2#,z2#)
    if dst#<>0 or tdd#<125.0
     tbullethitstatic=0
    endif
   endif
   `
   rem where wall not hit, must be a hit
   if tbullethitstatic=0
    trange#=gun(tgunid).settings.range
    tperc#=(trange#-dst#)/trange#
    if dst#<200 then tperc#=1.0
    bulletdamage#=gun(tgunid).settings.damage : dec bulletdamage#,rnd(bulletdamage#/5)
    if gun(tgunid).settings.damage>5
     rem enemy fire always one half the players effectiveness after first few points
     tperc#=tperc#*0.5
    endif
    tdamage#=bulletdamage#*tperc# : tdamage=tdamage#
    if entityelement(e).actualtarget=1
     rem player was the target
     if tdamage>0 then gosub _player_takedamage
     if player(1).health<=0
      rem hear the full sound of what killed you
      if tsndid>0
       playinternal3dsound(tsndid,camera position x(),camera position y(),camera position z())
      endif
     endif
    else
     rem entity was the target (store E while leap to other entity for damage control)
     if entityelement(e).actualtarget>1 and tdamage>0
      tdamagesource=0 : timpacttype=1
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
      stte=e : e=entityelement(e).actualtarget-1 : gosub _entity_deducthealth : e=stte
      tentid=entityelement(e).bankindex
      entid=entityelement(e).bankindex
     endif
    endif
    tbullethitstatic=0 : tbullethit=1
    tbullethitflesh=1
   endif
   `
   rem bullet result
   if tbullethit=1
    rem debris where the bullet struck
    for p=1 to 32
     if debris(p)=0
      rem debris where the bullet struck
      position particles p,x#,0,z#
      position particle emissions p,0,y#/20.0,0
      set particle emissions p,10
      debris(p)=40
      exit
     endif
    next p
    rem add scorch if hit universe static polygons
    if tbullethitstatic=1
     tscorchtype=gun(tgunid).settings.scorchtype
     gosub _entity_doscorch
    endif
   endif
   `
  else
   `
   rem FLAK (grenames, rockets)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   playinternal3dsound(tsndid,x1#,y1#,z1#)
   broadcast3dsound(x1#,y1#,z1#,15.0)
   `
   rem determine if need to pitch the launch based on direction and distance
   flakpitch=0
   if flak(flakid).throwangle=0
    rem LAUNCH
    tdx#=mex#-entityelement(e).x
    tdz#=mez#-entityelement(e).z
    tdy#=(mey#-50)-entityelement(e).y
    flakpitch=atanfull(tdy#,sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)))*-1
   else
    rem LOB
    if entityelement(e).actualtarget<>0
     y2#=entityelement(e).actualtargety
     if y2#>entityelement(e).y-100.0
      x2#=entityelement(e).actualtargetx
      z2#=entityelement(e).actualtargetz
      tdx#=abs(x2#-entityelement(e).x)
      tdy#=abs(y2#-entityelement(e).y)
      tdz#=abs(z2#-entityelement(e).z)
      tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
      flakpitch=22.0+((45.0/500.0)*tdd#)
      if flakpitch>80 then flakpitch=80
      if flakpitch<22.0 then flakpitch=22.0
      rem FPSCV105RC2 - so can throw closer to plr (through door)
      firestr#=entityelement(e).firestrength/100.0
      flakpitch=flakpitch*firestr#*-1.0
     endif
    endif
   endif
   `
   rem launch the flak
   flakangle=entityelement(e).mover.da : flakowner=e
   flakx=x1#+newxvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flaky=y1#+flak(flakid).throwheight
   flakz=z1#+newzvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flakspeed#=2.0
   gosub _flakelement_create
   `
  endif
  rem a pause while guns cools down (fingers of shooter release trigger and repress)
  entityelement(e).fireweapon=2
 else
  rem no wepon so deflag fire
  entityelement(e).fireweapon=0
 endif
else
 if entityelement(e).fireweapon>0
  tgunid=entityelement(e).currentweapon
  entityelement(e).fireweapon=entityelement(e).fireweapon+1
  if gun(tgunid).action.automatic.s>0
   if entityelement(e).currentammo<=0 and entityelement(e).firesoundloop>0
    stop sound entityelement(e).firesoundloop
    entityelement(e).firesoundloop=0
   endif
   if entityelement(e).fireweapon>6
    entityelement(e).fireweapon=0
   endif
  else
   if entityelement(e).fireweapon>30 then entityelement(e).fireweapon=0
  endif
 else
  if entityelement(e).firesoundloop>0
   stop sound entityelement(e).firesoundloop
   entityelement(e).firesoundloop=0
  endif
 endif
endif
`
rem Switch to FPI AI Scripts
if trundefaultscript>0
 `
 rem About to leave main?
 tleavingmain=0
 if entityelement(e).ai.libindex=entityelement(e).ai.libmain then tleavingmain=1
 `
 rem Switch to specified AI scripts
 entityelement(e).ai.libindex=trundefaultscript-1
 trundefaultscript=0
 `
 rem If returning from internal AI switch
 if entityelement(e).ai.usinginternalai=1
  rem restore old state values
  entityelement(e).ai.waypoint.state=entityelement(e).ai.oldwaypointstate
  entityelement(e).ai.alphafade=entityelement(e).ai.oldalphafade
  entityelement(e).ai.state=entityelement(e).ai.oldstate
  entityelement(e).ai.usinginternalai=0
 else
  if trundefaultscriptinternal=1 and tleavingmain=1
   gosub _entity_storemainai
  endif
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.state=0
 endif
 `
 rem Always reset these after AI script switch
 entityelement(e).ai.headdestangle=0
 entityelement(e).ai.headangle=0
 `
endif

return

_entity_doscorch:
 rem material damage
 if tbullethitmaterial>0
  tscorchsize2#=4.0+(rnd(10)/10.0) : tscorchtype2=11+tbullethitmaterial
  if tscorchtype2>15 then tscorchtype2=12 : rem FPSCV101 - fix
  add static scorch tscorchsize2#,tscorchtype2
 endif
 if tbullethitflesh>0
  rem blood splat
  tscorchtype3=8+rnd(3)
  tscorchsize3#=10.0+((tbullethitflesh/100.0)*(20.0+rnd(20)))
  add static scorch tscorchsize3#,tscorchtype3
 else
  rem bullethole
  tscorchsize#=2.0+(rnd(10)/10.0)
  if tscorchtype>=2 then tscorchsize#=3.0+(rnd(10)/10.0)
  add static scorch tscorchsize#,tscorchtype
 endif
return

_entity_controlspawn:

rem Only leaders control spawn events (activated is automatic for spawn switch on)
if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=0 and entityelement(e).activated=1 then entityelement(e).spawn.atstart=1
if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=1
 rem Count down to next spawn
 if entityelement(e).spawn.afterdelay=1
  entityelement(e).spawn.leadercount=entityelement(e).spawn.leadercount-1
 endif
 rem If count goes to zero (and have some left 'upto')
 tpermitaspawn=0
 if entityelement(e).spawn.upto>0
  if entityelement(e).spawn.leadercount<=0 then tpermitaspawn=1
  if entityelement(e).spawn.whendead=1
   for te=1+e to e+entityelement(e).spawn.max
    tobj=entityelement(te).obj
    if tobj>0
     if object exist(tobj)=1 and entityelement(te).active=0
      if entityelement(te).beenkilled=1
       entityelement(te).beenkilled=0
       tpermitaspawn=1 : exit
      endif
     endif
    endif
   next te
  endif
 endif
 if tpermitaspawn=1
  rem Restart spawn cycle
  entityelement(e).spawn.leadercount=entityelement(e).spawn.delay+rnd(entityelement(e).spawn.delayrandom)
  rem Find child of this leader to spawn
  tproduceqty=0
  tnumbertospawn=entityelement(e).spawn.qty+rnd(entityelement(e).spawn.qtyrandom)
  for te=1+e to e+entityelement(e).spawn.max
   tobj=entityelement(te).obj
   if tobj>0
    if object exist(tobj)=1 and entityelement(te).active=0
     `
     rem find place not occupied if entity driven object
     if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
      tokay=0
      ttriesrange=0
      while tokay=0
       for ttriesx=ttriesrange*-1 to ttriesrange
        for ttriesz=ttriesrange*-1 to ttriesrange
         tryx#=entityelement(e).spawn.x+(ttriesx*25)
         tryz#=entityelement(e).spawn.z+(ttriesz*25)
         ty=entityelement(te).y/100
         tx=tryx#/25 : tz=tryz#/-25
         if tx>=0 and ty>=0 and tz>=0
          if tx<=viscolx and ty<=viscoly and tz<=viscolz
           if viscolmap(tx,ty,tz)=0
            entityelement(te).y=entityelement(e).spawn.y
            entityelement(te).x=tryx#
            entityelement(te).z=tryz#
            tokay=1 : exit
           endif
          endif
         endif
        next ttriesz
       next ttriesx
       inc ttriesrange
       if ttriesrange>8 then tokay=2
      endwhile
     else
      entityelement(te).x=entityelement(e).spawn.x
      entityelement(te).y=entityelement(e).spawn.y
      entityelement(te).z=entityelement(e).spawn.z
      tokay=1
     endif
     `
     rem if space, init entity with AIINIT
     if tokay=1
      `
      entityelement(te).active=1
      entityelement(te).dormant=1
      entityelement(te).ai.libindex=entityelement(te).ai.libinit
      entityelement(te).ai.waypoint.state=0
      entityelement(te).ai.waypoint.tracker=0
      entityelement(te).ai.waypoint.current=0
      entityelement(te).ai.state=0
      entityelement(te).ai.headangle=0
      entityelement(te).ai.headdestangle=0
      entityelement(te).ai.usinginternalai=0
      entityelement(te).ai.oldstate=0
      entityelement(te).ai.alphafade=0
      entityelement(te).ai.oldalphafade=0
      entityelement(te).ai.destalphafade=0
      entityelement(te).ai.oldwaypointstate=0
      entityelement(te).actualtarget=0
      entityelement(te).losttargetcount=0
      `
      entityelement(te).rx=entityelement(e).rx
      entityelement(te).ry=entityelement(e).ry
      entityelement(te).rz=entityelement(e).rz
      entityelement(te).mover.da=entityelement(e).ry
      `
      entitybreadcrumbs(te,0).x=0
      entityelement(te).mover.grav=1.0
      entityelement(te).mover.moved=0
      entityelement(te).mover.inmotion=0
      entityelement(te).mover.ix=0
      entityelement(te).force.ix=0
      entityelement(te).mover.iy=0
      entityelement(te).force.iy=0
      entityelement(te).mover.iz=0
      entityelement(te).force.iz=0
      entityelement(te).force.active=0
      entityelement(te).logiccount=0
      entityelement(te).blockedby=0
      `
      rem reset entity that reappears in game
      if entityelement(te).eleprof.strength>0
       entityelement(te).health=entityelement(e).eleprof.strength
      else
       entityelement(te).health=1
      endif
      entityelement(te).eleprof.lives=entityelement(e).eleprof.lives
      entityelement(te).shotdamage=0
      entityelement(te).shotdamagesource=0
      `
      rem clear out dake player info
      tplrid=entityelement(e).fakeplayerid
      player(tplrid).inventorymax=0
      `
      rem put weapon back in character hands
      entityelement(te).currentweapon=entityelement(e).eleprof.hasweapon
      entityelement(te).currentclipammo=9999
      entityelement(te).firesoundloop=0
      entityelement(te).currentammo=0
      entityelement(te).fireweapon=0
      `
      rem give entity infinite or finite life
      if entityelement(e).spawn.life>0
       entityelement(te).spawn.life=timer()+(entityelement(e).spawn.life*1000)
      else
       entityelement(te).spawn.life=0
      endif
      `
      rem object setting
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       ste=e : e=te : gosub _ode_switchoffe : e=ste
      endif
      position object tobj,entityelement(te).x,entityelement(te).y,entityelement(te).z
      set alpha mapping on tobj,entityelement(te).ai.alphafade
      rem V106 RC3 set rotation of spawned to rotation values too
`      rotate object tobj,0,0,0
      rotate object tobj,entityelement(te).rx,entityelement(te).ry,entityelement(te).rz
      show object tobj
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       ste=e : e=te : gosub _ode_setupewithphysics
       tvel=entityelement(e).spawn.vel+rnd(entityelement(e).spawn.velrandom)
       tangle=entityelement(e).spawn.angle+rnd(entityelement(e).spawn.anglerandom)
       gosub _ode_pushusingtvelandangle
       e=ste
      endif
      `
      rem reset visuals
      entid=entityelement(te).bankindex
      tobj=entityelement(te).obj
      if total object frames(tobj)>0
       set object frame tobj,0
       if entityprofile(entid).ischaracter=1
        if entityprofile(entid).animmax>=1
         teai=0 : if entityanim(entid,1).start>0 then teai=1
         tbaseframe=teai : gosub _entity_getactualframestart : tfstart=tactualframe
         tbaseframe=teai : gosub _entity_getactualframefinish : tffinish=tactualframe
         loop object tobj,tfstart,tffinish
        else
         loop object tobj : stop object tobj
        endif
       endif
      endif
      `
      rem set spawned entity collision
      if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
       entityelement(te).collisionactive=0
       set object collision off tobj
      else
       entityelement(te).collisionactive=1
       set object collision on tobj
      endif
      `
      rem write entity to viscolmap if space available, else find new place
      if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
       tx=entityelement(te).x/25
       ty=entityelement(te).y/100
       tz=entityelement(te).z/-25
       if tx>=0 and ty>=0 and tz>=0
        if tx<=viscolx and ty<=viscoly and tz<=viscolz
         viscolmap(tx,ty,tz)=te
        endif
       endif
      endif
      `      `
      rem reduce overall UPTO count
      entityelement(e).spawn.upto=entityelement(e).spawn.upto-1
      if entityelement(e).spawn.upto<=0
       entityelement(e).spawn.upto=0
       exit
      endif
      `
      rem go to end if no more to produce
      inc tproduceqty
      if tproduceqty>=tnumbertospawn
       te=e+entityelement(e).spawn.max
       exit
      endif
      `
     endif
     `
    endif
   endif
  next te
 endif
endif

return

_entity_controlwaypoints:

rem waypoint behaviour substatesystem
if entityelement(e).ai.waypoint.state>0
 w=entityelement(e).ai.waypoint.current
 if entityelement(e).ai.waypoint.state=1
  `
  rem before set-off make sure can see destination
  tokay=0
  telex#=entityelement(e).x
  teley#=entityelement(e).y+35.0
  telez#=entityelement(e).z
  tdistx#=telex#-waypointcoord(w).x
  tdisty#=teley#-waypointcoord(w).y+35.0
  tdistz#=telez#-waypointcoord(w).z
  tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
  if tdist#<1000.0
   tmpx#=waypointcoord(w).x
   tmpy#=waypointcoord(w).y+35.0
   tmpz#=waypointcoord(w).z
   entityelement(e).raycastcount=0
   if static raycast(telex#,teley#,telez#,tmpx#,tmpy#,tmpz#)=0
    tokay=1
   endif
  endif
  `
  rem setup walk to get to next waypoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  entityelement(e).mover.run=0
  entityelement(e).ai.waypoint.state=2
  `
  rem characters animate when waypoint is followed, if alive
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1 and entityelement(e).health>0
   if entityelement(e).animdo<>entityelement(e).animset-1
    entityelement(e).animset=3
   endif
  endif
  `
 endif
 if entityelement(e).ai.waypoint.state=2
  rem walking along wayppoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  entityelement(e).mover.run=0
  tdx#=entityelement(e).mover.dx-entityelement(e).x
  tdz#=entityelement(e).mover.dz-entityelement(e).z
  entityelement(e).mover.da=atanfull(tdx#,tdz#)
  distx#=waypointcoord(w).x-entityelement(e).x
  distz#=waypointcoord(w).z-entityelement(e).z
  dist#=sqrt(abs(distx#*distx#)+abs(distz#*distz#))
  if dist#<7.0*(entityelement(e).eleprof.speed/100.0)
   rem decision on direction
   if entityelement(e).ai.waypoint.direction=1
    rem forward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w>=waypoint(entityelement(e).ai.waypoint.tracker).finish
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   else
    rem backward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w<=waypoint(entityelement(e).ai.waypoint.tracker).start
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   endif
   rem ensure action taken immediately
   entityelement(e).logiccount=0
  endif
 endif
 if entityelement(e).ai.waypoint.state=999
  rem internal state - wait for force to end in main AI
  if entityelement(e).ai.libindex=entityelement(e).ai.libmain
   if entityelement(e).force.active=0 and entityelement(e).ai.waypoint.tracker>0
    rem resume waypoint logic (only if alive and have waypoints)
    if entityelement(e).health>0
     entityelement(e).ai.waypoint.state=1
     entityelement(e).logiccount=0
    endif
   endif
  endif
 endif
endif

return

_entity_controlforce:

rem control force events via inertia values
if entityelement(e).force.active=1
 rem no force if entity immobile
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).force.active=0
 else
  rem degrade inertia values
  forceineffect=0
  if entityelement(e).force.ix<>0.0 then forceineffect=1 : entityelement(e).force.ix=entityelement(e).force.ix/1.1
  if entityelement(e).force.iz<>0.0 then forceineffect=1 : entityelement(e).force.iz=entityelement(e).force.iz/1.1
  rem apply gravity constant only when above ground
  entityelement(e).force.iy=entityelement(e).force.iy-1.0
  rem update entity position with inertia values if in effect
  if forceineffect=1
   rem restrict by active raycast collision
   tmpx1#=entityelement(e).x
   tmpz1#=entityelement(e).z
   tmpheight#=entityelement(e).y+40
   tnorm#=abs(entityelement(e).force.ix)+abs(entityelement(e).force.iz)
   tmpx2#=tmpx1#+entityelement(e).force.ix+((entityelement(e).force.ix/tnorm#)*20.0)
   tmpz2#=tmpz1#+entityelement(e).force.iz+((entityelement(e).force.iz/tnorm#)*20.0)
   entityelement(e).raycastcount=0
   if static raycast(tmpx1#,tmpheight#,tmpz1#,tmpx2#,tmpheight#,tmpz2#)=0
    rem move the element if no collision or collision too far away
    entityelement(e).mover.stepcount=1
    entityelement(e).mover.ix=entityelement(e).force.ix
    entityelement(e).mover.iy=entityelement(e).force.iy
    entityelement(e).mover.iz=entityelement(e).force.iz
    entityelement(e).ai.waypoint.state=999
    entityelement(e).mover.inmotion=1
   endif
   rem so small we can make them zero
   if entityprofile(entid).ischaracter=1
    rem characters regain themselves quicker
    if abs(entityelement(e).force.ix)<2 then entityelement(e).force.ix=0.0
    if abs(entityelement(e).force.iz)<2 then entityelement(e).force.iz=0.0
   else
    rem inanimate objects slide to a stop
    if abs(entityelement(e).force.ix)<0.1 then entityelement(e).force.ix=0.0
    if abs(entityelement(e).force.iz)<0.1 then entityelement(e).force.iz=0.0
   endif
  else
   entityelement(e).force.active=0
  endif
 endif
endif

return

_entity_controlanim:

rem entity with an object
if obj>0
 `
 rem animation and slerp handling
 if entityelement(e).animset>0
  entityelement(e).animdo=entityelement(e).animset-1
  entityelement(e).animtime=4
  entityelement(e).animset=0
  stop object obj : set object interpolation obj,25
  tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart
  set object frame obj,tactualframe
 endif
 if entityelement(e).animdo>=0
  rem handle transition into loop anim
  if entityelement(e).animtime=1
   set object interpolation obj,100
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart : tfstart=tactualframe
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
   rem hack as we know the anims (die anims) (multiplayer)
   if gmultiplayergame=1
    if entityelement(e).animdo=11 then entityelement(e).animonce=1
    if entityelement(e).animdo=14 then entityelement(e).animonce=1
    if entityelement(e).animdo=17 then entityelement(e).animonce=1
    if entityelement(e).animdo=20 then entityelement(e).animonce=1
   endif
   if entityelement(e).animonce=1
    loop object obj,tffinish-0.001,tffinish
    set object frame obj,tfstart
    entityelement(e).animonce=0
    set object speed obj,100
   else
    loop object obj,tfstart,tffinish
    if entityelement(e).animdir=1
     set object speed obj,-125
    else
     set object speed obj,125
    endif
   endif
  endif
  if entityelement(e).animtime>0 then entityelement(e).animtime=entityelement(e).animtime-1
  rem monitor any animation (periodically)
  if timeelapsedrefreshentityanimspeeds=0
   if entityelement(e).animdir=1
    set object speed obj,-110*timeelapsed#
   else
    set object speed obj,110*timeelapsed#
   endif
  endif
 endif
 `
 rem slerp limbs back into place
 if entityelement(e).limbslerp>0
  tlcount=0
  for tl=0 to entityelement(e).limbslerp-1
   if tl>0
    if limb exist(entityelement(e).obj,tl)=1
     tlx#=limb angle x(entityelement(e).obj,tl)/1.1
     tly#=limb angle y(entityelement(e).obj,tl)/1.1
     tlz#=limb angle z(entityelement(e).obj,tl)/1.1
     rotate limb entityelement(e).obj,tl,tlx#,tly#,tlz#
     if tlx#=0 and tly#=0 and tlz#=0 then inc tlcount
    endif
   else
    inc tlcount
   endif
  next tl
  if tlcount>=entityelement(e).limbslerp
   entityelement(e).limbslerp=0
  endif
 endif
 `
endif

return

_entity_controldecals:

rem decal effects from entity element
tindex=entityelement(e).decalindex
if tindex<>0
 if tindex<0
  decalid=abs(tindex)
 else
  decalid=entitydecal(entid,tindex-1)
 endif
 if decalid>0
  rem entityelement(e).decalmode
  rem 0-once face player
  rem 1-once keep angle
  rem 2-loop face player
  rem 3-loop keep angle
  rem 4-once face up
  rem 5-loop face up
  rem 6-character-spot-decal (at end of entity characters gun if available)
  decalorient=0
  decalx=entityelement(e).x : decalz=entityelement(e).z
  if entityelement(e).decalmode>=4 and entityelement(e).decalmode<=5
   decaly=entityelement(e).y+0.5
  else
   decaly=entityelement(e).y
  endif
  if entityelement(e).decalmode=1
   rem used for windows, where glass smash decal must exactly match
   if entityelement(e).obj>0
    decalx=decalx+object collision center x(entityelement(e).obj)
    decaly=decaly+object collision center y(entityelement(e).obj)
    decalz=decalz+object collision center z(entityelement(e).obj)
   endif
  endif
  if entityelement(e).decalmode=1 or entityelement(e).decalmode=3
   decalorient=1 : decalorientx#=entityelement(e).rx : decalorienty#=entityelement(e).ry : decalorientz#=entityelement(e).rz
  endif
  if entityelement(e).decalmode=4 or entityelement(e).decalmode=5
   decalorient=2
  endif
  decalscalemodx=entityelement(e).decalsizex
  decalscalemody=entityelement(e).decalsizey
  if entityelement(e).decalmode=6
   if entityprofile(entid).ischaracter=1
    tobj=entityelement(e).attachmentobj
    if tobj>0
     tobjlimb=entityelement(e).attachmentobjfirespotlimb
     decalx=limb position x(tobj,tobjlimb)
     decaly=limb position y(tobj,tobjlimb)
     decalz=limb position z(tobj,tobjlimb)
` see if close up decal position corrected
`     tdx#=(mex#-decalx)
`     tdy#=(mey#-decaly)
`     tdz#=(mez#-decalz)
`     tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)+abs(tdy#*tdy#))
`     tdx#=(tdx#/tdd#)*30.0
`     tdy#=(tdy#/tdd#)*30.0
`     tdz#=(tdz#/tdd#)*30.0
`     decalx=decalx+tdx#
`     decaly=decaly+tdy#
`     decalz=decalz+tdz#
    endif
   endif
   decalorient=3
  endif
  if entityelement(e).decalmode=0 or entityelement(e).decalmode=1 or entityelement(e).decalmode=4 or entityelement(e).decalmode=6
   rem play decal once
   entityelement(e).decalindex=0
   originatore=e : gosub _decalelement_create
  endif
  if entityelement(e).decalmode=2 or entityelement(e).decalmode=3 or entityelement(e).decalmode=5
   rem loop decal continually recreating it
   entityelement(e).decalloop=entityelement(e).decalloop+1
   if entityelement(e).decalloop>=15
    entityelement(e).decalloop=0
    currentdecald=entityelement(e).decalslotused
    originatore=e : gosub _decalelement_continue
    entityelement(e).decalslotused=currentdecald
   endif
  endif
 endif
endif

return

_entity_controlcollision:

rem no movement if entity immobile
if entityelement(e).mover.moved=1
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).mover.moved=0
 endif
endif

rem entity has moved, collision a consideration
if entityelement(e).mover.moved=1 and entityelement(e).force.active=0
 `
 rem tragectory of entity movement
 tdx#=entityelement(e).mover.dx-entityelement(e).x
 tdy#=entityelement(e).mover.dy-entityelement(e).y
 tdz#=entityelement(e).mover.dz-entityelement(e).z
 tdist#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))+30
 `
 rem ensure projected movement is free of large entity obstacles
 dstbest#=99999.9 : dstbestfound=0
 tblockedtox=entityelement(e).mover.dx
 tblockedtoy=entityelement(e).mover.dy
 tblockedtoz=entityelement(e).mover.dz
 `
 rem if blocked, a quicker check to see if collision disabled on it
 tusethisasweneeddoorstoblock=1
 if tusethisasweneeddoorstoblock=1
  if entityelement(e).blockedby>0
   if entityelement(e).blockedtox=tblockedtox and entityelement(e).blockedtoy=tblockedtoy and entityelement(e).blockedtoz=tblockedtoz
    te=entityelement(e).blockedby
    if entityelement(te).active=0 or entityelement(te).collisionactive=0
     entityelement(e).blockedby=0
    else
     dstbestfound=te
    endif
   else
    entityelement(e).blockedby=0
   endif
  endif
  rem obstacle detection removed for V1 (speed issue)
  if entityelement(e).blockedby=0 and entitysystemdisabled=0
   rem intensive scan for solid entity obstacles
   for te=1 to entityelementlist
    if te<>e
     if entityelement(te).active=1
      if entityelement(te).obj>0 and entityelement(te).collisionactive=1
       tentid=entityelement(te).bankindex
       if entityprofile(tentid).ischaracter=0
        rem ensure only entity with DOOR characteristics are rayscanned
        if entityelement(te).editorfixed<>0
         dst#=intersect object(entityelement(te).obj,entityelement(e).x,entityelement(e).y+40.0,entityelement(e).z,entityelement(e).mover.dx,entityelement(e).mover.dy+40.0,entityelement(e).mover.dz)
         if dst#>0 and dst#<tdist#-30
          if dst#<dstbest# then dstbest#=dst# : dstbestfound=te
         endif
        endif
       endif
      endif
     endif
    endif
   next te
   if dstbestfound>0
    rem if collide with close entity, recalc distance to move so we just touch it
    entityelement(e).blockedby=dstbestfound
    entityelement(e).blockedtox=tblockedtox
    entityelement(e).blockedtoy=tblockedtoy
    entityelement(e).blockedtoz=tblockedtoz
    tdist#=dstbest#-1.0 : dstbestfound=0
   endif
  endif
 endif
 `
 rem go ahead - can move or not move
 if dstbestfound=0
  `
  rem get angle from tragectory
  tda#=atanfull(tdx#,tdz#)
  tstepup#=0.0
  `
  rem strafe adjusts mover angle
  if entityelement(e).mover.strafe<>0
   tda#=tda#+entityelement(e).mover.strafe
   tdistold#=tdist#
   tdist#=50.0
  endif
  `
  rem When need to slide past other things
  if entityelement(e).mover.slidevel<>0
   tda#=tda#+entityelement(e).mover.slidevel
  endif
  `
  rem strafe dist over-shot so character not in wall, reduce back to real dist
  tdist#=tdist#-30.0
  `
  rem speed calc using timestamp
  tspeed#=tdist# : if tspeed#>3.0 then tspeed#=3.0
  `
  rem calculate mover inertias for per-cycle movement
  entityelement(e).mover.ix=newxvalue(0,tda#,tspeed#)
  entityelement(e).mover.iz=newzvalue(0,tda#,tspeed#)
  if entityelement(e).nogravity=1
   entityelement(e).mover.iy=tdy#/(tdist#/tspeed#)
  else
   entityelement(e).mover.iy=0.0
  endif
  if tdist#<1.0
   entityelement(e).mover.stepcount=0
  else
   entityelement(e).mover.stepcount=tdist#/tspeed#
  endif
  entityelement(e).mover.inmotion=1
  `
 else
  `
  rem if blocked, losing target
  entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
  `
 endif
 `
 rem checks over
 entityelement(e).mover.moved=0
 `
endif

return

_entity_move_removeref:
 tx=entityelement(e).x/25 : ttryx=tx
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25 : ttryz=tz
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=0
  endif
 endif
return

_entity_move_avoidentities:
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if ty>=0 and ty<=viscoly
  tnearest=0 : tnearestds#=9999
  for lsx=tx-2 to tx+2
   for lsz=tz-2 to tz+2
    if lsx>=0 and lsz>=0
     if lsx<=viscolx and lsz<=viscolz
      localscan=viscolmap(lsx,ty,lsz)
      if localscan>0
       rem touching entity
       tentid=entityelement(localscan).bankindex
       if entityprofile(tentid).ischaracter=1
        if entityelement(localscan).mover.inmotion=0 or e>localscan
         rem ensure this E does not enter cylinder of locally scanned E
         tldx#=entityelement(e).x-entityelement(localscan).x
         tldz#=entityelement(e).z-entityelement(localscan).z
         tlds#=sqrt(abs(tldx#*tldx#)+abs(tldz#*tldz#))
         if tlds#<36.0
          if tnearestds#>tlds# then tnearestds#=tlds# : tnearest=localscan
         endif
        endif
       endif
      endif
     endif
    endif
   next lsz
  next lsx
  if tnearest>0
   tldx#=entityelement(e).x-entityelement(tnearest).x
   tldz#=entityelement(e).z-entityelement(tnearest).z
   tlan#=atanfull(tldx#,tldz#)
   if (int(e/2.0)*2.0)=int((e/2.0)*2.0)
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel+1
    tlan#=tlan#+3
   else
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel-1
    tlan#=tlan#-3
   endif
   entityelement(e).x=newxvalue(entityelement(tnearest).x,tlan#,36.0)
   entityelement(e).z=newzvalue(entityelement(tnearest).z,tlan#,36.0)
   tavoidedentity=1
  endif
 endif
return

_entity_move_restoreref:
 rem get tile coord
 tputback=0
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if tx>=0 and tx<=viscolx and ty>=0 and ty<=viscoly and tz>=0 and tz<=viscolz
  rem or an obstacle (entity, not player) either above or below
  if viscolmap(tx,ty,tz)>0 then tputback=1
  rem FPSCV105RC2 - added all voids as obstacles in VISCOLMAP (so characters canont run off ledges)
  if viscolmap(tx,ty,tz)=-2
   rem if blocked, instantly lose target
   entityelement(e).losttargetcount=100
   tputback=1
  endif
  tryy = (entityelement(e).y+35)/100 : if tryy<=viscoly and viscolmap(tx,tryy,tz)>0 then tputback=1
  tryy = (entityelement(e).y-35)/100 : if tryy>=0 and viscolmap(tx,tryy,tz)>0 then tputback=1
 else
  tputback=1
 endif
 if tputback=1
  tkillfallingentity=0
  if entityelement(e).y<0
   rem entity left by falling off the universe, restore but remove all health and lives
   tkillfallingentity=1
  else
   rem restore by bouncing tragectory back
   if entityelement(e).mover.grav>1
    entityelement(e).mover.grav=entityelement(e).mover.grav*-1
   endif
  endif
  entityelement(e).x=toldx#
  entityelement(e).y=toldy#
  entityelement(e).z=toldz#
  entityelement(e).mover.stepcount=tstep#
  if tkillfallingentity=1 and entityelement(e).health>0
   entityelement(e).eleprof.lives=1
   entityelement(e).eleprof.strength=1
   tdamage=entityelement(e).health
   entityelement(e).health=1
   tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
   gosub _entity_deducthealth
  endif
 endif
 rem place back in viscolmap
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=e
  endif
 endif
return

_entity_controlmovements:
 `
 rem uses MOVER IX IY IZ and STEPCOUNT to move entity around the scene
 tstep#=entityelement(e).mover.stepcount
 if entityelement(e).eleprof.isimmobile=0
  `
  rem server controlled entities never have motion
  if entityelement(e).servercontrolled=1
   entityelement(e).mover.inmotion=0
  endif
  `
  rem clear viscolmap data if going to move
  if entityelement(e).mover.inmotion=1
   gosub _entity_move_removeref
  endif
  `
  rem control position movement
  toldx#=entityelement(e).x
  toldy#=entityelement(e).y
  toldz#=entityelement(e).z
  if tstep#>0.0
   `
   rem machine-independent inertia
   tbit#=(1.0*timeelapsed#)
   if tstep#>tbit#
    rem standard paced inertia movememt
    tix#=entityelement(e).mover.ix*timeelapsed#
    tiy#=entityelement(e).mover.iy*timeelapsed#
    tiz#=entityelement(e).mover.iz*timeelapsed#
    if entityelement(e).mover.run=1 then tix#=tix#*2.0 : tiy#=tiy#*2.0 : tiz#=tiz#*2.0
    if entityelement(e).eleprof.speed<>100
     tss#=entityelement(e).eleprof.speed/100.0
     tix#=tix#*tss# : tiy#=tiy#*tss# : tiz#=tiz#*tss#
    endif
   else
    rem ensure steps are taken to the last decimal bit
    tbit#=tstep#
    tix#=entityelement(e).mover.ix*tbit#
    tiy#=entityelement(e).mover.iy*tbit#
    tiz#=entityelement(e).mover.iz*tbit#
   endif
   rem movement
   entityelement(e).x=entityelement(e).x+tix#
   entityelement(e).y=entityelement(e).y+tiy#
   entityelement(e).z=entityelement(e).z+tiz#
   entityelement(e).mover.stepcount=tstep#-tbit#
   `
  endif
  `
  rem ensure entity characters do not croud each other
  tavoidedentity=0
  if entityelement(e).mover.inmotion=1
   if entityprofile(entid).ischaracter=1
    gosub _entity_move_avoidentities
   endif
  endif
  if tavoidedentity=0
   if entityelement(e).mover.slidevel<>0
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel/1.1
    if abs(entityelement(e).mover.slidevel)<1.0
     entityelement(e).mover.slidevel=0
    endif
   endif
  endif
  `
  rem simple volume check for free-moving entities
  if entityelement(e).mover.inmotion=1
   tokay=0 : tgravitydefeated=0
   if entityelement(e).nogravity=0
    if entityelement(e).nofloorlogic=0
     rem full gravity and volume handling of entities in motion
     if entitysystemdisabled=0
      rem can be a little heavy on CPU time (any ideas to speed up?)
      entityelement(e).y=entityelement(e).y-entityelement(e).mover.grav
      if static volume(toldx#,toldy#+30,toldz#,entityelement(e).x,entityelement(e).y+30,entityelement(e).z,1.0)=1
       entityelement(e).x=toldx#+get static collision x()
       entityelement(e).y=toldy#+get static collision y()
       entityelement(e).z=toldz#+get static collision z()
       colmaterialtype=-1
       if get static collision floor()=1
        tgravitydefeated=1 : colmaterialtype=get static collision value()-1
       endif
       tokay=1
      endif
     endif
    else
     rem quick no-vertical-no-gravity handling (always floor)
     entityelement(e).y=entityelement(e).y-entityelement(e).mover.grav
     if entityelement(e).y<entityelement(e).nofloorlogic-1
      entityelement(e).y=entityelement(e).nofloorlogic-1
      tgravitydefeated=1 : colmaterialtype=-1
      tokay=1
     endif
     if 0
      rem allow physics to do this - no static geom detection for v1 (speed issue)
      tdx2#=entityelement(e).x-toldx#
      tdz2#=entityelement(e).z-toldz#
      tda2#=atanfull(tdx2#,tdz2#)
      tdforex#=newxvalue(0,tda2#,30.0)
      tdforez#=newzvalue(0,tda2#,30.0)
      if static raycast(toldx#,toldy#+30,toldz#,entityelement(e).x+tdforex#,entityelement(e).y+30,entityelement(e).z+tdforez#)<>0
       entityelement(e).x=toldx#
       entityelement(e).z=toldz#
       tokay=1
      endif
     endif
    endif
   endif
   if tokay=1
    if tstep#>0.0
     if entityelement(e).mover.run=1
      basespeed#=55
     else
      basespeed#=35
     endif
     if entityelement(e).eleprof.speed<>100
      tss#=entityelement(e).eleprof.speed/100.0
      basespeed#=basespeed#*tss#
     endif
     movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
     if plrid>1 then gosub _player_playfootfall
    endif
    if entityelement(e).force.active=1
     if tgravitydefeated=1
      entityelement(e).force.iy=0
     else
      entityelement(e).force.ix=0 : entityelement(e).force.iz=0
     endif
    endif
   endif
   if tgravitydefeated=1
    rem determine if fall hurt character
    if entityelement(e).y<entityelement(e).mover.gravlasty-entityelement(e).eleprof.hurtfall
     rem level substantial different from last stood on ground
     tdamage=1+((abs(entityelement(e).y-entityelement(e).mover.gravlasty)-entityelement(e).eleprof.hurtfall)/5.0)
     tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
     tdamagesource=0 : timpacttype=1
     gosub _entity_deducthealth
    endif
    rem record last ground player stood on
    entityelement(e).mover.gravlasty=entityelement(e).y
    rem restore gravity
    entityelement(e).mover.grav=1
   else
    entityelement(e).mover.grav=entityelement(e).mover.grav+1
   endif
  endif
  `
  rem if not moving (colliding), increment losttarget counter
  if entityelement(e).mover.inmotion=1
   if abs(entityelement(e).x-toldx#)+abs(entityelement(e).z-toldz#)<(1.0*timeelapsed#)
    entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
   else
    entityelement(e).losttargetcount=0
   endif
  endif
  `
  rem restore entity viscolmap data
  if entityelement(e).mover.inmotion=1
   gosub _entity_move_restoreref
  endif
  `
  rem if gravity stops entity, and was in motion, and no-more-moving, deactivate motion
  if entityelement(e).mover.inmotion=1
   if tgravitydefeated=1 and tstep#=0
    rem entity stops moving
    entityelement(e).mover.inmotion=0
    rem stop animation too if logic count far from resolution
    if entityprofile(entid).animmax>=1
     if entityelement(e).animdo>=1 and entityelement(e).animdo<=5
      entityelement(e).animset=1+1
     endif
    endif
   endif
  endif
  `
 endif
 `
 rem control rotation movement
 entityelement(e).ry=curveangle(entityelement(e).mover.da,entityelement(e).ry,2.0/timeelapsed#)
 `
 rem control alpha level movement
 if entityelement(e).ai.destalphafade<>entityelement(e).ai.alphafade
  if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade+(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade>entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  else
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade-(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  endif
  entityelement(e).ai.alphafadeupdate=1
 endif
 `
 rem update animation frame of entity
 if entityelement(e).animframe<>entityelement(e).destanimframe
  tss#=1.0 : if entityelement(e).eleprof.speed<>100 then tss#=entityelement(e).eleprof.speed/100.0
  if entityelement(e).animframe<entityelement(e).destanimframe
   entityelement(e).animframe=entityelement(e).animframe+(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe>entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  else
   entityelement(e).animframe=entityelement(e).animframe-(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe<entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  endif
  entityelement(e).animframeupdate=1
 endif
 `
 rem make sure head rotates and can restore itself (in proportion)
 if entityelement(e).ai.headangle<>entityelement(e).ai.headdestangle
  if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
   entityelement(e).ai.headangle=entityelement(e).ai.headangle+(10*timeelapsed#)
   if entityelement(e).ai.headangle>entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  else
   entityelement(e).ai.headangle=entityelement(e).ai.headangle-(10*timeelapsed#)
   if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  endif
 else
  rem add subtle movements in headangle
  entityelement(e).ai.headangle=curvevalue(entityelement(e).ai.headdestangle-5.0+(rnd(100)/10.0),entityelement(e).ai.headangle,3.0)
 endif
 `
return

_entity_controlattachments:

rem handle entity attachment if cone of sight debug triangle
if gshowentitygameinfostate=1
 tobj=entityelement(e).attachmentobj
 if tobj>0
  if object exist(tobj)=1
   position object tobj,object position x(obj),object position y(obj),object position z(obj)
   rotate object tobj,object angle x(obj),object angle y(obj)+entityelement(e).ai.headangle,object angle z(obj)
   set alpha mapping on tobj,entityelement(e).mover.viewconeused
   if entityelement(e).mover.viewconeused>0
    entityelement(e).mover.viewconeused=entityelement(e).mover.viewconeused-(1.0*timeelapsed#)
    if entityelement(e).mover.viewconeused<0 then entityelement(e).mover.viewconeused=0
   endif
   show object tobj
  endif
 endif
endif

return

_entity_controllighting:

rem handle entity lighintg
gosub _lighting_applyentitycolor

return

_entity_storemainai:
 `
 rem store old behaviour (for internal AI changes such as HURT)
 if entityelement(e).ai.usinginternalai=0
  entityelement(e).ai.oldwaypointstate=entityelement(e).ai.waypoint.state
  entityelement(e).ai.oldalphafade=entityelement(e).ai.alphafade
  entityelement(e).ai.oldstate=entityelement(e).ai.state
  entityelement(e).ai.usinginternalai=1
  entityelement(e).logiccount=0
 endif
 `
return

_entity_setnewai:
 rem store old behaviour
 gosub _entity_storemainai
 rem setting waypoint state to 1 causes animation to retriger on return
 if entityelement(e).health<=0
  entityelement(e).ai.oldwaypointstate=999
 else
  if entityelement(e).ai.waypoint.state>0 and entityelement(e).ai.waypoint.state<99
   entityelement(e).ai.oldwaypointstate=1
  else
   entityelement(e).ai.oldwaypointstate=0
  endif
 endif
 rem trigger entity behaviour (aifile$)
 gosub _ai_findlibindex
 entityelement(e).ai.libindex=libindex
 entityelement(e).ai.waypoint.state=0
 entityelement(e).ai.alphafade=100
 entityelement(e).ai.state=0
 rem some resets to prevent cross-code
 entityelement(e).animframe=entityelement(e).destanimframe
 entityelement(e).animtime=0
 rem ensure it is immediate
 entityelement(e).logiccount=0
return

_entity_hasbulletrayhit:
 `
 rem optimise : only entities with range of the players range (of gun)
 `
 rem bulletray is x1#,y1#,z1#,x2#,y2#,z2#=bulletrayhit,gunrange#
 brayx1#=x1# : brayy1#=y1# : brayz1#=z1#
 brayx2#=x2# : brayy2#=y2# : brayz2#=z2#
 bulletrayhit=0 : bulletrayhitdist#=0.0
 `
 rem go through entities
 tclosestdist#=99999.0
 tcloseste=0 : tlimbifany=-1
 for e=1 to entityelementlist
  gosub _entity_controlrecalcdist
  if dist#<gunrange# and entityelement(e).obj>0
   rem within range of gun
   if entityelement(e).active<>0
    `
    rem if character (animated by GPU, work out general hit (faster paced target)
    dst#=0.0 : entid=entityelement(e).bankindex
    if entityprofile(entid).ischaracter=1
     if gmultiplayergame=0
      tbbase#=-25 : tbheight#=30 : if entityelement(e).crouchprofile=1 then tbheight#=10
     else
      tbbase#=0 : tbheight#=55 : if entityelement(e).crouchprofile=1 then tbheight#=35
     endif
     if (entityelement(e).collisionactive=1 and entityelement(e).invincibleactive=0) or gmultiplayergame=0
      dstx#=object position x(entityelement(e).obj)
      dsty#=object position y(entityelement(e).obj)
      dstz#=object position z(entityelement(e).obj)
      tbx#=brayx1# : tbix#=brayx2#-brayx1#
      tby#=brayy1# : tbiy#=brayy2#-brayy1#
      tbz#=brayz1# : tbiz#=brayz2#-brayz1#
      trange=sqrt(abs(tbix#*tbix#)+abs(tbiz#*tbiz#))
      trange#=trange/10.0
      tbix#=tbix#/trange#
      tbiy#=tbiy#/trange#
      tbiz#=tbiz#/trange#
      for st=1 to trange step 10
       if tbx#>=dstx#-15 and tbx#<=dstx#+15
        if tby#>=dsty#+tbbase# and tby#<=dsty#+tbheight#
         if tbz#>=dstz#-15 and tbz#<=dstz#+15
          ttbix#=tbx#-brayx1#
          ttbiy#=tby#-brayy1#
          ttbiz#=tbz#-brayz1#
          dst#=sqrt(abs(ttbix#*ttbix#)+abs(ttbiy#*ttbiy#)+abs(ttbiz#*ttbiz#))
          st=trange
          exit
         endif
        endif
       endif
       tbx#=tbx#+tbix#
       tby#=tby#+tbiy#
       tbz#=tbz#+tbiz#
      next st
     endif
    else
     dst#=intersect object(entityelement(e).obj,brayx1#,brayy1#,brayz1#,brayx2#,brayy2#,brayz2#)
    endif
    `
    rem if intersect
    if dst#>0
     if dst#<tclosestdist#
      tclosestdist#=dst# : tcloseste=e
      tlimbifany=checklist value b(1)
     endif
    endif
    `
   endif
  endif
 next e
 `
return

_entity_completerayhit:
 `
 if tcloseste>0
  `
  rem work on closest entity hit
  e=tcloseste
  gosub _entity_controlrecalcdist
  dst#=tclosestdist#
  `
  rem work out bullet force
  distx#=brayx2#-brayx1# : disty#=brayy2#-brayy1# : distz#=brayz2#-brayz1#
  fulldst#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  x#=brayx1#+((distx#/fulldst#)*dst#)
  y#=brayy1#+((disty#/fulldst#)*dst#)
  z#=brayz1#+((distz#/fulldst#)*dst#)
  `
  rem work out relative direction to throw entity from entity angle
  tdir=0
  distx#=entityelement(e).x-brayx1# : distz#=entityelement(e).z-brayz1#
  tentitya#=wrapvalue(atanfull(distx#,distz#))-wrapvalue(entityelement(e).ry)
  if tentitya#<0.0 then tentitya#=tentitya#+360.0
  if tentitya#>=360.0 then tentitya#=tentitya#-360.0
  if tentitya#>180-45 and tentitya#<180+45
   tdir=1
  else
   if tentitya#>315 or tentitya#<45
    tdir=2
   else
    if tentitya#>45 and tentitya#<180-45
     tdir=4
    else
     tdir=3
    endif
   endif
  endif
  `
  if tdir>0
   `
   rem Pierce
   if bulletraytype<>2
    `
    rem affect limb if hit
    if tlimbifany>0
     if entityelement(e).obj>0
      if object exist(entityelement(e).obj)=1
       tentid=entityelement(e).bankindex
       if entityprofile(tentid).headlimb=tlimbifany
        if limb exist(entityelement(e).obj,tlimbifany)=1
         if rnd(1)=1 then tr=6 else tr=-6
         entityelement(e).ai.headangle=tr
        endif
       endif
      endif
     endif
    endif
    `
   endif
   `
   rem if entity prone to damage deal damage to entity (based on distance)
   tentid=entityelement(e).bankindex
   tperc#=(gunrange#-dst#)/gunrange#
   if dst#<200 then tperc#=1.0
   tdamage=bulletdamage : dec tdamage,rnd(tdamage/5)
   tdamage=tdamage*tperc#
   tdamagesource=0 : timpacttype=bulletraytype
   tdamagex#=x# : tdamagey#=y# : tdamagez#=z#
   tuseentityowndecaldamage=1
   `
   rem arena game there are no knock-downs (multiplayer)
   if gmultiplayergame=1
    timpacttype=1
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).ischaracter=1
     multiplayerdamagecollected=multiplayerdamagecollected+tdamage
     multiplayerdamagechar=e
    else
     gosub _entity_deducthealth
    endif
   else
    gosub _entity_deducthealth
   endif
   `
   rem report bullet hit entity
   bulletrayhitdist#=dst#
   bulletrayhit=e
   `
  endif
  `
 endif
 `
return

_entity_spherecollision:
 `
 rem go through entities
 spheree=-1
 for e=1 to entityelementlist
  if entityelement(e).active=1
   distx#=entityelement(e).x-spherex#
   disty#=entityelement(e).y-spherey#
   distz#=entityelement(e).z-spherez#
   dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
   obj=entityelement(e).obj
   if obj>0
    if dist#<object size(obj)*2
     idist#=intersect object(obj,spherex#,spherey#,spherez#,spherenx#,sphereny#,spherenz#)
     if idist#>0 and idist#<=dist#
      spheree=e : exit
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_addforcesphere:
 `
 rem optimise : only entities with range of the sphere
 `
 rem go through entities
 for tte=1 to entityelementlist
  rem if entity prone to damage
  ttentid=entityelement(tte).bankindex
  rem work out if in range of force
  distx#=entityelement(tte).x-spherex#
  disty#=entityelement(tte).y-spherey#
  distz#=entityelement(tte).z-spherez#
  dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  tblastradius#=400.0*sphereforce#
  if dist#<tblastradius#
   rem calculate force
   tix#=distx#/dist# : tiy#=disty#/dist# : tiz#=distz#/dist#
   tforce#=(tblastradius#-dist#)/tblastradius#
   rem work out if direct or indirect damage (raycast)
   tdirectdamage=0
   if static raycast(spherex#,spherey#+2.5,spherez#,entityelement(tte).x,entityelement(tte).y+2.5,entityelement(tte).z)=0
    tdirectdamage=1
   endif
   if tdirectdamage=1
    rem add simple force to entity
    if entityelement(tte).eleprof.isimmobile=0
     if entityelement(tte).eleprof.physics=1
      rem apply force using physics
      todeforce#=tforce#*75 : rem a bit stronger force movement!
      todee=tte : tdx#=tix#*todeforce# : tdz#=tiz#*todeforce#
      if disty#>10.0
       tdy#=(tiy#*todeforce#)+(0.25*todeforce#)
      else
       tdy#=tiy#*todeforce#
      endif
      todefalloff#=0.0 : twithpointforce=0
      tpx#=spherex# : tpy#=spherey# : tpz#=spherez#
      gosub _ode_applyforce
     else
      rem apply regular force calc
      entityelement(tte).force.ix=entityelement(tte).force.ix+(tix#*tforce#)
      if abs(disty#)<10.0
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)+(1.5*tforce#)
      else
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)
      endif
      entityelement(tte).force.iz=entityelement(tte).force.iz+(tiz#*tforce#)
      entityelement(tte).force.active=1
     endif
     rem entity rotates to such large blast
     entityelement(tte).mover.da=atanfull(distx#*-1.0,distz#*-1.0)
    endif
   endif
   rem suggest damage to entity if strong enough force
   if tforce#>0.2
    rem indirect damage is a hugely reduced value
    if tdirectdamage=0 then tforce#=tforce#/50.0
    rem actual entity damage
    tdamagex#=entityelement(tte).x : tdamagey#=entityelement(tte).y : tdamagez#=entityelement(tte).z
    tdamage=tforce#*spheredamage
    tdamagesource=0 : timpacttype=3 : tdir=0
    ste=e : sttentid=tentid
    tentid=entityelement(tte).bankindex
    e=tte
    if entityprofile(tentid).ischaracter=1
     rem characters can shrug off some explosion force
     if tdamage<30 then timpacttype=1
     gosub _entity_deducthealth
    else
     gosub _entity_delayeddeducthealth
    endif
    e=ste : tentid=sttentid
   endif
  endif
 next tte
 `
 rem initial blast if player close
 distx#=camera position x()-spherex#
 disty#=camera position y()-spherey#
 distz#=camera position z()-spherez#
 dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
 tblastradius#=400.0*sphereforce#
 if dist#<tblastradius#
  rem damage power
  tpower#=(tblastradius#-dist#)/tblastradius#
  rem work out if direct damage or indirect
  tdirectdamage=0
  sphtx#=spherex#+((distx#/dist#)*20.0)
  sphtz#=spherez#+((distz#/dist#)*20.0)
  if static raycast(sphtx#,spherey#+2.5,sphtz#,camera position x(),camera position y(),camera position z())=0
   tdirectdamage=1
  endif
  if tdirectdamage=1
   rem force applied to player from blast (fly force is cumilative and bleeds into camforce)
   camflyforcex#=camflyforcex#+((distx#/dist#)*(spheredamage*25)*tpower#)
   camflyforcey#=camflyforcey#+((spheredamage*25)*tpower#)
   camflyforcez#=camflyforcez#+((distz#/dist#)*(spheredamage*25)*tpower#)
   camshake#=camshake#+tdamage# : camshakedir=rnd(1)
   if abs(camshake#)>20
    if camshake#>20 then camshake#=20.0
    if camshake#<-20 then camshake#=-20.0
   endif
  endif
  if tpower#>0.2
   rem indirect damage is a hugely reduced value
   if tdirectdamage=0 then tpower#=tpower#/50.0
   rem damage to player (if strong enough force)
   tdamage#=spheredamage*tpower#
   tdamage=tdamage# : if tdamage>0 then gosub _player_takedamage
  endif
 endif
 `
return

_entity_resolveobjective:
 rem e assumed to be active=0, ie tse<>e
 tokay=0 : tleadere=entityelement(e).spawn.leaderid
 if tleadere=0
  rem instant complete - no spawn versions
  tleadere=e
  tokay=1
 else
  if entityelement(tleadere).spawn.upto=0
   tokay=1 : rem complete unless child still alive (active)
   for tse=1+tleadere to tleadere+entityelement(tleadere).spawn.max
    if tse<>e
     tsobj=entityelement(tse).obj
     if tsobj>0
      if object exist(tsobj)=1
       if entityelement(tse).active<>0
        rem entity alive
        tokay=0
       endif
      endif
     endif
    endif
   next tse
  endif
 endif
 if tokay=1
  rem handle objective
  if gamewarmupcount=0
   rem Only if game in ful swing
   mi=entityelement(tleadere).eleprof.isobjective : if mi>0 then playerobjective(mi)=1
  endif
 endif
return

_entity_delayeddeducthealth:
 `
 rem store damage to be dealt when delay runs out
 if entityelement(e).delaydamagecount=0
  entityelement(e).delaydamagecount=10
  entityelement(e).delaydamagesource=tdamagesource
  entityelement(e).delaydamage=tdamage
  entityelement(e).delayimpact=timpacttype
  entityelement(e).delaydamagex#=tdamagex#
  entityelement(e).delaydamagey#=tdamagey#
  entityelement(e).delaydamagez#=tdamagez#
  entityelement(e).delaydir=tdir
 endif
 `
return

_entity_controldelayeddamage:
 `
 rem count down to delayed damage (fuel exploding)
 if entityelement(e).delaydamagecount>0
  entityelement(e).delaydamagecount=entityelement(e).delaydamagecount-1
  if entityelement(e).delaydamagecount=0
   tdamagesource=entityelement(e).delaydamagesource
   tdamage=entityelement(e).delaydamage
   timpacttype=entityelement(e).delayimpact
   tdamagex#=entityelement(e).delaydamagex#
   tdamagey#=entityelement(e).delaydamagey#
   tdamagez#=entityelement(e).delaydamagez#
   tdir=entityelement(e).delaydir
   gosub _entity_deducthealth
  endif
 endif
 `
return

_entity_deducthealth:
 `
 rem takes TDAMAGE,TDIR and TIMPACTTYPE
 tresult=0 : tentid=entityelement(e).bankindex
 `
 rem entity damage makes a material sound
 tsoundtrigger=0 : tsoundmaterial=0
 if entityprofile(tentid).ischaracter=0 and tdamage>1
  tmatindex=entityprofile(tentid).materialindex-1
  `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
  if tmatindex>=0 and tmatindex<=gmaterialmax
   tsoundtrigger=material(tmatindex).impactid
   tsoundmaterial=1+tmatindex
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
  endif
 endif
 `
 rem work out effect on health and lives
 if entityelement(e).eleprof.strength>0
  if entityelement(e).health>0 or gmultiplayergame=1
   rem multiplayer arena deals damage via server, opposed to directly to entity in single player mode
   if gmultiplayergame=1
    rem actual damage sent to server to control
    gosub _multi_dealentityedamage
   else
    rem deduct the health points (non-multiplayer only)
    entityelement(e).health=entityelement(e).health-tdamage
    entityelement(e).shotdamage=entityelement(e).shotdamage+tdamage
    entityelement(e).shotdamagesource=tdamagesource
    rem if hit, and character, give a priority to deal with AI (and duration to last the action)
    if entityprofile(tentid).ischaracter=1
     gosub _entity_stealpriorityandgivetoe
     if entityelement(e).priorityai=1
      entityelement(e).priorityduration=60
      entityelement(e).logiccount=0
     endif
    endif
   endif
   rem work out if dead or alive
   if entityelement(e).health<=0
    rem entity killed
    entityelement(e).health=0
    entityelement(e).shotdamage=0
    entityelement(e).shotdamagesource=0
    entityelement(e).eleprof.lives=entityelement(e).eleprof.lives-1
    rem if entity has more lives
    if entityelement(e).eleprof.lives>0
     rem rejuvinate entity
     entityelement(e).health=entityelement(e).eleprof.strength
     tresult=2
    else
     rem set as killed
     entityelement(e).beenkilled=1
     rem mission objective counter
     gosub _entity_resolveobjective
     rem dead perminantly
     tresult=3
     rem get explodable flag (0-none/1-bang/2-scorch leftover)
     texplodable=entityelement(e).eleprof.explodable
     rem remove entity from physics world
     if entityelement(e).eleprof.physics<>0
      tobj=entityelement(e).obj
      if texplodable<>2 then phyobjremove(tobj)=1
     endif
     rem entity destruction makes a material destroy sound
     if entityprofile(tentid).ischaracter=0
      rem non-character entities made from a material?
      tmatindex=entityprofile(tentid).materialindex-1
      `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
      if tmatindex>=0 and tmatindex<=gmaterialmax
       tsoundtrigger=material(tmatindex).destroyid
       tsoundmaterial=1+tmatindex
       tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
      endif
      rem debris from total destruction (regular physics only objects?)
      debrisshapeindex=entityprofile(tentid).debrisshapeindex
      if entityelement(e).eleprof.physics=1
       rem May shed debris..
       tobj=entityelement(e).obj
       frox#=entityelement(e).x : froy#=entityelement(e).y : froz#=entityelement(e).z
       `froa#=object angle y(tobj)
       frocopyorientfrom=tobj
       if debrisshapeindex>0
        rem place debris to explode in place of real object
        debristextureused=entityelement(e).eleprof.texdid
        debrissizex#=object size x(tobj) : debrissizey#=object size y(tobj) : debrissizez#=object size z(tobj)
        debrisexplodable=texplodable
        gosub _part_createfragment
        rem Forces object invisible (replaced by fragments)
        tobj=entityelement(e).obj
        hide object tobj
       else
        if texplodable=2 and explosionscorch<>0
         rem not quite explode, just scorch (as though internally fried)
         tobj=entityelement(e).obj
         set blend mapping on tobj, 1, explosionscorch, 3, 6
         set object transparency tobj,0
        endif
       endif
       rem May trigger explosion if entity needs one..
       if texplodable=1
        rem the visual part
        gosub _part_triggerexplosion
        rem the force part
        spheredamage=entityelement(e).eleprof.explodedamage
        spherex#=frox# : spherey#=froy# : spherez#=froz#
        sphereforce#=1.0 : gosub _entity_addforcesphere
       endif
      else
       rem obj not hidden, as phyobjectremove used
      endif
      `
     else
      rem entity character grunts in death
      tplrid=entityelement(e).fakeplayerid : tsnd=15
      if playersound(tplrid,tsnd)>0
       playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
      endif
     endif
    endif
    rem killing blows makes character fall!
    timpacttype=2
   else
    rem entity can sometimes shrug off a fall-over-hit
    if timpacttype=3
     rem flak reactions always thrown
     timpacttype=2
    else
     if timpacttype=2
      if entityelement(e).health>entityelement(e).eleprof.strength/2
       timpacttype=1
      else
       if rnd(3)=1 then timpacttype=1
      endif
     endif
    endif
    rem entity hurt
    tresult=1
    if entityprofile(tentid).ischaracter=1
     rem entity character grunts in hurt
     tplrid=entityelement(e).fakeplayerid : tsnd=12+rnd(2)
     if playersound(tplrid,tsnd)>0
      playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,5.0)
     endif
    endif
   endif
  endif
 else
  rem FLAK is always throwing
  if timpacttype=3 then timpacttype=2 : tresult=1
 endif
 `
 rem play and sounds that are due (entity hurt, damage, destroy)
 gosub _ode_triggermaterialsound
 `
 rem play decal only if requested (set in _entity_completerayhit)
 if tuseentityowndecaldamage=1 then tuseentityowndecaldamage=0 : gosub _decal_triggermaterialdebris
 `
 rem if character, result translates as reaction
 if tresult>0
  tentid=entityelement(e).bankindex
  if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).animmax>0
   rem only if not already reacting
   if entityelement(e).ai.libindex=entityelement(e).ai.libmain or entityelement(e).ai.libindex=entityelement(e).ai.libshoot or tresult=3
    if timpacttype=2
     rem Blast
     aifile$="people\throwback.fpi"
     if tdir=1 then aifile$="people\throwback.fpi"
     if tdir=2 then aifile$="people\throwfore.fpi"
     if tdir=3 then aifile$="people\throwleft.fpi"
     if tdir=4 then aifile$="people\throwright.fpi"
     gosub _entity_setnewai
     rem any waypoint activity must stop right away
     entityelement(e).ai.waypoint.state=999
     entityelement(e).mover.moved=0
    endif
   endif
  else
   rem non-character reaction
   if tresult=3
    aifile$=entityelement(e).eleprof.aidestroy$
    gosub _entity_setnewai
   endif
  endif
 endif
 `
return

_entity_findplayerstartposition:

rem Scan present elements for player start markers
playerstartx#=0
playerstartlives=0
playerstartstrength=0
playerstarthasweapon=0
playerstarthasweaponqty=0
playerhurtfall=0
playerspeedratio#=1.0

for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives>0
  rem Player Start Marker
  if playerstartx#=0 or rnd(2)=0
   playerstartx#=entityelement(e).x
   playerstarty#=entityelement(e).y
   playerstartz#=entityelement(e).z
   playerstartry#=entityelement(e).ry
   playerstartlives=entityelement(e).eleprof.lives
   playerstartstrength=entityelement(e).eleprof.strength
   playerstarthasweapon=entityelement(e).eleprof.hasweapon
   playerstarthasweaponqty=entityelement(e).eleprof.quantity
   playerhurtfall=entityelement(e).eleprof.hurtfall
   playerspeedratio#=entityelement(e).eleprof.speed/100.0
  endif
 endif
next e

rem FPSCV104 - make playerspeed reasonable - RC2 - min is now zero
if playerspeedratio#<0.0 then playerspeedratio#=0.0
if playerspeedratio#>2.0 then playerspeedratio#=2.0

rem if checkpoint, override position
if checkpointentity<>-1
 e=checkpointentity
 playerstartx#=entityelement(e).x
 playerstarty#=entityelement(e).y
 playerstartz#=entityelement(e).z
 playerstartry#=entityelement(e).ry
endif

rem Default settings
if playerstartlives=0 then playerstartlives=1
if playerstartstrength=0 then playerstartstrength=100
if playerhurtfall=0 then playerhurtfall=100
if playerspeedratio#=0.0 then playerspeedratio#=1.0

rem If from level 2 onwards, replace player start details with current-save-state
if level>1
 playerstartlives=saveplayerstate.lives
 rem FPSXV10X - actually replaced the MAX health, naughty naughty
 `playerstartstrength=saveplayerstate.health
 weaponammoindex=saveplayerstate.weaponindexholding
 playerstarthasweapon=weaponslot(weaponammoindex).pref
endif

return

_entity_switchtostaticformultiplayer:
 `
 rem usually no physics as most dynamic entities are converted to static here for the construction process
 if gmultiplayergame=1
  for e=1 to entityelementlist
   if entityelement(e).staticflag=0
    entid=entityelement(e).bankindex
    if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0 and entityprofile(entid).ishealth=0
     if entityelement(e).eleprof.isimmobile=1
      rem door or window
      entityelement(e).eleprof.physics=3
     else
      rem something else
      entityelement(e).staticflag=1
      entityelement(e).eleprof.physics=0
     endif
    else
     rem weapon, ammo or character, or health
     entityelement(e).eleprof.physics=0
    endif
   endif
  next e
 endif
 `
return


rem
rem Artificial Intelegence Core
rem

_ai_setkeywords:

rem Set all condition keywords
dim conword$(AICONDLAST)
conword$(AICONDNEVER)="never"
conword$(AICONDALWAYS)="always"
conword$(AICONDSTATE)="state"
conword$(AICONDRANDOM)="random"
conword$(AICONDHEALTH)="health"
conword$(AICONDHEALTHLESS)="healthless"
conword$(AICONDQUANTITY)="quantity"
conword$(AICONDSPEED)="speed"
conword$(AICONDRATEOFFIRE)="rateoffire"
conword$(AICONDPLRHEALTHLESS)="plrhealthless"
conword$(AICONDPLRHEALTHGREATER)="plrhealthgreater"
conword$(AICONDASSOCIATED)="playerassociated"
conword$(AICONDPLRDISTWITHIN)="plrdistwithin"
conword$(AICONDPLRDISTFURTHER)="plrdistfurther"
conword$(AICONDPLRALIVE)="plralive"
conword$(AICONDPLRHIGHER)="plrhigher"
conword$(AICONDPLRELEVWITHIN)="plrelevwithin"
conword$(AICONDPLRELEVFURTHER)="plrelevfurther"
conword$(AICONDANYWITHIN)="anywithin"
conword$(AICONDANYFURTHER)="anyfurther"
conword$(AICONDPLRCANBESEEN)="plrcanbeseen"
conword$(AICONDPLRCANNOTBESEEN)="plrcannotbeseen"
conword$(AICONDPLRHASKEY)="plrhaskey"
conword$(AICONDPLRUSINGACTION)="plrusingaction"
conword$(AICONDSHOTDAMAGE)="shotdamage"
conword$(AICONDIFWEAPON)="ifweapon"
conword$(AICONDCANTAKE)="cantake"
conword$(AICONDACTIVATED)="activated"
conword$(AICONDPLRWITHINZONE)="plrwithinzone"
conword$(AICONDENTITYWITHINZONE)="entitywithinzone"
conword$(AICONDPLRINGUNSIGHT)="plringunsight"
conword$(AICONDNEARACTIVATABLE)="nearactivatable"
conword$(AICONDNEWWEAPONCANBESEEN)="newweaponcanbeseen"
conword$(AICONDNOISEHEARD)="noiseheard"
conword$(AICONDANYWITHINZONE)="anywithinzone"
conword$(AICONDANYKEYWITHINZONE)="anykeywithinzone"
conword$(AICONDRAYCAST)="raycast"
conword$(AICONDRAYCASTUP)="raycastup"
conword$(AICONDRAYCASTBACK)="raycastback"
conword$(AICONDNORAYCASTUP)="noraycastup"
conword$(AICONDFRAMEATEND)="frameatend"
conword$(AICONDFRAMEATSTART)="frameatstart"
conword$(AICONDFRAMEWITHIN)="framewithin"
conword$(AICONDFRAMEBEYOND)="framebeyond"
conword$(AICONDANIMATIONOVER)="animationover"
conword$(AICONDALPHAFADEEQUAL)="alphafadeequal"
conword$(AICONDREACHTARGET)="reachtarget"
conword$(AICONDLOSETARGET)="losetarget"
conword$(AICONDHEADANGLEGREATER)="headanglegreater"
conword$(AICONDHEADANGLELESS)="headangleless"
conword$(AICONDWAYPOINTSTATE)="waypointstate"
conword$(AICONDIFMARKER)="ifmarker"
conword$(AICONDIFPLRTRAIL)="ifplrtrail"
conword$(AICONDHUDSELECTIONMADE)="hudselectionmade"
conword$(AICONDTIMERGREATER)="timergreater"
conword$(AICONDESCAPEKEYPRESSED)="escapekeypressed"
conword$(AICONDSCANCODEKEYPRESSED)="scancodekeypressed"
conword$(AICONDHUDEDITDONE)="hudeditdone"
conword$(AICONDHUDHAVENAME)="hudhavename"

rem Set all action keywords
dim actword$(AIACTLAST)
actword$(AIACTNONE)="none"
actword$(AIACTDESTROY)="destroy"
actword$(AIACTSUSPEND)="suspend"
actword$(AIACTFLOORLOGIC)="floorlogic"
actword$(AIACTNOGRAVITY)="nogravity"
actword$(AIACTRUNFPIDEFAULT)="runfpidefault"
actword$(AIACTRUNFPI)="runfpi"
actword$(AIACTSTATE)="state"
actword$(AIACTINCSTATE)="incstate"
actword$(AIACTMOVEUP)="moveup"
actword$(AIACTMOVEFORE)="movefore"
actword$(AIACTMOVEBACK)="moveback"
actword$(AIACTRUNFORE)="runfore"
actword$(AIACTFREEZE)="freeze"
actword$(AIACTROTATEY)="rotatey"
actword$(AIACTROTATEIY)="rotateiy"
actword$(AIACTNOROTATE)="norotate"
actword$(AIACTROTATETOPLR)="rotatetoplr"
actword$(AIACTRESETHEAD)="resethead"
actword$(AIACTROTATEHEAD)="rotatehead"
actword$(AIACTROTATEHEADRANDOM)="rotateheadrandom"
actword$(AIACTFORCEBACK)="forceback"
actword$(AIACTFORCEFORE)="forcefore"
actword$(AIACTFORCELEFT)="forceleft"
actword$(AIACTFORCERIGHT)="forceright"
actword$(AIACTFORCEBOUNCE)="forcebounce"
actword$(AIACTSPINRATE)="spinrate"
actword$(AIACTFLOATRATE)="floatrate"
actword$(AIACTSETFRAME)="setframe"
actword$(AIACTINCFRAME)="incframe"
actword$(AIACTDECFRAME)="decframe"
actword$(AIACTANIMATE)="animate"
actword$(AIACTADVFRAME)="advframe"
actword$(AIACTPLRASS)="associateplayer"
actword$(AIACTPLRNOASS)="unassociateplayer"
actword$(AIACTPLRMOVEUP)="plrmoveup"
actword$(AIACTPLRMOVEDOWN)="plrmovedown"
actword$(AIACTPLRMOVEEAST)="plrmoveeast"
actword$(AIACTPLRMOVEWEST)="plrmovewest"
actword$(AIACTPLRMOVENORTH)="plrmovenorth"
actword$(AIACTPLRMOVESOUTH)="plrmovesouth"
actword$(AIACTPLRMOVETO)="plrmoveto"
actword$(AIACTPLRMOVEIFUSED)="plrmoveifused"
actword$(AIACTACTIVATEIFUSED)="activateifused"
actword$(AIACTACTIVATEIFUSEDNEAR)="activateifusednear"
actword$(AIACTACTIVATETARGET)="activatetarget"
actword$(AIACTACTIVATEALLINZONE)="activateallinzone"
actword$(AIACTACTIVATE)="activate"
actword$(AIACTPLRADDHEALTH)="plraddhealth"
actword$(AIACTSETTARGET)="settarget"
actword$(AIACTROTATETOTARGET)="rotatetotarget"
actword$(AIACTLOOKATTARGET)="lookattarget"
actword$(AIACTMOVETOTARGET)="movetotarget"
actword$(AIACTCOLLECTTARGET)="collecttarget"
actword$(AIACTSETTARGETNAME)="settargetname"
actword$(AIACTCHOOSESTRAFE)="choosestrafe"
actword$(AIACTSTRAFE)="strafe"
actword$(AIACTPIVOTRANDOM)="pivotrandom"
actword$(AIACTLOOKATPLR)="lookatplr"
actword$(AIACTSOUND)="plrsound"
actword$(AIACT3DSOUND)="sound"
actword$(AIACTLOOPSOUND)="loopsound"
actword$(AIACTSTOPSOUND)="stopsound"
actword$(AIACTALTTEXTURE)="alttexture"
actword$(AIACTSETALPHAFADE)="setalphafade"
actword$(AIACTINCALPHAFADE)="incalphafade"
actword$(AIACTDECALPHAFADE)="decalphafade"
actword$(AIACTRUNDECAL)="rundecal"
actword$(AIACTSHAPEDECAL)="shapedecal"
actword$(AIACTTRIGGERFORCE)="triggerforce"
actword$(AIACTWAYPOINTSTART)="waypointstart"
actword$(AIACTWAYPOINTSTOP)="waypointstop"
actword$(AIACTWAYPOINTREVERSE)="waypointreverse"
actword$(AIACTWAYPOINTNEXT)="waypointnext"
actword$(AIACTWAYPOINTPREV)="waypointprev"
actword$(AIACTWAYPOINTRANDOM)="waypointrandom"
actword$(AIACTDROPMARKER)="dropmarker"
actword$(AIACTNEXTMARKER)="nextmarker"
actword$(AIACTRESETMARKERS)="resetmarkers"
actword$(AIACTFOLLOWPLR)="followplr"
actword$(AIACTPLRTAKE)="playertake"
actword$(AIACTPLRDROP)="playerdrop"
actword$(AIACTSHOOTPLR)="shootplr"
actword$(AIACTUSEWEAPON)="useweapon"
actword$(AIACTRELOADWEAPON)="reloadweapon"
actword$(AIACTCOLOFF)="coloff"
actword$(AIACTCOLON)="colon"
actword$(AIACTSPAWNON)="spawnon"
actword$(AIACTSPAWNOFF)="spawnoff"
actword$(AIACTAMBIENCE)="ambience"
actword$(AIACTAMBIENCERED)="ambiencered"
actword$(AIACTAMBIENCEGREEN)="ambiencegreen"
actword$(AIACTAMBIENCEBLUE)="ambienceblue"
actword$(AIACTFOG)="fog"
actword$(AIACTFOGRED)="fogred"
actword$(AIACTFOGGREEN)="foggreen"
actword$(AIACTFOGBLUE)="fogblue"
actword$(AIACTSKY)="sky"
actword$(AIACTSKYSCROLL)="skyscroll"
actword$(AIACTBACKDROP)="backdrop"
actword$(AIACTMUSIC)="music"
actword$(AIACTMUSICVOLUME)="musicvolume"
actword$(AIACTSOUNDSCALE)="soundscale"
actword$(AIACTVIDEO)="video"
actword$(AIACTLIGHTON)="lighton"
actword$(AIACTLIGHTOFF)="lightoff"
actword$(AIACTLIGHTRED)="lightred"
actword$(AIACTLIGHTGREEN)="lightgreen"
actword$(AIACTLIGHTBLUE)="lightblue"
actword$(AIACTLIGHTRANGE)="lightrange"
actword$(AIACTHUDRESET)="hudreset"
actword$(AIACTHUDX)="hudx"
actword$(AIACTHUDY)="hudy"
actword$(AIACTHUDZ)="hudz"
actword$(AIACTHUDSIZEX)="hudsizex"
actword$(AIACTHUDSIZEY)="hudsizey"
actword$(AIACTHUDSIZEZ)="hudsizez"
actword$(AIACTHUDRED)="hudred"
actword$(AIACTHUDGREEN)="hudgreen"
actword$(AIACTHUDBLUE)="hudblue"
actword$(AIACTHUDIMAGE)="hudimage"
actword$(AIACTHUDIMAGEFINE)="hudimagefine"
actword$(AIACTHUDFONT)="hudfont"
actword$(AIACTHUDSIZE)="hudsize"
actword$(AIACTHUDTEXT)="hudtext"
actword$(AIACTHUDTYPE)="hudtype"
actword$(AIACTHUDHIDE)="hudhide"
actword$(AIACTHUDSHOW)="hudshow"
actword$(AIACTHUDUNSHOW)="hudunshow"
actword$(AIACTHUDNAME)="hudname"
actword$(AIACTHUDANIM)="hudanim"
actword$(AIACTHUDFADEOUT)="hudfadeout"
actword$(AIACTHUDMAKE)="hudmake"
actword$(AIACTNEWGAME)="newgame"
actword$(AIACTLOADGAME)="loadgame"
actword$(AIACTSAVEGAME)="savegame"
actword$(AIACTCONTINUEGAME)="continuegame"
actword$(AIACTQUITGAME)="quitgame"
actword$(AIACTPAUSEGAME)="pausegame"
actword$(AIACTRESUMEGAME)="resumegame"
actword$(AIACTHOSTGAME)="hostgame"
actword$(AIACTJOINGAME)="joingame"
actword$(AIACTREPEATGAME)="repeatgame"
actword$(AIACTTIMERSTART)="timerstart"
actword$(AIACTQUICKLOADGAME)="quickloadgame"
actword$(AIACTQUICKSAVEGAME)="quicksavegame"

return

_ai_reset:

rem Reset counters
actstringmax=0
conindexcount=0
aicondseqcount=0
actindexcount=0
aiactseqcount=0
hudmax=0

return

_ai_stopentsounds:
 `
 rem stop any looping sound
 if entityelement(e).firesoundloop>0 then stop sound entityelement(e).firesoundloop
 entityelement(e).firesoundloop=0
 rem and entity sounds
 if entityelement(e).soundset>0
  if sound exist(entityelement(e).soundset)=1 then stop sound entityelement(e).soundset
 endif
 if entityelement(e).soundset1>0
  if sound exist(entityelement(e).soundset1)=1 then stop sound entityelement(e).soundset1
 endif
 if entityelement(e).soundlooping>0
  if sound exist(entityelement(e).soundlooping)=1 then stop sound entityelement(e).soundlooping
  entityelement(e).soundlooping=0
 endif
 `
return

_ai_control:

if aiindex>0
 `
 rem used to update timestamps if resumegame happens
 tensureentitytimestampsupdated=0
 `
 if gshowdebugtextingamestate=1
  if debugviewtog=1
   if entityelement(e).priorityai<>0 then ink rgb(255,255,255),0
   print upper$(entityelement(e).eleprof.name$)
   if entityelement(e).priorityai<>0 then ink rgb(128,255,128),0
  endif
 endif
 `
 rem Go through all triggers
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  `
  rem Result of condition
  dw as DWORD : dw=0
  airesult=1
  `
  rem Process conditions in 'conindex' (all have to be true)
  aiconttimer as DWORD : aiconttimer=0
  for seq=aicond(conindex).first to aicond(conindex).last
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     `if aiconditionseq(seq).type>10 or aiconttimer<>0
     if aiconditionseq(seq).type>10 or aiconttimer<>0
      if aiconttimer=0 then print " : ";
      if aiconttimer<>0 then print ", ";
      if aiconttimer=0 then aiconttimer=timer()
      print conword$(aiconditionseq(seq).type)+"("+str$(aiconditionseq(seq).valuea)+","+str$(aiconditionseq(seq).valueb)+")";
     endif
    endif
   endif
   select aiconditionseq(seq).type
    case AICONDNEVER: airesult=0 : endcase
    case AICONDALWAYS: airesult=airesult : endcase
    case AICONDSTATE:
     conda=entityelement(e).ai.state
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDRANDOM:
     conda=aiconditionseq(seq).valuea
     if rnd(conda)>0 then airesult=0
    endcase
    case AICONDHEALTH:
     conda=entityelement(e).health
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDHEALTHLESS:
     conda=entityelement(e).health
     condb=aiconditionseq(seq).valuea
     if conda>=condb then airesult=0
    endcase
    case AICONDQUANTITY:
     conda=entityelement(e).eleprof.quantity
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDSPEED:
     conda=entityelement(e).eleprof.speed
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDRATEOFFIRE:
     condb=entityelement(e).eleprof.rateoffire
     if condb<=0
      airesult=0
     else
      if condb>=100
       rem always fire
      else
       if rnd(100-condb)>0 then airesult=0
      endif
     endif
    endcase
    case AICONDPLRHEALTHLESS:
     conda=player(1).health
     condb=aiconditionseq(seq).valuea
     if conda>=condb then airesult=0
    endcase
    case AICONDPLRHEALTHGREATER:
     conda=player(1).health
     condb=aiconditionseq(seq).valuea
     if conda<=condb then airesult=0
    endcase
    case AICONDPLRDISTWITHIN:
     conda#=dist#
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDPLRDISTFURTHER:
     conda#=dist#
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDPLRALIVE:
     conda=player(1).health
     if conda<1 then conda=0
     if conda>1 then conda=1
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDPLRHIGHER:
     conda#=disty#
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDPLRELEVWITHIN:
     tmpy#=(entityelement(e).y+45.0)-mey#
     conda#=abs(atanfull(dist#,tmpy#)-90)
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDPLRELEVFURTHER:
     tmpy#=(entityelement(e).y+45.0)-mey#
     conda#=abs(atanfull(dist#,tmpy#)-90)
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDANYWITHIN:
     tokay=0
     condx=entityelement(e).x/25
     condy=entityelement(e).y/100
     condz=entityelement(e).z/-25
     condb=aiconditionseq(seq).valuea/25
     for taix=(condb*-1) to condb
      for taiz=(condb*-1) to condb
       if condx+taix>=0 and condx+taix<=viscolx
        if condz+taiz>=0 and condz+taiz<=viscolz
         tte=viscolmap(condx+taix,condy,condz+taiz)
         if tte<>0
          if tte>0
           ttentid=entityelement(tte).bankindex
           if entityprofile(ttentid).ischaracter=1
            tokay=1
           endif
          else
           rem FPSCV105RC2 - only player (-1), not void blocks (-2)
           if tte=-1
            tokay=1
           endif
          endif
         endif
        endif
       endif
      next taiz
     next taix
     if tokay=0 then airesult=0
    endcase
    case AICONDANYFURTHER:
     tokay=0
     condx=entityelement(e).x/25
     condy=entityelement(e).y/100
     condz=entityelement(e).z/-25
     condb=aiconditionseq(seq).valuea/25
     for taix=(condb*-1) to condb
      for taiz=(condb*-1) to condb
       if condx+taix>=0 and condx+taix<=viscolx
        if condz+taiz>=0 and condz+taiz<=viscolz
         tte=viscolmap(condx+taix,condy,condz+taiz)
         if tte<>0
          if tte>0
           ttentid=entityelement(tte).bankindex
           if entityprofile(ttentid).ischaracter=1
            tokay=1
           endif
          else
           rem FPSCV105RC2 - only player (-1), not void blocks (-2)
           if tte=-1
            tokay=1
           endif
          endif
         endif
        endif
       endif
      next taiz
     next taix
     if tokay=1 then airesult=0
    endcase
    case AICONDPLRCANBESEEN:
     if player(1).lives=0 or player(1).health=0
      airesult=0
     else
      entityelement(e).mover.viewconeused=10
      tdiffangle#=diffangle#-entityelement(e).ai.headangle
      conda#=abs(tdiffangle#-entityelement(e).mover.da)
      if conda#>180 then conda#=360-conda#
      conda#=abs(conda#)
      condb#=entityelement(e).eleprof.coneangle
      if entityelement(e).eleprof.coneangle=0 then condb#=361
      if conda#>=condb#
       airesult=0
      else
       if obj=0
        airesult=0
       else
        if entityprofile(entid).headlimb<>-1
         tmpx#=limb position x(obj,entityprofile(entid).headlimb)
         tmpy#=limb position y(obj,entityprofile(entid).headlimb)
         tmpz#=limb position z(obj,entityprofile(entid).headlimb)
        else
         tmpx#=object position x(obj)
         tmpy#=object position y(obj)+55.0
         tmpz#=object position z(obj)
        endif
        tvisibility=0 : gosub _player_determinevisibility
        if tvisibility=1
         rem vertical angle of sight
         tconda#=atanfull(dist#,tmpy#-mey#)-90
         tcondb#=aiconditionseq(seq).valuea
         if tcondb#=0 then tcondb#=22
         if tconda#<tcondb#
          inc gameperfentities2
          rem new intermitent raycast
          tokaystate=entityelement(e).raycastlaststate
          if entityelement(e).raycastcount<=0
           entityelement(e).raycastlaststate=static raycast(tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
           entityelement(e).raycastcount=15
          else
           entityelement(e).raycastcount=entityelement(e).raycastcount-1
          endif
          if tokaystate=0
           if tvisibilityifbreak>0
            rem must shoot transparent obstacle to player sighting!
            entityelement(e).possibletarget=1+tvisibilityifbreak
           else
            rem clean shot to player
            entityelement(e).possibletarget=1
           endif
          else
           airesult=0
          endif
         else
          airesult=0
         endif
        else
         airesult=0
        endif
       endif
      endif
     endif
    endcase
    case AICONDPLRCANNOTBESEEN:
     if player(1).lives>0 and player(1).health>0
      entityelement(e).mover.viewconeused=10
      tdiffangle#=diffangle#-entityelement(e).ai.headangle
      conda#=abs(tdiffangle#-entityelement(e).mover.da)
      if conda#>180 then conda#=360-conda#
      conda#=abs(conda#)
      condb#=entityelement(e).eleprof.coneangle
      if conda#<condb#
       if obj=0
        airesult=0
       else
        if entityprofile(entid).headlimb<>-1
         tmpx#=limb position x(obj,entityprofile(entid).headlimb)
         tmpy#=limb position y(obj,entityprofile(entid).headlimb)
         tmpz#=limb position z(obj,entityprofile(entid).headlimb)
        else
         tmpx#=object position x(obj)
         tmpy#=object position y(obj)+55.0
         tmpz#=object position z(obj)
        endif
        tvisibility=0 : gosub _player_determinevisibility
        if tvisibility=1
         tconda#=atanfull(dist#,tmpy#-mey#)-90
         tcondb#=aiconditionseq(seq).valuea
         if tcondb#=0 then tcondb#=22
         if tconda#<tcondb#
          inc gameperfentities2
          rem new intermitent raycast
          tokaystate=entityelement(e).raycastlaststate
          if entityelement(e).raycastcount<=0
           entityelement(e).raycastlaststate=static raycast(tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
           entityelement(e).raycastcount=15
          else
           entityelement(e).raycastcount=entityelement(e).raycastcount-1
          endif
          if tokaystate=0
           airesult=0
          endif
         endif
        endif
       endif
      endif
     endif
    endcase
    case AICONDPLRHASKEY:
     gosub _entity_playerhavekey
     conda=aiconditionseq(seq).valuea
     if tokay<>conda then airesult=0
    endcase
    case AICONDPLRUSINGACTION:
     conda=aiconditionseq(seq).valuea
     condb=player(1).usingaction
     if conda<>condb then airesult=0
    endcase
    `
    case AICONDSHOTDAMAGE:
     conda=aiconditionseq(seq).valuea
     condb=entityelement(e).shotdamage
     if condb>0 and condb>conda
      entityelement(e).possibletarget=1+entityelement(e).shotdamagesource
     else
      airesult=0
     endif
     entityelement(e).shotdamage=0
     entityelement(e).shotdamagesource=0
    endcase
    case AICONDIFWEAPON:
     conda=aiconditionseq(seq).valuea
     if entityelement(e).fireweapon=0
      tokay=0 : tgunid=entityelement(e).currentweapon
      if tgunid>0
       if entityelement(e).currentammo>0 or gun(tgunid).settings.reloadqty=0
        tokay=1
       endif
      endif
      if conda=0 and tokay=1 then airesult=0
      if conda=1 and tokay=0 then airesult=0
     else
      airesult=0
     endif
    endcase
    case AICONDCANTAKE:
     tokay=1
     if entityprofile(entid).ishealth>0
      rem check if NEED it, single player says do not waste
      if gmultiplayergame=0
       if player(1).health>=playerstartstrength
        tokay=0
       endif
      endif
     endif
     if tokay=0 then airesult=0
    endcase
    `
    case AICONDACTIVATED:
     conda=aiconditionseq(seq).valuea
     condb=entityelement(e).activated
     if conda<>condb then airesult=0
    endcase
    case AICONDPLRWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     tokay=0
     if mex#<condx1 then tokay=1
     if mey#<condy1 then tokay=1
     if mez#>condz1 then tokay=1
     if mex#>condx2 then tokay=1
     if mey#>condy2 then tokay=1
     if mez#<condz2 then tokay=1
     conda=aiconditionseq(seq).valuea
     if tokay<>conda
      rem player is within zone
      mi=entityelement(e).eleprof.isobjective : if mi>0 then playerobjective(mi)=1
     else
      airesult=0
     endif
    endcase
    case AICONDENTITYWITHINZONE:
     rem If I push a crate into the trigger zone, then detect for that CRATE
     rem TODO - if find one, set it as the TARGET
    endcase
    case AICONDPLRINGUNSIGHT:
     conda#=abs(diffangle#-entityelement(e).mover.da)
     if conda#>180 then conda#=360-conda#
     conda#=abs(conda#)
     if conda#>=5 then airesult=0
    endcase
    case AICONDNEARACTIVATABLE:
     tokay=0
     for tae=1 to entityelementlist
      if entityelement(tae).active=1
       if entityelement(tae).activated=aiconditionseq(seq).valuea
        cdistx#=entityelement(tae).x-entityelement(e).x
        cdisty#=entityelement(tae).y-entityelement(e).y
        cdistz#=entityelement(tae).z-entityelement(e).z
        cdist#=sqrt(abs(cdistx#*cdistx#)+abs(cdisty#*cdisty#)+abs(cdistz#*cdistz#))
        if cdist#<70.0
         tokay=1 : entityelement(e).possibletarget=1+tae
         tae=entityelementlist+1 : exit
        endif
       endif
      endif
     next tae
     if tokay=0 then airesult=0
    endcase
    `
    case AICONDNEWWEAPONCANBESEEN:
     tentitytype=1 : gosub _entity_conescanforentity
     tplrid=entityelement(e).fakeplayerid
     if tfounde>0 and tplrid>0
      tgunbestdamage=0
      for pi=1 to player(tplrid).inventorymax
       te=playerinventory(tplrid,pi).index
       tentid=entityelement(te).bankindex
       tgunid=entityprofile(tentid).isweapon
       if tgunid>0
        if gun(tgunid).settings.damage>tgunbestdamage then tgunbestdamage=gun(tgunid).settings.damage
       endif
      next pi
      tokay=0
      tent2id=entityelement(tfounde).bankindex
      tgun2id=entityprofile(tent2id).isweapon
      if tgun2id>0
       if gun(tgun2id).settings.damage>tgunbestdamage then tokay=1
      endif
      if tokay=1 then entityelement(e).possibletarget=1+tfounde
      if tokay=0 then airesult=0
     else
      airesult=0
     endif
    endcase
    `
    case AICONDNOISEHEARD:
     if bcsoundstrength#>0
      conda=aiconditionseq(seq).valuea
      cdistx#=bcsoundx#-entityelement(e).x
      cdisty#=bcsoundy#-entityelement(e).y
      cdistz#=bcsoundz#-entityelement(e).z
      cdist#=sqrt(abs(cdistx#*cdistx#)+abs(cdisty#*cdisty#)+abs(cdistz#*cdistz#))
      if cdist#>50.0
       rem not too close (as this would be itself making the noise)
       if bcsoundstrength#*10>cdist#
        rem heard something (-1 is sound coord target)
        entityelement(e).possibletarget=-1
       else
        airesult=0
       endif
      else
       airesult=0
      endif
     else
      airesult=0
     endif
    endcase
    `
    case AICONDANYWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     conda=aiconditionseq(seq).valuea
     condfound=0
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1
       tokay=0
       if entityelement(te).x<condx1 then tokay=1
       if entityelement(te).y<condy1 then tokay=1
       if entityelement(te).z>condz1 then tokay=1
       if entityelement(te).x>condx2 then tokay=1
       if entityelement(te).y>condy2 then tokay=1
       if entityelement(te).z<condz2 then tokay=1
       if tokay=0
        condfound=te : exit
       endif
      endif
     next te
     if conda=1
      if condfound=0
       airesult=0
      endif
     else
      if condfound<>0
       airesult=0
      endif
     endif
    endcase
    case AICONDANYKEYWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     conda=aiconditionseq(seq).valuea
     condfound=0
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1
       tokay=0
       if entityelement(te).x<condx1 then tokay=1
       if entityelement(te).y<condy1 then tokay=1
       if entityelement(te).z>condz1 then tokay=1
       if entityelement(te).x>condx2 then tokay=1
       if entityelement(te).y>condy2 then tokay=1
       if entityelement(te).z<condz2 then tokay=1
       if tokay=0
        if lower$(entityelement(te).eleprof.name$)=lower$(entityelement(e).eleprof.usekey$)
         condfound=te : exit
        endif
       endif
      endif
     next te
     if conda=1
      if condfound=0
       airesult=0
      endif
     else
      if condfound<>0
       airesult=0
      endif
     endif
    endcase
    `
    case AICONDFRAMEATEND:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframefinish : condb#=tactualframe
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEATSTART:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframestart : condb#=tactualframe
       if conda#>condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEWITHIN:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       conda=aiconditionseq(seq).valuea
       condb#=aiconditionseq(seq).valueb/100.0
       tbaseframe=conda : gosub _entity_getactualframefinish : condc#=tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condc#=condc#-tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condb#=tactualframe+(condc#*condb#)
       if conda#>condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEBEYOND:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       conda=aiconditionseq(seq).valuea
       condb#=aiconditionseq(seq).valueb/100.0
       tbaseframe=conda : gosub _entity_getactualframefinish : condc#=tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condc#=condc#-tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condb#=tactualframe+(condc#*condb#)
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    case AICONDANIMATIONOVER:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframefinish : condb#=tactualframe-5.0
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    `
    case AICONDREACHTARGET:
     te=entityelement(e).actualtarget-1
     if te>0
      tdistx#=entityelement(te).x-entityelement(e).x
      tdistz#=entityelement(te).z-entityelement(e).z
     else
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
     endif
     conda#=sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))
     condb#=aiconditionseq(seq).valuea
     if conda#>=5.0 then airesult=0
    endcase
    case AICONDLOSETARGET:
     conda=entityelement(e).losttargetcount
     condb=aiconditionseq(seq).valuea
     if conda<condb then airesult=0
    endcase
    `
    case AICONDHEADANGLEGREATER:
     conda#=entityelement(e).ai.headangle
     condb#=aiconditionseq(seq).valuea
     if conda#<condb# then airesult=0
    endcase
    case AICONDHEADANGLELESS:
     conda#=entityelement(e).ai.headangle
     condb#=aiconditionseq(seq).valuea
     if conda#>condb# then airesult=0
    endcase
    `
    case AICONDRAYCAST:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj)
      tmpy#=object position y(obj)
      tmpz#=object position z(obj)
      tmpx1#=tmpx#
      tmpz1#=tmpz#
      tmpheight#=40
      tnorm#=abs(entityelement(e).force.ix)+abs(entityelement(e).force.iz)
      tvx#=entityelement(e).force.ix/tnorm#
      tvz#=entityelement(e).force.iz/tnorm#
      tvel#=aiconditionseq(seq).valueb
      tmpx2#=tmpx#+(tvx#*tvel#)
      tmpz2#=tmpz#+(tvz#*tvel#)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if tmpy#>-50
       if static raycast(tmpx1#,tmpy#+tmpheight#,tmpz1#,tmpx2#,tmpy#+tmpheight#,tmpz2#)=0 then airesult=0
      endif
     endif
    endcase
    case AICONDRAYCASTUP:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if tmpy#>-50
       if static raycast(tmpx#,tmpy#+aiconditionseq(seq).valuea,tmpz#,tmpx#,tmpy#+aiconditionseq(seq).valueb,tmpz#)=0 then airesult=0
      endif
     endif
    endcase
    case AICONDRAYCASTBACK:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      tmpa#=object angle y(obj) : tmpheight#=50
      conda#=aiconditionseq(seq).valuea*-1
      condb#=aiconditionseq(seq).valueb*-1
      tmpx1#=tmpx#+(sin(tmpa#)*conda#)
      tmpz1#=tmpz#+(cos(tmpa#)*conda#)
      tmpx2#=tmpx#+(sin(tmpa#)*condb#)
      tmpz2#=tmpz#+(cos(tmpa#)*condb#)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy#+tmpheight#,tmpz1#,tmpx2#,tmpy#+tmpheight#,tmpz2#)=0 then airesult=0
     endif
    endcase
    case AICONDNORAYCASTUP:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if static raycast(tmpx#,tmpy#+aiconditionseq(seq).valuea,tmpz#,tmpx#,tmpy#+aiconditionseq(seq).valueb,tmpz#)<>0 then airesult=0
      if tmpy#<-50 then airesult=0
     endif
    endcase
    case AICONDALPHAFADEEQUAL:
     conda#=entityelement(e).ai.alphafade
     condb#=aiconditionseq(seq).valuea
     if conda#<>condb# then airesult=0
    endcase
    case AICONDWAYPOINTSTATE:
     conda=entityelement(e).ai.waypoint.state
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    `
    case AICONDIFMARKER:
     conda=entitybreadcrumbs(e,0).x
     condb=aiconditionseq(seq).valuea
     if condb=0 and conda>0 then airesult=0
     if condb=1 and conda=0 then airesult=0
    endcase
    case AICONDIFPLRTRAIL:
     rem player trail!
     conda=0
     condb=aiconditionseq(seq).valuea
     if condb=0 and conda>0 then airesult=0
     if condb=1 and conda=0 then airesult=0
    endcase
    `
    `
    `
    case AICONDHUDSELECTIONMADE:
     conda=aiconditionseq(seq).valuea
     if conda>0
      if hudselectionmade<>conda then airesult=0 else hudselectionmade=0
     else
      if hudselectionmade=0 then airesult=0 else hudselectionmade=0
     endif
    endcase
    case AICONDTIMERGREATER:
     conda=timer()-hudtimer
     condb=aiconditionseq(seq).valuea
     if conda<condb then airesult=0
    endcase
    case AICONDESCAPEKEYPRESSED:
     conda=aiconditionseq(seq).valuea
     if escapekey()=1 and conda=0 then airesult=0
     if escapekey()=0 and conda=1 then airesult=0
    endcase
    case AICONDSCANCODEKEYPRESSED:
     conda=aiconditionseq(seq).valuea
     condb=scancode()
     if condb<>conda then airesult=0
    endcase
    case AICONDHUDEDITDONE:
     for thudid=1 to hudmax
      if hud(thudid).maintype=8 and hud(thudid).hide=0 and hud(thudid).typemode<20
       airesult=0
      endif
     next thudid
    endcase
    case AICONDHUDHAVENAME:
     conda=aiconditionseq(seq).valuea
     if hudhaveplayername=0 and conda=1 then airesult=0
     if hudhaveplayername=1 and conda=0 then airesult=0
    endcase
    `
    `
    `
   endselect
   `
   rem nw addition, if airesult prematurely zero can leave NOW
   if airesult=0 then seq=aicond(conindex).last
   `
  next seq
  if gshowdebugtextingamestate=1
   if debugviewtog=1
    if aiconttimer<>0 then print " : ";
   endif
  endif
  `
  rem Process action if all true
  if airesult=1
   `
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     if aiconttimer=0 then aiconttimer=timer() : print " : ";
     print strarr$(1);
    endif
   endif
   `
   rem Process all actions in sequence
   actindex=aicond(conindex).action
   for seq=aiaction(actindex).first to aiaction(actindex).last
    if gshowdebugtextingamestate=1
     if debugviewtog=1
      print actword$(aiactionseq(seq).type)+"("+str$(aiactionseq(seq).value)+")"+", ";
     endif
    endif
    select aiactionseq(seq).type
     `
     case AIACTSTATE:
      entityelement(e).ai.state=aiactionseq(seq).value
     endcase
     case AIACTINCSTATE:
      entityelement(e).ai.state=entityelement(e).ai.state+aiactionseq(seq).value
     endcase
     `
     case AIACTDESTROY:
      rem deactivate and hide entity (beenkilled used by spawner)
      entityelement(e).beenkilled=1
      entityelement(e).active=0
      if obj>0
       if entityelement(e).eleprof.physics<>0
        gosub _ode_switchoffe
       else
        set object collision off obj
       endif
       hide object obj
      endif
      rem stop any looping sound
      gosub _ai_stopentsounds
      rem clear entity from col map
      tx=entityelement(e).x/25
      ty=entityelement(e).y/100
      tz=entityelement(e).z/-25
      if tx>=0 and ty>=0 and tz>=0
       if tx<=viscolx and ty<=viscoly and tz<=viscolz
        if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
       endif
      endif
     endcase
     case AIACTSUSPEND:
      rem deactivate entity (like a corpse)
      entityelement(e).active=0
      entityelement(e).beenkilled=1
      entityelement(e).logiccount=0 : entityelement(e).logiccountburst=5
      rem stop any looping sound
      if entityelement(e).firesoundloop>0 then stop sound entityelement(e).firesoundloop
      entityelement(e).firesoundloop=0
      rem clear entity from col map
      tx=entityelement(e).x/25
      ty=entityelement(e).y/100
      tz=entityelement(e).z/-25
      viscolmap(tx,ty,tz)=0
     endcase
     case AIACTFLOORLOGIC:
      entityelement(e).nofloorlogic=1+entityelement(e).y
      entityelement(e).nogravity=1
      if gmultiplayergame=0
       if entityelement(e).eleprof.physics<>0
        rem switch off gravity for this object
        if obj>0 then ode set gravity obj,0
       endif
      endif
     endcase
     case AIACTNOGRAVITY:
      entityelement(e).nogravity=1
      if gmultiplayergame=0
       if entityelement(e).eleprof.physics<>0
        rem switch off gravity for this object
        if obj>0 then ode set gravity obj,0
       endif
      endif
     endcase
     `
     case AIACTRUNFPIDEFAULT:
      rem leave and run new DEFAULT AI script
      trundefaultscriptinternal=1
      if aiactionseq(seq).value=0 then trundefaultscript=1+entityelement(e).ai.libinit
      if aiactionseq(seq).value=1 then trundefaultscript=1+entityelement(e).ai.libmain
      if aiactionseq(seq).value=2 then trundefaultscript=1+entityelement(e).ai.libdestroy
      if aiactionseq(seq).value=3 then trundefaultscript=1+entityelement(e).ai.libshoot
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     case AIACTRUNFPI:
      rem Switch FPI AI Scripts via SPECIFIED FILE
      trundefaultscriptinternal=0
      trundefaultscript=1+aiactionseq(seq).value
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     `
     case AIACTMOVEUP:
      if obj>0
       tmpx#=object position x(obj)
       tmpy#=object position y(obj)
       tmpz#=object position z(obj)
       temp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
       entityelement(e).y=tmpy#+temp#
       gosub _entity_controlrecalcdist
       position object obj,tmpx#,entityelement(e).y,tmpz#
      endif
     endcase
     case AIACTMOVEFORE:
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
      tmp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTRUNFORE:
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
      tmp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=1
     endcase
     case AIACTFREEZE:
      entityelement(e).mover.dx=entityelement(e).x
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.dz=entityelement(e).z
      entityelement(e).ai.headangle=0.0
      entityelement(e).ai.headdestangle=0.0
      entityelement(e).ai.waypoint.state=999
      entityelement(e).mover.moved=0
      entityelement(e).mover.run=0
      entityelement(e).strafemode=0
      entityelement(e).mover.ix=0
      entityelement(e).mover.iz=0
      entityelement(e).mover.strafe=0
      entityelement(e).mover.stepcount=0
      entityelement(e).plrtrailindex=0
     endcase
     `
     case AIACTROTATEY:
      tmp#=aiactionseq(seq).value
      entityelement(e).mover.da=entityelement(e).mover.da+tmp#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
     endcase
     case AIACTROTATETOPLR:
      entityelement(e).ai.headangle=0.0
      entityelement(e).ai.headdestangle=0.0
      entityelement(e).mover.da=wrapvalue(diffangle#)
     endcase
     case AIACTROTATEIY:
      tmp#=aiactionseq(seq).value
      entityelement(e).ry=entityelement(e).ry+tmp#
      entityelement(e).mover.da=entityelement(e).ry
      if obj>0
       yrotate object obj,entityelement(e).ry
      endif
     endcase
     case AIACTNOROTATE:
      entityelement(e).norotate=aiactionseq(seq).value
     endcase
     `
     case AIACTRESETHEAD:
      entityelement(e).ai.headdestangle=0.0
     endcase
     case AIACTROTATEHEAD:
      tmp#=aiactionseq(seq).value
      entityelement(e).ai.headdestangle=tmp#
     endcase
     case AIACTROTATEHEADRANDOM:
      tmp#=(rnd(1)*2)-1
      tmp#=rnd(aiactionseq(seq).value)*tmp#
      entityelement(e).ai.headdestangle=tmp#
     endcase
     `
     case AIACTFORCEBOUNCE:
      if tmpframe=aiactionseq(seq).value=0
       entityelement(e).force.ix=0
       entityelement(e).force.iz=0
      else
       entityelement(e).force.ix=entityelement(e).force.ix*-0.5
       entityelement(e).force.iz=entityelement(e).force.iz*-0.5
      endif
     endcase
     `
     case AIACTSPINRATE:
      entityelement(e).spinrate=aiactionseq(seq).value
      rem to have spin, must disable physics
      if entityelement(e).eleprof.physics<>0
       gosub _ode_switchoffe
       entityelement(e).eleprof.physics=0
      endif
     endcase
     case AIACTFLOATRATE:
      entityelement(e).floatrate=aiactionseq(seq).value
      rem to have float, must disable physics
      if entityelement(e).eleprof.physics<>0
       gosub _ode_switchoffe
       entityelement(e).eleprof.physics=0
      endif
     endcase
     `
     case AIACTSETFRAME:
      tmpframe=aiactionseq(seq).value
      tbaseframe=tmpframe : gosub _entity_getactualframestart : tmpframe#=tactualframe
      entityelement(e).animframe=tmpframe#
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
      entityelement(e).animdo=-1
      if obj>0
       stop object obj
       set object interpolation obj,100
       set object frame obj,tmpframe#
      endif
     endcase
     case AIACTINCFRAME:
      tmpframe=aiactionseq(seq).value
      tbaseframe=tmpframe : gosub _entity_getactualframefinish : tmpframe#=tactualframe
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
     endcase
     case AIACTDECFRAME:
      tmpframe=aiactionseq(seq).value
      tbaseframe=tmpframe : gosub _entity_getactualframestart : tmpframe#=tactualframe
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
     endcase
     case AIACTANIMATE:
      tmpframe1=entityelement(e).animdo
      tmpframe2=aiactionseq(seq).value
      if tmpframe1<>tmpframe2
       entityelement(e).animset=1+aiactionseq(seq).value
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
      endif
     endcase
     case AIACTADVFRAME:
      tmpframe=aiactionseq(seq).value
      tmpframe#=entityelement(e).destanimframe-entityelement(e).animframe
      tmpframe#=(tmpframe#/100.0)*tmpframe
      entityelement(e).animframe=entityelement(e).animframe+tmpframe#
     endcase
     `
     case AIACTSOUND:
      tmpx#=camera position x()
      tmpy#=camera position y()
      tmpz#=camera position z()
      if aiactionseq(seq).value=-1
       playinternal3dsound(entityelement(e).soundset,tmpx#,tmpy#,tmpz#)
      else
       if aiactionseq(seq).value=-2
        playinternal3dsound(entityelement(e).soundset1,tmpx#,tmpy#,tmpz#)
       else
        playinternal3dsound(aiactionseq(seq).value,tmpx#,tmpy#,tmpz#)
       endif
      endif
      broadcast3dsound(tmpx#,tmpy#,tmpz#,100.0)
     endcase
     case AIACT3DSOUND:
      tmpx#=entityelement(e).x
      tmpy#=entityelement(e).y
      tmpz#=entityelement(e).z
      if aiactionseq(seq).value=-1
       playinternal3dsound(entityelement(e).soundset,tmpx#,tmpy#,tmpz#)
      else
       if aiactionseq(seq).value=-2
        playinternal3dsound(entityelement(e).soundset1,tmpx#,tmpy#,tmpz#)
       else
        playinternal3dsound(aiactionseq(seq).value,tmpx#,tmpy#,tmpz#)
       endif
      endif
      broadcast3dsound(tmpx#,tmpy#,tmpz#,100.0)
     endcase
     case AIACTLOOPSOUND:
      tmpx#=entityelement(e).x
      tmpy#=entityelement(e).y
      tmpz#=entityelement(e).z
      if aiactionseq(seq).value=-1
       tsnd=entityelement(e).soundset
      else
       if aiactionseq(seq).value=-2
        tsnd=entityelement(e).soundset1
       else
        tsnd=aiactionseq(seq).value
       endif
      endif
      loopinternal3dsound(tsnd,tmpx#,tmpy#,tmpz#)
      entityelement(e).soundlooping=tsnd
     endcase
     case AIACTSTOPSOUND:
      if aiactionseq(seq).value=0
       if entityelement(e).soundset>0 then stop sound entityelement(e).soundset
      else
       if aiactionseq(seq).value=1
        if entityelement(e).soundset1>0 then stop sound entityelement(e).soundset1
       endif
      endif
      if entityelement(e).soundlooping>0
       if sound exist(entityelement(e).soundlooping)=1
        stop sound entityelement(e).soundlooping
       endif
       entityelement(e).soundlooping=0
      endif
     endcase
     `
     case AIACTALTTEXTURE:
      if obj>0
       if aiactionseq(seq).value=0
        texture object obj,0,entityelement(e).eleprof.texdid
       else
        texture object obj,0,entityelement(e).eleprof.texaltdid
       endif
       if entityelement(e).eleprof.usingeffect>0
        if entityelement(e).eleprof.tex1id<>0 then texture object obj,1,entityelement(e).eleprof.tex1id
        if entityelement(e).eleprof.tex2id<>0 then texture object obj,2,entityelement(e).eleprof.tex2id
        if entityelement(e).eleprof.tex3id<>0 then texture object obj,3,entityelement(e).eleprof.tex3id
        set object effect obj,entityelement(e).eleprof.usingeffect
       endif
      endif
     endcase
     `
     case AIACTSETALPHAFADE:
      entityelement(e).ai.alphafade=aiactionseq(seq).value
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
      if obj>0
       set alpha mapping on obj,entityelement(e).ai.alphafade
      endif
     endcase
     case AIACTINCALPHAFADE:
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
     endcase
     case AIACTDECALPHAFADE:
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
     endcase
     `
     case AIACTRUNDECAL:
      tdecalmode=aiactionseq(seq).value
      if tdecalmode=-1
       entityelement(e).decalindex=0
      else
       entityelement(e).decalindex=1
       entityelement(e).decalmode=tdecalmode
       if entityelement(e).decalmode=6
        if entityelement(e).currentweapon=0
         entityelement(e).decalindex=0
        endif
       endif
      endif
     endcase
     case AIACTSHAPEDECAL:
      if obj>0
       entityelement(e).decalsizex=object size x(obj)
       entityelement(e).decalsizey=object size y(obj)
      endif
     endcase
     `
     case AIACTTRIGGERFORCE:
      taddforcesphere=aiactionseq(seq).value
     endcase
     `
     case AIACTPLRASS:
      gosub _player_resettrail
      meridinglift=1+e
     endcase
     case AIACTPLRNOASS:
      meridinglift=0
     endcase
     `
     case AIACTPLRMOVEUP:
      memovingy#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVEDOWN:
      memovingy#=(aiactionseq(seq).value/100.0)*-1
     endcase
     case AIACTPLRMOVEEAST:
      memovingx#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVEWEST:
      memovingx#=(aiactionseq(seq).value/100.0)*-1
     endcase
     case AIACTPLRMOVENORTH:
      memovingz#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVESOUTH:
      memovingz#=(aiactionseq(seq).value/100.0)*-1
     endcase
     case AIACTPLRMOVETO:
      foundte=aiactionseq(seq).value
      if foundte>0
       tranmex#=entityelement(foundte).x
       tranmey#=entityelement(foundte).y+55.0
       tranmez#=entityelement(foundte).z
       tranmeangley#=entityelement(foundte).ry+180
       gosub _player_resettrail
       meridingtransporter=1
      endif
     endcase
     case AIACTPLRMOVEIFUSED:
      tname$=entityelement(e).eleprof.ifused$
      gosub _entity_findname
      if foundte>0
       tranmex#=entityelement(foundte).x
       tranmey#=entityelement(foundte).y+55.0
       tranmez#=entityelement(foundte).z
       tranmeangley#=entityelement(foundte).ry+180
       gosub _player_resettrail
       meridingtransporter=1
      endif
     endcase
     `
     case AIACTACTIVATEIFUSED:
      tname$=entityelement(e).eleprof.ifused$
      tstate=aiactionseq(seq).value
      gosub _entity_activatename
     endcase
     case AIACTACTIVATEIFUSEDNEAR:
      tname$=entityelement(e).eleprof.ifusednear$
      tstate=aiactionseq(seq).value
      gosub _entity_activatename
     endcase
     case AIACTACTIVATETARGET:
      te=entityelement(e).actualtarget-1
      if te>0
       entityelement(te).activated=aiactionseq(seq).value
       entityelement(te).logiccount=0 : entityelement(te).logiccountburst=5
       entityelement(te).dormant=0
      endif
     endcase
     case AIACTACTIVATE:
      entityelement(e).activated=aiactionseq(seq).value
      entityelement(e).logiccount=0 : entityelement(e).logiccountburst=5
      entityelement(e).dormant=0
     endcase
     case AIACTACTIVATEALLINZONE:
      tactivated=aiactionseq(seq).value
      condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
      condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
      condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
      condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
      condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
      condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
      condy1=condy1/100 : condy1=condy1*100
      condy2=condy2/100 : condy2=condy2*100
      gosub _entity_activateallinzone
     endcase
     `
     case AIACTPLRADDHEALTH:
      if aiactionseq(seq).value<0
       tdamage=abs(aiactionseq(seq).value)
       gosub _player_takedamage
      else
       player(1).health=player(1).health+aiactionseq(seq).value
       if player(1).health>playerstartstrength then player(1).health=playerstartstrength
      endif
     endcase
     `
     case AIACTSETTARGET:
      if entityelement(e).possibletarget<>0
       entityelement(e).actualtarget=entityelement(e).possibletarget
       if entityelement(e).actualtarget>1
        tte=entityelement(e).actualtarget-1
        entityelement(e).actualtargetx=entityelement(tte).x
        entityelement(e).actualtargety=entityelement(tte).y
        entityelement(e).actualtargetz=entityelement(tte).z
        entityelement(e).losttargetcount=0
       else
        if entityelement(e).actualtarget=-1
         entityelement(e).actualtargetx=bcsoundx#
         entityelement(e).actualtargety=bcsoundy#
         entityelement(e).actualtargetz=bcsoundz#
         entityelement(e).losttargetcount=0
        else
         `
         rem target is player
         tdx#=(mex#-entityelement(e).x)
         tdy#=(mey#-entityelement(e).y)
         tdz#=(mez#-entityelement(e).z)
         tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)+abs(tdy#*tdy#))+0.001
         tdxh#=(tdx#/tdd#)*10.0
         tdzh#=(tdz#/tdd#)*10.0
         ttactualtargetx=mex#-tdxh#
         ttactualtargety=mey#-phyeyeheight# : rem too much -meheight#
         ttactualtargetz=mez#-tdzh#
         `
         rem only if actual target position has CHANGED!
         taquirelinetoplr=0
         if int(entityelement(e).actualtargetx/100)<>int(ttactualtargetx/100) or int(entityelement(e).actualtargety/100)<>int(ttactualtargety/100) or int(entityelement(e).actualtargetz/100)<>int(ttactualtargetz/100)
          rem new position of target, so check ground before use it
          entityelement(e).actualtargetx=ttactualtargetx
          entityelement(e).actualtargety=ttactualtargety
          entityelement(e).actualtargetz=ttactualtargetz
          rem can go straight to players position to start trail if plr level(ish)
          traily#=entityelement(e).actualtargety
          if entityelement(e).plrtrailindex<>0
           rem entity already has trail, but might be 'follow the leader' nonesense
           rem if there is good ground between player and entity, give opportunity to skip
           tokay=1
           tstbx#=entityelement(e).x
           tstby#=entityelement(e).y
           tstbz#=entityelement(e).z
           tdxi#=tdx#/tdd# : tdyi#=tdy#/tdd# : tdzi#=tdz#/tdd#
           for tst#=0.0 to tdd# step 90.0
            tstx#=tstbx#+(tdxi#*tst#)
            tsty#=tstby#+(tdyi#*tst#)
            tstz#=tstbz#+(tdzi#*tst#)
            inc gameperfentities3
            entityelement(e).raycastcount=0
            if static raycast(tstx#,tsty#,tstz#,tstx#,tsty#-50,tstz#)=0
             tokay=0
            endif
           next tst#
           if tokay=1 then taquirelinetoplr=2
          endif
          `
         else
          entityelement(e).losttargetcount=0
         endif
         if taquirelinetoplr=2
          if abs(traily#-entityelement(e).y)<10.0
           rem if on same level
           taquirelinetoplr=1
          endif
          if traily#<entityelement(e).y
           rem if player lower than entity
           taquirelinetoplr=1
          endif
         endif
         if taquirelinetoplr=1
          trailx#=mex# : trailz#=mez#
          trailaction=1 : gosub _player_leavetrail
          entityelement(e).plrtrailindex=playertrailmax-1
          if entityelement(e).plrtrailindex<1 then entityelement(e).plrtrailindex=100
         endif
         `
        endif
       endif
       entityelement(e).possibletarget=0
`       interferes with target lock, but character is stuck (like a barrier)
`       entityelement(e).losttargetcount=0
      endif
     endcase
     case AIACTROTATETOTARGET:
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
      tdiffangle#=atanfull(tdistx#,tdistz#)
      if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
      entityelement(e).mover.da=wrapvalue(tdiffangle#)
     endcase
     case AIACTLOOKATTARGET:
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
      tdiffangle#=wrapvalue(atanfull(tdistx#,tdistz#))-wrapvalue(entityelement(e).mover.da)
      if tdiffangle#>180 then tdiffangle#=tdiffangle#-360
      if abs(tdiffangle#)>aiactionseq(seq).value then tdiffangle#=0
      entityelement(e).ai.headdestangle=tdiffangle#
     endcase
     case AIACTMOVETOTARGET:
      tokay=0
      if entityelement(e).actualtarget<>1 then tokay=1
      if entityelement(e).actualtarget=1 and player(1).health>0 then tokay=1
      if tokay=1
       tdistx#=entityelement(e).actualtargetx-entityelement(e).x
       tdistz#=entityelement(e).actualtargetz-entityelement(e).z
       tdiffangle#=atanfull(tdistx#,tdistz#)
       tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))
       if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
       entityelement(e).mover.da=wrapvalue(tdiffangle#)
       tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
       entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
       entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
       entityelement(e).mover.dy=entityelement(e).actualtargety
       entityelement(e).mover.moved=1
       entityelement(e).mover.run=aiactionseq(seq).value
       entityelement(e).mover.strafe=0
      endif
     endcase
     case AIACTCOLLECTTARGET:
      te=entityelement(e).actualtarget-1
      if te>0
       tobj=entityelement(te).obj
       if tobj>0
        if entityelement(te).x<>-99999
         rem Not already collected
         `detach object from static tobj : hide object tobj
         hide object tobj
         entityelement(te).x=-99999
         entityelement(te).y=-99999
         entityelement(te).z=-99999
         tplrid=entityelement(e).fakeplayerid
         if tplrid>0
          pi=player(tplrid).inventorymax : inc pi
          playerinventory(tplrid,pi).new=1
          playerinventory(tplrid,pi).index=te
          player(tplrid).inventorymax=pi
          rem make NPC player responsible for weapon selection (change to entity control)
          tentid=entityelement(te).bankindex : tgunid=entityprofile(tentid).isweapon
          if tgunid>0
           entityelement(e).currentweapon=tgunid
          endif
         endif
         entityelement(e).actualtarget=0
        endif
       endif
      endif
     endcase
     case AIACTCHOOSESTRAFE:
      entityelement(e).strafemode=rnd(2)
     endcase
     case AIACTSTRAFE:
`      if entityelement(e).strafemode=0 then entityelement(e).mover.strafe=0
`      if entityelement(e).strafemode=1 then entityelement(e).mover.strafe=aiactionseq(seq).value
`      if entityelement(e).strafemode=2 then entityelement(e).mover.strafe=aiactionseq(seq).value*-1
      rem replaced with immediate strafe
      tdiffangle#=aiactionseq(seq).value
      entityelement(e).mover.da=entityelement(e).mover.da+tdiffangle#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z : tdist#=15.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.strafe=0
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTPIVOTRANDOM:
      tmp#=aiactionseq(seq).value
      tdiffangle#=rnd(tmp#*2)-tmp#
      entityelement(e).mover.da=entityelement(e).mover.da+tdiffangle#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z : tdist#=5.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.strafe=0
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTLOOKATPLR:
      tdistx#=mex#-entityelement(e).x
      tdistz#=mez#-entityelement(e).z
      tdiffangle#=wrapvalue(atanfull(tdistx#,tdistz#))-wrapvalue(entityelement(e).mover.da)
      if tdiffangle#>180 then tdiffangle#=tdiffangle#-360
      if abs(tdiffangle#)>aiactionseq(seq).value
       if tdiffangle#>=0
        tdiffangle#=aiactionseq(seq).value
       else
        tdiffangle#=aiactionseq(seq).value*-1
       endif
      endif
      entityelement(e).ai.headdestangle=tdiffangle#
     endcase
     case AIACTSETTARGETNAME:
      tstrindex=aiactionseq(seq).value
      tname$=actstring$(tstrindex)
      gosub _entity_findname
      if foundte>0
       entityelement(e).actualtarget=1+foundte
       entityelement(e).possibletarget=0
       if entityelement(e).actualtarget>1
        tte=entityelement(e).actualtarget-1
        entityelement(e).actualtargetx=entityelement(tte).x
        entityelement(e).actualtargety=entityelement(tte).y
        entityelement(e).actualtargetz=entityelement(tte).z
        entityelement(e).losttargetcount=0
       endif
      endif
     endcase
     `
     case AIACTWAYPOINTSTART:
      rem find nearest waypoint
      twdistbest#=99999.9 : twbest=0
      for w=1 to waypointcoordmax
       twdx#=abs(waypointcoord(w).x-entityelement(e).x)
       twdy#=abs(waypointcoord(w).y-entityelement(e).y)
       twdz#=abs(waypointcoord(w).z-entityelement(e).z)
       twdist#=sqrt((twdx#*twdx#)+(twdy#*twdy#)+(twdz#*twdz#))
       if twdist#<1000.0
        inc gameperfentities3
        entityelement(e).raycastcount=0
        if static raycast(entityelement(e).x,entityelement(e).y+35,entityelement(e).z,waypointcoord(w).x,waypointcoord(w).y+35,waypointcoord(w).z)=0
         if twdist#<twdistbest#
          twdistbest#=twdist# : twbest=w
         endif
        endif
       endif
      next w
      if twbest>0
       entityelement(e).ai.waypoint.current=twbest
       entityelement(e).ai.waypoint.tracker=waypointcoord(twbest).index
       entityelement(e).ai.waypoint.direction=1
       entityelement(e).ai.waypoint.state=1
      else
       rem if no start, place state in limbo away from WP activity
       entityelement(e).ai.waypoint.state=99
       rem special animation directive to enter idle mode
       entityelement(e).animset=1+1
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
      endif
      entityelement(e).losttargetcount=0
     endcase
     case AIACTWAYPOINTSTOP:
      entityelement(e).mover.dx=entityelement(e).x
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.dz=entityelement(e).z
      entityelement(e).ai.waypoint.state=99 : rem still waypoint activity
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTWAYPOINTREVERSE:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        entityelement(e).ai.waypoint.direction=2
        w=entityelement(e).ai.waypoint.current
        if w>waypoint(entityelement(e).ai.waypoint.tracker).start
         entityelement(e).ai.waypoint.current=w-1
        endif
       else
        entityelement(e).ai.waypoint.direction=1
        w=entityelement(e).ai.waypoint.current
        if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
         entityelement(e).ai.waypoint.current=w+1
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTNEXT:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        w=entityelement(e).ai.waypoint.current
        if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
         entityelement(e).ai.waypoint.current=w+1
        endif
       else
        w=entityelement(e).ai.waypoint.current
        if w>waypoint(entityelement(e).ai.waypoint.tracker).start
         entityelement(e).ai.waypoint.current=w-1
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTPREV:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        entityelement(e).ai.waypoint.current=entityelement(e).ai.waypoint.current-1
       else
        entityelement(e).ai.waypoint.current=entityelement(e).ai.waypoint.current+1
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTRANDOM:
      if entityelement(e).ai.waypoint.current>0
       r=rnd(1)
       if r=0
        entityelement(e).ai.waypoint.current=linkto
        entityelement(e).ai.waypoint.tracker=waypointcoord(linkto).index
       else
        if entityelement(e).ai.waypoint.direction=1
         w=entityelement(e).ai.waypoint.current
         if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
          entityelement(e).ai.waypoint.current=w+1
         endif
        else
         w=entityelement(e).ai.waypoint.current
         if w>waypoint(entityelement(e).ai.waypoint.tracker).start
          entityelement(e).ai.waypoint.current=w-1
         endif
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     `
     case AIACTDROPMARKER:
      tindex=entitybreadcrumbs(e,0).x
      if tindex<50
       rem find center of tile
       tcx=(int(entityelement(e).x/100)*100)+50
       tcy=(int(entityelement(e).y/100)*100)+10
       tcz=(int(entityelement(e).z/100)*100)-50
       tgeoblock=0
       tmpx1#=tcx
       tmpy1#=tcy+50
       tmpz1#=tcz
       tmpx2#=entitybreadcrumbs(e,tindex).x
       tmpy2#=entitybreadcrumbs(e,tindex).y+50
       tmpz2#=entitybreadcrumbs(e,tindex).z
       inc gameperfentities3
       entityelement(e).raycastcount=0
       if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
        tcx=entityelement(e).x
        tcy=entityelement(e).y
        tcz=entityelement(e).z
       endif
       if entitybreadcrumbs(e,tindex).x=tcx and entitybreadcrumbs(e,tindex).y=tcy and entitybreadcrumbs(e,tindex).z=tcz
        rem same as current crumb
       else
        rem new one
        if tindex<50
         inc tindex
         entitybreadcrumbs(e,0).x=tindex
         entitybreadcrumbs(e,tindex).x=tcx
         entitybreadcrumbs(e,tindex).y=tcy
         entitybreadcrumbs(e,tindex).z=tcz
        endif
       endif
      endif
     endcase
     case AIACTNEXTMARKER:
      tindex=entitybreadcrumbs(e,0).x
      tmpx1#=entityelement(e).x
      tmpy1#=entityelement(e).y+40
      tmpz1#=entityelement(e).z
      tmpx2#=entitybreadcrumbs(e,tindex).x
      tmpy2#=entitybreadcrumbs(e,tindex).y+40
      tmpz2#=entitybreadcrumbs(e,tindex).z
      inc gameperfentities3
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
       rem entity lost or trapped, or clipping geometry
       tmpx2#=(entitybreadcrumbs(e,tindex).x+rnd(150))-75
       tmpz2#=(entitybreadcrumbs(e,tindex).z+rnd(150))-75
       inc gameperfentities3
       entityelement(e).raycastcount=0
       if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)=0
        entitybreadcrumbs(e,tindex).x=tmpx2#
        entitybreadcrumbs(e,tindex).z=tmpz2#
       endif
      endif
      rem keep looking until clear path found
      inc gameperfentities3
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)=0
       if tindex>0
        tdistx#=entitybreadcrumbs(e,tindex).x-entityelement(e).x
        tdistz#=entitybreadcrumbs(e,tindex).z-entityelement(e).z
        if entityelement(e).mover.moved=0
         tdiffangle#=atanfull(tdistx#,tdistz#)
         tdist#=sqrt((tdistx#*tdistx#)+(tdistz#*tdistz#))
         if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
         entityelement(e).mover.da=wrapvalue(tdiffangle#)
         tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
         entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
         entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
         entityelement(e).mover.dy=entitybreadcrumbs(e,tindex).y
         entityelement(e).mover.moved=1
         entityelement(e).mover.run=0
        endif
        if abs(tdistx#+tdistz#)<2.0
         dec tindex : entitybreadcrumbs(e,0).x=tindex
        endif
       endif
      else
       rem no, that path was blocked
       entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
      endif
     endcase
     case AIACTRESETMARKERS:
      entitybreadcrumbs(e,0).x=0
      entityelement(e).mover.moved=0
      entityelement(e).mover.run=0
     endcase
     case AIACTFOLLOWPLR:
      rem LEGACY - DarkAI should improve this failed code significantly
      if entityelement(e).plrtrailindex>0
       if entityelement(e).plrtrailindex<>playertrailmax
        ttrailindex=entityelement(e).plrtrailindex+1
        if ttrailindex>100 then ttrailindex=1
        if playertrial(ttrailindex).time>0
         tdistx#=playertrial(ttrailindex).x-entityelement(e).x
         tdistz#=playertrial(ttrailindex).z-entityelement(e).z
         if sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))<20.0
          entityelement(e).plrtrailindex=entityelement(e).plrtrailindex+1
          if entityelement(e).plrtrailindex>100
           entityelement(e).plrtrailindex=1
          endif
         endif
         if entityelement(e).mover.moved=0
          tdiffangle#=atanfull(tdistx#,tdistz#)
          if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
          entityelement(e).mover.da=wrapvalue(tdiffangle#)
          tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
          entityelement(e).mover.dx=playertrial(ttrailindex).x
          entityelement(e).mover.dy=playertrial(ttrailindex).y
          entityelement(e).mover.dz=playertrial(ttrailindex).z
          entityelement(e).mover.run=aiactionseq(seq).value
          entityelement(e).mover.moved=1
         endif
        else
         entityelement(e).plrtrailindex=0
        endif
       else
        rem reached player, no more following just look at plr
        tdistx#=mex#-entityelement(e).x
        tdistz#=mez#-entityelement(e).z
        tdiffangle#=atanfull(tdistx#,tdistz#)
        if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
        entityelement(e).mover.da=wrapvalue(tdiffangle#)
       endif
      else
       rem if no place in trail, find newest node that was at entities level
       tcount=0 : ttrailindex=playertrailmax-1
       `set cursor 0,0
       while tcount<100
        if playertrial(ttrailindex).time>0
         `print "plry=";playertrial(ttrailindex).y;" enty=";entityelement(e).y;" diff=";abs(playertrial(ttrailindex).y-entityelement(e).y)
         if abs(playertrial(ttrailindex).y-entityelement(e).y)<40.0 then exit
        endif
        dec ttrailindex : if ttrailindex<1 then ttrailindex=100
        inc tcount
       endwhile
       if tcount<100
        rem if point is good to go, go to it
        if playertrial(ttrailindex).time>0
`         dec ttrailindex : if ttrailindex<1 then ttrailindex=100 `why one less? already deducted above
         entityelement(e).plrtrailindex=ttrailindex
        else
         entityelement(e).plrtrailindex=0
        endif
       else
        rem could not find any trail
        entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
       endif
      endif
      `
      rem if debug, show which trail marker by flashing it
      if gshowdebugtextingamestate=1
       if entityelement(e).plrtrailindex>0
        ttrailindex=entityelement(e).plrtrailindex+1
        if ttrailindex>100 then ttrailindex=1
        tdobj=gamdebugobjoffset+ttrailindex
        if object exist(tdobj)=1 then set object emissive tdobj,rgb(rnd(255),rnd(255),rnd(255))
       endif
      endif
      `
     endcase
     `
     case AIACTPLRTAKE:
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1
        mptrigger=1 : mptriggervalue1=e
        gosub _multi_mptrigger
       endif
       `
       rem if child of spawn leader, reset spawn count
       spawne=entityelement(e).spawn.leaderid
       if spawne=0 then spawne=e
       entityelement(spawne).spawn.leadercount=entityelement(spawne).spawn.delay
       `
       rem switch off obj
       if obj>0
        gosub _ode_switchoffe
        hide object obj
        set object collision off obj
       endif
       rem stop any looping sound
       gosub _ai_stopentsounds
       rem reset values
       entityelement(e).beenkilled=1
       entityelement(e).active=0
       rem clear entity from col map
       tx=entityelement(e).x/25
       ty=entityelement(e).y/100
       tz=entityelement(e).z/-25
       if tx>=0 and ty>=0 and tz>=0
        if tx<=viscolx and ty<=viscoly and tz<=viscolz
         if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
        endif
       endif
       `
       rem mission objective counter
       gosub _entity_resolveobjective
       `
       rem only allow weapons
       pi=player(1).inventorymax : inc pi
       if pi<100
        playerinventory(1,pi).new=1
        playerinventory(1,pi).index=e
        player(1).inventorymax=pi
       endif
       `
     endcase
     case AIACTPLRDROP:
      entityelement(e).x=mex# : rem whoever had it
      entityelement(e).y=mey#-40
      entityelement(e).z=mez#
      entityelement(e).active=1
      gosub _entity_controlrecalcdist
      if obj>0
       position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
       set object collision on obj
       show object obj
      endif
      rem in case drop originated outside (not .drop=x)
      for pi=1 to player(1).inventorymax
       if playerinventory(1,pi).index=e then player(1).command.drop=pi : exit
      next pi
     endcase
     `
     case AIACTSHOOTPLR:
      rem replace with shoot sequence
      trundefaultscriptinternal=1
      trundefaultscript=1+entityelement(e).ai.libshoot
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     `
     case AIACTUSEWEAPON:
      rem fire weapon (entity may have)
      tgunid=entityelement(e).currentweapon
      if tgunid>0
       if entityelement(e).currentammo>0 or gun(tgunid).settings.reloadqty=0
        if entityelement(e).currentammo>0
         entityelement(e).currentammo=entityelement(e).currentammo-1
        endif
        entityelement(e).fireweapon=1
        rem FPSCV105RC2 - strength of fire (throw grenade when plr close)
        if aiactionseq(seq).value>0
         entityelement(e).firestrength=aiactionseq(seq).value
        else
         entityelement(e).firestrength=100
        endif
       endif
      else
       rem does enemy make dry-fire sound
      endif
     endcase
     case AIACTRELOADWEAPON:
      tgunid=entityelement(e).currentweapon
      if tgunid>0
       tneedfromclip=gun(tgunid).settings.reloadqty-entityelement(e).currentammo
       if tneedfromclip>0
        entityelement(e).currentammo=gun(tgunid).settings.reloadqty
        entityelement(e).currentclipammo=entityelement(e).currentclipammo-tneedfromclip
       endif
      endif
     endcase
     `
     case AIACTCOLOFF:
      if obj>0
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1 then mptrigger=2 : mptriggervalue1=e : gosub _multi_mptrigger
       `
       entityelement(e).collisionactive=0
       if entityelement(e).eleprof.physics<>0
        gosub _ode_switchoffe
       else
        set object collision off obj
       endif
      endif
     endcase
     case AIACTCOLON:
      if obj>0
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1 then mptrigger=2 : mptriggervalue1=e : gosub _multi_mptrigger
       `
       rem entity collision solid
       entityelement(e).collisionactive=1
       rem activate object collision
       if entityelement(e).eleprof.physics<>0
        gosub _ode_setupewithphysics
        gosub _ode_ensureeisnotpenetrated
       else
        set object collision on obj
       endif
       rem ensure plr is pushed out of entity influence
       tdx#=mex#-entityelement(e).x
       tdz#=mez#-entityelement(e).z
       tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
       if tdd#<30.0
        tda#=atanfull(tdx#,tdz#)
        camforcex#=newxvalue(entityelement(e).x,tda#,30.0)-camerapositionx
        camforcez#=newzvalue(entityelement(e).z,tda#,30.0)-camerapositionz
       endif
       rem ensure ALL entities are pushed out of entity influence (this is why second door zoomed away)
       for te=1 to entityelementlist
        if entityelement(te).active=1 and entityelement(te).eleprof.physics<=2
         if entityelement(te).eleprof.isimmobile=0
          tdx#=entityelement(te).x-entityelement(e).x
          tdz#=entityelement(te).z-entityelement(e).z
          tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
          if tdd#<30.0
           rem TE-entity within solid entity
           tda#=atanfull(tdx#,tdz#)
           entityelement(te).mover.dx=newxvalue(entityelement(e).x,tda#,30.0)
           entityelement(te).mover.dz=newzvalue(entityelement(e).z,tda#,30.0)
           entityelement(te).mover.dy=entityelement(e).y
           entityelement(te).mover.moved=1
           entityelement(te).mover.run=0
          endif
         endif
        endif
       next te
      endif
     endcase
     case AIACTSPAWNON:
      entityelement(e).spawn.atstart=1
     endcase
     case AIACTSPAWNOFF:
      entityelement(e).spawn.atstart=0
     endcase
     `
     case AIACTAMBIENCE:
      guivisualsettings.ambience=aiactionseq(seq).value
      forceambientlightsetting=10
      gosub _lighting_postdefaults
     endcase
     case AIACTAMBIENCERED:
      hudambiencered=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTAMBIENCEGREEN:
      hudambiencegreen=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTAMBIENCEBLUE:
      hudambienceblue=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTFOG:
      if aiactionseq(seq).value>0
       fog on
       rem FPSCV104 added global vars for fog
       hudfogon=1
       if aiactionseq(seq).value>1
        hudfognear=aiactionseq(seq).value
        if aiactionseq(seq).value>1000
         hudfogfar=4000.0
        else
         hudfogfar=1000.0
        endif
       else
        hudfognear=0
        hudfogfar=1000.0
       endif
       fog distance hudfognear,hudfogfar
       fog color hudfogred,hudfoggreen,hudfogblue
      else
       fog off
       hudfogon=0
      endif
     endcase
     case AIACTFOGRED:
      hudfogred=aiactionseq(seq).value
      fog color hudfogred,hudfoggreen,hudfogblue
     endcase
     case AIACTFOGGREEN:
      hudfoggreen=aiactionseq(seq).value
      fog color hudfogred,hudfoggreen,hudfogblue
     endcase
     case AIACTFOGBLUE:
      hudfogblue=aiactionseq(seq).value
      fog color hudfogred,hudfoggreen,hudfogblue
     endcase
     case AIACTSKY:
      rem Already done during loading of AI-Asset
     endcase
     case AIACTSKYSCROLL:
      rem Already done during loading of AI-Asset
     endcase
     `
     `
     `
     case AIACTBACKDROP:
      if aiactionseq(seq).value>0
       set sprite 65534,0,0
       sprite 65534,-10000,-10000,aiactionseq(seq).value
       size sprite 65534,screen width(),screen height()
       paste sprite 65534,0,0
      endif
     endcase
     case AIACTMUSIC:
      if lastmusicplayed>0
       if sound exist(lastmusicplayed)=1 then stop sound lastmusicplayed
       lastmusicplayed=0
      endif
      if aiactionseq(seq).value>0
       hudmusicvolume=100
       loop sound aiactionseq(seq).value
       set sound volume aiactionseq(seq).value,80+(hudmusicvolume/5)
       lastmusicplayed=aiactionseq(seq).value
      endif
     endcase
     case AIACTMUSICVOLUME:
      hudmusicvolume=aiactionseq(seq).value
      if lastmusicplayed>0
       if sound exist(lastmusicplayed)=1
        set sound volume lastmusicplayed,80+(hudmusicvolume/5)
       endif
      endif
     endcase
     case AIACTSOUNDSCALE:
      tmp#=aiactionseq(seq).value
      tmp#=tmp#/100.0 : scale listener tmp#
     endcase
     `
     case AIACTVIDEO:
      videofilename$=""
      if aiactionseq(seq).value=-1
       videofilename$=entityelement(e).eleprof.soundset$
      else
       if aiactionseq(seq).value=-2
        videofilename$=entityelement(e).eleprof.soundset1$
       else
        tstringindex=aiactionseq(seq).value
        if tstringindex>0
         videofilename$=actstring$(tstringindex)
        endif
       endif
      endif
      if videofilename$<>""
       if file exist(videofilename$)=1
        lastvideoplayed=1
        load animation videofilename$,lastvideoplayed
        play animation lastvideoplayed,0,0,screen width(),screen height()
        while animation playing(lastvideoplayed)=1
         if escapekey()=1 then exit
         if spacekey()=1 then exit
         if mouseclick()<>0 then exit
         sync
        endwhile
        while escapekey()=1 or spacekey()=1 or mouseclick()<>0 : sync : endwhile
        delete animation lastvideoplayed
        lastvideoplayed=0
        tensureentitytimestampsupdated=1
       endif
      endif
     endcase
     `
     case AIACTLIGHTON:
      entityelement(e).eleprof.light.islit=1
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).islit=1
      endif
     endcase
     case AIACTLIGHTOFF:
      entityelement(e).eleprof.light.islit=0
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).islit=0
      endif
     endcase
     case AIACTLIGHTRED:
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(aiactionseq(seq).value,rgbg(dw),rgbb(dw))
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).colrgb.r=aiactionseq(seq).value
      endif
     endcase
     case AIACTLIGHTGREEN:
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(rgbr(dw),aiactionseq(seq).value,rgbb(dw))
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).colrgb.g=aiactionseq(seq).value
      endif
     endcase
     case AIACTLIGHTBLUE:
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(rgbr(dw),rgbg(dw),aiactionseq(seq).value)
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).colrgb.b=aiactionseq(seq).value
      endif
     endcase
     case AIACTLIGHTRANGE:
      entityelement(e).eleprof.light.range=aiactionseq(seq).value
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).range=aiactionseq(seq).value
      endif
     endcase
     `
     case AIACTHUDRESET:
      workhudx=0 : workhudy=0 : workhudz=0
      workhudsizex=0 : workhudsizey=0 : workhudsizez=0
      workhudred=255 : workhudgreen=255 : workhudblue=255 : workhudimage=0
      workhudfont$="" : workhudsize=0 : workhudtext$=""
      workhudtype=0 : workhudmake$=""
      workhudname$=""
      workhudhide=0
     endcase
     case AIACTHUDX:
      workhudx=(gdisplaywidth/100.0)*aiactionseq(seq).value
     endcase
     case AIACTHUDY:
      workhudy=(gdisplayheight/100.0)*aiactionseq(seq).value
     endcase
     case AIACTHUDZ:
      workhudz=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEX:
      workhudsizex=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEY:
      workhudsizey=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEZ:
      workhudsizez=aiactionseq(seq).value
     endcase
     case AIACTHUDRED:
      workhudred=aiactionseq(seq).value
     endcase
     case AIACTHUDGREEN:
      workhudgreen=aiactionseq(seq).value
     endcase
     case AIACTHUDBLUE:
      workhudblue=aiactionseq(seq).value
     endcase
     case AIACTHUDIMAGE:
      workhudimage=aiactionseq(seq).value
     endcase
     case AIACTHUDIMAGEFINE:
      workhudimage=aiactionseq(seq).value
     endcase
     case AIACTHUDFONT:
      tindex=aiactionseq(seq).value
      workhudfont$=actstring$(tindex)
     endcase
     case AIACTHUDSIZE:
      workhudsize=aiactionseq(seq).value
     endcase
     case AIACTHUDTEXT:
      tindex=aiactionseq(seq).value
      workhudtext$=actstring$(tindex)
     endcase
     case AIACTHUDTYPE:
      workhudtype=aiactionseq(seq).value
     endcase
     case AIACTHUDHIDE:
      workhudhide=aiactionseq(seq).value
     endcase
     case AIACTHUDSHOW:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).hide=0
        if hud(thudid).maintype=8
         if hud(thudid).typemode>=20
          hud(thudid).typemode=hud(thudid).typemode-20
         endif
         clear entry buffer
         set text size 30
        endif
       endif
      next thudid
     endcase
     case AIACTHUDUNSHOW:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).hide=1
       endif
      next thudid
     endcase
     case AIACTHUDNAME:
      tindex=aiactionseq(seq).value
      workhudname$=actstring$(tindex)
     endcase
     case AIACTHUDANIM:
      workhudimage=aiactionseq(seq).value
     endcase
     case AIACTHUDFADEOUT:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).fadeout=150
       endif
      next thudid
     endcase
     case AIACTHUDMAKE:
      tindex=aiactionseq(seq).value
      workhudmake$=actstring$(tindex)
      gosub _ai_hud_add
     endcase
     `
     case AIACTNEWGAME:
      rem Continue Only
      continueokay=1
     endcase
     case AIACTLOADGAME:
      rem Continue And Load
      saveload.loadswitch=1
      saveloadfile$=""
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      gosub _saveload_maindialogloop
      if saveloadfile$<>""
       rem Load level from scratch (using loadsavedlevel$)
       loadsavedlevel$=saveloadfile$ : saveloadfile$=""
       continueokay=1 : levelwon=3
      endif
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      hudselectionmade=0
     endcase
     case AIACTSAVEGAME:
      rem Continue And Save
      saveload.loadswitch=0
      saveloadfile$=""
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      gosub _saveload_maindialogloop
      if saveloadfile$<>""
       rem Save the current game position using 'saveloadfile$'
       gosub _saveload_savegame
       saveloadfile$=""
      endif
      while mouseclick()<>0 : endwhile
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      hudselectionmade=0
     endcase
     case AIACTQUICKLOADGAME:
      rem Quick Load no prompt
      if gtestgamemodefromeditor=0
       saveloadfile$="gamesaves\slot"+str$(1)+".dat"
       if file exist(saveloadfile$)=1
        saveload.loadswitch=1
        loadsavedlevel$=saveloadfile$
        continueokay=1 : levelwon=3
        hudselectionmade=0
       endif
       saveloadfile$=""
      endif
     endcase
     case AIACTQUICKSAVEGAME:
      rem Quick Save no prompt
      if gtestgamemodefromeditor=0
       gosub _saveload_savebox_earlygrab
       gosub _saveload_savebox_initlist
       saveload.loadswitch=0
       saveload.slotselected=1
       gosub _saveload_savebox_dosave
       gosub _saveload_savegame
       hudselectionmade=0
       saveloadfile$=""
      endif
     endcase
     case AIACTCONTINUEGAME:
      rem Continue And Leave Level
      continueokay=1 : levelwon=2
     endcase
     case AIACTQUITGAME:
      rem Continue And Quit Out
      continueokay=1 : loopapp=0 : levelwon=2
     endcase
     case AIACTPAUSEGAME:
      rem User pressed ESCAPE, and is now in pause mode
      gosub _saveload_savebox_earlygrab
      position mouse screen width()/2,(screen height()/4)*3
      hudselectionmade=0 : ttemp=mouseclick()
      showgamemenu=1
     endcase
     case AIACTRESUMEGAME:
      showgamemenu=0
      while mouseclick()<>0 : endwhile
      cleardelta=mousemovex() : cleardelta=mousemovey()
      tensureentitytimestampsupdated=1
     endcase
     case AIACTHOSTGAME:
      createorjoin=1
      gmultiplayergame=1
     endcase
     case AIACTJOINGAME:
      createorjoin=2
      gmultiplayergame=1
     endcase
     case AIACTREPEATGAME:
      rem flag a repeat of the game (without reloading then remove comments)
      repeatsamelevel=1
     endcase
     case AIACTTIMERSTART:
      hudtimer=timer()
     endcase
     `
     `
     `
    endselect
    `
   next seq
   `
  else
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     if aiconttimer<>0
      print strarr$(2);
     endif
    endif
   endif
  endif
  `
  if gshowdebugtextingamestate=1
   if debugviewtog=1
    if aiconttimer<>0
     print "."
    endif
   endif
  endif
  `
 rem next trigger
 next conindex
 `
 if tensureentitytimestampsupdated=1
  tensureentitytimestampsupdated=0
  for ttse=1 to entityelementlist
   if entityelement(ttse).active=1
    entityelement(ttse).logictimestamp=timer()
   endif
  next ttse
  timestamp=timer()
 endif
 `
endif

return

_ai_load:

rem FPSCV10X : Ensure AILIST is large enough
if aiindex>=array count(ailist(0))
 dim ailist(aiindex+32) as ailiblisttype
endif

rem If not loaded, load it
if ailist(aiindex).loaded=0

rem Load AI Script
gosub _ai_loaddata

rem Only if AI data exists
desc$=ailist(aiindex).desc$
if desc$<>""
 `
 rem Go through actions to look for required resources
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  actindex=aicond(conindex).action
  for seq=aiaction(actindex).first to aiaction(actindex).last
   select aiactionseq(seq).type
    case AIACTRUNFPI:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      aifile$=tfile$ : gosub _ai_findlibindex
      aiactionseq(seq).value=libindex
     endif
    endcase
    case AIACTSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if file exist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACT3DSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if file exist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTLOOPSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if file exist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTMUSIC:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if file exist(tfile$)=1
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
       if aiactionseq(seq).value=0
        tfile$="languagebank\"+language$+"\"+tfile$
        addfiletocollection(tfile$)
        aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
       endif
      endif
     endif
    endcase
    case AIACTVIDEO:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$="$0"
      aiactionseq(seq).value=-1
     else
      if tfile$="$1"
       aiactionseq(seq).value=-2
      else
       if file exist(tfile$)=1
        inc actstringmax : dim actstring$(actstringmax)
        actstring$(actstringmax)=tfile$
        addfiletocollection(tfile$)
        aiactionseq(seq).value=actstringmax
       endif
      endif
     endif
    endcase
    `
    case AIACTSKY:
     sky$=aiactionseq(seq).filename
     if sky$<>""
      rem Load in sky
      if guseskystate=1
       tskyname$=right$(sky$,3)
       tsky$=sky$+"\"+tskyname$+".x"
       if file exist(tsky$)=1
        if object exist(65123)=0
         debugviewtext(-1,strarr$(3))
         load object tsky$,65123
         addfiletocollection(tsky$)
         for tfor=0 to 1
          if tfor=0 then text$="dds"
          if tfor=1 then text$="tga"
          tsky$=sky$+"\"+tskyname$+"_U."+text$
          if file exist(tsky$)=1
           addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_D."+text$ : addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_L."+text$ : addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_R."+text$ : addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_B."+text$ : addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_F."+text$ : addfiletocollection(tsky$)
           tfor=2
          endif
         next tfor
         set object collision off 65123
         sk#=(100*(realrange#-4000))/5.0
         scale object 65123,sk#,sk#,sk#
         set object texture 65123,2,0
         set object light 65123,0
         set object cull 65123,0
         set object fog 65123,0
        endif
       endif
      endif
     endif
    endcase
    case AIACTSKYSCROLL:
     skyscroll$=aiactionseq(seq).filename
     if skyscroll$<>""
      rem Load in sky scroll texture
      if guseskystate=1
       if file exist(skyscroll$)=1
        addfiletocollection(skyscroll$)
        if object exist(65124)=0
         debugviewtext(-1,strarr$(4))
         make object plain 65124,9000,9000
         tskyscrollimg=loadinternalimagecompressquality(skyscroll$,5,1)
         texture object 65124,0,tskyscrollimg
         set object texture 65124,2,0
         rem hack - change to new command when DGSDK done!
`         set blend mapping on 65124,loadinternalimage("skybank\generic\skyportal.tga"),4,0
`         set blend mapping on 65124,loadinternalimage("skybank\generic\skyportal.tga"),10
         position object 65124,0,1000,0
         set object transparency 65124,1
         set object collision off 65124
         xrotate object 65124,270
         set object light 65124,0
         set object cull 65124,0
         set object fog 65124,0
         `
         rem now create a second UV data layer for static second texture (alphaportal)
         q#=1.0
         lock vertexdata for limb 65124,0
         set vertexdata uv 0,1,0,0
         set vertexdata uv 0,1,q#,0
         set vertexdata uv 1,1,0,0
         set vertexdata uv 2,1,q#,q#
         set vertexdata uv 3,1,0,0
         set vertexdata uv 4,1,0,q#
         set vertexdata uv 5,1,q#,q#
         unlock vertexdata
         `
        endif
       endif
      endif
     endif
    endcase
    case AIACTBACKDROP:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalimagequality(tfile$)
      if aiactionseq(seq).value=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
    endcase
    case AIACTHUDIMAGE:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      if aiactionseq(seq).value=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
    endcase
    case AIACTHUDIMAGEFINE:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,0,1)
      if aiactionseq(seq).value=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
    endcase
    case AIACTHUDTEXT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDFONT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDSHOW:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDUNSHOW:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDNAME:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDANIM:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      for tnum=0 to 10
       ttfile$=tfile$+str$(tnum)+".tga"
       addfiletocollection(ttfile$)
       tnumimg=loadinternalimagecompressquality(ttfile$,5,1)
       if tnum=0 then aiactionseq(seq).value=tnumimg
      next tnum
     endif
    endcase
    case AIACTHUDFADEOUT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDMAKE:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTSETTARGETNAME:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
   endselect
  next seq
  `
 next conindex
 `
rem no AI script exists endif
endif

rem AI has been delt with and loaded
ailist(aiindex).loaded=1

rem If not loaded, load above
endif

return

_ai_createentityreferences:

rem go through all AI, and link entitynames to entityelementsubscripts
for aiindex=1 to aiindexmaster
 desc$=ailist(aiindex).desc$
 if desc$<>""
  for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
   actindex=aicond(conindex).action
   for seq=aiaction(actindex).first to aiaction(actindex).last
    select aiactionseq(seq).type
     case AIACTPLRMOVETO:
      tname$=aiactionseq(seq).filename : gosub _entity_findname
      aiactionseq(seq).value=foundte
     endcase
    endselect
   next seq
  next conindex
 endif
next aiindex

return


_ai_free:

rem Only if AI data exists
desc$=ailist(aiindex).desc$
if desc$<>""
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  actindex=aicond(conindex).action
  for seq=aiaction(actindex).first to aiaction(actindex).last
   select aiactionseq(seq).type
    case AIACTSOUND:
     if aiactionseq(seq).value>0
      stop sound aiactionseq(seq).value
     endif
    endcase
    case AIACTMUSIC:
     if aiactionseq(seq).value>0
      stop sound aiactionseq(seq).value
     endif
    endcase
   endselect
  next seq
 next conindex
endif

rem Free AI resource flag
ailist(aiindex).loaded=0

return

_ai_dividetriggerblock:

rem go through and get item from stringblock$
word$="" : value$=""
for c=1 to len(stringblock$)
 if mid$(stringblock$,c)="," or c=len(stringblock$)
  rem get one item in block
  if c=len(stringblock$)
   chunk$=stringblock$
  else
   chunk$=left$(stringblock$,c-1)
  endif
  stringblock$=right$(stringblock$,len(stringblock$)-(len(chunk$)+1))
  if len(chunk$)>0
   rem find equate seperator (or all otherwise)
   sep=0
   for c2=1 to len(chunk$)
    if mid$(chunk$,c2)="=" then sep=c2 : exit
    if c2=len(chunk$) then sep=c2+1 : exit
   next c2
   if sep>0
    `
    rem find word and value
    word$=lower$(removeedgespaces(left$(chunk$,sep-1)))
    value$=removeedgespaces(right$(chunk$,len(chunk$)-(len(word$)+1)))
    `
    rem reset value vars
    mid1=0 : mid2=0
    value1$=""
    value2$=""
    value3$=""
    `
    rem take value 1 2 3 from value
    for c=0 to len(value$)
     if mid$(value$,c)=" " and mid1=0 then mid1=c : exit
     if mid$(value$,c)=" " and mid1<>0 and mid2=0 then mid2=c : exit
    next c
    if mid1=0
     value1$=value$
    else
     if mid2=0
      value1$=left$(value$,mid1-1)
      value2$=right$(value$,len(value$)-(len(value1$)+1))
     else
      value1$=left$(value$,mid1-1)
      value2$=left$(right$(value$,mid1),(mid2-mid1)-1)
      value3$=right$(value$,len(value$)-mid2)
     endif
    endif
    `
    rem calculate values from value strings
    value1=val(value1$)
    value2=val(value2$)
    value3=val(value3$)
    `
   endif
  endif
  exit
 endif
next c

return

_ai_loaddata:

rem Ensure AI Script still exists
if file exist(aidir$+ai$)=1
`
rem About to add conditions
conindexfirst=conindexcount
`
rem Load AI Script Data from file
dim data$(150)
load array aidir$+ai$,data$()
addfiletocollection(aidir$+ai$)
for l=0 to 149
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem Field or Triggerline
   if left$(line$,1)<>":"
    `
    rem Standard Field Line
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem AI header
    if field$="desc" then ailist(aiindex).desc$=value$
    `
   else
    `
    rem AI Triggerline (slice line marked by leading colon:)
    cutline$=right$(line$,len(line$)-1)
    `
    rem find : seperator
    sep=0
    for c=1 to len(cutline$)
     if mid$(cutline$,c)=":" then sep=c : exit
    next c
    if sep>0
     `
     rem conditions collected
     conditions$=left$(cutline$,sep-1)
     cutline$=right$(cutline$,len(cutline$)-(len(conditions$)+1))
     rem now rest is actions
     if len(cutline$)>0
      rem actions collected
      actions$=cutline$
     endif
     `
     rem Parse through conditions
     aicondfirst=aicondseqcount
     stringblock$=conditions$
     while len(stringblock$)>0
      gosub _ai_dividetriggerblock
      for tindex=0 to AICONDLAST
       if word$=conword$(tindex)
        if aicondseqcount+10>array count(aiconditionseq()) then dim aiconditionseq(aicondseqcount+1000) as aiconditiontype
        aiconditionseq(aicondseqcount).type=tindex
        aiconditionseq(aicondseqcount).valuea=value1
        aiconditionseq(aicondseqcount).valueb=value2
        aiconditionseq(aicondseqcount).valuec=value3
        inc aicondseqcount
        exit
       endif
      next tindex
     endwhile
     if conindexcount+10>array count(aicond()) then dim aicond(conindexcount+100) as aiconditionitemtype
     aicond(conindexcount).first=aicondfirst
     aicond(conindexcount).last=aicondseqcount-1
     aicond(conindexcount).action=actindexcount
     inc conindexcount
     `
     rem Parse through actions
     aiactfirst=aiactseqcount
     stringblock$=actions$
     while len(stringblock$)>0
      gosub _ai_dividetriggerblock
      for tindex=0 to AIACTLAST
       if word$=actword$(tindex)
        if aiactseqcount+10>array count(aiactionseq()) then dim aiactionseq(aiactseqcount+1000) as aiactiontype
        aiactionseq(aiactseqcount).type=tindex
        aiactionseq(aiactseqcount).value=value1
        aiactionseq(aiactseqcount).filename=value$
        inc aiactseqcount
        exit
       endif
      next tindex
     endwhile
     if actindexcount+10>array count(aiaction()) then dim aiaction(actindexcount+100) as aiactionitemtype
     aiaction(actindexcount).first=aiactfirst
     aiaction(actindexcount).last=aiactseqcount-1
     inc actindexcount
     `
    endif
    `
   endif
  endif
 endif
next l
undim data$()
`
rem Finalise condition data values
conindexlast=conindexcount-1
ailist(aiindex).conditionfirst=conindexfirst
ailist(aiindex).conditionlast=conindexlast
`
rem File not exist endif
endif

return

_ai_scanfornewscriptsonly:

rem Reset count
aiindexmaster=0

rem Scan for scripts
oldir$=get dir$()
aidir$="scriptbank\"
empty array filelist$()
buildfilelist(aidir$,"")

rem Ensure scriptbank is big enough
dim scriptbank$(1+array count(filelist$()))

rem If AI Script exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem AI Script filename from folder
  ai$=filelist$(chkfile)
  `
  rem Check if filename valid
  if right$(ai$,4)=".fpi"
  `
  rem Check AI Script exists in bank
  tokay=1
  if aiindexmaster>0
   for aiindex=1 to aiindexmaster
    if scriptbank$(aiindex)=ai$ then tokay=0
   next aiindex
  endif
  if tokay=1
    `
    rem Find free space in 'scriptbank'
    freeaiindex=-1
    if aiindexmaster>0
     for aiindex=1 to aiindexmaster
      if scriptbank$(aiindex)="" then freeaiindex=aiindex : exit
     next aiindex
    endif
    `
    rem New AI Script or Free One
    if freeaiindex=-1
     inc aiindexmaster
     aiindex=aiindexmaster
    else
     aiindex=freeaiindex
    endif
    `
    rem Store AI Script for later loading (below)
    scriptbank$(aiindex)=ai$
    `
   endif
   `
  endif
  `
 next chkfile
endif

rem Restore directory
set dir oldir$

return

_ai_loadallscripts:
 if aiindexmaster>0
  aidir$="scriptbank\"
  for aiindex=1 to aiindexmaster
   ai$=scriptbank$(aiindex)
   if lower$(left$(ai$,len(aidir$)))<>lower$(aidir$)
    gosub _ai_load
   endif
  next aiindex
 endif
return

_ai_scanfornewscripts:

rem Scan all to get names
gosub _ai_scanfornewscriptsonly

rem Now load all AI scripts fully
gosub _ai_loadallscripts

return

_ai_findlibindex:
 libindex=-1
 if aiindexmaster>0
  for taiindex=1 to aiindexmaster
   if lower$(scriptbank$(taiindex))=lower$(aifile$) then libindex=taiindex : exit
  next taiindex
 endif
return


rem
rem FUNCTIONS FOR COMMON USE
rem

`
` SUBROUTINES RELATING TO COMMON ACTIVITIES AND RESOURCES
`

_common_wipeeffectifnotexist:
 rem if file not exist, do not try to use effect
 if file exist(tfile$)=0 then tfile$=""
return

_common_makeeffecttextureset:
 `
 rem used by entitycore and segmentmaker (takes tfile$ and texdir$)
 gosub _common_wipeeffectifnotexist
 `
 rem reset output
 absolutelyrequirethistexture=0
 ensureclearlayermax=0
 texdir1$=""
 texdir2$=""
 texdir3$=""
 texdir4$=""
 texdir5$=""
 `
 rem determine effect textures to use
 if tfile$<>"" and segnoeffects=0
  `
  rem D2=D+I+N+S
  tstr0$=left$(texdir$,len(texdir$)-4) : rem _01_D2.TGA -> _01_D2
  tstr1$=left$(texdir$,len(texdir$)-6) : rem _01_D2.TGA -> _01_
  tstr2$=right$(texdir$,4) : rem _01_D2.TGA -> .TGA
  `
  rem D2 must be present to indicate existence of D, N, S, I, etc
  if upper$(right$(tstr0$,2))="D2"
   `
   rem The system used by FPSC is D.I.N.S for 0,1,2,3
   if guseeffectsonessentials=1
    rem no EA essential mode in V1
   else
    rem we will deal with shaders more thoroughly in V1
    hardcodedtexturestages=0
    `
    rem related to scene universe (lightmap stage present)
    ttt$="illuminationmap.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=1
    ttt$="bump.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=2
    `
    rem related to entities (lightmap stage NOT present)
    ttt$="illuminationent.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=11
    ttt$="bumpent.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=12
    ttt$="bumpbone.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=13
    `
    if hardcodedtexturestages>0
     if hardcodedtexturestages=1
      rem [LM]+[DIFF+ILLU]
      ensureclearlayermax=2
      texdir1$=tstr1$+"D2"+tstr2$
      texdir2$=tstr1$+"D2"+tstr2$
      texdir3$=tstr1$+"I"+tstr2$
     endif
     if hardcodedtexturestages=2
      rem [LM]+[DIFF+NORM]
      ensureclearlayermax=2
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"D"+tstr2$
      texdir3$=tstr1$+"N"+tstr2$
      rem Absolutely must have a NORMAL MAP, or fail this effect
      absolutelyrequirethistexture=3
     endif
     if hardcodedtexturestages=11
      rem [DIFF+ILLU]
      ensureclearlayermax=1
      texdir1$=tstr1$+"D2"+tstr2$
      texdir2$=tstr1$+"I"+tstr2$
     endif
     if hardcodedtexturestages=12
      rem [DIFF+NORM]
      ensureclearlayermax=1
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"N"+tstr2$
      rem Absolutely must have a NORMAL MAP, or fail this effect
      absolutelyrequirethistexture=2
     endif
     if hardcodedtexturestages=13
      rem [DIFF+NORM+SPEC]
      ensureclearlayermax=2
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"N"+tstr2$
      texdir3$=tstr1$+"S"+tstr2$
      rem Absolutely must have a NORMAL MAP, or fail this effect
      absolutelyrequirethistexture=2
     endif
    else
     rem Standard DINS system
     if teffectuseslightmapstage=1
      rem [LM]+[DIFF+ILLU+NORM+SPEC+BRIH]
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"D"+tstr2$
      texdir3$=tstr1$+"I"+tstr2$
      texdir4$=tstr1$+"N"+tstr2$
      texdir5$=tstr1$+"S"+tstr2$
     else
      rem [DIFF+ILLU+NORM+SPEC+BRIH]
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"I"+tstr2$
      texdir3$=tstr1$+"N"+tstr2$
      texdir4$=tstr1$+"S"+tstr2$
      texdir5$=tstr1$+"B"+tstr2$
     endif
    endif
   endif
   `
  else
   `
   rem not D2.XXX, so just use texdir$ as base texture
   texdir1$=texdir$
   `
  endif
  `
 else
  rem use no effect this time
  tfile$=""
 endif
 `
return

rem
rem MESH AND TEXTURE HANDLING
rem
`
function loadinternalmesh(tfile$)

rem Default return
meshid=0

rem Scan for existing mesh
if meshbankmax>0
 for m=1 to meshbankmax
  if tfile$=meshbank$(m) then meshid=meshbankoffset+m : exit
 next m
else
 m=meshbankmax+1
endif

rem Did not find, load it
if m>meshbankmax
 inc meshbankmax
 dim meshbank$(meshbankmax)
 if file exist(tfile$)=1
  meshid=meshbankoffset+meshbankmax
  load mesh tfile$,meshid
  meshbank$(meshbankmax)=tfile$
 endif
endif

endfunction meshid

function deleteallinternalimages()
 if imagebankmax>0
  for t=1 to imagebankmax
   imgid=imagebankoffset+t
   if image exist(imgid)=1
    delete image imgid
   endif
  next t
  imagebankmax=0
  undim imagebank$()
  dim imagebank$(imagebankmax)
 endif
 if texturebankmax>0
  for t=1 to texturebankmax
   texid=texturebankoffset+t
   if image exist(texid)=1
    delete image texid
   endif
  next t
  texturebankmax=0
  undim texturebank$()
  dim texturebank$(texturebankmax)
 endif
endfunction

function refreshallinternalimages()
 if imagebankmax>0
  for t=1 to imagebankmax
   tfile$=imagebank$(t)
   imgid=imagebankoffset+t
   loadinternalimageexcompressquality(tfile$,imgid,1,0)
  next t
 endif
endfunction

function refreshinternalimage(t)
 tfile$=imagebank$(t)
 imgid=imagebankoffset+t
 loadinternalimageexcompressquality(tfile$,imgid,1,0)
endfunction

function loadinternalimageexcompressquality(tfile$,imgid,compressmode,quality)
 if lower$(right$(tfile$,4))=".jpg" then tstarttry=2 else tstarttry=1
 if lower$(right$(tfile$,4))=".png" then tstarttry=2 else tstarttry=1
 for try=tstarttry to 3
  if try=1 then tryfile$=left$(tfile$,len(tfile$)-4)+".dds"
  if try=2 then tryfile$=tfile$
  if try=3 then tryfile$=left$(tfile$,len(tfile$)-3)+imgext$
  if file exist(tryfile$)=1
   if gincludeonlyvideo=1 and left$(lower$(tryfile$),len(gincludeonlyname$))<>lower$(gincludeonlyname$)
    rem fill video with basic random color
    create bitmap 7,4,4
    cls rgb(rnd(255),rnd(255),rnd(255))
    get image imgid,0,0,4,4
    delete bitmap 7
    set current bitmap 0
   else
    `
    rem low texture use in editor ( Special divide reduction value of 16384=norealload )
    tempdividetexturesize=gdividetexturesize
    if segobjusedformapeditor=1 then tempdividetexturesize=8
    `
    rem FPSCV104RC10 - can skip 'real load' unless full lightmapping which requires alpha from texture
    `if gcompilestandaloneexe=1 then tempdividetexturesize=16384 : quality=0
    if gcompilestandaloneexe=1 and glightshadowsstate=0 then tempdividetexturesize=16384 : quality=0
    `
    rem load image (skip if building = quicker build)
    if quality=0
     load image tryfile$,imgid,quality,tempdividetexturesize
    else
     if quality=1
      load image tryfile$,imgid,quality
     else
      rem Quality Mode 2 means only reduce have as much (smaller items blur too much in QM=1)
      load image tryfile$,imgid,1,tempdividetexturesize/2
     endif
    endif
    `
    rem and perhaps save it
    if grealgameviewstate=0
     tdds$=left$(tfile$,len(tfile$)-4)+".dds"
     if file exist(tdds$)=0 and tempdividetexturesize=0
      save image tdds$,imgid,compressmode
      addfiletocollection(tdds$)
     else
      addfiletocollection(tryfile$)
     endif
    else
     addfiletocollection(tryfile$)
    endif
    `
   endif
   exit
  endif
 next try
endfunction

function loadinternalimageexcompress(tfile$,imgid,compressmode)
 loadinternalimageexcompressquality(tfile$,imgid,compressmode,0)
endfunction

function loadinternalimageex(tfile$,imgid)
 loadinternalimageexcompress(tfile$,imgid,1)
endfunction

function loadinternalimagecompressquality(tfile$,compressmode,quality)

rem Default return
imgid=0

rem Scan for existing
if imagebankmax>0
 for t=1 to imagebankmax
  if tfile$=imagebank$(t) then imgid=imagebankoffset+t : exit
 next t
else
 t=imagebankmax+1
endif

rem Did not find, load it
if t>imagebankmax
 inc imagebankmax
 dim imagebank$(imagebankmax)
 imgid=imagebankoffset+imagebankmax
 loadinternalimageexcompressquality(tfile$,imgid,compressmode,quality)
 if image exist(imgid)=1
  imagebank$(imagebankmax)=tfile$
 else
  dec imagebankmax
  imgid=0
 endif
endif

endfunction imgid

function loadinternalimagecompress(tfile$,compressmode)
 imgid=loadinternalimagecompressquality(tfile$,compressmode,0)
endfunction imgid

function loadinternalimage(tfile$)
 imgid=loadinternalimagecompress(tfile$,1)
endfunction imgid

function loadinternalimagequality(tfile$)
 imgid=loadinternalimagecompressquality(tfile$,1,1)
endfunction imgid

function loadinternaltexture(tfile$)

rem Default return
texid=0

rem Scan for existing
if texturebankmax>0
 for t=1 to texturebankmax
  if tfile$=texturebank$(t) then texid=texturebankoffset+t : exit
 next t
else
 t=texturebankmax+1
endif

rem Did not find, load it
if t>texturebankmax
 rem Attempt to load
 inc texturebankmax
 dim texturebank$(texturebankmax)
 texturebank$(texturebankmax)=tfile$
 texid=texturebankoffset+texturebankmax
 loadinternalimageex(tfile$,texid)
 if image exist(texid)=0
  rem failed to load, so reverse creation
  texturebank$(texturebankmax)=""
  dec texturebankmax : texid=0
 endif
endif

endfunction texid

function loadinternaltextureex(tfile$,compressmode,quality)

rem Default return
texid=0

rem Scan for existing
if texturebankmax>0
 for t=1 to texturebankmax
  if tfile$=texturebank$(t) then texid=texturebankoffset+t : exit
 next t
else
 t=texturebankmax+1
endif

rem Did not find, load it
if t>texturebankmax
 rem Attempt to load
 inc texturebankmax
 dim texturebank$(texturebankmax)
 texturebank$(texturebankmax)=tfile$
 texid=texturebankoffset+texturebankmax
 loadinternalimageexcompressquality(tfile$,texid,compressmode,quality)
 if image exist(texid)=0
  rem failed to load, so reverse creation
  texturebank$(texturebankmax)=""
  dec texturebankmax : texid=0
 endif
endif

endfunction texid

function loadinternaleffectunique(tfile$,makeunique)

rem Default return
effectid=0

rem Scan for existing
if effectbankmax>0 and makeunique=0
 for t=1 to effectbankmax
  if tfile$=effectbank$(t) then effectid=effectbankoffset+t : exit
 next t
else
 t=effectbankmax+1
endif

rem Did not find, load it
if t>effectbankmax
 if file exist(tfile$)=1
  inc effectbankmax
  dim effectbank$(effectbankmax)
  effectid=effectbankoffset+effectbankmax
  if lower$(left$(tfile$,14))="effectbank\csg"
   load effect tfile$,effectid,1
  else
   load effect tfile$,effectid,0
  endif
  if effect exist(effectid)=1
   effectbank$(effectbankmax)=tfile$
  else
   rem could not use effect
   dec effectbankmax
   effectid=0
  endif
  addfiletocollection(tfile$)
 endif
endif

endfunction effectid

function loadinternaleffect(tfile$)
 effectid=loadinternaleffectunique(tfile$,0)
endfunction effectid

function loadinternalsoundcore(tfile$,mode)

rem Default return
soundid=0

rem No scan for existing - all sounds unique for overlay play
t=soundbankmax+1
if t>soundbankmax
 tspecialogg=0 : if right$(lower$(tfile$),4)=".ogg" then tspecialogg=1
 if right$(lower$(tfile$),4)=".wav" or tspecialogg=1
  if file exist(tfile$)=1
   inc soundbankmax
   dim soundbank$(soundbankmax)
   soundid=soundbankoffset+soundbankmax
   if mode=1 and tspecialogg=0
    load 3dsound tfile$,soundid,1
    if sound exist(soundid)=0 then load sound tfile$,soundid,0,1
   else
    load sound tfile$,soundid,0,1
   endif
   if sound exist(soundid)=0
    rem sound could not loaded
    soundbank$(soundbankmax)=""
    dec soundbankmax
    soundid=0
   else
    rem success
    soundbank$(soundbankmax)=tfile$
    addfiletocollection(tfile$)
   endif
  endif
 endif
endif

endfunction soundid

function loadinternalsound(tfile$)
 soundid=loadinternalsoundcore(tfile$,0)
endfunction soundid

function managebroadcastsound()
 if bcsoundstrength#>0.0
  dec bcsoundstrength#,1.0
  if bcsoundstrength#<0 then bcsoundstrength#=0.0
 endif
endfunction

function broadcast3dsound(x#,y#,z#,strength#)
 if strength#>bcsoundstrength#
  bcsoundstrength#=strength#
  bcsoundx#=x# : bcsoundy#=y# : bcsoundz#=z#
 endif
endfunction

function playinternalBC3dsound(id,x#,y#,z#,strength#)
 if id>0
  if sound exist(id)=1
   broadcast3dsound(x#,y#,z#,strength#)
   position sound id,x#/10.0,y#/10.0,z#/10.0
   play sound id
  endif
 endif
endfunction

function playinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
   play sound id
  endif
 endif
endfunction

function loopinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
   if sound playing(id)=0 then loop sound id
  endif
 endif
endfunction

function posinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
  endif
 endif
endfunction

function playinternal3dsoundfactor(id,x#,y#,z#,factor#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
   factor#=(factor#*2.0)+80.0
   if factor#<0 then factor#=0
   if factor#>100 then factor#=100
   set sound volume id,factor#
   play sound id
  endif
 endif
endfunction

`
` FUNCTION TO BUILD A SUB-DIRECTORY = filelist$()
`
function buildfilelist(folder$,rel$)
 if path exist(folder$)=1
  set dir folder$
  find first : fin=0
  while get file type()>-1
   file$=get file name$()
   if file$="." or file$=".."
    rem ignore . and ..
   else
    if get file type()=1
     rem folder
     buildfilelist(file$,rel$+file$+"\")
     find first
     if fin>0
      for t=1 to fin : find next : next t
     endif
    else
     rem file
     array insert at bottom filelist$()
     filelist$()=rel$+file$
    endif
   endif
   find next
   fin=fin+1
  endwhile
  set dir ".."
 endif
endfunction

`
` FUNCTIONS TO CUT-UP STRINGS
`
function getfirstdir(file$)
 firstdir$=""
 for c=1 to len(file$)
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   firstdir$=left$(file$,c) : exit
  endif
 next c
endfunction firstdir$

function getseconddir(file$)
 firstdir$="" : count=2
 for c=1 to len(file$)
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   dec count
   if count=0
    firstdir$=left$(file$,c) : exit
   endif
  endif
 next c
endfunction firstdir$

function getpath(file$)
 path$=""
 for c=len(file$) to 1 step -1
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   path$=left$(file$,c) : exit
  endif
 next c
endfunction path$

function getfile(file$)
 for c=len(file$) to 1 step -1
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   file$=right$(file$,len(file$)-c) : exit
  endif
 next c
endfunction file$

`
` SUPPORT FUNCTIONS (DUPLICATED IN GUNSYSTEM)
`
function removeedgespaces(text$)
 returntext$=""
 if len(text$)>0
  st=0
  for c=1 to len(text$)
   if asc(mid$(text$,c))>32 then st=c : exit
  next c
  if st=0
   rem all sub-spaces
  else
   for c=len(text$) to 1 step -1
    if asc(mid$(text$,c))>32 then en=c : exit
   next c
   for c=st to en
    returntext$=returntext$+mid$(text$,c)
   next c
  endif
 endif
endfunction returntext$

function minstring(text$,minsize)
 sizegap=minsize-len(text$)
 text$=text$+space$(sizegap)
endfunction text$

`
` FILECOLLECTOR FUNCTIONS
`

function resetfilecollection()
 empty array filecollection$()
endfunction

function addfiletocollection(filename$)
 if segobjusedformapeditor=0 and segobjusedforsegeditor=0
  if len(filename$)>0
   if mid$(filename$,2)=":"
    rem absolute paths not allowed for filenames!
    debugstring(filename$,strarr$(41))
   else
    rem verify file not duplicated
    tokay=1
    for chk=1 to array count(filecollection$())
     if lower$(filecollection$(chk))=lower$(filename$)
      tokay=0
     endif
     if lower$(left$(filecollection$(chk),len(filecollection$(chk))-4))=lower$(left$(filename$,len(filename$)-4))
      rem if have a DDS, and a TGA of the same name, replace it
      if lower$(right$(filecollection$(chk),4))=".tga"
       if lower$(right$(filename$,4))=".dds"
        filecollection$(chk)=filename$
        tokay=0 : exit
       endif
      endif
     endif
    next chk
    rem add file to collection
    if tokay=1
     array insert at bottom filecollection$()
     filecollection$()=filename$
    endif
   endif
  endif
 endif
endfunction

  addallfilestocollection(left$(src$,len(src$)-5))

function addallfilestocollection(folder$)
 storedir$=get dir$()
 set dir folder$
 perform checklist for files
 for c=1 to checklist quantity()
  file$=checklist string$(c)
  if file$<>"." and file$<>".."
   if right$(lower$(file$),4)<>".tga"
    rem all except raw TGA file
    addfiletocollection(folder$+"\"+file$)
   endif
  endif
 next c
 set dir storedir$
endfunction

`
` ASSESS FILE FOR HOW OLD IT IS
`
function getdatevaluefromdatestring(dayofyear$)
   rem get year
   year$=right$(dayofyear$,4)
   dayofyear$=left$(dayofyear$,len(dayofyear$)-5)
   rem eat day
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem find month
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     month$=lower$(left$(dayofyear$,c-1))
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem find date
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     date$=lower$(left$(dayofyear$,c-1))
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem get time
   time$=""
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)<>":"
     time$=time$+mid$(dayofyear$,c)
    endif
   next c
   time$=left$(time$,len(time$)-2)
   if month$="jan" then month=1
   if month$="feb" then month=2
   if month$="mar" then month=3
   if month$="apr" then month=4
   if month$="may" then month=5
   if month$="jun" then month=6
   if month$="jul" then month=7
   if month$="aug" then month=8
   if month$="sep" then month=9
   if month$="oct" then month=10
   if month$="nov" then month=11
   if month$="dec" then month=12
   filedatevalue=((val(year$)-2004)*12*32*2500)+(month*32*2500)+(val(date$)*2500)+val(time$)
endfunction filedatevalue

function isbinaryfileolderthantxtfile(binaryfilefull$,textfilefull$)
 result=0
 if file exist(binaryfilefull$)=1
  stdir$=get dir$()
  binaryfile$=getfile(binaryfilefull$)
  textfile$=getfile(textfilefull$)
  set dir getpath(binaryfilefull$)
  filedatevalueB=0
  filedatevalueT=0
  find first
  while get file type()<>-1
   if get file type()=0
    if lower$(get file name$())=lower$(binaryfile$)
     this$=get file date$()
     dayofyearB$=this$
     filedatevalueB=getdatevaluefromdatestring(dayofyearB$)
    else
     if lower$(get file name$())=lower$(textfile$)
      this$=get file date$()
      dayofyearT$=this$
      filedatevalueT=getdatevaluefromdatestring(dayofyearT$)
     endif
    endif
    if filedatevalueB<>0 and filedatevalueT<>0 then exit
   endif
   find next
  endwhile
  if filedatevalueB<>0 and filedatevalueT<>0
   if filedatevalueB<filedatevalueT
    result=1
   endif
  endif
  set dir stdir$
 endif
endfunction result


rem
rem GAME PLAYER
rem

`
` Player Core Subroutines (for human and NPC players)
`

_player_init:

rem For all players
for plrid=1 to playermax
 `
 rem Player or NPCs
 if plrid=1 then t3d=0 else t3d=1
 `
 rem Sounds 0-9 reserved
 `
 rem Load player grunt sounds
 tsoundset$=playersoundset$(plrid)
 if tsoundset$<>"" and right$(tsoundset$,1)<>"\" then tsoundset$=tsoundset$+"\"
 snd$="audiobank\voices\"+tsoundset$+"leap.wav"
 playersound(plrid,10)=loadinternalsoundcore(snd$,t3d)
 snd$="audiobank\voices\"+tsoundset$+"land.wav"
 playersound(plrid,11)=loadinternalsoundcore(snd$,t3d)
 snd$="audiobank\voices\"+tsoundset$+"hurt1.wav"
 playersound(plrid,12)=loadinternalsoundcore(snd$,t3d)
 snd$="audiobank\voices\"+tsoundset$+"hurt2.wav"
 playersound(plrid,13)=loadinternalsoundcore(snd$,t3d)
 snd$="audiobank\voices\"+tsoundset$+"hurt3.wav"
 playersound(plrid,14)=loadinternalsoundcore(snd$,t3d)
 snd$="audiobank\voices\"+tsoundset$+"finalmoan.wav"
 playersound(plrid,15)=loadinternalsoundcore(snd$,t3d)
 snd$="audiobank\voices\"+tsoundset$+"spawn.wav"
 playersound(plrid,16)=loadinternalsoundcore(snd$,t3d)
 `
 rem Load tred sounds from material list
 for mi=0 to gmaterialmax
  for titer=0 to 3
   if material(mi).name$<>""
    if titer=0 then snd$=material(mi).tred0$
    if titer=1 then snd$=material(mi).tred1$
    if titer=2 then snd$=material(mi).tred2$
    if titer=3 then snd$=material(mi).tred3$
    playersound(plrid,21+(mi*4)+titer)=loadinternalsoundcore(snd$,t3d)
   endif
  next titer
 next mi
 `
 rem Setup player default start values (before startpos fills with real ones)
 if plrid=1
  checkpointentity=-1
  gosub _entity_findplayerstartposition : rem gets 'playerstartlives'
  player(plrid).lives=playerstartlives
 else
  player(plrid).lives=1
 endif
 player(plrid).recovershield=0
 player(plrid).health=100
 `
 rem test game gives player 99 lives (but regular health to test logic)
 if gtestgamemodefromeditor=1 then player(plrid).lives=99
 `
next plrid

rem place listener far away at start
position listener -999999,-999999,-999999
rotate listener 90,0,0

return

_player_free:

rem As sounds are unique, free them before re-creating players
for plrid=1 to playermax
 for tt=0 to 520
  tsnd=playersound(plrid,tt)
  if tsnd>0
   if sound exist(tsnd)=1 then delete sound tsnd
  endif
 next tt
next plrid

return

_player_startgun:

rem Get player start data
gosub _entity_findplayerstartposition
if playerstarthasweapon>0
 rem only if not got gun in slot already
 for tww=1 to 10
  if weaponslot(tww).pref>0
   if weaponslot(tww).pref=playerstarthasweapon then exit
  endif
 next tww
 if tww>10
  for tww=1 to 10
   if weaponslot(tww).pref=0
    weaponslot(tww).pref=playerstarthasweapon
    weaponslot(tww).got=playerstarthasweapon
    weaponhud(tww)=gun(playerstarthasweapon).hudimage
    tww=11 : exit
   endif
  next tww
 endif
 gun(playerstarthasweapon).activeingame=1
endif

return

_player_setstartposonly:
 `
 rem Find player start location
 gosub _entity_findplayerstartposition
 if playerstartx#=0
  rem look for first filled map piece
  for lay=0 to 19
   for x=0 to maxx-1
    for y=0 to maxy-1
     if map(lay,x,y)<>0
      playerstartx#=(x*100)+50
      playerstarty#=(lay*100)
      playerstartz#=(y*-100)-50
      playerstartry#=135
      x=maxx : y=maxy : lay=20
      exit
     endif
    next y
   next x
  next lay
 endif
 `
return

_player_startpos:
 `
 rem clear weaponammoindex (startpostion routine can fill this var)
 weaponammoindex=0
 `
 rem Find player start location
 gosub _player_setstartposonly
 `
 rem Setup player default start values
 player(1).health=playerstartstrength
 if level>1
  rem FPSCV10X - carried from previous level (no longer writes over MAX)
  player(1).health=saveplayerstate.health
 endif
 `
 rem restart basic player vars
 gosub _player_restart
 `
return

_player_restart:
 `
 rem uses playerstartxyz#
 rem Ensure player start height avoids stairs and other ground obstacles
 pttry=0
 while pttry<500
  if static volume(playerstartx#,playerstarty#+1.0,playerstartz#,playerstartx#,playerstarty#,playerstartz#,1.0)=0 then exit
  playerstarty#=playerstarty#+1.0
  inc pttry
 endwhile
 `
 rem sort out camera default rotation at start
 yrotate camera playerstartry#
 zrotate camera 0
 `
 rem start with a jump
 grav#=-1.0 : jumpaction=0 : jumpspeed#=0.0 : jumpangle#=camera angle y() : gravlasty#=mey#
 camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
 camforcex#=0 : camforcey#=0 : camforcez#=0
 `
 rem crouch state
 crouchmode=0
 tcamerasize#=1.0
 ellipsevolumesize#=1.0
 `
 rem recover shield
 player(1).recovershield=0`
 `
 rem Player Weapon default
 if gunzoommode=10 then gunzoommode=11
 autoloadgun=playerstarthasweapon
 `
 rem Default position in center (borble uses this xyz for its position, then camera adjustment later)
 tvalueheight=11 : rem height from base of player start value to center of borble
 lastcamx#=playerstartx# : lastcamy#=playerstarty#+tvalueheight : lastcamz#=playerstartz#
 phystood#=40.0 : phyeyeheight#=phystood#
 camerapositionx=lastcamx#
 camerapositiony=lastcamy#+phyeyeheight#
 camerapositionz=lastcamz#
 mex#=camerapositionx : mey#=camerapositiony : mez#=camerapositionz
 cx#=camerapositionx : cy#=camerapositiony : cz#=camerapositionz
 `
 rem Activate player borble (uses plrpos)
 gosub _ode_playerborble
 `
 rem Can be called within before_and_after move, so ensure vars are set
 ctox#=ctx# : ctoy#=cty# : ctoz#=ctz#
 if object exist(physicsplayerborble)=1
  camerapositionx=object position x(physicsplayerborble)
  camerapositiony=object position y(physicsplayerborble)+phyeyeheight#
  camerapositionz=object position z(physicsplayerborble)
  position camera camerapositionx,camerapositiony,camerapositionz
 endif
 realcx#=camerapositionx : realcy#=camerapositiony : realcz#=camerapositionz
 `
return

_player_savestate:

rem Record players leaving level state
saveplayerstate.lives=player(1).lives
saveplayerstate.health=player(1).health
saveplayerstate.weaponindexholding=weaponammoindex

return

_player_setup:
 `
 rem Setup camera
 position camera 0,52,0
 point camera 0,52,0
 set light range 0,10000
 `
 rem start camera for player
 plrzoominchange=0 : plrzoomin#=0.0
 set camera fov 75.0
 `
 rem Find player start location
 gosub _player_startpos
 `
 rem if weapon, add bullets if any
 if playerstarthasweapon>0 and level=1
  for tww=1 to 10
   if weaponslot(tww).pref=playerstarthasweapon
    tqty=gun(playerstarthasweapon).settings.reloadqty
    if playerstarthasweaponqty>=1
     weaponammo(tww)=tqty
     if playerstarthasweaponqty>1
      weaponclipammo(tww)=(playerstarthasweaponqty-1)*tqty
     endif
    endif
    tww=11 : exit
   endif
  next tww
 endif
 `
 rem Reset some plater related states when restart
 gosub _player_resettrail
 trailx#=mex# : traily#=mey#-52 : trailz#=mez#
 inc playertrailmax
 playertrial(playertrailmax).time=timer()
 playertrial(playertrailmax).x=trailx#
 playertrial(playertrailmax).y=traily#
 playertrial(playertrailmax).z=trailz#
 `
 rem restore player camera states
 phyeyeheight#=phystood#
 tcamerasize#=1.0
 grav#=0
 cameraspeed=0
 cameraholding=0
 camerapickupkeyrelease=0
 camerareach#=0
 camerapicked=0
 cameradampen#=1.0
 `
return

_player_playfootfall:

sndid=0
if colmaterialtype>=0
 if colmaterialtype>=100 then colmaterialtype=colmaterialtype-(int(colmaterialtype/100)*100)
 if colmaterialtype>=0 and colmaterialtype<100
  tt=21+(colmaterialtype*4)
  for titer=0 to 3
   ttrr=rnd(3)
   sndid=playersound(plrid,tt+ttrr)
   if sndid>0
    if sound playing(sndid)=1 then sndid=0
   endif
   if sndid<>0 then playersoundtimeused(plrid,tt+ttrr)=perftimer() : exit
  next titer
  if sndid=0
   titerdw as DWORD
   tdwsmalltest as DWORD
   bestsndid=0
   for titer=0 to 3
    titerdw=playersoundtimeused(plrid,tt+titer)
    if titer=0 then tdwsmalltest=titerdw
    sndid=playersound(plrid,tt+titer)
    if sndid>0
     if titerdw<=tdwsmalltest
      tdwsmalltest=titerdw : bestsndid=sndid
     endif
    endif
   next titer
   sndid=bestsndid
  endif
 endif
 if sndid>0
  if (movement<>0 and jumpaction=0) or leapedlanded=1 or plrid>1
   playermovementstep(plrid)=playermovementstep(plrid)+timeelapsed#
   if movement=2 then tfootspeed#=2.0 else tfootspeed#=1.0
   if plrid=1
    if basespeed#<=40.0 then tsteppingsound#=6.0*tfootspeed#
    if basespeed#>40.0 then tsteppingsound#=5.0*tfootspeed#
   else
    if basespeed#<=40.0 then tsteppingsound#=11.0*tfootspeed#
    if basespeed#>40.0 then tsteppingsound#=7.0*tfootspeed#
   endif
   if plrid=1 then tsteppingsound#=tsteppingsound#/playerspeedratio#
   if playermovementstep(plrid)>tsteppingsound# or leapedlanded=1
    leapedlanded=0 : playermovementstep(plrid)=0.0
    if plrid>1
     playinternal3dsoundfactor(sndid,entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
    else
     broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0)
     play sound sndid
    endif
   endif
  endif
 endif
endif

return

_player_resetobjectives:

rem Set mission after 100 cycle void, for now reset objectives
for mi=1 to 99 : playerobjective(mi)=0 : next mi
newlevelobjectivevoid=10
triggergameexitfade=0
missiongoaltotal=0

return

_player_mission:

rem For player one only
plrid=1

rem Only if game in ful swing
if newlevelobjectivevoid>0
 `
 rem Ensure objective cannot be met for 100 cycles at start of level
 dec newlevelobjectivevoid
 if newlevelobjectivevoid<=0
  rem Set mission through entity objective flags
  for mi=1 to 99 : playerobjective(mi)=0 : next mi
  gosub _entity_calculateobjectivestotal
  newlevelobjectivevoid=0
  triggergameexitfade=0
  rem FPSCV104RC4 - if just loaded a game, refresh objectives from savedata
  if gsaveloadobjectivesloaded=1
   for mi=0 to 99
    playerobjective(mi)=saveloadgamepositionplayerobjective(mi)
   next mi
   gsaveloadobjectivesloaded=0
  endif
 endif
 `
else
 `
 rem Decide when player wins/loses
 if player(plrid).lives=0 and player(plrid).health=0
  `
  rem Never lose if in arena mode (other players you see)
  if gmultiplayergame=1
   rem simply skip
  else
   rem LOST
   if triggergameexitfade=0
    triggergameexitfade=1 : levelwon=0
   endif
  endif
  `
 else
  `
  rem only if objectives in this level
  if missiongoaltotal>0
   `
   rem default is mission COMPLETE
   objectivesmet=1
   `
   rem All active objectives must be met, else mission not complete
   for mi=1 to missiongoaltotal
    if playerobjective(mi)=0 then objectivesmet=0
   next mi
   `
   rem Objective never met if arena game not objective based
   if gmultiplayergame=1
    if ggameobjectivetype<>1 then objectivesmet=0
   endif
   `
   rem If all objectives met, player wins level
   if objectivesmet=1
    `
    rem WON
    if triggergameexitfade=0
     triggergameexitfade=1 : levelwon=1
    endif
    `
   endif
   `
  endif
  `
 endif
 `
endif

rem Fading system prior to WIN/LOSE logic escape
if triggergameexitfade>0
 `
 rem Fade out screen
 inc triggergameexitfade,4
 if triggergameexitfade>255
  triggergameexitfade=255
 endif
 `
 rem apply fade to hud
 if internalfaderhud>0
  hudid=internalfaderhud : hud(hudid).hide=0
  set sprite alpha hudid,triggergameexitfade
 endif
 `
 rem When fade complete, can continue win/lose triggers
 if triggergameexitfade=255
  rem can switch from WIN to LOSE if no health by time fade done
  if player(1).health<=0 then levelwon=0
  rem complete game session
  if gmultiplayergame=1
   rem allow multi code to determine conclusion actions (multiplayer)
   gosub _multi_missioncomplete
  else
   rem exit level (single player)
   continueokay=1
  endif
  rem reset fader
  triggergameexitfade=0
 endif
 `
endif

return

_player_manager:

rem For all players
for plrid=1 to playermax
 `
 rem Player commands received
 dropitem=player(plrid).command.drop
 if dropitem>0
  playerinventory(plrid,dropitem).drop=1
  player(plrid).command.drop=0
 endif
 `
next plrid

return

_player_obtainaweapon:
 `
 rem uses weaponindex,tqty
 if weaponindex>0
  rem adds the weapon
  weaponinvposition=pi : tgunid=weaponindex
  if gun(tgunid).settings.weaponisammo=0 and tqty=0 then tqty=1
  tqty=tqty*gun(tgunid).settings.reloadqty
  gosub _player_addweapon
 endif
 `
return

_player_itemmanager:

rem For all players
for plrid=1 to playermax
 `
 rem Check inventory for any new items added
 for pi=1 to player(plrid).inventorymax
  if playerinventory(plrid,pi).new=1
   `
   rem Item checked in
   playerinventory(plrid,pi).new=0
   `
   rem Entity ID
   e=playerinventory(plrid,pi).index
   entid=entityelement(e).bankindex
   `
   rem If main player, handle internal resources
   if plrid=1
    `
    rem Entities record when they have been collected
    entityelement(e).collected=1
    `
    rem Respond to presence of WEAPON
    weaponindex=entityprofile(entid).isweapon
    tqty=entityelement(e).eleprof.quantity
    gosub _player_obtainaweapon
    `
    rem Respond to presence of AMMO
    ammoindex=entityprofile(entid).isammo
    if ammoindex>0
     tnogunforammo=1
     for ws=1 to 10
      tgunid=weaponslot(ws).pref
      if tgunid=entityprofile(entid).hasweapon
       tnogunforammo=0
       tqty=entityelement(e).eleprof.quantity*gun(tgunid).settings.reloadqty
       if gun(tgunid).settings.weaponisammo=1
        weaponammo(ws)=weaponammo(ws)+tqty
       else
        weaponclipammo(ws)=weaponclipammo(ws)+tqty
       endif
       exit
      endif
     next ws
     if tnogunforammo=1
      rem create a gun slot for it, and fill with ready ammo
      for ws=1 to 10
       if weaponslot(ws).pref=0
        tgunid=entityprofile(entid).hasweapon
        weaponslot(ws).pref=tgunid
        weaponhud(ws)=gun(tgunid).hudimage
        tqty=entityelement(e).eleprof.quantity*gun(tgunid).settings.reloadqty
        weaponclipammo(ws)=tqty
        exit
       endif
      next ws
     endif
    endif
    `
   else
    `
    rem any maintenance the NPC needs to do when it gets an item
    `
   endif
   `
  endif
 next pi
 `
 rem Check inventory for any items we need to drop
 for pi=1 to player(plrid).inventorymax
  if playerinventory(plrid,pi).drop=1
   `
   rem Entity ID
   e=playerinventory(plrid,pi).index
   entid=entityelement(e).bankindex
   `
   rem Item Entities expect a state incrememt if player drops after pickup
   entityelement(e).ai.state=entityelement(e).ai.state+1
   `
   rem Handle main player internal resources
   if plrid=1
    `
    rem Entities record when they have been dropped
    entityelement(e).collected=0
    `
    rem Respond to removal of item from inventory
    weaponindex=entityprofile(entid).isweapon
    if weaponindex>0 then gosub _player_removeweapon
    `
   else
    `
    rem any maintenance the NPC needs to do when it drops an item
    `
   endif
   `
   rem Item checked out
   playerinventory(plrid,pi).drop=0
   playerinventory(plrid,pi).index=0
   `
  endif
 next pi
 `
next plrid

return

`
` Main Player Subroutines Only
`

_player_input:

rem Input relates to PLAYER ONE ONLY (main controller of this app)
plrid=1

rem Gather input data
k$=lower$(inkey$())

rem Invincibe Mode - God Mode
if ggodmodestate=1 or gtestgamemodefromeditor=1
 if k$="i" then player(1).health=9999
endif

rem Mouseclick
tmouseclick=mouseclick()
if showgamemenu=1 then tmouseclick=0

rem Mouse
player(plrid).state.firingmode=0
if player(plrid).health>0
 if tmouseclick=1 then player(plrid).state.firingmode=1
 if tmouseclick=2
  if gunzoommode=0 and gun(gunid).settings.zoommode<>0
   gunzoommode=1 : gunzoommag#=1.0
   rem play sound of gun select-zoom
   if gunsound(gunid,4).soundid>0
    if sound exist(gunsound(gunid,4).soundid)=1
     if sound playing(gunsound(gunid,4).soundid)=0
      playinternalBC3dsound(gunsound(gunid,4).soundid,camera position x(),camera position y(),camera position z(),1)
     endif
    endif
   endif
  endif
  if gunzoommode=10 then gunzoommode=11
 else
  if gunzoommode=9 then gunzoommode=10
  if gunzoommode=20 then gunzoommode=0
 endif
 if (plrkeyR)=1 then player(plrid).state.firingmode=2
endif

rem Keyboard
if k$<>"" and gunzoommode=0
 if keyboardpress=0
  `
  rem Change weapon
  if player(plrid).health>0
   if (k$>="1" and k$<="9")
    sel=(asc(k$)-asc("1"))
    weaponkeyselection=1+sel
    weaponindex=weaponslot(weaponkeyselection).got
    if weaponindex>0 then player(plrid).command.newweapon=weaponindex
   endif
   if k$="0"
    if gunid<>0
     gunmode=31 : gunselectionafterhide=0
    endif
   endif
  endif
  `
  rem Restart if in recovermode, early start
  if player(plrid).recovershield>0 and player(plrid).recovershield<50 and k$=" "
   player(plrid).recovershield=1
  endif
  `
  rem Cannot keypress until release
  keyboardpress=1
  `
 endif
else
 keyboardpress=0
endif

rem Mouse Wheel scrolls weapons
tmz=mousemovez()
if gunselectionlockdown=0 and gunzoommode=0
 if tmz<>0
  tokay=0 : ttries=10
  while tokay=0 and ttries>0
   if tmz<0 then weaponkeyselection=weaponkeyselection-1
   if tmz>0 then weaponkeyselection=weaponkeyselection+1
   if weaponkeyselection>10 then weaponkeyselection=1
   if weaponkeyselection<1 then weaponkeyselection=10
   tweaponindex=weaponslot(weaponkeyselection).got
   if tweaponindex>0 then tokay=1
   dec ttries
  endwhile
  if tokay=1
   rem change up or down
   weaponindex=weaponslot(weaponkeyselection).got
   if weaponindex>0 then player(plrid).command.newweapon=weaponindex
  endif
 endif
else
 rem zoom magnification wheel
 if tmz<>0
  tmz#=tmz : gunzoommag#=gunzoommag#+(tmz#/100.0)
  if gunzoommag#<1.0 then gunzoommag#=1.0
  if gunzoommag#>10.0 then gunzoommag#=10.0
  plrzoominchange=1
 endif
endif

rem Use Action
if (plrkeyRETURN)=1
 player(plrid).usingaction=1
else
 player(plrid).usingaction=0
endif

rem Recover mode progress (RESTART PLAYER NEW LIFE)
tsetplayereyehud=0
if player(plrid).recovershield>0
 if player(plrid).lives>0
  player(plrid).recovershield=player(plrid).recovershield-1
  if player(plrid).recovershield>0
   tsetplayereyehud=1
  else
   rem recover player
   player(plrid).recovershield=0
   player(plrid).health=playerstartstrength
   rem restart player at spawn point
   gosub _player_unmark
   gosub _player_startpos
   rem reset entities to make distant ones dormant again
   gosub _entity_resetentitiesifplrleaps
  endif
 endif
endif
if player(plrid).lives=0 and player(plrid).health<=0
 tsetplayereyehud=1
endif
if tsetplayereyehud=1
 rem update sprite used for screen fade
 if internaleyehud>0
  hudid=internaleyehud : hud(hudid).hide=0
  hud(hudid).hidedelay=5
 endif
endif

return

_player_addweapon:

rem check all weapon slots
gotweapon=0
for ws=1 to 10
 if weaponslot(ws).got=weaponindex then gotweapon=ws
next ws
if gotweapon=0
 rem check if we have a slot preference
 gotweaponpref=0
 for ws=1 to 10
  if weaponslot(ws).pref=weaponindex then gotweaponpref=ws
 next ws
 rem add weapon
 if gotweaponpref=0
  rem find free slot
  for ws=1 to 10
   if weaponslot(ws).pref=0 then exit
  next ws
  if ws<=10
   rem add weapon into free slow and create pref for it
   weaponslot(ws).pref=weaponindex
   weaponhud(ws)=gun(weaponindex).hudimage
  else
   rem no room for weapon in available slots
   ws=0
  endif
 else
  ws=gotweaponpref
 endif
 remstart
 rem switch to collected weapon
 if ws>0
  rem insert as slot weapon
  weaponslot(ws).got=weaponindex
  weaponslot(ws).invpos=weaponinvposition
  autoloadgun=weaponindex
  weaponkeyselection=ws
  gotweapon=ws
 endif
 remend
 rem place details of weapon in slot
 if ws>0
  rem insert as slot weapon
  weaponslot(ws).got=weaponindex
  weaponslot(ws).invpos=weaponinvposition
  gotweapon=ws
  if gunid=0
   rem if no gun held, auto select collected
   autoloadgun=weaponindex
   weaponkeyselection=ws
  endif
 endif
endif
`
rem weapons start with some ammo
if gotweapon>0
 tgunid=weaponslot(gotweapon).pref
 if gun(tgunid).settings.weaponisammo=0
  if tqty=0 then tqty=1
  if weaponammo(gotweapon)=0
   weaponammo(gotweapon)=tqty
  else
   weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
  endif
 endif
endif

return

_player_removeweapon:

rem check all weapon slots
for ws=1 to 10
 if weaponslot(ws).got=weaponindex then exit
next ws
if ws<=10
 `
 rem Ensure gun is removed (if applicable)
 if gunid>0 and weaponslot(ws).got=gunid
  autoloadgun=0
 endif
 `
 rem drop weapon from slot
 weaponslot(ws).got=0
 weaponslot(ws).invpos=0
 `
endif

return

`
` Player Movement Related
`

_player_unmark:
 gosub _ode_unmark
return

_player_mark:
 gosub _ode_mark
return

_player_camera:
 plrid=1 : gosub _ode_playercamera
 basespeed#=plrbasespeed# : gosub _player_playfootfall
 if cty#<=-100 then tdamage=65000 : gosub _player_takedamage
return

_player_listener:
 gosub _ode_listener
return

`
` Player Gun Functions (should they be here)
`

function loadgun(tfile$)
 index=0
 if gunbankmax>0
  for t=1 to gunbankmax
   if tfile$=gunbank$(t) then index=gunbankoffset+t : exit
  next t
 else
  t=gunbankmax+1
 endif
 if t>gunbankmax
  inc gunbankmax
  if file exist(tfile$)=1
   index=gunbankoffset+gunbankmax
   gunbank$(gunbankmax)=tfile$
   load object tfile$,index
   addfiletocollection(tfile$)
   set object collision off index
   set object interpolation index,100
   set object frame index,gun(gunbankmax).action.show.s
   hide object index
  endif
 endif
endfunction index

function createsecondgun()
 inc gunbankmax
 gunbank$(gunbankmax)="second"
 index=gunbankoffset+gunbankmax
endfunction index

function loadbrass(tfile$)
 index=0
 if brassbankmax>0
  for t=1 to brassbankmax
   if tfile$=brassbank$(t) then index=brassbankoffset+t : exit
  next t
 else
  t=brassbankmax+1
 endif
 if t>brassbankmax
  inc brassbankmax
  if file exist(tfile$)=1
   index=brassbankoffset+brassbankmax
   brassbank$(brassbankmax)=tfile$
   load object tfile$,index
   addfiletocollection(tfile$)
   set object collision off index
   disable object zdepth index
   set object transparency index,1
   set object specular index,15
   set object fov index,45
  endif
 endif
endfunction index

function loadmuzzle(tfile$)
 index=0
 if muzzlebankmax>0
  for t=1 to muzzlebankmax
   if tfile$=muzzlebank$(t) then index=muzzlebankoffset+t : exit
  next t
 else
  t=muzzlebankmax+1
 endif
 if t>muzzlebankmax
  inc muzzlebankmax
  muzzlebank$(muzzlebankmax)=tfile$
  index=muzzlebankoffset+muzzlebankmax
  loadinternalimageexcompress(tfile$,index,5)
 endif
endfunction index

function loadsmoke(tfile$)
 index=0
 if smokebankmax>0
  for t=1 to smokebankmax
   if tfile$=smokebank$(t) then index=smokebankoffset+t : exit
  next t
 else
  t=smokebankmax+1
 endif
 if t>smokebankmax
  inc smokebankmax
  smokebank$(smokebankmax)=tfile$
  index=smokebankoffset+smokebankmax
  loadinternalimageexcompress(tfile$,index,5)
 endif
endfunction index


rem
rem GUN CORE
rem


_gun_init:

rem Load all guns into memory
gosub _gun_scaninall_ref

rem Force all weapons into weapon slots (initial default start)
if level=1 then gosub _gun_gatherslotorder

rem No gun to start with
weaponammoindex=0
autoloadgun=-1
gunid=0

return

_gun_loadonlypresent:
 `
 rem Load only active guns from slots (and from playerstartentry)
 for tww=1 to 10
  gunid=weaponslot(tww).pref
  if gunid>0 then gun(gunid).activeingame=1
 next tww
 `
 rem load in any guns that entities specify
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  gunid=entityprofile(entid).hasweapon
  if gunid>0 then gun(gunid).activeingame=1
  gunid=entityprofile(entid).isweapon
  if gunid>0 then gun(gunid).activeingame=1
 next e
 `
 rem Load all guns that have been activated
 for gunid=1 to gunmax
  if gun(gunid).activeingame=1
   gun$=gun(gunid).name$ : gosub _gun_load
  endif
 next gunid
 `
 rem And now fill in player weapon details
 for tww=1 to 10
  gunid=weaponslot(tww).pref
  if gunid>0
   if gun(gunid).activeingame=1
    weaponhud(tww)=gun(gunid).hudimage
   endif
  endif
 next tww
 `
 rem Ensure gun vars are reset
 gunid=0
 `
return

_gun_resetgunsettings:
 `
 rem Reset weapons (1=restart)
 if tcopyorrestart=0
  rem copy
  dim copyweaponslot(10) as weaponslottype
  dim copyweaponammo(10) as integer
  dim copyweaponclipammo(10) as integer
  dim copyweaponhud(10) as integer
  for ws=1 to 10
   copyweaponslot(ws)=weaponslot(ws)
   copyweaponammo(ws)=weaponammo(ws)
   copyweaponclipammo(ws)=weaponclipammo(ws)
   copyweaponhud(ws)=weaponhud(ws)
  next ws
 else
  rem restore
  for ws=1 to 10
   weaponslot(ws)=copyweaponslot(ws)
   weaponammo(ws)=copyweaponammo(ws)
   weaponclipammo(ws)=copyweaponclipammo(ws)
   weaponhud(ws)=copyweaponhud(ws)
  next ws
 endif
 `
return

_gun_manager:

rem Gun controls
gunclick=player(1).state.firingmode
if gunmode<100
 rem Gun Firing
 if gunclick<>1 then gunmustreleasefirst=0
 if gunclick<>0
  if gunclick=1 and gunmustreleasefirst=0 then gunmode=101
  if gunclick=2 then gunmode=121
 else
  rem Gun Movement
  if gunmode<21 or gunmode>39
   if player(1).state.moving=1 then gunmode=21
  endif
 endif
endif

rem Gun Selection
if gunselectionlockdown=0
 if player(1).command.newweapon>0
  sel=player(1).command.newweapon
  player(1).command.newweapon=0
  if weaponammoindex>0
   rem only if 'different weapon'
   if weaponslot(weaponammoindex).pref<>sel
    gunmode=31 : gunselectionafterhide=sel
   endif
  else
   gunmode=131 : autoloadgun=sel
  endif
 endif
endif

rem Change weapon
gosub _gun_change

rem Need to update hud object for gun here (and again after SYNC)
gosub _gun_update_hud

rem Gun control
if gunid>0
 if object exist(currentgunobj)=1
  gosub _gun_control
  gosub _gun_shoot
  if gun(gunid).settings.flashlimb>=0 then gosub _gun_flash
  if gun(gunid).settings.brasslimb>=0 then gosub _gun_brass
  if gun(gunid).settings.brasslimb>=0 then gosub _gun_smoke
  gosub _gun_soundcontrol
 endif
endif

rem Independent handling (no matter which guns is selected)
gosub _gun_brass_indi

return

_gun_change:

if autoloadgun<>-1
 `
 rem Free the old gun
 gosub _gun_free
 `
 rem Gun selection
 gunid=autoloadgun
 gun$=gun(gunid).name$
 autoloadgun=-1
 `
 rem If gun selection valid, load it
 if gun$<>"" then gosub _gun_selectandorload

 rem cause gun lighting to reset
 currentguncolr=-1 : gosub _lighting_applyplayerlighting

 rem Show gun as active
 currentgunobj=gun(gunid).obj
 if currentgunobj>0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.show.s
  show object currentgunobj
 else
  gunid=0
 endif

 rem Default gun action is to SHOW and reveal gun (then goes to gunmode=5 idle)
 gunmode=131 : keyboardpress=0

 rem locate slot for ammo usage
 weaponammoindex=0
 if gunid>0
  for ws=1 to 10
   if weaponslot(ws).pref=gunid
    weaponammoindex=ws : exit
   endif
  next ws
 endif

endif

return

_gun_update_hud:

rem HUD marker update
if object exist(hudbankoffset+2)=1
 gunax#=camera angle x() : gunay#=camera angle y()
 position object hudbankoffset+2,camera position x(),camera position y(),camera position z()
 rotate object hudbankoffset+2,gunax#,gunay#,0
 if currentgunobj>0
  if object exist(currentgunobj)=1
   if player(1).health>0
    show object currentgunobj
   else
    hide object currentgunobj
   endif
  endif
 endif
endif

return

_gun_update_overlay:
return

_gun_control:

rem gun position offset and rotation
if plrzoomin#<>0.0
 plrzoomaccuracy#=gun(gunid).settings.zoomaccuracy/100.0
 position object currentgunobj,gun(gunid).horiz#,gun(gunid).vert#,gun(gunid).forward#-(plrzoomin#*10.0)
else
 position object currentgunobj,gun(gunid).horiz#,gun(gunid).vert#,gun(gunid).forward#
endif
rotate object currentgunobj,0,180,0

rem hide the object if weapon-ammo and no qty left
if gun(gunid).settings.weaponisammo=1
 if weaponammo(weaponammoindex)=0
  hide object currentgunobj
 else
  show object currentgunobj
 endif
endif

rem gun idle control ((4*0.75)=3.0)
if gunmode=5
 gunmode=6
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.idle.s+3.0
endif
if gunmode=6
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.idle.s+3.0
  gunmode=7
 endif
endif
if gunmode=7
 gunmode=8
 play object currentgunobj,gun(gunid).action.idle.s+3.0,gun(gunid).action.idle.e
endif
if gunmode=8
 if object frame(currentgunobj)>=gun(gunid).action.idle.e then gunmode=9
endif
if gunmode=9
 gunmode=10
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.idle.s+3.0
endif
if gunmode=10
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.idle.s+3.0
  gunmode=7
 endif
endif

rem gun movment control ((4*0.75)=3.0
if gunmode=21
 gunmode=22
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.move.s+3.0
endif
if gunmode=22
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.move.s+3.0
  gunmode=23
 endif
endif
if gunmode>=23 and gunmode<=26
 if movement=0 then gunmode=5
endif
if gunmode=23
 gunmode=24
 play object currentgunobj,gun(gunid).action.move.s+3.0,gun(gunid).action.move.e
endif
if gunmode=24
 if object frame(currentgunobj)>=gun(gunid).action.move.e then gunmode=25
endif
if gunmode=25
 gunmode=26
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.move.s+3.0
endif
if gunmode=26
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.move.s+3.0
  gunmode=23
 endif
endif

rem gun put away and hide control
if gunmode=31
 gunmode=32
 guninterp=4
 gunselectionlockdown=1
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.hide.s
 rem play sound of gun select-change
 if gunsound(gunid,4).soundid>0
  if sound exist(gunsound(gunid,4).soundid)=1
   if sound playing(gunsound(gunid,4).soundid)=0
    playinternalBC3dsound(gunsound(gunid,4).soundid,camera position x(),camera position y(),camera position z(),1)
   endif
  endif
 endif
endif
if gunmode=32
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.hide.s
  set object speed currentgunobj,125
  gunmode=33
 endif
endif
if gunmode=33
 gunmode=34
 set object interpolation currentgunobj,100
 play object currentgunobj,gun(gunid).action.hide.s,gun(gunid).action.hide.e
endif
if gunmode=34
 if object frame(currentgunobj)>=gun(gunid).action.hide.e then gunmode=35
endif
if gunmode=35
 set object speed currentgunobj,75
 autoloadgun=gunselectionafterhide
 gunselectionlockdown=0
 gunmode=5
endif

rem gun firing control
if gunmode=101
 if gun(gunid).settings.reloadqty=0 then weaponammo(weaponammoindex)=99999
 if weaponammo(weaponammoindex)>0
  gunmode=102
  set object interpolation currentgunobj,100
  play object currentgunobj,gun(gunid).action.start.s,gun(gunid).action.start.e
 else
  if gunclick<>1
   if gunsound(gunid,3).soundid>0
    if sound exist(gunsound(gunid,3).soundid)=1
     if sound playing(gunsound(gunid,3).soundid)=0
      playinternalBC3dsound(gunsound(gunid,3).soundid,camera position x(),camera position y(),camera position z(),50)
     endif
    endif
   endif
   gunmode=107
  endif
 endif
endif
if gunmode=102
 if object frame(currentgunobj)>=gun(gunid).action.start.e then gunmode=103
endif
if gunmode=103
 gunmode=104 : gunflash=1
 gunshoot=1 : guntimercount=6
 weaponammo(weaponammoindex)=weaponammo(weaponammoindex)-1
 if gun(gunid).settings.brasslimb<>-1 then gunbrass=1 : gunbrasscount=6
 if gun(gunid).settings.brasslimb<>-1 then gunsmoke=1 : gunsmokecount=6
 sndid=gunsound(gunid,1).soundid
 if sndid>0
  if sound exist(sndid)=1
   if gun(gunid).action.automatic.s>0
    loop object currentgunobj,gun(gunid).action.automatic.s,gun(gunid).action.automatic.e
    play sound sndid,gun(gunid).sound.fireloopend : rem some sound bug
    loop sound sndid,0,gun(gunid).sound.fireloopend
   endif
  endif
 endif
endif
if gunmode=104
 if weaponammo(weaponammoindex)>0
  if gunflash=0 then gunflash=1
  dec gunbrasscount : dec gunsmokecount : dec guntimercount
  if gunbrasscount<=0 and gun(gunid).settings.brasslimb<>-1 then gunbrass=1 : gunbrasscount=6
  if gunsmokecount<=0 and gun(gunid).settings.brasslimb<>-1 then gunsmoke=1 : gunsmokecount=6
  if guntimercount<=0 then gunshoot=1 : guntimercount=6 : weaponammo(weaponammoindex)=weaponammo(weaponammoindex)-1
  if gun(gunid).action.automatic.s=0 then gunmode=105
  if gunclick<>1 then gunmode=105
  sndid=gunsound(gunid,1).soundid
  if sndid>0
   if sound exist(sndid)=1
    position sound sndid,camera position x(),camera position y(),camera position z()
    broadcast3dsound(camera position x(),camera position y(),camera position z(),100)
   endif
  endif
 else
  gunmode=105
 endif
endif
if gunmode=105
 if gun(gunid).action.automatic.s>0
  rem automatic weapons cannot resume firing right away
 else
  gunmustreleasefirst=1
 endif
 if gun(gunid).action.finish.s>0
  gunmode=106
  play object currentgunobj,gun(gunid).action.finish.s,gun(gunid).action.finish.e
  sndid=gunsound(gunid,1).soundid
  if sndid>0
   if sound exist(sndid)=1
    position sound sndid,camera position x(),camera position y(),camera position z()
    play sound sndid,gun(gunid).sound.fireloopend
   endif
  endif
  broadcast3dsound(camera position x(),camera position y(),camera position z(),50)
 else
  gunmode=107
 endif
endif
if gunmode=106
 if object frame(currentgunobj)>=gun(gunid).action.finish.e then gunmode=107
endif
if gunmode=107
 rem reset to normal
 gunmode=5
 rem auto-reload if no bullets
 if weaponammo(weaponammoindex)=0
  if weaponclipammo(weaponammoindex)>0
   rem direct into reload
   gunmode=121
  endif
 endif
endif

rem gun reload and cock control
if gunmode=121
 if weaponclipammo(weaponammoindex)=0 or gun(gunid).settings.weaponisammo=1
  if gun(gunid).settings.weaponisammo=0
   if gunsound(gunid,3).soundid>0
    if sound exist(gunsound(gunid,3).soundid)=1
     if sound playing(gunsound(gunid,3).soundid)=0
      playinternalBC3dsound(gunsound(gunid,3).soundid,camera position x(),camera position y(),camera position z(),50)
     endif
    endif
   endif
  endif
  gunmode=5
 else
  gunmode=122
  guninterp=4
  stop object currentgunobj
  set object interpolation currentgunobj,25
  set object frame currentgunobj,gun(gunid).action.startreload.s
 endif
endif
if gunmode=122
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.startreload.s
  gunmode=123
 endif
endif
if gunmode=123
 gunmode=124
 set object interpolation currentgunobj,100
 play object currentgunobj,gun(gunid).action.startreload.s,gun(gunid).action.cock.e
 if gunsound(gunid,2).soundid>0
  if sound exist(gunsound(gunid,2).soundid)=1
   position sound gunsound(gunid,2).soundid,camera position x(),camera position y(),camera position z()
  endif
 endif
endif
if gunmode=124
 if object frame(currentgunobj)>=gun(gunid).action.cock.e then gunmode=125
endif
if gunmode=125
 rem actual reload
 tneedfromclip=gun(gunid).settings.reloadqty-weaponammo(weaponammoindex)
 if tneedfromclip>weaponclipammo(weaponammoindex) then tneedfromclip=weaponclipammo(weaponammoindex)
 if tneedfromclip>0
  weaponammo(weaponammoindex)=weaponammo(weaponammoindex)+tneedfromclip
  weaponclipammo(weaponammoindex)=weaponclipammo(weaponammoindex)-tneedfromclip
 endif
 gunmode=5
endif

rem gun reveal
if gunmode=131
 set object interpolation currentgunobj,100
 set object frame currentgunobj,gun(gunid).action.show.s
 play object currentgunobj,gun(gunid).action.show.s,gun(gunid).action.show.e
 if gunsound(gunid,2).soundid>0
  if sound exist(gunsound(gunid,2).soundid)=1
   position sound gunsound(gunid,2).soundid,camera position x(),camera position y(),camera position z()
  endif
 endif
 gunmode=132
endif
if gunmode=132
 if object frame(currentgunobj)>=gun(gunid).action.show.e then gunmode=5
endif

return

_gun_flash:

if plrzoomin#<>0.0 then gunflash=0
if gunflash=1
 `
 rem fire flash init
 gunflash=2
 gunflashcount=6
 rotate object hudbankoffset+5,0,0,rnd(360)
 show object hudbankoffset+5
 if gun(gunid).settings.flashlimb2<>-1
  rotate object hudbankoffset+32,0,0,rnd(360)
  show object hudbankoffset+32
 endif
 `
 rem light flash init
 spotflash=100
 tx#=camera position x()
 ty#=camera position y()
 tz#=camera position z()
 tcolr=gun(gunid).settings.muzzlecolorr
 tcolg=gun(gunid).settings.muzzlecolorg
 tcolb=gun(gunid).settings.muzzlecolorb
 gosub _lighting_spotflash
 `
endif
if gunflash=2
 dec gunflashcount
 if gunflashcount<=4
  rem hide early
  hide object hudbankoffset+5
  hide object hudbankoffset+32
 endif
 if gunflashcount<=0
  gunflash=3
 endif
endif
if gunflash=3
 gunflash=0
 rem final hide
 hide object hudbankoffset+5
 hide object hudbankoffset+32
endif

return

_gun_brass:

rem FPSCV104RC5-twingun
gunbrass2=0 : if gunbrass=1 and gun(gunid).settings.flashlimb2<>-1 then gunbrass2=1

rem find free shell and expell
for o=6 to 20
 obj=hudbankoffset+o
 if object visible(obj)=0 and gunbrass=1
  lx#=limb position x(currentgunobj,gun(gunid).settings.brasslimb)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,gun(gunid).settings.brasslimb)
  lz#=limb position z(currentgunobj,gun(gunid).settings.brasslimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  set object to object orientation obj,hudbankoffset+2
  roll object left obj,25+rnd(10)
  brassfallcount(o)=15
  show object obj
  gunbrass=0
 endif
 if object visible(obj)=0 and gunbrass=0 and gunbrass2=1
  lx#=limb position x(currentgunobj,gun(gunid).settings.brasslimb2)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,gun(gunid).settings.brasslimb2)
  lz#=limb position z(currentgunobj,gun(gunid).settings.brasslimb2)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  set object to object orientation obj,hudbankoffset+2
  roll object left obj,25+rnd(10)
  brassfallcount(o)=15
  show object obj
  gunbrass2=0
 endif
next o

return

_gun_brass_indi:
 for o=6 to 20
  obj=hudbankoffset+o
  if object visible(obj)=1
   if brassfallcount(o)>5
    eject#=1.0
   else
    eject#=brassfallcount(o)/5.0
   endif
   move object right obj,1.0
   if object position y(obj)>object position y(hudbankoffset+2)-20
    if brassfallcount(o)>0
     brassfallcount(o)=brassfallcount(o)-1
     roll object right obj,4.0
    endif
   endif
   position object obj,object position x(obj),object position y(obj)-((1.0-eject#)*1.0),object position z(obj)
   if object position y(obj)<object position y(hudbankoffset+2)-50 or object in screen(obj)=0
    hide object obj
   endif
  endif
 next o
return

_gun_smoke:

rem FPSCV104RC5-twingun
gunsmoke2=0 : if gunsmoke=1 and gun(gunid).settings.flashlimb2<>-1 then gunsmoke2=1

rem find free smoke and puff
for o=21 to 30
 obj=hudbankoffset+o
 if object visible(obj)=0 and gunsmoke=1
  ttsmokelimb=gun(gunid).settings.smokelimb
  if ttsmokelimb<=0 then ttsmokelimb=gun(gunid).settings.brasslimb
  lx#=limb position x(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  lz#=limb position z(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  show object obj
  gunsmoke=0 : smokeframe=0
 endif
 if object visible(obj)=0 and gunsmoke=0 and gunsmoke2=1
  ttsmokelimb=gun(gunid).settings.smokelimb2
  if ttsmokelimb<=0 then ttsmokelimb=gun(gunid).settings.brasslimb
  lx#=limb position x(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  lz#=limb position z(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  show object obj
  gunsmoke2=0 : smokeframe=0
 endif
 if object visible(obj)=1
  point object obj,camera position x(),camera position y(),camera position z()
  smokerisespeed#=gun(gunid).settings.smokespeed/100.0
  position object obj,object position x(obj),object position y(obj)+smokerisespeed#,object position z(obj)
  smokeframe=(object position y(obj)-ly#)/0.75
  if object in screen(obj)=1 and smokeframe<=15
   ty=smokeframe/4
   tx=smokeframe-(ty*4)
   q#=1.0/4.0 : tx#=tx*q# : ty#=ty*q#
   rem vertex data lock mode of 1=update (faster method if mesh size unchanged)
   lock vertexdata for limb obj,0,1
   set vertexdata uv 0,tx#+q#,ty#
   set vertexdata uv 1,tx#,ty#
   set vertexdata uv 2,tx#+q#,ty#+q#
   set vertexdata uv 3,tx#,ty#
   set vertexdata uv 4,tx#,ty#+q#
   set vertexdata uv 5,tx#+q#,ty#+q#
   unlock vertexdata
  else
   hide object obj
  endif
 endif
next o

return

_gun_shoot:

rem when fire line active
if gunshoot=1
 if gun(gunid).settings.flakindex=0
  `
  rem BULLET
  rem gun data controls iterations and accuracy
  trayiter=1+gun(gunid).settings.iterate
  trayaccuracy=gun(gunid).settings.accuracy
  bulletdamage=gun(gunid).settings.damage
  `
  rem Special ZOOMODE kill in multiplayer
  if gmultiplayergame=1
   if gunzoommode<>0
    bulletdamage=65500
   endif
  endif
  `
  rem for some weapons, blunderbus style five-ray shot
  multiplayerdamagecollected=0
  for traycount=1 to trayiter
   `
   rem project gun-line-for-shot
   x1#=camera position x()+(trayaccuracy/2)-rnd(trayaccuracy)
   y1#=camera position y()+(trayaccuracy/2)-rnd(trayaccuracy)
   z1#=camera position z()+(trayaccuracy/2)-rnd(trayaccuracy)
   position object hudbankoffset+3,x1#,y1#,z1#
   set object to camera orientation hudbankoffset+3
   move object hudbankoffset+3,gun(gunid).settings.range
   disable object zdepth hudbankoffset+3
   x2#=object position x(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   y2#=object position y(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   z2#=object position z(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   `
   rem reset bullethit vars
   bullethit=0 : bullethitstatic=0
   tbullethitmaterial=0 : tbullethitflesh=0
   bulletraytype=gun(gunid).settings.damagetype
   gunrange#=gun(gunid).settings.range
   `
   rem raycastto entity
   gosub _entity_hasbulletrayhit
   `
   rem raycast to surface (bullets path)
   dstwallhit#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
   if dstwallhit#>0
    wallhitx#=checklist fvalue a(6)
    wallhity#=checklist fvalue b(6)
    wallhitz#=checklist fvalue c(6)
    wallhitmaterial=get static collision value()-1
   endif
   `
   rem has bullet hit any entity
   if tcloseste>0 and (dstwallhit#=0 or dstwallhit#>tclosestdist#)
    `
    rem complete rayhit if wall not in way (must come right after _entity_hasbulletrayhit)
    gosub _entity_completerayhit
    `
    rem bulletraytype (1-pierce, 2-shutgun)
    tix#=x#-x1# : tiy#=y#-y1# : tiz#=z#-z1#
    tnorm#=(abs(tix#)+abs(tiy#)+abs(tiz#))/3.0
    tix#=tix#/tnorm# : tiy#=tiy#/tnorm# : tiz#=tiz#/tnorm#
    `
    rem move entity by that direction with some force (non-multiplayer)
    e=bulletrayhit
    tentid=entityelement(e).bankindex
    if gmultiplayergame=0
     if bulletraytype=2
      tforce#=gun(gunid).settings.damage/5.0
     else
      tforce#=gun(gunid).settings.damage/30.0
     endif
     rem entity prone to force
     if entityelement(e).eleprof.isimmobile=0
      rem apply force
      if entityelement(e).eleprof.physics=1
       rem using advanced physics (force is soft if entity destroyed in hit)
       todee=e : tdx#=tix# : tdy#=tiy# : tdz#=tiz# : todefalloff#=0.0
       if entityelement(e).health>0 then todeforce#=tforce#*10.0 else todeforce#=tforce#/10.0
       tpx#=x# : tpy#=y# : tpz#=z# : gosub _ode_applypointforce
      else
       rem using regular force calc
       entityelement(e).force.active=1
       entityelement(e).force.ix=tix#*tforce#
       entityelement(e).force.iy=tiy#*tforce#
       entityelement(e).force.iz=tiz#*tforce#
      endif
     endif
    endif
    if entityprofile(tentid).ischaracter=1
     rem only if character full of red blood (and had health)!
     tbullethitflesh=entityprofile(tentid).bloodscorch
    endif
    bullethit=1
    `
   else
    `
    rem has bullet hit some debris between gun and wall
    if dstwallhit#>0
     tforce#=gun(gunid).settings.damage/5.0
     gosub _part_movedebrisifinray
    endif
    `
   endif
   `
   rem had bulletray hit anything solid
   if bulletrayhit>0
    if tbullethitflesh=0
     if bulletrayhitdist#<dstwallhit# then dstwallhit#=0.0
    else
     rem work out size of blood splat based on distance from flesh to surface (0-100)
     t#=abs(dstwallhit#-bulletrayhitdist#)
     if t#<200
      tbullethitflesh=t#/2.0
     else
      dstwallhit#=0.0
     endif
    endif
   endif
   `
   rem wallhit?
   tsoundtrigger=0 : tsoundmaterial=0
   if dstwallhit#>0
    rem flag the creation of a scorch for the solid surface
    x#=wallhitx# : y#=wallhity# : z#=wallhitz#
    `if wallhitmaterial>=1 and wallhitmaterial<=4 then tbullethitmaterial=wallhitmaterial : rem FPSCV101 - fix
    if wallhitmaterial>=1 then tbullethitmaterial=wallhitmaterial
    bullethitstatic=1 : bullethit=1
    rem trigger a sound for this material type (1-stone/4-glass)
    if wallhitmaterial>=0
     tmatindex=wallhitmaterial
     `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
     if tmatindex>=0 and tmatindex<=gmaterialmax
      tsoundmaterial=1+tmatindex
      tsoundtrigger=material(tmatindex).impactid
      tsx#=wallhitx# : tsy#=wallhity# : tsz#=wallhitz#
      tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
     endif
    endif
   endif
   `
   rem if material sound triggered
   gosub _ode_triggermaterialsound
   gosub _decal_triggermaterialdebris
   `
   rem bullet result
   if bullethit=1
    `
    rem trigger decal for blood splat/whatever effect
    if bulletrayhit>0
     e=bulletrayhit
     tentid=entityelement(e).bankindex
     decalid=entitydecal(tentid,1)
     rem FPSCV101 - decal effect already used
     `rem if no built-in decal, use material of entity
     `if decalid=0
      `if entityprofile(tentid).ischaracter=0
      ` if entityprofile(tentid).materialindex>0
        `tmatindex=entityprofile(tentid).materialindex : rem FPSCV101 - fix
        `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
      `  tmatindex=entityprofile(tentid).materialindex-1
      `  if tmatindex>=0 and tmatindex<=gmaterialmax
      `   decalid=material(tmatindex).decalid
      `  endif
      ` endif
      `endif
     `endif
     if decalid>0
      rem direction from player to entity
      tix#=x2#-x1# : tiy#=y2#-y1# : tiz#=z2#-z1#
      tdd#=sqrt(abs(tix#*tix#)+abs(tiy#*tiy#)+abs(tiz#*tiz#))
      tix#=tix#/tdd# : tiy#=tiy#/tdd# : tiz#=tiz#/tdd#
      rem find point of impact
      tix#=tix#*(bulletrayhitdist#-10.0)
      tiy#=tiy#*(bulletrayhitdist#-10.0)
      tiz#=tiz#*(bulletrayhitdist#-10.0)
      rem create a splat decal
      decalscalemodx=0 : rem FPSCV101 - fix
      decalorient=0 : decalx=x1#+tix# : decaly=y1#+tiy# : decalz=z1#+tiz#
      originatore=-1 : gosub _decalelement_create
     endif
    endif
    `
    rem add scorch if hit universe static polygons
    if bullethitstatic=1
     tscorchtype=gun(gunid).settings.scorchtype
     gosub _entity_doscorch
    endif
    `
   endif
   `
  rem repeat ray over
  next traycount
  `
  rem after all rays of shot, deal damage OR missed-shot (multiplayer)
  if gmultiplayergame<>0
   rem inform session when make a shot
   gosub _multi_playershoots
   rem deal damage if collected for character hit
   if multiplayerdamagecollected>0
    rem deal damage to entitycharacter (to multiplayerdamagechar)
    tdamage=multiplayerdamagecollected
    e=multiplayerdamagechar : gosub _entity_deducthealth
   endif
  endif
  `
  rem shot over
  gunshoot=0
  `
 else
  `
  rem FLAK
  rem create-projectile-for-shot
  flakid=gun(gunid).settings.flakindex
  if flakid>0
   flakangle=camera angle y() : flakpitch=camera angle x() : flakowner=0
   if gun(gunid).settings.flashlimb<>-1
    flakx=limb position x(hudbankoffset+5,0)
    flaky=limb position y(hudbankoffset+5,0)
    flakz=limb position z(hudbankoffset+5,0)
   else
    flakx=camera position x()+newxvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
    flaky=camera position y()+flak(flakid).throwheight
    flakz=camera position z()+newzvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
    flaky=flaky-(sin(flakpitch)*flak(flakid).throwforward)
   endif
   flakspeed#=1.0
   gosub _flakelement_create
   rem if something blocking launch, explode flak
   texplodeflakinstantly=0
   flakx=flakelement(tf).xpos
   flaky=flakelement(tf).ypos
   flakz=flakelement(tf).zpos
   if static raycast(camerapositionx,camerapositiony,camerapositionz,flakx,flaky,flakz)<>0
    texplodeflakinstantly=1
   endif
   rem intensive scan for solid entity obstacles
   for te=1 to entityelementlist
    if entityelement(te).active=1
     if entityelement(te).obj>0 and entityelement(te).collisionactive=1
      tentid=entityelement(te).bankindex
      if intersect object(entityelement(te).obj,camerapositionx,camerapositiony,camerapositionz,flakx,flaky,flakz)<>0
       texplodeflakinstantly=1 : exit
      endif
     endif
    endif
   next te
   if texplodeflakinstantly=1
    flakelement(tf).profile.weight=0
    flakelement(tf).profile.xinc=0
    flakelement(tf).profile.yinc=0
    flakelement(tf).profile.zinc=0
    flakelement(tf).xpos=camerapositionx
    flakelement(tf).ypos=camerapositiony
    flakelement(tf).zpos=camerapositionz
    gosub _flakelement_explodeinstantly
   endif
  endif
  `
  rem shot over
  gunshoot=0
  `
 endif
endif

return

_gun_soundcontrol:

rem Play sound frames when object frame matches
if gun(gunid).sound.soundframes>0
 for p=0 to gun(gunid).sound.soundframes-1
  sndid=gunsound(gunid,gunsounditem(gunid,p).playsound).soundid
  if gun(gunid).action.automatic.s>0 and p=0 then sndid=0
  if sndid>0
   if int(gunsounditem(gunid,p).keyframe)=int(object frame(currentgunobj))
    if gunsounditem(gunid,p).lastplay=0
     gunsounditem(gunid,p).lastplay=1
     broadcast3dsound(camera position x(),camera position y(),camera position z(),50)
     if sound exist(sndid)=1
      play sound sndid
     endif
    endif
   else
    gunsounditem(gunid,p).lastplay=0
   endif
  endif
 next p
endif

return

`
` Gun Resources
`

_gun_create_hud:

rem Setup HUD Center Marker
make object box hudbankoffset+2,30,100,30
set object collision off hudbankoffset+2
hide object hudbankoffset+2

rem Setup HUD Gun-line Marker (shows impact coord)
make object cube hudbankoffset+3,5
set object collision off hudbankoffset+3
hide object hudbankoffset+3

rem Muzzle Flash(es)
for t=0 to 1
 if t=0 then tobj=hudbankoffset+5
 if t=1 then tobj=hudbankoffset+32
 make object plain tobj,25,25
 set object collision off tobj
 set object transparency tobj,1
 disable object zdepth tobj
 set object ambient tobj,0
 set object light tobj,0
 set object fov tobj,45
 hide object tobj
next t

rem Brass
for o=6 to 20
 obj=hudbankoffset+o
 make object sphere obj,5
 set object collision off obj
 disable object zdepth obj
 hide object obj
next o

rem Smoke
for o=21 to 30
 obj=hudbankoffset+o
 make object plain obj,20,20
 set object collision off obj
 disable object zdepth obj
 disable object zwrite obj
 set object transparency obj,1
 set object ambient obj,0
 set object light obj,0
 set object fov obj,45
 hide object obj
next obj

rem crosshair hud object
obj=hudbankoffset+31
make object cube obj,25
set object collision off obj
disable object zdepth obj
disable object zwrite obj
lock object on obj
position object obj,0,0,400
ghost object on obj
set object ambient obj,0
set object light obj,0
hide object obj

return

_gun_setup:

rem Create common resources for gun
gosub _gun_create_hud

rem Debris
img$="gamecore\debris\debris1.tga"
imgid=loadinternalimage(img$)
for p=1 to 32
 make particles p,imgid,2,20.0
 set particle life p,12.0
 set particle speed p,0.04
 set particle velocity p,5.0
 ghost particles on p,5
 hide particles p
next p

return

_gun_gatherslotorder:

tslotmax=0
gunslotmax=0
dim data$(100)
filename$="..\"+setupfilename$
if file exist(filename$)=0 then debugstring(strarr$(375),filename$)
load array filename$,data$()
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem gather gun type from slot
   for tww=1 to 9
    tryfield$="slot"+str$(tww)
    if field$=tryfield$
     rem find gun id from name
     findgun$=value$
     gosub _gun_findweaponindexbyname
     weaponslot(tww).pref=foundgunid
     if foundgunid>0 then gunslotmax=tww
    endif
   next tww
   `
  endif
 endif
next l
undim data$()

return

_gun_loaddata:

dim data$(100)
filename$="gamecore\guns\"+gun$+"\gunspec.txt"
if file exist(filename$)=1
load array filename$,data$()
addfiletocollection(filename$)
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem GUN SETTINGS
   if field$="muzzleflash" then gun(gunid).settings.muzzleflash=value1
   if field$="muzzlesize" then gun(gunid).settings.muzzlesize#=value1
   if field$="muzzlecolorr" then gun(gunid).settings.muzzlecolorr=value1
   if field$="muzzlecolorg" then gun(gunid).settings.muzzlecolorg=value1
   if field$="muzzlecolorb" then gun(gunid).settings.muzzlecolorb=value1
   if field$="brass" then gun(gunid).settings.brass=value1
   if field$="smoke" then gun(gunid).settings.smoke=value1
   if field$="flak" then gun(gunid).settings.flakname$=value$
   if field$="second" then gun(gunid).settings.seconduse=value1
   if field$="damage" then gun(gunid).settings.damage=value1
   if field$="damagetype" then gun(gunid).settings.damagetype=value1
   if field$="scorchtype" then gun(gunid).settings.scorchtype=value1
   if field$="reloadqty" then gun(gunid).settings.reloadqty=value1
   if field$="weaponisammo" then gun(gunid).settings.weaponisammo=value1
   if field$="iterate" then gun(gunid).settings.iterate=value1
   if field$="accuracy" then gun(gunid).settings.accuracy=value1
   if field$="zoommode" then gun(gunid).settings.zoommode=value1
   if field$="zoomaccuracy" then gun(gunid).settings.zoomaccuracy=value1
   if field$="range" then gun(gunid).settings.range=value1
   if field$="decal" then gun(gunid).decal$=value$
   if field$="smokespeed" then gun(gunid).settings.smokespeed=value1
   if field$="smokedecal" then gun(gunid).settings.smokedecal$=value$
   `
   rem GUN VISUALS
   tryfield$="textured"
   if field$=tryfield$ then gun(gunid).texd$=value$
   tryfield$="effect"
   if field$=tryfield$ then gun(gunid).effect$=value$
   tryfield$="transparency"
   if field$=tryfield$ then gun(gunid).transparency=value1
   tryfield$="zoomscope"
   if field$=tryfield$ then gun(gunid).zoomscope$=value$
   tryfield$="weapontype"
   if field$=tryfield$ then gun(gunid).weapontype=value1
   `
   rem GUN SOUNDS
   if field$="fireloop" then gun(gunid).sound.fireloopend=value1
   for p=1 to 4
    tryfield$="sound"+str$(p)
    if field$=tryfield$ then gunsound(gunid,p).name$=value$
   next p
   `
   rem GUN AND MUZZLE ALIGNMENT
   if field$="horiz" then gun(gunid).horiz#=value1
   if field$="vert" then gun(gunid).vert#=value1
   if field$="forward" then gun(gunid).forward#=value1
   if field$="alignx" then gun(gunid).settings.muzzlex#=value1
   if field$="aligny" then gun(gunid).settings.muzzley#=value1
   if field$="alignz" then gun(gunid).settings.muzzlez#=value1
   `
   rem HUD ANIMATION DATA
   if field$="select" then gun(gunid).action.show.s=value1 : gun(gunid).action.show.e=value2
   if field$="idle" then gun(gunid).action.idle.s=value1 : gun(gunid).action.idle.e=value2
   if field$="move" then gun(gunid).action.move.s=value1 : gun(gunid).action.move.e=value2
   if field$="fire" then gun(gunid).action.start.s=value1 : gun(gunid).action.start.e=value1 : gun(gunid).action.finish.s=value1 : gun(gunid).action.finish.e=value2
   if field$="start fire" then gun(gunid).action.start.s=value1 : gun(gunid).action.start.e=value2
   if field$="automatic fire" then gun(gunid).action.automatic.s=value1 : gun(gunid).action.automatic.e=value2
   if field$="end fire" then gun(gunid).action.finish.s=value1 : gun(gunid).action.finish.e=value2
   if field$="reload"
    gun(gunid).action.startreload.s=value1 : gun(gunid).action.startreload.e=value2
    gun(gunid).action.reloadloop.s=value2 : gun(gunid).action.reloadloop.e=value2
    gun(gunid).action.endreload.s=value2 : gun(gunid).action.endreload.e=value2
   endif
   if field$="start reload" then gun(gunid).action.startreload.s=value1 : gun(gunid).action.startreload.e=value2
   if field$="reload loop" then gun(gunid).action.reloadloop.s=value1 : gun(gunid).action.reloadloop.e=value2
   if field$="end reload" then gun(gunid).action.endreload.s=value1 : gun(gunid).action.endreload.e=value2
   if field$="cock" then gun(gunid).action.cock.s=value1 : gun(gunid).action.cock.e=value2
   if field$="putaway" then gun(gunid).action.hide.s=value1 : gun(gunid).action.hide.e=value2
   if field$="keyframe ratio" then keyframeratio=value1
   `
   rem GUN SOUND FRAMES DATA
   tryfield$="soundframes"
   if field$=tryfield$ then gun(gunid).sound.soundframes=value1
   if gun(gunid).sound.soundframes>0
    for p=0 to gun(gunid).sound.soundframes
     tryfield$="sframe"+str$(p)
     if field$=tryfield$ then gunsounditem(gunid,p).keyframe=(value1*keyframeratio) : gunsounditem(gunid,p).playsound=value2
    next p
   endif
   `
  endif
 endif
next l
undim data$()
endif

rem If no COCK animation, fill with end of reload data
if gun(gunid).action.cock.e=0
 gun(gunid).action.cock.s=gun(gunid).action.endreload.e
 gun(gunid).action.cock.e=gun(gunid).action.endreload.e
endif

rem FPSCV104RC5 if no muzzle colour, go with default
if gun(gunid).settings.muzzlecolorr=0 and gun(gunid).settings.muzzlecolorg=0 and gun(gunid).settings.muzzlecolorb=0
 gun(gunid).settings.muzzlecolorr=255
 gun(gunid).settings.muzzlecolorg=255
 gun(gunid).settings.muzzlecolorb=0
endif

rem FPSCV104RC8 - can set the smoke speed
if gun(gunid).settings.smokespeed=0
 gun(gunid).settings.smokespeed=25
endif

rem FPSCV104RC9
if gun(gunid).settings.smokedecal$=""
 gun(gunid).settings.smokedecal$="smoke1"
endif

rem Find the decal specified
gun(gunid).decalid=0
if gun(gunid).decal$<>""
 decal$=gun(gunid).decal$ : gosub _decal_find
 if decalid<0
  decalid=0
 else
  decal(decalid).active=1
  gun(gunid).decalid=decalid
 endif
endif

rem Default gun range
if gun(gunid).settings.range=0 then gun(gunid).settings.range=1000

return

_gun_selectandorload:

rem Load gun if not selected
if gun(gunid).obj=0
 gosub _gun_load
endif

rem Associate gun with player
currentgunobj=gun(gunid).obj

rem Setup gun with muzzle flash image
if gun(gunid).settings.flashlimb<>-1
 texture object hudbankoffset+5,gun(gunid).settings.flashimg
 glue object to limb hudbankoffset+5,hudbankoffset+2,0
 position object hudbankoffset+5,gun(gunid).settings.muzzlex#,gun(gunid).settings.muzzley#,gun(gunid).settings.muzzlez#
 size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
 scale object hudbankoffset+5,size#,size#,size#
endif
if gun(gunid).settings.flashlimb2<>-1
 texture object hudbankoffset+32,gun(gunid).settings.flashimg
 glue object to limb hudbankoffset+32,hudbankoffset+2,0
 position object hudbankoffset+32,gun(gunid).settings.muzzlex#*-1,gun(gunid).settings.muzzley#,gun(gunid).settings.muzzlez#
 size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
 scale object hudbankoffset+32,size#,size#,size#
else
 scale object hudbankoffset+32,0,0,0
endif

rem Setup gun with brass models
if gun(gunid).settings.brasslimb<>-1
 for o=6 to 20
  obj=hudbankoffset+o
  if object exist(obj)=1 then delete object obj
  instance object obj,gun(gunid).settings.brassobjmaster
  set object collision off obj
  disable object zdepth obj
  set object fov obj,45
  hide object obj
 next o
endif

rem Setup gun with smoke images
if gun(gunid).settings.brasslimb<>-1
 for o=21 to 30
  obj=hudbankoffset+o
  texture object obj,gun(gunid).settings.smokeimg
  hide object obj
 next o
endif

rem Setup gun with crosshair
obj=hudbankoffset+31
timg=gun(gunid).settings.crosshairimg
texture object obj,timg
crosshairx=(screen width()-image width(timg))/2
crosshairy=(screen height()-image height(timg))/2
ts#=(100.0/64.0)*image width(timg)
scale object obj,ts#,ts#,ts#
show object obj

`rem Second-Handed Weapon Mode
`if gun(gunid).settings.seconduse=1
` currentgunsecondobj=gun(gunid).secondobj
` glue object to limb currentgunsecondobj,hudbankoffset+2,0
` if gun(gunid).settings.flashlimb<>-1
`  texture object hudbankoffset+32,gun(gunid).settings.flashimg
`  glue object to limb hudbankoffset+32,hudbankoffset+2,0
`  position object hudbankoffset+32,gun(gunid).settings.muzzlex#*-1.0,gun(gunid).settings.muzzley#,gun(gunid).settings.muzzlez#
`  size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
`  scale object hudbankoffset+32,size#,size#,size#
` endif
`else
` hide object hudbankoffset+32
`endif

return

_gun_load:

rem Load gun data
gosub _gun_loaddata

rem Load gun models
currentgunobj=loadgun("gamecore\guns\"+gun$+"\HUD.x")
gun(gunid).obj=currentgunobj

rem FPSCV10X - ensure multi-textures in HUD are recorded for final build
nout$=findmaterialtexturesinmodelfile("gamecore\guns\"+gun$+"\HUD.x","gamecore\guns\"+gun$+"\")

rem Set the unique FOV aspect of the gun
set object fov currentgunobj,45

rem Perform scan to determine hotspot markers
flashlimb=-1 : brasslimb=-1 : smokelimb=-1 : handlimb=-1
flashlimb2=-1 : brasslimb2=-1 : smokelimb2=-1
perform checklist for object limbs currentgunobj
for c=1 to checklist quantity()
 name$=upper$(checklist string$(c))
 if name$="FIRESPOT" then flashlimb=c-1
 if name$="X3DS_FIRESPOT" then flashlimb=c-1
 if name$="FIRESPOT02" then flashlimb2=c-1
 if name$="BRASS" then brasslimb=c-1
 if name$="X3DS_BRASS" then brasslimb=c-1
 if name$="BRASS02" then brasslimb2=c-1
 if name$="SMOKE" then smokelimb=c-1
 if name$="X3DS_SMOKE" then smokelimb=c-1
 if name$="SMOKE02" then smokelimb2=c-1
 if name$="HAND" then handlimb=c-1
 if name$="X3DS_HAND" then handlimb=c-1
next c

rem Store limbs in limb-data
gun(gunid).settings.flashlimb=flashlimb
gun(gunid).settings.brasslimb=brasslimb
gun(gunid).settings.handlimb=handlimb
rem FPSCV104RC5 - new fields
gun(gunid).settings.smokelimb=smokelimb
gun(gunid).settings.flashlimb2=flashlimb2
gun(gunid).settings.brasslimb2=brasslimb2
gun(gunid).settings.smokelimb2=smokelimb2

rem Determine number of frames per keyframe
if keyframeratio>0
 ratio#=keyframeratio
else
 ratio#=1
endif

rem Adjust animation data based on actual number of keyframes
gun(gunid).action.show.s = gun(gunid).action.show.s * ratio#
gun(gunid).action.show.e = gun(gunid).action.show.e * ratio#
gun(gunid).action.idle.s = gun(gunid).action.idle.s * ratio#
gun(gunid).action.idle.e = gun(gunid).action.idle.e * ratio#
gun(gunid).action.move.s = gun(gunid).action.move.s * ratio#
gun(gunid).action.move.e = gun(gunid).action.move.e * ratio#
gun(gunid).action.start.s = gun(gunid).action.start.s * ratio#
gun(gunid).action.start.e = gun(gunid).action.start.e * ratio#
gun(gunid).action.automatic.s = gun(gunid).action.automatic.s * ratio#
gun(gunid).action.automatic.e = gun(gunid).action.automatic.e * ratio#
gun(gunid).action.finish.s = gun(gunid).action.finish.s * ratio#
gun(gunid).action.finish.e = gun(gunid).action.finish.e * ratio#
gun(gunid).action.startreload.s = gun(gunid).action.startreload.s * ratio#
gun(gunid).action.startreload.e = gun(gunid).action.startreload.e * ratio#
gun(gunid).action.reloadloop.s = gun(gunid).action.reloadloop.s * ratio#
gun(gunid).action.reloadloop.e = gun(gunid).action.reloadloop.e * ratio#
gun(gunid).action.endreload.s = gun(gunid).action.endreload.s * ratio#
gun(gunid).action.endreload.e = gun(gunid).action.endreload.e * ratio#
gun(gunid).action.cock.s = gun(gunid).action.cock.s * ratio#
gun(gunid).action.cock.e = gun(gunid).action.cock.e * ratio#
gun(gunid).action.hide.s = gun(gunid).action.hide.s * ratio#
gun(gunid).action.hide.e = gun(gunid).action.hide.e * ratio#

rem Load Effect (if allowed)
if guseeffectongunsstate=1 and gun(gunid).effect$<>""
 tfile$=gun(gunid).effect$
 debugfilename(tfile$,"effect for gun")
 teffectid=loadinternaleffect(tfile$)
else
 teffectid=0
endif

rem Setup gun model materiual properties
set object diffuse currentgunobj,rgb(255,255,255)
set object ambience currentgunobj,rgb(255,255,255)
set object specular currentgunobj,0
set object emissive currentgunobj,0

rem First Textures are PLATES
if teffectid>0
 `
 rem Load effect textures
 if gun(gunid).transparency>2
  img$="gamecore\guns\"+gun$+"\gun_D.tga" : imgDid=loadinternalimagecompressquality(img$,0,1)
  img$="gamecore\guns\"+gun$+"\gun_N.tga" : imgNid=loadinternalimagecompressquality(img$,0,1)
  img$="gamecore\guns\"+gun$+"\gun_R.tga" : imgRid=loadinternalimagecompressquality(img$,0,1)
 else
  img$="gamecore\guns\"+gun$+"\gun_D.tga" : imgDid=loadinternalimagecompress(img$,5)
  img$="gamecore\guns\"+gun$+"\gun_N.tga" : imgNid=loadinternalimage(img$)
  img$="gamecore\guns\"+gun$+"\gun_R.tga" : imgRid=loadinternalimage(img$)
 endif
 `
 rem Last Texture Image is CUBE
 img$="gamecore\guns\"+gun$+"\gun_cube.dds" : imgCUBEid=loadinternalimage(img$)
 if file exist(img$)=1 then load image img$,imgCUBEid,2
 `
 rem Bump Quality
 texture object currentgunobj,0,imgDid
 texture object currentgunobj,1,imgNid
 texture object currentgunobj,2,imgRid
 texture object currentgunobj,3,imgCUBEid
 `
 rem Apply effect to object
 gun(gunid).effectidused=teffectid
 set object effect currentgunobj,teffectid
 `
else
 `
 rem Basic Diffuse2 for Gun (and AmmoClip) - if specified in gunspec.txt
 tfile$=gun(gunid).texd$
 if len(tfile$)=0 then tfile$="gun_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 if len(gun(gunid).texd$)>0 and left$(gun(gunid).texd$,1)<>" "
  texture object currentgunobj,imgD2id
 endif
 tfile$="ammo_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 tfile$="scope_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 rem FPSCV104RC10
 tfile$="hand_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 tfile$="supressor_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 `
endif

rem load in scope if any
if gun(gunid).zoomscope$<>""
 img$="gamecore\guns\"+gun$+"\"+gun(gunid).zoomscope$
 gun(gunid).zoomscope=loadinternalimagecompress(img$,5)
 addfiletocollection(img$)
else
 gun(gunid).zoomscope=0
endif

rem Glue gun to HUD-Gun-Marker
glue object to limb currentgunobj,hudbankoffset+2,0

rem Setup gun for correct visuals (special transparency for after-shadow setting)
if gun(gunid).transparency>2
 set object transparency currentgunobj,gun(gunid).transparency
else
 set object transparency currentgunobj,2
endif
disable object zdepth currentgunobj

rem Setup gun for animation
set object speed currentgunobj,75
loop object currentgunobj

rem Setup gun with muzzle flash image
num=gun(gunid).settings.muzzleflash : if num=0 then num=1
size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
muzzleflash$="gamecore\muzzleflash\flash"+str$(num)+".tga"
imgid=loadmuzzle(muzzleflash$)
gun(gunid).settings.flashimg=imgid
`
rem Setup gun with brass models
num=gun(gunid).settings.brass : if num=0 then num=1
brass$="gamecore\brass\brass"+str$(num)+"\brass"+str$(num)+".x"
brassobj=loadbrass(brass$)
addfiletocollection("gamecore\brass\brass"+str$(num)+"\brass"+str$(num)+"_D2.dds")
gun(gunid).settings.brassobjmaster=brassobj

rem Setup gun with smoke images
num=gun(gunid).settings.smoke
if len(gun(gunid).settings.smokedecal$)>0
 smoke$="gamecore\decals\"+gun(gunid).settings.smokedecal$+"\decal.tga"
 imgid=loadsmoke(smoke$)
else
 if num=0 then num=1
 rem FPSCV04RC9 0- replace smoke1 usage with gunsmoke usage (better visual)
 if num=1
  smoke$="gamecore\decals\gunsmoke\decal.tga"
 else
  smoke$="gamecore\decals\smoke"+str$(num)+"\decal.tga"
 endif
 imgid=loadsmoke(smoke$)
endif
gun(gunid).settings.smokeimg=imgid

rem Setup gun with crosshair
crosshair$="gamecore\guns\"+gun$+"\crosshair.tga"
crosshairimage=loadinternalimagecompressquality(crosshair$,5,1)
gun(gunid).settings.crosshairimg=crosshairimage
gun(gunid).secondobj=0

rem Load gun sounds (and companions)
for p=1 to 5
 if gunsound(gunid,p).name$<>""
  rem main sound for player
  snd$="gamecore\guns\"+gun$+"\"+gunsound(gunid,p).name$
  timestampactivity(0,"Loading Sound:"+snd$)
  gunsound(gunid,p).soundid=loadinternalsound(snd$)
  rem FPSCV104RC4 - extra sound value checks in many places
  if gunsound(gunid,p).soundid>0
   if sound exist(gunsound(gunid,p).soundid)=0
    gunsound(gunid,p).soundid=0
   endif
  endif
  rem companion sounds for other weapon sound uses
  if p<=3
   gunsoundcompanion(gunid,p,0).soundid=loadinternalsoundcore(snd$,1)
   gunsoundcompanion(gunid,p,1).soundid=loadinternalsoundcore(snd$,1)
   gunsoundcompanion(gunid,p,2).soundid=loadinternalsoundcore(snd$,1)
  endif
 endif
next p

rem Load HUD image (ammo and weapon selected image)
img$="gamecore\guns\"+gun$+"\hud_icon.tga" : addfiletocollection(img$)
gun(gunid).hudimage=loadinternalimagecompressquality(img$,5,1)

rem Find and store flak index for later use
if gun(gunid).settings.flakname$<>""
 flak$=gun(gunid).settings.flakname$ : gosub _flak_findindex
 gun(gunid).settings.flakindex=tindex
endif

return

_gun_freeafterlevel:
 `
 rem Free the old gun
 autoloadgun=0 : gosub _gun_change
 `
return

_gun_scaninall:

rem Scan entire guns folder
gosub _gun_scaninall_ref

rem Load all guns
for gunid=1 to gunmax
 gun$=gun(gunid).name$ : gosub _gun_load
next gunid

return

_gun_scaninall_dataonly:
 for gunid=1 to gunmax
  gun$=gun(gunid).name$ : gosub _gun_loaddata
 next gunid
return


`
` Particles
`


_particles_control:

rem Handle any debris
for p=1 to 32
 if debris(p)>0
  if debris(p)<=38 then show particles p
  if debris(p)<=37 then set particle emissions p,0
  debris(p)=debris(p)-1
  if debris(p)=0
   hide particles p
  endif
 endif
next p

return


rem
rem Waypoint Core Functions
rem

`
` Subroutines for waypoint system
`

_waypoint_savedata:

rem Save list
if file exist("mapbank\testmap\map.way")=1 then delete file "mapbank\testmap\map.way"
open to write 1,"mapbank\testmap\map.way"
 rem strands
 write file 1,waypointmax
 if waypointmax>0
  for w=1 to waypointmax
   a=waypoint(w).count : write file 1,a
   a=waypoint(w).start : write file 1,a
   a=waypoint(w).finish : write file 1,a
  next w
 endif
 rem coords
 write file 1,waypointcoordmax
 if waypointcoordmax>0
  for w=1 to waypointcoordmax
   a#=waypointcoord(w).x : write float 1,a#
   a#=waypointcoord(w).y : write float 1,a#
   a#=waypointcoord(w).z : write float 1,a#
   a=waypointcoord(w).link : write file 1,a
   a=waypointcoord(w).index : write file 1,a
  next w
 endif
close file 1

return

_waypoint_loaddata:

rem Free any old
gosub _waypoint_deleteall

rem load list
if file exist(levelmapptah$+"\map.way")=1
 filename$=levelmapptah$+"map.way"
 open to read 1,filename$
  rem strands
  read file 1,waypointmax
  if waypointmax>0
   undim waypoint()
   dim waypoint(waypointmax+1) as waypointtype
   for w=1 to waypointmax
    read file 1,a : waypoint(w).count=a
    read file 1,a : waypoint(w).start=a
    read file 1,a : waypoint(w).finish=a
   next w
  endif
  rem coords
  read file 1,waypointcoordmax
  if waypointcoordmax>0
   undim waypointcoord()
   dim waypointcoord(waypointcoordmax+1) as waypointcoordtype
   for w=1 to waypointcoordmax
    read float 1,a# : waypointcoord(w).x=a#
    read float 1,a# : waypointcoord(w).y=a#
    read float 1,a# : waypointcoord(w).z=a#
    read file 1,a : waypointcoord(w).link=a
    read file 1,a : waypointcoord(w).index=a
   next w
  endif
 close file 1
endif

rem also ensure data is not pointing to larger arrays than we have (old legacy editing rogue data)
if waypointmax>0
 for waypointindex=1 to waypointmax
  if waypoint(waypointindex).count>0
   if waypoint(waypointindex).start>waypointcoordmax or waypoint(waypointindex).finish>waypointcoordmax
    rem waypoint indexes exceed current arrays - diable waypoint
    waypoint(waypointindex).count=0
    waypoint(waypointindex).start=0
    waypoint(waypointindex).finish=0
   endif
  endif
 next waypointindex
 for w=1 to waypointcoordmax
  if waypointcoord(w).link>waypointcoordmax
   waypointcoord(w).link=0
  endif
  if waypointcoord(w).index>waypointmax
   waypointcoord(w).index=0
  endif
 next w
endif

return

_waypoint_recreateobjs:
 for waypointindex=1 to waypointmax
  if waypoint(waypointindex).count>0
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
  endif
 next waypointindex
return

_waypoint_createnew:

rem Create a new waypoint strand (or find empty one)
for tw=1 to waypointmax
 if waypoint(tw).count=0
  waypointindex=tw : exit
 endif
next tw
if tw>waypointmax
 inc waypointmax
 dim waypoint(waypointmax)
 waypointindex=waypointmax
endif
`
rem Do the creatin
waypoint(waypointindex).count=1
inc waypointcoordmax
w=waypointcoordmax
dim waypointcoord(waypointcoordmax)
waypoint(waypointindex).start=w
waypoint(waypointindex).finish=w
waypointcoord(w).x=mx#
waypointcoord(w).y=(gridlayer*100.0)+5
waypointcoord(w).z=mz#
waypointcoord(w).index=waypointindex
`if waypointindex<=10 `odd - 210105
 if gdontcreatewaypointobjects=0
  if waypoint(waypointindex).count>0
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
  endif
 endif
`endif

rem Create highlight sphere for easier selection
if gdontcreatewaypointobjects=0
 if object exist(editorwaypointoffset+0)=0
  make object sphere editorwaypointoffset+0,25
  set object collision off editorwaypointoffset+0
  ghost object on editorwaypointoffset+0
  set object transparency editorwaypointoffset+0,2
  disable object zread editorwaypointoffset+0
  hide object editorwaypointoffset+0
 endif
endif

return

_waypoint_createallobjs:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if gdontcreatewaypointobjects=0
   if waypoint(waypointindex).count>0
    createwaypointobj(obj,waypointindex)
   else
    if object exist(obj)=1 then delete object obj
   endif
  endif
 next waypointindex
return

_waypoint_deleteall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then delete object obj
 next waypointindex
 waypointmax=0
 waypointcoordmax=0
return

_waypoint_hideall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then hide object obj
 next waypointindex
return

_waypoint_showall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then show object obj
 next waypointindex
return

_waypoint_mousemanage:

rem Grid the waypoint coordinate input
mx#=int(mx#/5)*5 : mz#=int(mz#/5)*5

rem Simply find waypoint over cursor
waypointiovercursor=0
waypointindexovercursor=0
for twaypointindex=1 to waypointmax
 if waypoint(twaypointindex).count>0
  tbest#=9999 : tbestwaypointindex=0 : tbestwaypointiovercursor=0
  for w=waypoint(twaypointindex).start to waypoint(twaypointindex).finish
   dx#=abs(mx#-waypointcoord(w).x)
   dz#=abs(mz#-waypointcoord(w).z)
   tdd#=sqrt((dx#*dx#)+(dz#*dz#))
   if tdd#<20 and abs(waypointeditheight#-waypointcoord(w).y)<20
    if tdd#<tbest#
     tbest#=tdd# : tbestwaypointindex=twaypointindex : tbestwaypointiovercursor=w
    endif
   endif
  next w
  if tbest#<9999
   if tbestwaypointiovercursor<>0
    waypointindexovercursor=tbestwaypointindex
    waypointiovercursor=tbestwaypointiovercursor
    exit
   endif
  endif
 endif
next twaypointindex

rem mclickdone is for singlr mouse clicks
mclickdone=0
if mclick=0 then mclickpressed=0
if mclick>0 and mclickpressed=0 then mclickdone=mclick : mclickpressed=1

rem Move existing new waypoint
if mclick>0
 `
 if onedrag=0
  rem Find waypoint
  if waypointiovercursor>0 and waypointindexovercursor>0
   onedrag=waypointiovercursor : onedragmode=mclick : onedragx#=mx# : onedragz#=mz#
   waypointindex=waypointindexovercursor
  endif
 else
  rem Drag waypoint around
  if onedragmode=1 and (mx#<>onedragx# or mz#<>onedragz#)
   w=onedrag
   waypointcoord(w).x=mx#
   waypointcoord(w).y=waypointeditheight#
   waypointcoord(w).z=mz#
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
   rem Drag linked waypoint too
   linkto=waypointcoord(w).link
   if linkto>0
    waypointcoord(linkto).x=mx#
    waypointcoord(linkto).y=waypointeditheight#
    waypointcoord(linkto).z=mz#
    for twayp=1 to waypointmax
     for w=waypoint(twayp).start to waypoint(twayp).finish
      if w=linkto then createwaypointobj(editorwaypointoffset+twayp,twayp)
     next w
    next twayp
   endif
  endif
 endif
else
 rem Release waypoint
 if onedrag>0
  if onedragmode=1
   rem Glue if waypoint is linked to other waypoint
   for twayp=1 to waypointmax
    if twayp<>waypointindex
     for w=waypoint(twayp).start to waypoint(twayp).finish
      clipx1=int(mx#/20)
      clipz1=int(mz#/20)
      clipx2=int(waypointcoord(w).x/20)
      clipz2=int(waypointcoord(w).z/20)
      if clipx1=clipx2 and abs(waypointcoord(w).y-waypointeditheight#)<20 and clipz1=clipz2
       if waypointcoord(w).link=0
        waypointcoord(onedrag).link=w : waypointcoord(w).link=onedrag
        createwaypointobj(editorwaypointoffset+twayp,twayp)
        exit
       endif
      endif
     next w
    endif
   next twayp
  else
   rem Detatch if waypoint is linked
   if waypointcoord(onedrag).link>0
    linkto=waypointcoord(onedrag).link
    waypointcoord(linkto).x=waypointcoord(linkto).x+10
    waypointcoord(linkto).z=waypointcoord(linkto).z+10
    waypointcoord(onedrag).x=waypointcoord(onedrag).x
    waypointcoord(onedrag).z=waypointcoord(onedrag).z
    waypointcoord(onedrag).link=0
    waypointcoord(linkto).link=0
   endif
   for twayp=1 to waypointmax
    for w=waypoint(twayp).start to waypoint(twayp).finish
     if w=onedrag then createwaypointobj(editorwaypointoffset+twayp,twayp) : exit
     if w=linkto then createwaypointobj(editorwaypointoffset+twayp,twayp) : exit
    next w
   next twayp
  endif
 endif
 onedrag=0
endif

rem Delete last waypoint selected
if inputsys.keyshift=1 and mclickdone=2 and waypointiovercursor>0
 rem Delete waypoint
 w=waypointiovercursor
 if w=waypoint(waypointindex).start
  rem delete whole waypoint
  tsize0=0+waypoint(waypointindex).finish-waypoint(waypointindex).start
  tsize1=1+waypoint(waypointindex).finish-waypoint(waypointindex).start
  while w<waypointcoordmax-tsize0
   waypointcoord(w).x=waypointcoord(w+tsize1).x
   waypointcoord(w).y=waypointcoord(w+tsize1).y
   waypointcoord(w).z=waypointcoord(w+tsize1).z
   waypointcoord(w).link=waypointcoord(w+tsize1).link
   waypointcoord(w).index=waypointcoord(w+tsize1).index
   inc w
  endwhile
  for tw=w to w+tsize0
   waypointcoord(tw).x=0
   waypointcoord(tw).y=0
   waypointcoord(tw).z=0
   waypointcoord(tw).link=0
   waypointcoord(tw).index=0
  next tw
  dec waypointcoordmax,tsize1
  w=waypointiovercursor+tsize0
  for twayp=1 to waypointmax
   if twayp<>waypointindex
    if w<waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start-tsize1
    if w<waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish-tsize1
   endif
  next twayp
  rem delete wayppint-sequence itself
  waypoint(waypointindex).count=0
  waypoint(waypointindex).start=0
  waypoint(waypointindex).finish=0
 else
  rem delete node from waypoint
  w=waypointiovercursor
  while w<waypointcoordmax
   waypointcoord(w).x=waypointcoord(w+1).x
   waypointcoord(w).y=waypointcoord(w+1).y
   waypointcoord(w).z=waypointcoord(w+1).z
   waypointcoord(w).link=waypointcoord(w+1).link
   waypointcoord(w).index=waypointcoord(w+1).index
   inc w
  endwhile
  waypointcoord(w).x=0
  waypointcoord(w).y=0
  waypointcoord(w).z=0
  waypointcoord(w).link=0
  waypointcoord(w).index=0
  dec waypointcoordmax
  waypoint(waypointindex).count=waypoint(waypointindex).count-1
  waypoint(waypointindex).finish=waypoint(waypointindex).finish-1
  w=waypointiovercursor
  for twayp=1 to waypointmax
   for tw=waypoint(twayp).start to waypoint(twayp).finish
    if w<waypointcoord(tw).link then waypointcoord(tw).link=waypointcoord(tw).link-1
   next tw
   if twayp<>waypointindex
    if w<waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start-1
    if w<waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish-1
   endif
  next twayp
 endif
 if waypoint(waypointindex).count>0
  createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
 else
  if object exist(editorwaypointoffset+waypointindex)=1
   delete object editorwaypointoffset+waypointindex
  endif
 endif
 waypointiovercursor=0
 mdoubleclick=0
 onedragmode=0
 onedrag=0
endif

rem Insert waypoint at selected
if inputsys.keyshift=1 and mclickdone=1 and waypointiovercursor>0
 w=waypointiovercursor+1
 if w>=waypointcoordmax
  rem at end
  inc waypointcoordmax
  dim waypointcoord(waypointcoordmax)
  w=waypointcoordmax
 else
  rem shuffle
  inc waypointcoordmax
  dim waypointcoord(waypointcoordmax)
  w=waypointcoordmax
  while w>waypointiovercursor+1
   waypointcoord(w).x=waypointcoord(w-1).x
   waypointcoord(w).y=waypointcoord(w-1).y
   waypointcoord(w).z=waypointcoord(w-1).z
   waypointcoord(w).link=waypointcoord(w-1).link
   waypointcoord(w).index=waypointcoord(w-1).index
   dec w
  endwhile
  w=waypointiovercursor+1
 endif
 waypointcoord(w).x=waypointcoord(w-1).x+10
 waypointcoord(w).y=waypointcoord(w-1).y
 waypointcoord(w).z=waypointcoord(w-1).z+10
 waypointcoord(w).link=0
 waypointcoord(w).index=waypointindex
 waypoint(waypointindex).count=waypoint(waypointindex).count+1
 waypoint(waypointindex).finish=waypoint(waypointindex).finish+1
 for twayp=1 to waypointmax
  if twayp<>waypointindex
   if w<=waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start+1
   if w<=waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish+1
  endif
  for tw=waypoint(twayp).start to waypoint(twayp).finish
   if waypointcoord(tw).link>0
    if w<=waypointcoord(tw).link then waypointcoord(tw).link=waypointcoord(tw).link+1
   endif
  next tw
 next twayp
 if waypoint(waypointindex).count>0
  createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
 else
  if object exist(editorwaypointoffset+waypointindex)=1
   delete object editorwaypointoffset+waypointindex
  endif
 endif
 waypointiovercursor=0
 onedragmode=0
 onedrag=0
endif

rem Show selected waypoint
if object exist(editorwaypointoffset+0)=1
 if waypointiovercursor>0
  w=waypointiovercursor
  position object editorwaypointoffset+0,waypointcoord(w).x,waypointcoord(w).y,waypointcoord(w).z
  show object editorwaypointoffset+0
 else
  hide object editorwaypointoffset+0
 endif
endif

return


`
` Function to build waypoint object
`


function createwaypointobj(obj,waypointindex)
if obj<=editorwaypointoffsetmax
 if waypoint(waypointindex).count>0
  polycount=((waypoint(waypointindex).count-1)*2)+(waypoint(waypointindex).count*2)
  makepolymesh(obj,polycount)
  w=waypoint(waypointindex).start
  fwx#=waypointcoord(w).x
  fwy#=waypointcoord(w).y+6
  fwz#=waypointcoord(w).z
  polyindex=0
  diffuse as DWORD
  rem lines
  for w=waypoint(waypointindex).start+1 to waypoint(waypointindex).finish
   wx#=waypointcoord(w).x
   wy#=waypointcoord(w).y+6
   wz#=waypointcoord(w).z
   wa#=atanfull(wx#-fwx#,wz#-fwz#)-90
   pwa#=wa# : fwa#=wa#
   fade#=1.0-(abs(waypointcoord(w).y-waypointeditheight#)/500.0)
   tcolorcycle=waypointcoord(w).index-((waypointcoord(w).index/6)*6)
   if tcolorcycle=0 then diffuse=rgb(0*fade#,0*fade#,155*fade#)
   if tcolorcycle=1 then diffuse=rgb(155*fade#,0,0)
   if tcolorcycle=2 then diffuse=rgb(0,155*fade#,0)
   if tcolorcycle=3 then diffuse=rgb(155*fade#,155*fade#,0)
   if tcolorcycle=4 then diffuse=rgb(155*fade#,0,155*fade#)
   if tcolorcycle=5 then diffuse=rgb(0,155*fade#,155*fade#)
   if w=waypoint(waypointindex).start+1 then lastdiffuse=diffuse
   c1x#=newxvalue(fwx#,fwa#,5) : c1z#=newzvalue(fwz#,fwa#,5) : c1y#=fwy#
   c2x#=newxvalue(fwx#,fwa#,-5) : c2z#=newzvalue(fwz#,fwa#,-5) : c2y#=fwy#
   c3x#=newxvalue(wx#,pwa#,5) : c3z#=newzvalue(wz#,pwa#,5) : c3y#=wy#
   c4x#=newxvalue(wx#,pwa#,-5) : c4z#=newzvalue(wz#,pwa#,-5) : c4y#=wy#
   addpolytomesh(obj,polyindex+0,lastdiffuse,diffuse,diffuse,c1x#,c1y#,c1z#,c3x#,c3y#,c3z#,c4x#,c4y#,c4z#)
   addpolytomesh(obj,polyindex+1,lastdiffuse,lastdiffuse,diffuse,c2x#,c2y#,c2z#,c1x#,c1y#,c1z#,c4x#,c4y#,c4z#)
   fwx#=wx# : fwy#=wy# : fwz#=wz# : fwa#=wa# : lastdiffuse=diffuse : inc polyindex,2
  next w
  rem stars
  for w=waypoint(waypointindex).start to waypoint(waypointindex).finish
   wx#=waypointcoord(w).x
   wy#=waypointcoord(w).y+6
   wz#=waypointcoord(w).z
   if waypointcoord(w).link>0
    if abs(waypointcoord(w).y-waypointeditheight#)<50
     diffuse=rgb(0,255,255)
    else
     diffuse=rgb(0,128,128)
    endif
   else
    if abs(waypointcoord(w).y-waypointeditheight#)<50
     diffuse=rgb(255,255,0)
    else
     diffuse=rgb(255,0,0)
    endif
   endif
   if w=waypoint(waypointindex).start then tsize#=1.5 else tsize#=1.0
   c1x#=newxvalue(wx#,55,8*tsize#) : c1z#=newzvalue(wz#,55,8*tsize#) : c1y#=wy#
   c2x#=newxvalue(wx#,-55,8*tsize#) : c2z#=newzvalue(wz#,-55,8*tsize#) : c2y#=wy#
   c3x#=newxvalue(wx#,180,10*tsize#) : c3z#=newzvalue(wz#,180,10*tsize#) : c3y#=wy#
   c4x#=newxvalue(wx#,235,8*tsize#) : c4z#=newzvalue(wz#,235,8*tsize#) : c4y#=wy#
   c5x#=newxvalue(wx#,125,8*tsize#) : c5z#=newzvalue(wz#,125,8*tsize#) : c5y#=wy#
   c6x#=newxvalue(wx#,0,10*tsize#) : c6z#=newzvalue(wz#,0,10*tsize#) : c6y#=wy#
   addpolytomesh(obj,polyindex+0,diffuse,diffuse,diffuse,c1x#,c1y#,c1z#,c2x#,c2y#,c2z#,c3x#,c3y#,c3z#)
   addpolytomesh(obj,polyindex+1,diffuse,diffuse,diffuse,c4x#,c4y#,c4z#,c5x#,c5y#,c5z#,c6x#,c6y#,c6z#)
   inc polyindex,2
  next w
  finalisepolymesh(obj)
 else
  if object exist(obj)=1 then delete object obj
 endif
endif
endfunction

function makepolymesh(obj,polycount)
 `
 rem Free old memblock
 memblock=1 : if memblock exist(1)=1 then delete memblock 1
 `
 rem Make a Simple Cube Mesh Memblock
 headersize=12 : fvf=338 : vertsize=36 : verts=polycount*3
 memsize=headersize+(vertsize*verts)
 make memblock 1,memsize
 `
 rem Set header info
 write memblock dword 1,0,fvf
 write memblock dword 1,4,vertsize
 write memblock dword 1,8,verts
 `
endfunction

function addpolytomesh(obj,polyindex,diffuse1 as DWORD,diffuse2 as DWORD,diffuse3 as DWORD,x1#,y1#,z1#,x2#,y2#,z2#,x3#,y3#,z3#)
 `
 rem Create vertex data (3 make a triangle polygon)
 diff as DWORD
 memblock=1 : vertsize=36
 for t=0 to 2
  `
  rem Corners of poly
  if t=0 then x#=x1#:y#=y1#:z#=z1# : diff=diffuse1
  if t=1 then x#=x2#:y#=y2#:z#=z2# : diff=diffuse2
  if t=2 then x#=x3#:y#=y3#:z#=z3# : diff=diffuse3
  v=(polyindex*3)+t
  `
  rem Position of vertex in memblock
  pos=12+(v*vertsize)
  `
  rem Create some random vertex data
  nx#=0 : ny#=1.0 : nz#=0
  `
  rem Set vertex position
  write memblock float 1,pos+0,x#
  write memblock float 1,pos+4,y#
  write memblock float 1,pos+8,z#
  `
  rem Set vertex normals
  write memblock float 1,pos+12,nx#
  write memblock float 1,pos+16,ny#
  write memblock float 1,pos+20,nz#
  `
  rem Set vertex diffuse
  write memblock dword 1,pos+24,diff
  `
  rem Set vertex texture UV coords
  write memblock float 1,pos+28,0
  write memblock float 1,pos+32,0
  `
 next t
 `
endfunction

function finalisepolymesh(obj)
 `
 rem Make a new object from the memblock
 if object exist(obj)=1 then delete object obj
 if mesh exist(2)=1 then delete mesh 2
 memblock=1 : make mesh from memblock 2,memblock
 make object obj,2,0 : set object obj,1,0,0,0,0,0,0
 texture object obj,editorimagesoffset+13
 set object transparency obj,2
 set object collision off obj
 disable object zdepth obj
 set object light obj,0
 ghost object on obj
 set object transparency obj,2
 disable object zread obj
 `
endfunction


rem
rem FUNCTIONS FOR LINKING EXES
rem

`
` FUNCTION TO LAUNCH BROWSER
`
function browseropen$(browsemode)

rem this way still used by segment editor
localdesc$=""
if segobjusedforsegeditor=1

 `
 ` FOR SEGMENT EDITOR
 `

 rem Clear result
 resultstring$=""

 rem Store directory
 curdir$=get dir$()

 rem Launch browser in freeze mode
 set dir rootdir$ : set dir ".."

 rem Run if not currently active
 if window exist(browsername$)=0
  execute file browserexe$,"",""
  while window exist(browsername$)=0
   sync
  endwhile
 else
  window to front browsername$
 endif

 rem Trigger it to provide correct cateogory for browse
 filemapname$=browsername$+"(ACTIVE)"
 write filemap value filemapname$,1
 filemapname$=browsername$+"(MODE)"
 write filemap value filemapname$,browsemode
 write filemap string filemapname$,strarr$(42)

 rem Switch this app to processor friendly
 sync off : always active off

 rem Must wait for response..
 filemapname$=browsername$+"(ACTIVE)"
 while read filemap value(filemapname$)<>2
 endwhile

 rem This app must wait for..
 tresult=0
 tresult$=""
 filemapname$=browsername$+"(RESULT)"
 while tresult=0
  if window exist(browsername$)=1
   window to front browsername$
   tresult=read filemap value(filemapname$)
  else
   exit
  endif
 endwhile

 rem Take action based on result
 if tresult=0 then resultstring$=""
 if tresult=1 then resultstring$=read filemap string(filemapname$)
 if tresult=2 then resultstring$=""

 rem Restore primary activity
 window to back browsername$
 window to front
 sync on : always active on : sync

 rem set directory to return string (or restore)
 if len(resultstring$)>0
  tfile$=getfile(resultstring$)
  tpath$=left$(resultstring$,len(resultstring$)-len(tfile$))
  set dir rootdir$ : set dir tpath$
  resultstring$=get dir$()+"\"+tfile$
 else
  set dir curdir$
 endif

else

`
` FOR MAP EDITOR
`

rem Prepare browse type settings
browsetype=browsemode
baseimagepath$=".\editors\gfx\browser\"
if browsetype=1
 browsetitle$=strarr$(43)
 baselib$=""
 baseimage$="all.bmp"
endif
if browsetype=2
 browsetitle$=strarr$(44)
 baselib$="texturebank\"
 baseimage$="texture.bmp"
endif
if browsetype=3
 browsetitle$=strarr$(45)
 baselib$="meshbank\"
 baseimage$="mesh.bmp"
endif
if browsetype=4
 browsetitle$=strarr$(46)
 baselib$="audiobank\"
 baseimage$="audio.bmp"
endif
if browsetype=5
 browsetitle$=strarr$(47)
 baselib$="effectbank\"
 baseimage$="effect.bmp"
endif
if browsetype=6
 browsetitle$=strarr$(48)
 baselib$="segments\"
 baseimage$="segment.bmp"
endif
if browsetype=7
 browsetitle$=strarr$(49)
 baselib$="prefabs\"
 baseimage$="prefab.bmp"
endif
if browsetype=8
 browsetitle$=strarr$(50)
 baselib$="mapbank\"
 baseimage$="map.bmp"
endif
if browsetype=9
 browsetitle$=strarr$(51)
 baselib$="entitybank\"
 baseimage$="entity.bmp"
endif

rem Assign filters to browse types
browseextcount=0
dim browseext$(64)
if browsetype=1
 browseext$(browseextcount+1)=".*"
 inc browseextcount,1
endif
if browsetype=2
 browseext$(browseextcount+1)="tga"
 inc browseextcount,1
endif
if browsetype=3
 browseext$(browseextcount+1)="x"
 inc browseextcount,1
endif
if browsetype=4
 browseext$(browseextcount+1)="wav"
 browseext$(browseextcount+2)="mp3"
 inc browseextcount,2
endif
if browsetype=5
 browseext$(browseextcount+1)="fx"
 inc browseextcount
endif
if browsetype=6
 browseext$(browseextcount+1)="fps"
 inc browseextcount
endif
if browsetype=7
 browseext$(browseextcount+1)="fpp"
 inc browseextcount
endif
if browsetype=8
 browseext$(browseextcount+1)="fpm"
 inc browseextcount
endif
if browsetype=9
 browseext$(browseextcount+1)="fpe"
 inc browseextcount
endif

rem Build extension string (ie .wav,.mp3)
extstring$=""
for t=1 to browseextcount
 if t>1 then extstring$=extstring$+","
 extstring$=extstring$+browseext$(t)
next t

rem Call up browser dialog
set file map string$ 1, 1000, rootdir$+"\"+baselib$
set file map string$ 1, 1256, browsetitle$

rem File Filter
set file map string$ 1, 1768,extstring$

rem Default image if no thumbnail found
set file map string$ 1, 2024, rootdir$+"\"+baseimagepath$+baseimage$

rem Window Title
set file map string$ 1, 2280, browsetitle$

rem Set last location for navigation
if browserfolderhistory$(browsetype)<>""
 set file map string$ 1, 2536, browserfolderhistory$(browsetype)
endif

rem Wait for dialog session to end
set file map dword 1, 800, 1
wait for file map event 1
while get file map dword(1,800)=1
 wait for file map event 1
endwhile

rem localized description of selection
localdesc$=get file map string$( 1, 1768 )

rem return string from browser dialog
set dir rootdir$
resultstring$=get file map string$( 1, 1512 )
if resultstring$<>""
 rem Final return string
 rem Store location as we leave browser
 resultstring$=right$(resultstring$,len(resultstring$)-len(rootdir$+"\"))
 browserfolderhistory$(browsetype)=right$(resultstring$,len(resultstring$)-len(baselib$))
 resultstring$=get dir$()+"\"+resultstring$
else
 rem No return string
endif

rem Seg Or Map Browser version
endif

endfunction resultstring$

`
` FUNCTION TO LAUNCH SEGEDIT (INDEPENDENT TOOL)
`
function segedit$(segeditmode)

rem Clear result
resultstring$=""

rem Store directory
curdir$=get dir$()

rem Launch in freeze mode
set dir rootdir$ : set dir ".."

rem Run if not currently active
if window exist(segeditname$)=0
 execute file segeditexe$,"",""
 while window exist(segeditname$)=0
  sync
 endwhile
else
 window to front segeditname$
endif

endfunction

rem
rem FLAK
rem

_flak_init:

rem Load in all flak
gosub _flak_scaninall

rem Start with no flak
flakid=0

return

_flak_loaddata:

dim data$(100)
filename$="gamecore\flak\"+flak$+"\flakspec.txt"
load array filename$,data$()
addfiletocollection(filename$)
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem flak START
   if field$="throwangle" then flak(flakid).throwangle=value1
   if field$="throwforward" then flak(flakid).throwforward=value1
   if field$="throwheight" then flak(flakid).throwheight=value1
   `
   rem flak MOVEMENT
   if field$="lifespan" then flak(flakid).profile.lifespan=value1
   if field$="yinc" then flak(flakid).profile.yinc=value1
   if field$="zinc" then flak(flakid).profile.zinc=value1
   if field$="xspeed" then flak(flakid).profile.xspeed=1.0+(value1/1000.0)
   if field$="yspeed" then flak(flakid).profile.yspeed=1.0+(value1/1000.0)
   if field$="zspeed" then flak(flakid).profile.zspeed=1.0+(value1/1000.0)
   if field$="weight" then flak(flakid).profile.weight=value1/1000.0
   if field$="spinx" then flak(flakid).profile.spinx=value1/10.0
   if field$="bounceonhit" then flak(flakid).profile.bounceonhit=value1
   if field$="explodeonhit" then flak(flakid).profile.explodeonhit=value1
   if field$="damage" then flak(flakid).profile.damage=value1
   `
   rem flak EXPLOSION
   if field$="exponfloor" then flak(flakid).exponfloor$=value$
   if field$="expinair" then flak(flakid).expinair$=value$
   `
   rem flak SOUND
   if field$="sndbounce" then flak(flakid).sound.sndbounce$=value$
   if field$="sndexplode" then flak(flakid).sound.sndexplode$=value$
   `
  endif
 endif
next l
undim data$()

return

_flak_load:

rem Load flak data
gosub _flak_loaddata

rem Load flak models
currentflakobj=loadflak("gamecore\flak\"+flak$+"\PROJECTILE.x")
flak(flakid).obj=currentflakobj

rem Effect on projectiles
`if guseeffectongunsstate=0 `lee, currently no NORMAL MAPS for projectiles!
if 1
 `
 rem Base texture for fast moving projectiles
 img$="gamecore\flak\"+flak$+"\projectile_D2.tga" : imgD2id=loadinternalimage(img$)
 texture object currentflakobj,imgD2id
 `
else
 `
 rem Load Effect
 tfile$="effectbank\BumpCubeReflectAlpha\BumpCubeReflectAlpha.fx"
 debugfilename(tfile$,"effect for flak")
 teffectid=loadinternaleffect(tfile$)
 `
 rem First Textures are PLATES
 img$="gamecore\flak\"+flak$+"\flak_D.tga" : imgDid=loadinternalimage(img$)
 img$="gamecore\flak\"+flak$+"\flak_N.tga" : imgNid=loadinternalimage(img$)
 img$="gamecore\flak\"+flak$+"\flak_R.tga" : imgRid=loadinternalimage(img$)
 `
 rem Last Texture Image is CUBE
 img$="gamecore\flak\"+flak$+"\flak_cube.dds" : imgCUBEid=loadinternalimage(img$)
 if file exist(img$)=1 then load image img$,imgCUBEid,2
 addfiletocollection(img$)
 `
 rem Bump Quality
 texture object currentflakobj,0,imgDid
 texture object currentflakobj,1,imgNid
 texture object currentflakobj,2,imgRid
 texture object currentflakobj,3,imgCUBEid
 `
 rem Apply effect to object
 set object effect currentflakobj,teffectid
 `
endif

rem Setup flak for correct visuals
set object transparency currentflakobj,1
disable object zdepth currentflakobj

rem Setup flak for animation
set object speed currentflakobj,45
loop object currentflakobj

rem Find Explosion for this flak
decal$=flak(flakid).exponfloor$ : gosub _decal_find : flak(flakid).exponfloorid=decalid : if decalid>0 then decal(decalid).active=1
decal$=flak(flakid).expinair$ : gosub _decal_find : flak(flakid).expinairid=decalid : if decalid>0 then decal(decalid).active=1

rem Load sounds into bank
flak(flakid).sound.sndbounceid=loadinternalsoundcore("gamecore\flak\"+flak$+"\"+flak(flakid).sound.sndbounce$,1)
flak(flakid).sound.sndexplodeid=loadinternalsoundcore("gamecore\flak\"+flak$+"\"+flak(flakid).sound.sndexplode$,1)

return

_flak_scaninall_ref:

rem Scan entire flaks folder
set dir "gamecore" : flakid=1
empty array filelist$()
buildfilelist("flak","")
set dir ".."
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   if lower$(right$(file$,12))="projectile.x"
    if flakid>flakmax
     flakmax=flakid
     dim flak(flakmax) as flaktype
    endif
    flak(flakid).name$=left$(file$,len(file$)-13)
    inc flakid
   endif
  endif
 next chkfile
endif

return

_flak_scaninall_dataonly:
 for flakid=1 to flakmax
  flak$=flak(flakid).name$
  gosub _flak_loaddata
 next flakid
return

_flak_scaninall:

rem Scan entire flaks folder
gosub _flak_scaninall_ref

rem Load all flaks
for flakid=1 to flakmax
 flak$=flak(flakid).name$
 gosub _flak_load
next flakid

return

_flak_findindex:
 tindex=-1
 for flakid=1 to flakmax
  if flak$=flak(flakid).name$
   tindex=flakid : exit
  endif
 next flakid
return

`
` FLAK ELEMENTS HANDLING
`

_flakelement_create:

for tf=1 to flakelementmax
 if flakelement(tf).active=0 then exit
next tf
if tf<flakelementmax
 rem found free flak element
 flakelement(tf).flakid=flakid
 flakelement(tf).profile=flak(flakid).profile
 rem activate new flak element
 flakelement(tf).active=1
 flakelement(tf).range=0
 flakelement(tf).xpos=flakx
 flakelement(tf).ypos=flaky
 flakelement(tf).zpos=flakz
 flakelement(tf).owner=flakowner
 rem create projectile
 flakelement(tf).obj=flakelementoffset+tf
 tfobj=flakelement(tf).obj
 if object exist(tfobj)=1 then delete object tfobj
 instance object tfobj,flak(flakid).obj
 rem use ORIENT to get correct rotation and intertias
 if flakowner=0
  set object to camera orientation tfobj
 else
  rotate object tfobj,flakpitch,flakangle,0
 endif
 move object tfobj,flakelement(tf).profile.zinc
 flakelement(tf).profile.xinc=object position x(tfobj)*2
 flakelement(tf).profile.yinc=flakelement(tf).profile.yinc+(object position y(tfobj)*2)
 flakelement(tf).profile.zinc=object position z(tfobj)*2
 flakelement(tf).xpos=flakelement(tf).xpos+(flakelement(tf).profile.xinc*flakspeed#)
 flakelement(tf).ypos=flakelement(tf).ypos+(flakelement(tf).profile.yinc*flakspeed#)
 flakelement(tf).zpos=flakelement(tf).zpos+(flakelement(tf).profile.zinc*flakspeed#)
 position object tfobj,99999,99999,99999
 rem show flak object
 show object tfobj
else
 rem no more free flak
endif

return

_flakelement_explodeinstantly:
 rem last tick before BANG! (tf from _flakelement_create)
 flakelement(tf).profile.lifespan=1
return

_flakelement_control:

rem update me vars
mex#=camera position x()
mey#=camera position y()
mez#=camera position z()

rem Control all flak activity
for f=1 to flakelementmax
 if flakelement(f).active=1
  rem update flak object (initial so we see starting position of flak)
  tobj=flakelement(f).obj
  tflakid=flakelement(f).flakid
  position object tobj,flakelement(f).xpos,flakelement(f).ypos,flakelement(f).zpos
  xrotate object tobj,object angle x(tobj)+flakelement(f).profile.spinx
  rem affect flak by inertia and gravity
  tmpx1#=flakelement(f).xpos : tmpy1#=flakelement(f).ypos : tmpz1#=flakelement(f).zpos
  flakelement(f).xpos=flakelement(f).xpos+flakelement(f).profile.xinc
  flakelement(f).ypos=flakelement(f).ypos+flakelement(f).profile.yinc
  flakelement(f).zpos=flakelement(f).zpos+flakelement(f).profile.zinc
  flakelement(f).profile.xinc=flakelement(f).profile.xinc/flakelement(f).profile.xspeed
  flakelement(f).profile.yinc=flakelement(f).profile.yinc/flakelement(f).profile.yspeed
  flakelement(f).profile.zinc=flakelement(f).profile.zinc/flakelement(f).profile.zspeed
  flakelement(f).profile.yinc=flakelement(f).profile.yinc-flakelement(f).profile.weight
  rem handle flak collision
  tdetonate=0 : tcollide=0
  rem handle timer delay
  if flakelement(f).profile.lifespan>0
   dec flakelement(f).profile.lifespan
   if flakelement(f).profile.lifespan=0
    tdetonate=1
   endif
  endif
  if tdetonate=0
   `
   rem if not zero-life
   if flakelement(f).ypos<0
    flakelement(f).profile.yinc=flakelement(f).profile.yinc*-0.9
    flakelement(f).ypos=0
    tcollide=1
   endif
   tmpx2#=tmpx1#+(flakelement(f).profile.xinc*3.0)
   tmpy2#=tmpy1#+(flakelement(f).profile.yinc*3.0)
   tmpz2#=tmpz1#+(flakelement(f).profile.zinc*3.0)
   if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
    `
    rem checklist now filled with collision feedback data
    flakelement(f).profile.xinc=checklist fvalue a(8)
    flakelement(f).profile.yinc=checklist fvalue b(8)
    flakelement(f).profile.zinc=checklist fvalue c(8)
    flakelement(f).profile.xinc=flakelement(f).profile.xinc*0.4
    flakelement(f).profile.yinc=flakelement(f).profile.yinc*0.6
    flakelement(f).profile.zinc=flakelement(f).profile.zinc*0.4
    flakelement(f).xpos=checklist fvalue a(6)+flakelement(f).profile.xinc
    flakelement(f).ypos=checklist fvalue b(6)+flakelement(f).profile.yinc
    flakelement(f).zpos=checklist fvalue c(6)+flakelement(f).profile.zinc
    tcollide=2
    `
    rem collision bounce requires orientation
    if flakelement(f).profile.bounceonhit>0
     point object tobj,flakelement(f).xpos+(flakelement(f).profile.xinc*10.0),flakelement(f).ypos+(flakelement(f).profile.yinc*10.0),flakelement(f).zpos+(flakelement(f).profile.zinc*10.0)
    endif
    `
    rem kill Y ineria if get too low
    if abs(flakelement(f).profile.yinc)<0.02
     flakelement(f).profile.spinx=0
     flakelement(f).profile.yinc=0
    endif
    `
   endif
   rem collides with entity in area
   spherex#=flakelement(f).xpos
   spherey#=flakelement(f).ypos
   spherez#=flakelement(f).zpos
   spherenx#=spherex#+flakelement(f).profile.xinc
   sphereny#=spherey#+flakelement(f).profile.yinc
   spherenz#=spherez#+flakelement(f).profile.zinc
   gosub _entity_spherecollision
   if spheree<>-1
    if flakelement(f).owner=spheree
     rem owners of flak are except
    else
     rem backtrack to leave collision
     flakelement(f).profile.xinc=flakelement(f).profile.xinc*-1
     flakelement(f).profile.zinc=flakelement(f).profile.zinc*-1
     flakelement(f).xpos=flakelement(f).xpos+flakelement(f).profile.xinc
     flakelement(f).ypos=flakelement(f).ypos+flakelement(f).profile.yinc
     flakelement(f).zpos=flakelement(f).zpos+flakelement(f).profile.zinc
     tcollide=1
    endif
   endif
   rem if shot BY entity, can collide with player
   if flakelement(f).owner<>0
    tx#=flakelement(f).xpos-mex#
    tz#=flakelement(f).zpos-mez#
    td#=sqrt(abs(tx#*tx#)+abs(tz#*tz#))
    ty#=abs(flakelement(f).ypos-mey#)
    if td#<30.0 and ty#<100.0 then tcollide=1
   endif
   rem complete collision code
   if tcollide>0
    if flakelement(f).profile.explodeonhit>0 or flakelement(f).profile.bounceonhit>0
     if flakelement(f).profile.bounceonhit>0 and flakelement(f).profile.explodeonhit=0
      flakelement(f).profile.bounceonhit=flakelement(f).profile.bounceonhit-1
      playinternal3dsound(flak(tflakid).sound.sndbounceid,tmpx1#,tmpy1#,tmpz1#)
     else
      rem detonate at last collision, add scorch
      tdetonate=1
     endif
    endif
   endif
   `
  endif
  rem detonate trigger
  if tdetonate=1
   rem trigger explosion
   flakelement(f).active=2
  endif
 endif
 if flakelement(f).active=2
  rem hide flak object
  hide object flakelement(f).obj
  rem trigger exploder
  frox#=flakelement(f).xpos
  froy#=flakelement(f).ypos
  froz#=flakelement(f).zpos
  gosub _part_triggerexplosion
  rem make sound seem louder by moving it closer to player
  playinternal3dsound(flak(tflakid).sound.sndexplodeid,decalx,decaly,decalz)
  rem ONLY affect decal with ZBIAS if explosion that needs to be seen by player in full
  if object exist(tobj)=1 then enable object zbias tobj,-500.0,0.0
  rem initial blast creates scorch (in six directions)
  for tscdir=1 to 6
   if tscdir=1 then t=static raycast(decalx+0,decaly,decalz,decalx-200,decaly,decalz)
   if tscdir=2 then t=static raycast(decalx+0,decaly,decalz,decalx+200,decaly,decalz)
   if tscdir=3 then t=static raycast(decalx,decaly+0,decalz,decalx,decaly-200,decalz)
   if tscdir=4 then t=static raycast(decalx,decaly+0,decalz,decalx,decaly+200,decalz)
   if tscdir=5 then t=static raycast(decalx,decaly,decalz+0,decalx,decaly,decalz-200)
   if tscdir=6 then t=static raycast(decalx,decaly,decalz+0,decalx,decaly,decalz+200)
   tsize#=45-rnd(30) : if t=1 then add static scorch tsize#,4+rnd(3)
  next tscdir
  rem initial blast creates light flash
  spotflash=100 : tx#=decalx : ty#=decaly : tz#=decalz
  tcolr=255
  tcolg=255
  tcolb=0
  gosub _lighting_spotflash
  rem start range of expanding explosion at zero
  flakelement(f).range=0
  rem create force of damage
  flakelement(f).active=3
  rem all entities that can take damage (characters, windows)
  tx#=flakelement(f).xpos : ty#=flakelement(f).ypos : tz#=flakelement(f).zpos
  spheredamage=flakelement(f).profile.damage
  spherex#=tx# : spherey#=ty# : spherez#=tz# : sphereforce#=1.0
  gosub _entity_addforcesphere
 endif
 if flakelement(f).active=3
  rem increase range as force expands
  flakelement(f).range=flakelement(f).range+10
  if flakelement(f).range>100
   flakelement(f).active=0
  endif
  rem detonate any other flak (other grenades)
  tx#=flakelement(f).xpos
  ty#=flakelement(f).ypos
  tz#=flakelement(f).zpos
  for sf=1 to flakelementmax
   if f<>sf and flakelement(sf).active=1
    tsx#=flakelement(sf).xpos-tx#
    tsy#=flakelement(sf).ypos-ty#
    tsz#=flakelement(sf).zpos-tz#
    d#=sqrt(abs(tsx#*tsx#)+abs(tsy#*tsy#)+abs(tsz#*tsz#))
    if d#<flakelement(f).range
     rem explode the flak
     flakelement(sf).active=2
     flakelement(sf).range=0
    endif
   endif
  next sf
 endif
 `
next f

return

`
` FUNCTIONS FOR FLAK
`

function loadflak(tfile$)
 index=0
 if flakbankmax>0
  for t=1 to flakbankmax
   if tfile$=flakbank$(t) then index=flakbankoffset+t : exit
  next t
 else
  t=flakbankmax+1
 endif
 if t>flakbankmax
  inc flakbankmax
  if file exist(tfile$)=1
   index=flakbankoffset+flakbankmax
   flakbank$(flakbankmax)=tfile$
   addfiletocollection(tfile$)
   load object tfile$,index
   yrotate object index,180
   fix object pivot index
   set object collision off index
   hide object index
  endif
 endif
endfunction index

rem
rem DECAL
rem

_decal_init:

rem Load in all decal
gosub _decal_scaninallref

rem Precreate elements as each is unique (UV writing)
for f=1 to decalelementmax
 tobj=decalelementoffset+f : decalelement(f).obj=tobj
 if object exist(tobj)=1 then delete object tobj
 make object plain tobj,100,100
 set object transparency tobj,2
 set object collision off tobj
 disable object zwrite tobj
 set object texture tobj,0,0
 set object light tobj,0
 set object cull tobj,0
 hide object tobj
next f

return

_decal_loaddata:

dim data$(100)
filename$="gamecore\decals\"+decal$+"\decalspec.txt"
addfiletocollection(filename$)
load array filename$,data$()
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem decal
   if field$="across" then decal(decalid).across=value1
   if field$="down" then decal(decalid).down=value1
   if field$="offsety" then decal(decalid).offsety=value1
   if field$="scale" then decal(decalid).scale=value1
   `
  endif
 endif
next l
undim data$()

rem default scale is 100
if decal(decalid).scale=0 then decal(decalid).scale=100

rem Some pre-game calculations
decal(decalid).framemax=decal(decalid).across*decal(decalid).down

return

_decal_load:

rem Load decal data
gosub _decal_loaddata

rem Load decal image and store name in bank
loaddecal("gamecore\decals\"+decal$+"\decal.tga",decalid)

return

_decal_scaninallref:

rem Scan entire decals folder
set dir "gamecore" : decalid=1
empty array filelist$()
buildfilelist("decals","")
set dir ".."
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   tryfile$=lower$(right$(file$,9))
   if left$(tryfile$,len(tryfile$)-4)="decal"
    newdecal$=left$(file$,len(file$)-10)
    for tdecalid=1 to decalmax
     if decal(tdecalid).name$=newdecal$ then exit
    next tdecalid
    if tdecalid>decalmax
     if decalid>decalmax
      decalmax=decalid
      dim decal(decalmax) as decaltype
     endif
     decal(decalid).name$=newdecal$
     inc decalid
    endif
   endif
  endif
 next chkfile
endif
decalmax=decalid-1

return

_decal_scaninall:

rem Load all decal data list in
gosub _decal_scaninallref

rem Load all decals
for decalid=1 to decalmax
 decal$=decal(decalid).name$
 decal(decalid).active=1
 gosub _decal_load
next decalid

return

_decal_loadonlyactivedecals:

rem Load all decals that have been activated
for decalid=1 to decalmax
 if decal(decalid).active=1
  decal$=decal(decalid).name$
  gosub _decal_load
 endif
next decalid

return

`
` decal ELEMENTS HANDLING
`

_decalelement_create:

for d=1 to decalelementmax
 if decalelement(d).active=0 then exit
next d
if d<decalelementmax
 rem activate new decal element
 currentdecald=d
 decalelement(d).decalid=decalid
 decalelement(d).active=1
 decalelement(d).xpos=decalx
 decalelement(d).ypos=decaly
 decalelement(d).zpos=decalz
 decalelement(d).frame=0
 decalelement(d).orient=decalorient
 decalelement(d).originator=originatore
 rem prepare decal object
 tobj=decalelement(d).obj
 ty=decal(decalid).offsety
 position object tobj,decalelement(d).xpos,decalelement(d).ypos+ty,decalelement(d).zpos
 rem face camera or leave as is
 if decalelement(d).orient=0
  point object tobj,camera position x(),camera position y(),camera position z()
  xrotate object tobj,0 : zrotate object tobj,0
 endif
 if decalelement(d).orient=1
  rotate object tobj,decalorientx#,decalorienty#,decalorientz#
 endif
 if decalelement(d).orient=2
  rotate object tobj,90,0,0
 endif
 if decalelement(d).orient=3
  point object tobj,camera position x(),camera position y(),camera position z()
 endif
 if decalelement(d).orient=4
  point object tobj,camera position x(),camera position y(),camera position z()
  move object tobj,5.0
 endif
 enable object zbias tobj,0.0,0.0
 rem texture for this decal type
 texture object tobj,decal(decalid).imageid
 rem scale the decal
 if decalscalemodx=0
  decalelement(d).scalemodx=decal(decalid).scale
  decalelement(d).scalemody=decal(decalid).scale
 else
  decalelement(d).scalemodx=decalscalemodx
  decalelement(d).scalemody=decalscalemody
 endif
 scale object tobj,decalelement(d).scalemodx,decalelement(d).scalemody,100
 rem show decal object
 show object tobj
else
 tobj=0
endif

return

_decalelement_continue:
 `
 rem decal is looping, merely need to continue the current decal
 d=currentdecald
 if d>0 and decalelement(d).originator=originatore
  rem simply reset decal
  decalelement(d).frame=0
 else
  rem different, so recreate
  gosub _decalelement_create
 endif
 `
return

_decalelement_control:

rem Control all decal activity
for f=1 to decalelementmax
 if decalelement(f).active=1
  rem update decal object
  tobj=decalelement(f).obj : tdetonate=0
`  rem if decal not in visible screen, destroy for performance - off no code
  if tdetonate=0
   rem animation
   decalid=decalelement(f).decalid
   if decalelement(f).frame<decal(decalid).framemax-1
    rem next frame
    decalelement(f).framedelay=decalelement(f).framedelay+1
    if decalelement(f).framedelay>0
     decalelement(f).framedelay=0
     decalelement(f).frame=decalelement(f).frame+1
    endif
   else
    rem no more animation
    tdetonate=1
   endif
   rem write UV for correct anim frame
   if object visible(tobj)=1 and object in screen(tobj)=1 and tdetonate=0
    rem rotate to face camera if flagged
    if decalelement(f).orient=0
     point object tobj,camera position x(),camera position y(),camera position z()
     xrotate object tobj,0 : zrotate object tobj,0
    endif
    if decalelement(f).orient=2
     set object cull tobj,1
    else
     set object cull tobj,0
    endif
    if decalelement(f).orient=3
     point object tobj,camera position x(),camera position y(),camera position z()
    endif
    rem animation UVs
    tframe=decalelement(f).frame
    ty=tframe/decal(decalid).across : tx=tframe-(ty*decal(decalid).across)
    q#=1.0/(decal(decalid).across+0.0) : tx#=tx*q# : ty#=ty*q#
    lock vertexdata for limb tobj,0,1
    set vertexdata uv 0,tx#+q#,ty#
    set vertexdata uv 1,tx#,ty#
    set vertexdata uv 2,tx#+q#,ty#+q#
    set vertexdata uv 3,tx#,ty#
    set vertexdata uv 4,tx#,ty#+q#
    set vertexdata uv 5,tx#+q#,ty#+q#
    unlock vertexdata
   endif
  endif
  rem detonate trigger
  if tdetonate=1
   hide object decalelement(f).obj
   decalelement(f).originator=0
   decalelement(f).active=0
  endif
 endif
next f

return

_decal_triggermaterialdebris:
 `
 rem takes tsoundmaterial,tsx#,tsy#,tsz#
 if tsoundmaterial>0
  decalid=material(tsoundmaterial-1).decalid
  if decalid>0
   rem create the decal for this event
   decalscalemodx=0 : rem FPSCV101 - fix
   decalorient=4 : decalx=tsx# : decaly=tsy# : decalz=tsz#
   originatore=-1 : gosub _decalelement_create
  endif
  rem FPSCV101 - add
  tsoundmaterial=0
 endif
 `
return

`
` FUNCTIONS FOR decal
`

function loaddecal(tfile$,decalid)
 timg=loadinternalimagecompress(tfile$,5)
 decal(decalid).imageid=timg
endfunction timg

`
`
`

_gun_findweaponindexbyname:

foundgunid=0
if findgun$<>""
 for tid=1 to gunmax
  if findgun$=lower$(gun(tid).name$)
   foundgunid=tid
   exit
  endif
 next tid
endif

return

_player_resettrail:
 playertrailmax=1
 for tp=0 to 100
  playertrial(tp).time=0
 next tp
return

_player_spawnsound:
 rem uses plrindex and te, make the spawn sound for the player appearing
 if gmultiplayergame=1
  tsnd=16
  if playersound(plrindex,tsnd)>0
   playinternal3dsoundfactor(playersound(plrindex,tsnd),entityelement(te).x,entityelement(te).y,entityelement(te).z,25.0)
  endif
 endif
return

_player_takedamage:

rem Either player One (main) or tplrid to use 'fake player entity soundset (multiplayer)
plrid=1 : tplrid=plrid : if gmultiplayergame=1 then tplrid=plrindex

rem special client case
if gmultiplayergame=1 and createorjoin=2
`
rem if multiplayer client, cannot take damage directly
`
else
`
rem Determine what to do from damage
if player(plrid).health>0 and tdamage>0
 player(plrid).health=player(plrid).health-tdamage
 if player(plrid).health<=0
  rem player looses a life
  player(plrid).recovershield=100
  player(plrid).health=0
  player(plrid).lives=player(plrid).lives-1
  if player(plrid).lives<=0
   player(plrid).lives=0
  endif
  rem player grunts in deadness
  tsnd=15
  if playersound(tplrid,tsnd)>0
   broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0)
   play sound playersound(tplrid,tsnd)
  endif
  rem player puts weapon away if fallen
  autoloadgun=0 : gosub _gun_change
  rem restore player zoom
  plrzoominchange=1 : plrzoomin#=0.0
  rem restore player modes
  onladder=0 : jumpaction=0 : crouchmode=0
  gunzoommode=0 : gunzoommag#=0
  rem stop any sliding force
  camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
  camforcex#=0 : camforcey#=0 : camforcez#=0
 else
  rem player grunts in hurt
  tsnd=12+rnd(2)
  if playersound(tplrid,tsnd)>0
   broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0)
   play sound playersound(tplrid,tsnd)
  endif
 endif
 rem cause eyehud(red) to flare quickly
 hudid=internaleyehud
 hud(hudid).hidedelay=3
 hud(hudid).hide=0
endif
`
endif

return

_decal_find:

rem Load all decals
for decalid=1 to decalmax
 if decal(decalid).name$=decal$ then exit
next decalid
if decalid>decalmax then decalid=-1

return

_gun_free:

rem Hide gun from HUD
if currentgunobj>0
 if object exist(currentgunobj)=1
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.show.s
  hide object currentgunobj
 endif
` if gun(gunid).secondobj>0
`  if object exist(gun(gunid).secondobj)=1 then hide object gun(gunid).secondobj
` endif
endif

rem Stop any gun sounds if free suddenly
if gunid>0
 for p=1 to 3
  if gunsound(gunid,p).soundid>0 then stop sound gunsound(gunid,p).soundid
  if gunsoundcompanion(gunid,p,0).soundid>0 then stop sound gunsoundcompanion(gunid,p,0).soundid
  if gunsoundcompanion(gunid,p,1).soundid>0 then stop sound gunsoundcompanion(gunid,p,1).soundid
  if gunsoundcompanion(gunid,p,2).soundid>0 then stop sound gunsoundcompanion(gunid,p,2).soundid
 next p
endif

rem Disassociate gun with player
gunselectionlockdown=0
currentgunobj=0

rem Hide support objects for gun
if gun(gunid).settings.flashlimb<>-1
 obj=hudbankoffset+5
 if object exist(obj)=1 then hide object obj
endif
if gun(gunid).settings.brasslimb<>-1
 for o=6 to 20
  obj=hudbankoffset+o
  if object exist(obj)=1 then hide object obj
 next o
endif
if gun(gunid).settings.brasslimb<>-1
 for o=21 to 30
  obj=hudbankoffset+o
  if object exist(obj)=1 then hide object obj
 next o
endif

rem Hide cross hair
obj=hudbankoffset+31
if object exist(obj)=1 then hide object obj

rem Clear basic gun vars
gunflash=0 : gunsmoke=0 : gunbrass=0 : gunshoot=0 : gunmode=5

return

_gun_scaninall_ref:

rem Scan entire guns folder
set dir "gamecore" : gunid=1
empty array filelist$()
buildfilelist("guns","")
set dir ".."
if array count(filelist$())>0
 dim gun(array count(filelist$())) as guntype
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   if lower$(right$(file$,5))="hud.x"
    gun(gunid).name$=left$(file$,len(file$)-6)
    inc gunid
   endif
  endif
 next chkfile
 gunmax=gunid-1
 dim gun(gunmax+1) as guntype
 dim gunsound(gunmax+1,5) as gunsoundbanktype
 dim gunsoundcompanion(gunmax+1,5,2) as gunsoundbankcompaniontype
 dim gunsounditem(gunmax+1,50) as gunsounditemtype
endif

rem Now sort the gun list into alphabetical order (MP needs gunid identical on each PC)
for tgid1=1 to gunmax
 for tgid2=1 to gunmax
  if tgid1<>tgid2
   tname1$=lower$(gun(tgid1).name$)
   tname2$=lower$(gun(tgid2).name$)
   if tname1$>tname2$
    rem smallest at top
    gun(tgid1).name$=tname2$
    gun(tgid2).name$=tname1$
   endif
  endif
 next tgid2
next tgid1

return



rem
rem Lighting Routines
rem

`
` General Visual Settings
`

_lighting_init:
 `
 rem Set approporiate ambience (FPI controlled)
 guivisualsettings.ambience=0
 `
 rem Lighting defaults
 guivisualsettings.shadows=1
 guivisualsettings.shadowstrength=128
 guivisualsettings.shadowshades=1
 guivisualsettings.dynamiclightcount=0
 guivisualsettings.updateflag=1
 `
 rem Initialize lighting objects
 if gdynamiclightingstate=1
  gosub _lighting_setupdynamiclights
  if gshowdebugtextingamestate=1
   activatedynamiclightsdebug=1
  else
   activatedynamiclightsdebug=0
  endif
 endif
 `
 rem Hero Light (used for source point for shadows and effects)
` set point light 0,50,50,-50
 color light 0,rgb(0,0,0)
 set light range 0,1
 hide light 0
 `
return

_lighting_postdefaults:

rem if no lights, set ambience to full
tokay=0
array index to top infinilight()
while array index valid(infinilight())
 if infinilight().islit=1
  tokay=1
 endif
 next array index infinilight()
 inc currentindex
endwhile
if tokay=0
 rem no lights, use full ambience (zero means no FPI aetting, go for defaults)
 if guseeffectonscenesstate=1
  guivisualsettings.ambience=25
 else
  guivisualsettings.ambience=75
 endif
endif
forceambientlightsetting=10

return

_lighting_ambientcontrol:

rem Irrespective of dynamic light setting
if inkey$()="," and guivisualsettings.ambience>0 then dec guivisualsettings.ambience : guivisualsettings.updateflag=1
if inkey$()="." and guivisualsettings.ambience<100 then inc guivisualsettings.ambience : guivisualsettings.updateflag=1

return

_lighting_control:
 `
 rem Direct keyboard control of adjustments
 tupdate=0
 if gdynamicshadowsstate=1
  if inkey$()="e" then guivisualsettings.shadows=0 : tupdate=1
  if inkey$()="r" then guivisualsettings.shadows=1 : tupdate=1
  if inkey$()="t" and guivisualsettings.shadowstrength>0 then dec guivisualsettings.shadowstrength : tupdate=1
  if inkey$()="y" and guivisualsettings.shadowstrength<255 then inc guivisualsettings.shadowstrength : tupdate=1
  if inkey$()="'" then guivisualsettings.shadowshades=1 : tupdate=1
  if inkey$()="#" then guivisualsettings.shadowshades=5 : tupdate=1
 endif
 if tupdate=1 then guivisualsettings.updateflag=1
 `
 rem Display lighting info
 if gshowdebugtextingamestate=1
  t$=strarr$(148)+str$(guivisualsettings.ambience)+strarr$(149)
`  if gdynamicshadowsstate=1
`   t$=t$+"  shad[E][R]:"+str$(guivisualsettings.shadows)+"  str[T][Y]:"+str$(guivisualsettings.shadowstrength)+"  shade['][#]:"+str$(guivisualsettings.shadowshades)
`  endif
  center text screen width()/2,screen height()-60, t$
 endif
 `
 rem Constantly handle spot lighting
 gosub _lighting_spotflash
 `
return

_lighting_controlupdate:
 `
 rem Automated update from force value
 if forceambientlightsetting>0 then guivisualsettings.updateflag=1 : dec forceambientlightsetting
 `
 rem Make adjustments to game settings
 if guivisualsettings.updateflag=1
  `
  rem make adjustments
  set ambient light guivisualsettings.ambience
  if guivisualsettings.shadows=1
   set global shadows on
  else
   set global shadows off
  endif
  set global shadow color 0,0,0,guivisualsettings.shadowstrength
  set global shadow shades guivisualsettings.shadowshades
  `
  rem reset update flag
  guivisualsettings.updateflag=0
  `
 endif
 `
return

`
` Dynamic Light Handling
`

_lighting_setupdynamiclights:

rem Create dynamic hardware lights
if light exist(1)=1 then hide light 1
for lightindex=2 to 7
 if light exist(lightindex)=0
  make light lightindex
 endif
 color light lightindex,0,0,0
next lightindex

rem Hero Gun/Fire Light
if light exist(1)=0 then make light 1
if light exist(1)=1 then hide light 1

rem Reset dynamic light array
activatedynamiclightscount=0
empty array infinilight(0)
testmarkerstart=50000
testmarker=testmarkerstart

return

_lighting_restore:

rem Delete all spare lights
for lightindex=1 to 7
 if light exist(lightindex)=1
  hide light lightindex
  delete light lightindex
 endif
next lightindex

rem Delete any test objects
for tobj=testmarkerstart to testmarker
 if object exist(tobj)=1 then delete object tobj
next tobj

rem Default directional light
color light 0,rgb(255,255,255)
set directional light 0,0.1,-0.7,0.2
set light range 0,3000
show light 0

return


_lighting_adddynamiclight:

rem Add dynamic light
inc testmarker
if lgtype=1 then inc activatedynamiclightscount
array insert at bottom infinilight()
infinilight().used=0
infinilight().type=lgtype
infinilight().x=lgx#
infinilight().y=lgy#
infinilight().z=lgz#
infinilight().colrgb.r=lgr#
infinilight().colrgb.g=lgg#
infinilight().colrgb.b=lgb#
infinilight().range=lgrange#
infinilight().id=testmarker
infinilight().islit=1
if activatedynamiclightsdebug=1
 make object sphere testmarker,20
 set object collision off testmarker
 position object testmarker,infinilight().x,infinilight().y,infinilight().z
 color object testmarker,rgb(infinilight().colrgb.r,infinilight().colrgb.g,infinilight().colrgb.b)
 set object diffuse testmarker,rgb(infinilight().colrgb.r,infinilight().colrgb.g,infinilight().colrgb.b)
 set object ambient testmarker,0
endif

rem return index for possible entity tie
infinilightindex=array count(infinilight())

return

_lighting_managedynamiclights:

rem Only if dynamic lights in scene
if activatedynamiclightscount>0

rem Specify current location
mex#=camera position x()
mey#=camera position y()
mez#=camera position z()
mea#=camera angle y()

rem Fill list with six nearest lights
tnumlights=6
empty array infinilightshortlist(0)
worstoveralldist#=0
bestoveralldist#=999999
for l=1 to tnumlights
 if array count(infinilightshortlist(0))<tnumlights-1
  rem find nearest light
  currentindex=0
  bestdist#=999999 : bestindex=-1
  array index to top infinilight()
  while array index valid(infinilight())
   if activatedynamiclightsdebug=1
    scale object infinilight().id,25,25,25
   endif
   if infinilight().used=0 and infinilight().type=1
    `
    rem And only those lights that are LIT
    if infinilight().islit=1
     `
     distx#=infinilight().x-mex#
     disty#=infinilight().y-mey#
     distz#=infinilight().z-mez#
     dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
     tat#=atanfull(distx#,distz#)
     if tat#<0 then tat#=tat#+360
     tat#=abs(tat#-wrapvalue(mea#))
     if tat#>180 then tat#=360-tat#
     tokay=0
     if dist#<600.0 then tokay=1
     if dist#>=600.0
      if tat#<90.0 then tokay=1
     endif
     if tokay=1
      if dist#<bestdist#
       bestdist#=dist# : bestindex=currentindex
      endif
     endif
     `
    endif
    `
   endif
   next array index infinilight()
   inc currentindex
  endwhile
  if bestindex<>-1
   rem work out best and worst
   if bestdist#<bestoveralldist# then bestoveralldist#=bestdist#
   if bestdist#>worstoveralldist# then worstoveralldist#=bestdist#
   rem add to shortlist
   infinilight(bestindex).used=1
   infinilight(bestindex).dist=bestdist#
   array insert at bottom infinilightshortlist()
   infinilightshortlist()=bestindex
  endif
 endif
next l

rem Reveal lights in shortlist
lightindex=2
array index to top infinilightshortlist()
while array index valid(infinilightshortlist())
 `
 rem Place and configure light for this pass
 tindex=infinilightshortlist() : tobj=infinilight(tindex).id
 infinilight(tindex).used=0 : perc#=1.0
 set point light lightindex,infinilight(tindex).x,infinilight(tindex).y,infinilight(tindex).z
 color light lightindex,infinilight(tindex).colrgb.r*perc#,infinilight(tindex).colrgb.g*perc#,infinilight(tindex).colrgb.b*perc#
 set light range lightindex,infinilight(tindex).range
 next array index infinilightshortlist()
 show light lightindex
 `
 rem Show light as object if in debug mode
 if activatedynamiclightsdebug=1
  distx#=infinilight(tindex).x-mex#
  disty#=infinilight(tindex).y-mey#
  distz#=infinilight(tindex).z-mez#
  tat#=atanfull(distx#,distz#)
  if tat#<0 then tat#=tat#+360
  tat#=abs(tat#-wrapvalue(mea#))
  if tat#>180 then tat#=360-tat#
  if object in screen(tobj)=1
   t$=strarr$(150)+str$(tindex)+strarr$(151)+str$(lightindex)+strarr$(152)+str$(int(tat#))
   center text object screen x(tobj),object screen y(tobj),t$
  endif
 endif
 `
 rem Next light
 inc lightindex
 `
endwhile

rem Then Hide The Rest of the lights
while lightindex<=7
 if light exist(lightindex)=1
  hide light lightindex
 endif
 inc lightindex
endwhile

rem can skip if ZERO dynamic lights anywhere
endif

return

_lighting_managegloballightingreciever:

rem Optimisation Table for quick-re-reference of a particular grid location
recx=recx#/25
recy=recy#/100
recz=recz#/-25
if recx<0 then recx=0
if recy<0 then recy=0
if recz<0 then recz=0
if recx>viscolx then recx=viscolx
if recy>viscoly then recy=viscoly
if recz>viscolz then recz=viscolz
`if lighttable(recx,recy,recz).x>0
if lighttable(recx,recy,recz).x>0 and 0
 `
 rem Return quick info from pre-calculated table
 avlightposx#=lighttable(recx,recy,recz).x
 avlightposy#=lighttable(recx,recy,recz).y
 avlightposz#=lighttable(recx,recy,recz).z
 avlightcolr#=lighttable(recx,recy,recz).r
 avlightcolg#=lighttable(recx,recy,recz).g
 avlightcolb#=lighttable(recx,recy,recz).b
 `
else
 `
 rem Reset ready to store strongest point
 avlightposx#=0 : avlightposy#=0 : avlightposz#=0
 avlightcolr#=0 : avlightcolg#=0 : avlightcolb#=0
 tlightinfluencedbydynamiclight=0
 avlightrange#=0
 `
 rem Go through ALL scene lights
 titer=0 : tqty=0
 closestdist#=99999
 array index to top infinilight()
 while array index valid(infinilight())
  `
  rem Collect position of light
  ldistx#=infinilight().x-recx#
  ldisty#=infinilight().y-recy#
  ldistz#=infinilight().z-recz#
  ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
  `
  rem for all lights within range
  if ldist#<infinilight().range and infinilight().islit=1
   `
   rem Relatve to overall distance (influence)
   tlightpower#=cos((ldist#/infinilight().range)*90)
   `
   rem Count visible illuminations
   avlightposx#=avlightposx#+infinilight().x
   avlightposy#=avlightposy#+infinilight().y
   avlightposz#=avlightposz#+infinilight().z
   avlightcolr#=avlightcolr#+(infinilight().colrgb.r*tlightpower#)
   avlightcolg#=avlightcolg#+(infinilight().colrgb.g*tlightpower#)
   avlightcolb#=avlightcolb#+(infinilight().colrgb.b*tlightpower#)
   avlightrange#=avlightrange#+(ldist#*tlightpower#)
   inc tqty
   `
   rem check for dynamic type
   if infinilight().type=1
    tlightinfluencedbydynamiclight=1
   endif
   `
  endif
  `
  next array index infinilight()
  `
 endwhile
 `
 rem Center to player for correct averaged single light position
 avlightposx#=avlightposx#/tqty
 avlightposy#=avlightposy#/tqty
 avlightposz#=avlightposz#/tqty
 `
 rem get correct average light color
 avlightcolr#=avlightcolr#/tqty
 avlightcolg#=avlightcolg#/tqty
 avlightcolb#=avlightcolb#/tqty
 `
 rem FPSCV104RC8 - ensure colours not maxed
 if avlightcolr#>255 then avlightcolr#=255
 if avlightcolg#>255 then avlightcolg#=255
 if avlightcolb#>255 then avlightcolb#=255
 `
 rem Record info in light table
 lighttable(recx,recy,recz).x=avlightposx#
 lighttable(recx,recy,recz).y=avlightposy#
 lighttable(recx,recy,recz).z=avlightposz#
 lighttable(recx,recy,recz).r=avlightcolr#
 lighttable(recx,recy,recz).g=avlightcolg#
 lighttable(recx,recy,recz).b=avlightcolb#
 `
 rem if ANY of the light is dynamically generated, cannot keep quick-ref as it might change
 if tlightinfluencedbydynamiclight=1
  lighttable(recx,recy,recz).x=0
 endif
 `
endif

return

_lighting_managegloballighting:
 `
 recx#=mex# : recy#=mey# : recz#=mez#
 gosub _lighting_managegloballightingreciever
 `
return

_lighting_applyplayerlighting:

rem Display test objects to show key markers
if activatedynamiclightsdebug=1
 tobj=49998 : if object exist(tobj)=0 then make object cone tobj,25 : xrotate object tobj,180
 set object collision off tobj
 position object tobj,avlightposx#,avlightposy#+20,avlightposz#
 if object in screen(tobj)=1
  center text object screen x(tobj),object screen y(tobj)-20,strarr$(153)
 endif
` if gdynamicshadowsstate=1
`  tsli=1
`  if array count(shadowlight())>=tsli
`   tobj=49999 : if object exist(tobj)=0 then make object cube tobj,25
`   set object collision off tobj
`   position object tobj,shadowlight(tsli).x#,shadowlight(tsli).y#,shadowlight(tsli).z#
`   if object in screen(tobj)=1
`    center text object screen x(tobj),object screen y(tobj)-20,strarr$(154)
`   endif
`  endif
` endif
endif

rem Apply averaged colour to player (avlightcolX#)
gosub _lighting_applyplayercolor

rem Shadow light controlled by most prominant light zero
`if gdynamicshadowsstate=1
` scene shadows disabled for V1.0
` for tsli=1 to array count(shadowlight())
`  set shadow light tsli,shadowlight(tsli).x#,shadowlight(tsli).y#,shadowlight(tsli).z#,shadowlight(tsli).range#
` next tsli
`endif

return

_lighting_applyplayercolor:
 `
 rem Apply player average colour to gun
 if gunid>0 then teffectid=gun(gunid).effectidused else teffectid=0
 if teffectid>0
  rem apply shader values
  r=make vector4(1)
  set vector4 1,avlightposx#,avlightposy#,avlightposz#,1.0
  set effect constant vector teffectid,"LightSource",1
  set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
  set effect constant vector teffectid,"SurfColor",1
  tamb#=guivisualsettings.ambience/100.0 : set vector4 1,tamb#,tamb#,tamb#,1.0
  set effect constant vector teffectid,"AmbiColor",1
  r=delete vector4(1)
 else
  rem illumonate player without shader
  if currentgunobj>0
   tcurrentguncolr=avlightcolr# : tcurrentguncolg=avlightcolg# : tcurrentguncolb=avlightcolb#
   if tcurrentguncolr<>currentguncolr or tcurrentguncolg<>currentguncolg or tcurrentguncolb<>currentguncolb
    currentguncolr=tcurrentguncolr : currentguncolg=tcurrentguncolg : currentguncolb=tcurrentguncolb
    set object emissive currentgunobj,rgb(avlightcolr#,avlightcolg#,avlightcolb#)
   endif
  endif
 endif
 `
return

_lighting_applyentitycolor:
 `
 rem Position of entity to calc light for
 recx#=entityelement(e).x
 recy#=entityelement(e).y
 recz#=entityelement(e).z
 `
 rem Optimise by only calculating light of entity shifts position
 tcurrentcolx=recx#/25
 tcurrentcoly=recy#/25
 tcurrentcolz=recz#/25
 if tcurrentcolx<>entityelement(e).colr or tcurrentcoly<>entityelement(e).colg or tcurrentcolz<>entityelement(e).colb
  `
  rem Record new color-light-calc position
  entityelement(e).colr=tcurrentcolx : entityelement(e).colg=tcurrentcoly : entityelement(e).colb=tcurrentcolz
  `
  rem calculate light from base position
  gosub _lighting_managegloballightingreciever
  `
  rem Apply average colour
  teffectid=entityelement(e).eleprof.usingeffect
  if teffectid>0
   rem apply shader values
   r=make vector4(1)
   set vector4 1,avlightposx#,avlightposy#,avlightposz#,1.0
   set effect constant vector teffectid,"LightSource",1
   set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
   set effect constant vector teffectid,"LightColor",1
   set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
   set effect constant vector teffectid,"SurfColor",1
   tamb#=guivisualsettings.ambience/100.0 : set vector4 1,tamb#,tamb#,tamb#,1.0
   set effect constant vector teffectid,"AmbiColor",1
   r=delete vector4(1)
  else
   rem no shader color for diffuse entities
   if activatedynamiclightsdebug=1 then entitydebug$(e)=str$(int(avlightcolr#))+","+str$(int(avlightcolg#))+","+str$(int(avlightcolb#))
   if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
    set object emissive entityelement(e).obj,rgb(255,255,255)
   else
    set object emissive entityelement(e).obj,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)
   endif
  endif
  `
 endif
 `
return

_lighting_applytoscene:

rem Set light zero for dynamic shadows of objects that cast them
`if gdynamicshadowsstate=1
` the old system for scene shadows, leave for next version
` disabled scene shadow for V1.0
` if array count(shadowlight(0))>0
` set global shadow color 0,0,0,128
`  tsli=1 : set point light 0,shadowlight(tsli).x#, shadowlight(tsli).y#, shadowlight(tsli).z#
`  shadowlight(tsli).range#
` endif
`endif

rem Constantly update hero light (for shadows and effects)
`set point light 0,camera position x(),camera position y(),camera position z()
rem for V1 need a way to handle this singular-light issue with SHADERS
rem for the ODE tests, a fixed light zero for the shadows
rem ultimate problem solver for shadow distance is a Sun-Style Light
`ODE physics controls shadow light now
`set point light 0,-1500,3000,1500

rem Scene can have effects in play (which require general parameters passed in)
tamb#=guivisualsettings.ambience/100.0
r=make vector4(1)
for tef=1 to effectbankmax
 teffectid=effectbankoffset+tef
 set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
 set effect constant vector teffectid,"LightColor",1
 set vector4 1,tamb#,tamb#,tamb#,1.0
 set effect constant vector teffectid,"AmbiColor",1
next tef
r=delete vector4(1)

return

_lighting_spotflash:
 `
 rem Control spot flash
 if spotflash=100
  spotflash=99 : spotflashx#=tx# : spotflashy#=ty# : spotflashz#=tz#
  if light exist(1)=1
   set point light 1,spotflashx#,spotflashy#,spotflashz# : set light range 1,600
   spotlightr#=tcolr : spotlightg#=tcolg : spotlightb#=tcolb
   color light 1,spotlightr#,spotlightg#,spotlightb#
   show light 1
  endif
 endif
 if spotflash>0 and spotflash<100
  dec spotflash,20
  if spotflash>0
   if light exist(1)=1
    spotfadeout#=spotflash/100.0
    color light 1,spotlightr#*spotfadeout#,spotlightg#*spotfadeout#,spotlightb#*spotfadeout#
   endif
  else
   spotflash=0
   if light exist(1)=1 then hide light 1
  endif
 endif
 `
return

rem
rem ENTITY
rem

_entity_validatearraysize:
 `
 rem ensure enough space in entity profile arrays
 if entidmaster+32>entidmastermax
  entidmastermax=entidmaster+32
  dim entitybodypart(entidmastermax,100) as integer
  dim entityanim(entidmastermax,animmax) as entityanimtype
  dim entityprofileheader(entidmastermax) as entityprofileheadertype
  dim entityprofile(entidmastermax) as entityprofiletype
  dim entitydecal$(entidmastermax,100) as string
  dim entitydecal(entidmastermax,100) as integer
  entitybankmax=entidmastermax
  dim entitybank$(entitybankmax)
 endif
 `
return

_entity_savebank:

rem FPSCV104RC6 - scan entire entityelement, delete all entitybank entries not used
rem V106 RC3 but not if we are constructing the level (as ENT will not match ELE)
if gcompilestandaloneexe=0
 if entidmaster>0
  dim entitybankused(entidmaster)
  for tttentid=1 to entidmaster
   entitybankused(tttentid)=0
  next tttentid
  for ttte=1 to entityelementlist
   tttentid=entityelement(ttte).bankindex
   if tttentid>0
    entitybankused(tttentid)=1
   endif
  next ttte
  for tttentid=1 to entidmaster
   if entitybankused(tttentid)=0
    rem remove entity entry if not used when save FPM
    entitybank$(tttentid)=""
   endif
  next tttentid
  rem shuffle to remove empty entries
  for tttentid=1 to entidmaster
   rem not used to record where entities have been moved to
   entitybankused(tttentid)=0
  next tttentid
  treadentid=1 : tlargest=0
  for tttentid=1 to entidmaster
   if treadentid<=entidmaster
    while entitybank$(treadentid)=""
     inc treadentid : if treadentid>entidmaster then exit
    endwhile
    if treadentid<=entidmaster
     entitybank$(tttentid)=entitybank$(treadentid)
     entityprofileheader(tttentid)=entityprofileheader(treadentid)
     entityprofile(tttentid)=entityprofile(treadentid)
     for tt=0 to 100 : entitybodypart(tttentid,tt)=entitybodypart(treadentid,tt) : next tt
     for tt=0 to animmax : entityanim(tttentid,tt)=entityanim(treadentid,tt) : next tt
     for tt=0 to 100 : entitydecal$(tttentid,tt)=entitydecal$(treadentid,tt) : next tt
     for tt=0 to 100 : entitydecal(tttentid,tt)=entitydecal(treadentid,tt) : next tt
     entitybankused(treadentid)=tttentid
     tlargest=tttentid
    else
     entitybank$(tttentid)=""
    endif
   else
    entitybank$(tttentid)=""
   endif
   inc treadentid
  next tttentid
  rem new list size
  if entidmaster<>tlargest
   entidmaster=tlargest
   entityorsegmententrieschanged=1
  endif
  rem update bank index numbers in entityelements
  for ttte=1 to entityelementlist
   tttentid=entityelement(ttte).bankindex
   if tttentid>0
    rem new entity entry place index
    entityelement(ttte).bankindex=entitybankused(tttentid)
   endif
  next ttte
  undim entitybankused()
 endif
endif

rem Save segment bank
if file exist("mapbank\testmap\map.ent")=1 then delete file "mapbank\testmap\map.ent"
open to write 1,"mapbank\testmap\map.ent"
 write file 1,entidmaster
 if entidmaster>0
  for entid=1 to entidmaster
   write string 1,entitybank$(entid)
  next entid
 endif
close file 1

return

_entity_deletebank:

rem Destroy old entities
if entidmastermax>0
 rem V104RC6 changed from entidmaster
 for entid=1 to entidmastermax
  entobj=entitybankoffset+entid
  if object exist(entobj)=1 then delete object entobj
  entitybank$(entid)=""
 next entid
endif

rem Destroy profile data
undim entityprofile()
dim entityprofile(100) as entityprofiletype
entidmastermax=100
entidmaster=0

return

_entity_loadbank:

rem If ent file exists
filename$=levelmapptah$+"map.ent"
if file exist(filename$)=1
 `
 rem Destroy old entities
 gosub _entity_deletebank
 `
 rem Load entity bank
 open to read 1,levelmapptah$+"map.ent"
  read file 1,entidmaster
  if entidmaster>0
   gosub _entity_validatearraysize
   for entid=1 to entidmaster
    read string 1,entitybank$(entid)
   next entid
  endif
 close file 1
 `
 rem Load in all entity objects and data
 gosub _entity_loadentitiesnow
 `
rem No file
endif

return

_entity_loadentitiesnow:

rem Load entities specified by bank
entdir$="entitybank\"
if entidmaster>0
 for entid=1 to entidmaster
  ent$=entitybank$(entid)
  entpath$=getpath(ent$)
  gosub _entity_load
  if desc$=""
   rem where entities have been lost, delete from list
   entitybank$(entid)=""
  endif
 next entid
endif

return

_entity_updatebank:

rem If ent file exists
filename$=levelmapptah$+"map.ent"
if file exist(filename$)=1

rem Clear non-present entries
for entid=entidmaster+1 to entitybankmax
 entitybank$(entid)=""
next entid

rem Update entity bank
open to read 2,filename$
 read file 2,tvalmax
 if tvalmax>0
  for tvalindex=1 to tvalmax
   read string 2,tent$
   addentityfile$=tent$
   gosub _entity_adduniqueentity
  next tvalindex
 endif
close file 2

rem No file
endif

return

_entity_adduniqueentity:

rem Ensure 'entitybank\' is not part of entity filename
entdir$="entitybank\"
if lower$(left$(addentityfile$,11))="entitybank\"
 addentityfile$=right$(addentityfile$,len(addentityfile$)-11)
endif

rem Check if entity already loaded in
talreadyloaded=0
for t=1 to entidmaster
 if entitybank$(t)=addentityfile$ then talreadyloaded=1 : entid=t
next t
if talreadyloaded=0
 `
 rem Allocate one more entity item in array
 if entidmaster>entitybankmax-4
  dim tempentitybank$(entitybankmax)
  for t=0 to entitybankmax : tempentitybank$(t)=entitybank$(t) : next t
  inc entitybankmax
  undim entitybank$(0)
  dim entitybank$(entitybankmax)
  for t=0 to entitybankmax-1 : entitybank$(t)=tempentitybank$(t) : next t
 endif
 `
 rem Add entity to bank
 inc entidmaster : gosub _entity_validatearraysize
 entitybank$(entidmaster)=addentityfile$
 `
 rem Load extra entity
 entid=entidmaster
 ent$=entitybank$(entid)
 entpath$=getpath(ent$)
 gosub _entity_load
 `
endif

return

_entity_loadextra:

rem load if entity is unique (unloaded - uses addentityfile$)
gosub _entity_adduniqueentity

rem Allocate one more into entity element array too
if entityelementlist>entityelementmax-4
 dim tempentityelement(entityelementmax) as entitytype
 for t=0 to entityelementmax : tempentityelement(t)=entityelement(t) : next t
 undim entityelement()
 undim entitydebug$(0)
 inc entityelementmax
 dim entityelement(entityelementmax) as entitytype
 dim entitydebug$(entityelementmax)
 for t=0 to entityelementmax-1 : entityelement(t)=tempentityelement(t) : next t
endif

rem Ensure we subtract the offset used by the entity(which would be part of the seg-info)
addentityx=addentityx-entityprofile(entid).offx
addentityz=addentityz-entityprofile(entid).offz
addentityy=addentityy-entityprofile(entid).offy

rem Add reference to entity as element
gosub _entity_addelement

return

_entity_addelement:
 `
 rem find spare
 for e=1 to entityelementlist
  if entityelement(e).bankindex=0 then exit
 next e
 if e>entityelementlist
  rem add new
  inc entityelementlist
  if entityelementlist>entityelementmax
   entityelementmax=entityelementlist
   dim entityelement(entityelementmax) as entitytype
   dim entitydebug$(entityelementmax)
  endif
  e=entityelementlist
 endif
 `
 rem create element entry data
 gosub _entity_fillelementfromprofile
 entityelement(e).editorfixed=0
 entityelement(e).maintype=1
 entityelement(e).bankindex=entid
 entityelement(e).x=addentityx+entityprofile(entid).offx
 entityelement(e).y=addentityy+entityprofile(entid).offy
 entityelement(e).z=addentityz+entityprofile(entid).offz
 entityelement(e).rx=addentityrx+entityprofile(entid).rotx
 entityelement(e).ry=addentityry+entityprofile(entid).roty
 entityelement(e).rz=addentityrz+entityprofile(entid).rotz
 `
return

_entity_loadtexturesandeffect:

rem If entity object not exist, reset var
if entobj>0
 if object exist(entobj)=0 then entobj=0
endif

rem Only characters need a higher quality texture, rest use divide standard settings
tfullorhalfdivide=0
if segobjusedformapeditor=0
 if entityprofile(entid).ischaracter=1
  tfullorhalfdivide=2
 else
  if entityprofile(entid).reducetexture<>0
   if entityprofile(entid).reducetexture=-1
    tfullorhalfdivide=1
   else
    tfullorhalfdivide=2
   endif
  endif
 endif
endif
`
rem Apply TEXTURE to entity object
tcanceltheeffect=0
tuseeffecttexture=0
tfile$=entityprofile(entid).texd$
tfilealt$=entityprofile(entid).texaltd$
if tfile$<>""
 `
 rem optional texture path for getting at any texture (gamecore gun textures, etc)
 if entityprofile(entid).texpath$<>""
  texdir$=entityprofile(entid).texpath$+tfile$
  texaltdir$=entityprofile(entid).texpath$+tfilealt$
 else
  texdir$=entdir$+entpath$+tfile$
  texaltdir$=entdir$+entpath$+tfilealt$
 endif
 if entityprofile(entid).transparency=0
  texuseid=loadinternaltextureex(texdir$,1,tfullorhalfdivide)
 else
  texuseid=loadinternaltextureex(texdir$,5,tfullorhalfdivide)
 endif
 if texuseid=0
  rem if not local texture, look in texture bank
  texdir$=entityprofile(entid).texd$
  texaltdir$=entityprofile(entid).texaltd$
 endif
 `
 rem Effect Or No
 tstage=0
 tfile$=entityprofile(entid).effect$
 teffectuseslightmapstage=0 : gosub _common_makeeffecttextureset
 if tfile$<>"" and guseeffectonentitiesstate=1 and segobjusedformapeditor=0
  `
  rem Load and apply MAIN texture directly
  for tlayer=0 to 4
   if tlayer=0 then texfiletouse$=texdir1$
   if tlayer=1 then texfiletouse$=texdir2$
   if tlayer=2 then texfiletouse$=texdir3$
   if tlayer=3 then texfiletouse$=texdir4$
   if tlayer=4 then texfiletouse$=texdir5$
   if entityprofile(entid).transparency=0
    texuseid=loadinternalimagecompressquality(texfiletouse$,1,tfullorhalfdivide)
   else
    texuseid=loadinternalimagecompressquality(texfiletouse$,5,tfullorhalfdivide)
   endif
   if texuseid=0
    if tlayer=0
     rem can fall back to D2 if D not exist
     texdir1$=tstr1$+"D2"+tstr2$ : texfiletouse$=texdir1$
     if entityprofile(entid).transparency=0
      texuseid=loadinternalimagecompressquality(texfiletouse$,1,tfullorhalfdivide)
     else
      texuseid=loadinternalimagecompressquality(texfiletouse$,5,tfullorhalfdivide)
     endif
    endif
    if texuseid=0
     rem main support textures N and I might be global (ie aiko_1_D2 and aiko_2_D2 use aiko_N.TGA, etc)
     if tlayer>0
      if upper$(right$(texfiletouse$,5))="N.TGA" then texfiletouse$=left$(tstr1$,len(tstr1$)-2)+"N"+tstr2$
      if upper$(right$(texfiletouse$,5))="S.TGA" then texfiletouse$=left$(tstr1$,len(tstr1$)-2)+"S"+tstr2$
      if entityprofile(entid).transparency=0
       texuseid=loadinternalimagecompressquality(texfiletouse$,1,tfullorhalfdivide)
      else
       texuseid=loadinternalimagecompressquality(texfiletouse$,5,tfullorhalfdivide)
      endif
     endif
    endif
    if texuseid=0
     rem some effects NEED to have a specific texture, or we cancel the effect
     if absolutelyrequirethistexture>0 and (1+tlayer)=absolutelyrequirethistexture
      rem no texture for this layer means we
      tcanceltheeffect=1
     else
      rem some effects need a blank texture if no file available
      if tlayer<=ensureclearlayermax
       rem black texture if no texture
       texuseid=loadinternalimagecompressquality("texturebank\common\black.tga",1,0)
      endif
     endif
    endif
   endif
   if texuseid>0
    if entobj>0 then texture object entobj,tstage,texuseid
    if tstage=0 then entityprofile(entid).texdid=texuseid
    if tstage=1 then entityprofile(entid).tex1id=texuseid
    if tstage=2 then entityprofile(entid).tex2id=texuseid
    if tstage=3 then entityprofile(entid).tex3id=texuseid
    if tstage=4 then entityprofile(entid).tex4id=texuseid
    inc tstage
   endif
  next tlayer
  if tstage<3
   for tst=tstage to 3
    if tst=1 then entityprofile(entid).tex1id=0
    if tst=2 then entityprofile(entid).tex2id=0
    if tst=3 then entityprofile(entid).tex3id=0
   next tst
  endif
  `
  rem Using effect
  if tcanceltheeffect=0
   if tstage>0 then tuseeffecttexture=1
  endif
  `
 endif
 `
 rem Record number of texture stages used
 entityprofile(entid).texidmax=tstage-1
 `
 rem Load basic D2 MAIN texture (if no effect textures)
 if tuseeffecttexture=0
  if entityprofile(entid).transparency=0
   texid=loadinternalimagecompressquality(texdir$,1,tfullorhalfdivide)
  else
   texid=loadinternalimagecompressquality(texdir$,5,tfullorhalfdivide)
  endif
  entityprofile(entid).texdid=texid
  if entobj>0
   texture object entobj,texid
  endif
 endif
 `
 rem Load ALT texture if available
 texaltdid=loadinternalimagecompressquality(texaltdir$,1,tfullorhalfdivide)
 entityprofile(entid).texaltdid=texaltdid
 `
else
 `
 rem FPSCV101 - add texturenames from file into filecollection (or exes will not find them)
 if entobj>0
  limbtexturename$=findmaterialtexturesinmodelfile(entdir$+entpath$+entityprofile(entid).model$,entdir$+entpath$)
 endif
 `
endif
`
rem Apply effect to entity object (map editor does NOT use any effects)
entityprofile(entid).usingeffect=0
if guseeffectonentitiesstate=1 and segobjusedformapeditor=0 and tcanceltheeffect=0
 tfile$=entityprofile(entid).effect$
 gosub _common_wipeeffectifnotexist
 if tfile$<>""
  teffectid=loadinternaleffect(tfile$)
  if teffectid>0
`  V1040805 - do not apply to entity profile obj (the elements are assigned after the clone)
`  if entobj>0 and teffectid>0
`  set object effect entobj,teffectid
   entityprofile(entid).usingeffect=teffectid
  endif
 endif
endif
`
rem Set any entity transparenct
if entobj>0 then set object transparency entobj,entityprofile(entid).transparency
`
rem If transparent, no need to Z write
if entityprofile(entid).transparency>0 and entobj>0
 rem had to remove this as in the game, the minigun (trans=1) was rendered inside out
 if entityprofile(entid).transparency>=2
  disable object zwrite entobj
  enable object zbias entobj,0.0,-0.000001
 endif
endif

return

_entity_load:

rem Entity Object Index
entobj=entitybankoffset+entid

rem debug info
mytimer=timer()

rem Load Entity profile data
gosub _entity_loaddata

rem Only load characters for entity-local-testing
desc$=entityprofileheader(entid).desc$
if scanforentitiescharactersonly=1
 if entityprofile(entid).ischaracter=0
  desc$=""
 endif
endif

rem Only if profile data exists
if desc$<>""
 `
 rem progress report as this is a slow phase
 debugviewtext(175,strarr$(136)+str$(entid)+"a\"+str$(entidmaster)+" ("+entityprofile(entid).model$+")")
 `
 rem Load the model
 tfile$=entdir$+entpath$+entityprofile(entid).model$
 if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
 if tdbofile$<>"" and file exist(tdbofile$)=1 then tfile$=tdbofile$
 if file exist(tfile$)=0 then tfile$=entityprofile(entid).model$
 if file exist(tfile$)=1
  `
  rem if DBO version exists, use that (quicker)
  if file exist(tdbofile$)=1
   tfile$=tdbofile$
   tdbofile$=""
  else
   rem allowed to save DBO (once only)
  endif
  `
  rem Load entity (compile does not need the dynamic objects)
  load object tfile$,entobj
  set object collision off entobj
  addfiletocollection(tfile$)
  if object exist(entobj)=1
   `
   rem Save if DBO not exist for entity (for fast loading)
   if len(tdbofile$)>1
    save object tdbofile$,entobj
    if file exist(tdbofile$)=1
     delete object entobj
     load object tdbofile$,entobj
     set object collision off entobj
    endif
   endif
   `
   rem main profile object adjustments
   if entityprofile(entid).scale<>0 then scale object entobj,entityprofile(entid).scale,entityprofile(entid).scale,entityprofile(entid).scale
   `
   rem Apply texture and effect to entity profile obj
   gosub _entity_loadtexturesandeffect
   `
   rem until static bonemodel scales when not animaating, loop
   if entityprofile(entid).ischaracter=1
    loop object entobj : stop object entobj
   endif
   `
   rem if entity has decals, find indexes to decals (which are already preloaded)
   entityprofile(entid).bloodscorch=0
   if entityprofile(entid).decalmax>0
    for tq=0 to entityprofile(entid).decalmax-1
     decal$=entitydecal$(entid,tq)
     if lower$(decal$)="blood" then entityprofile(entid).bloodscorch=1
     gosub _decal_find
     if decalid<0 then decalid=0
     entitydecal(entid,tq)=decalid
    next tq
   endif
   `
   rem Hide object away
   position object entobj,100000,100000,100000
   `
  endif
 else
  debugstring(right$(tfile$,70),strarr$(100))
 endif
 `
 rem Resolve default weapon gun ids
 if entityprofile(entid).isweapon$<>""
  findgun$=lower$(entityprofile(entid).isweapon$) : gosub _gun_findweaponindexbyname
  entityprofile(entid).isweapon=foundgunid
  if foundgunid>0 then gun(foundgunid).activeingame=1
 else
  entityprofile(entid).isweapon=0
 endif
 rem Finding hasweapon also in createlemenents (as eleprof may have changed the weapon!)
 if entityprofile(entid).hasweapon$<>""
  findgun$=lower$(entityprofile(entid).hasweapon$) : gosub _gun_findweaponindexbyname
  entityprofile(entid).hasweapon=foundgunid
  if foundgunid>0 and entityprofile(entid).isammo=0 then gun(foundgunid).activeingame=1
 else
  entityprofile(entid).hasweapon=0
 endif
 `
 rem see if we can find head automatically
 if entityprofile(entid).ischaracter=1
  if entityprofile(entid).headlimb=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_head"
      entityprofile(entid).headlimb=tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif
  endif
  if entityprofile(entid).firespotlimb=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="firespot"
      entityprofile(entid).firespotlimb=tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif
  endif
 endif
 `
 rem assign physics weight and friction (if not set)
 if entityprofile(entid).physics<>0
  tfriction=(object size x(entobj)*75)+(object size y(entobj)*75)+(object size z(entobj)*75)
  tweight=(object size x(entobj)*25)+(object size y(entobj)*25)+(object size z(entobj)*25)
  tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
  if tweight<200 then tweight=200
`  if entityprofile(entid).phyweight=0 then entityprofile(entid).phyweight=tweight
`  if entityprofile(entid).phyfriction=0 then entityprofile(entid).phyfriction=tfriction
  entityprofile(entid).phyweight=tweight
  entityprofile(entid).phyfriction=tfriction
 endif
 `
rem no profile exists endif
endif

rem debug info and timestamp list (if logging)
debugviewtext(-1,"Built "+ent$+" in "+str$(timer()-mytimer)+"ms")
timestampactivity(0,"Loaded "+str$(entid)+":"+ent$)

return

_entity_loaddata:

rem Ensure entity profile still exists
entityprofileheader(entid).desc$=""
tprofile$=left$(entdir$+ent$,len(entdir$+ent$)-4)+".bin"
if isbinaryfileolderthantxtfile(tprofile$,entdir$+ent$)=1 then delete file tprofile$
if file exist(entdir$+ent$)=1 or file exist(tprofile$)=1

rem Export entity FPE file if flagged
if gexportassets=1
 tthumbbmpfile$=left$(entdir$+ent$,len(entdir$+ent$)-4)+".bmp"
 addfiletocollection(entdir$+ent$) : addfiletocollection(tthumbbmpfile$)
endif

rem Check if binary version of entity profile exists (DELETE BIN AT MOMEMENT!)
addfiletocollection(tprofile$)
if file exist(tprofile$)=0
 `
 rem Must be reset before parse
 entityprofile(entid).limbmax=0
 entityprofile(entid).animmax=0
 entityprofile(entid).headlimb=-1
 entityprofile(entid).firespotlimb=-1
 entityprofile(entid).physics=1
 entityprofile(entid).phyweight=100
 entityprofile(entid).phyfriction=0
 `
 rem Load entity Data from file
 dim data$(400)
 load array entdir$+ent$,data$()
 for l=0 to 399
  line$=data$(l)
  if len(line$)>0
   if left$(line$,1)<>";"
    `
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem entity header
    if field$="desc" then entityprofileheader(entid).desc$=value$
    `
    rem entity AI
    tryfield$="aiinit"
    if field$=tryfield$ then entityprofile(entid).aiinit$=value$
    tryfield$="aimain"
    if field$=tryfield$ then entityprofile(entid).aimain$=value$
    tryfield$="aidestroy"
    if field$=tryfield$ then entityprofile(entid).aidestroy$=value$
    tryfield$="aishoot"
    if field$=tryfield$ then entityprofile(entid).aishoot$=value$
    tryfield$="soundset"
    if field$=tryfield$ then entityprofile(entid).soundset$=value$
    tryfield$="soundset1"
    if field$=tryfield$ then entityprofile(entid).soundset1$=value$
    `
    rem entity AI related vars
    tryfield$="usekey"
    if field$=tryfield$ then entityprofile(entid).usekey$=value$
    tryfield$="ifused"
    if field$=tryfield$ then entityprofile(entid).ifused$=value$
    tryfield$="ifusednear"
    if field$=tryfield$ then entityprofile(entid).ifusednear$=value$
    `
    rem entity SPAWN
    tryfield$="spawnmax"
    if field$=tryfield$ then entityprofile(entid).spawnmax=value1
    tryfield$="spawndelay"
    if field$=tryfield$ then entityprofile(entid).spawndelay=value1
    tryfield$="spawnqty"
    if field$=tryfield$ then entityprofile(entid).spawnqty=value1
    `
    rem entity orientation
    tryfield$="model"
    if field$=tryfield$ then entityprofile(entid).model$=value$
    tryfield$="offx"
    if field$=tryfield$ then entityprofile(entid).offx=value1
    tryfield$="offy"
    if field$=tryfield$ then entityprofile(entid).offy=value1
    tryfield$="offz"
    if field$=tryfield$ then entityprofile(entid).offz=value1
    tryfield$="rotx"
    if field$=tryfield$ then entityprofile(entid).rotx=value1
    tryfield$="roty"
    if field$=tryfield$ then entityprofile(entid).roty=value1
    tryfield$="rotz"
    if field$=tryfield$ then entityprofile(entid).rotz=value1
    tryfield$="scale"
    if field$=tryfield$ then entityprofile(entid).scale=value1
    tryfield$="fixnewy"
    if field$=tryfield$ then entityprofile(entid).fixnewy=value1
    tryfield$="forwardfacing"
    if field$=tryfield$ then entityprofile(entid).forwardfacing=value1
    tryfield$="defaultheight"
    if field$=tryfield$ then entityprofile(entid).defaultheight=value1
    tryfield$="defaultstatic"
    if field$=tryfield$ then entityprofile(entid).defaultstatic=value1
    tryfield$="collisionmode"
    if field$=tryfield$ then entityprofile(entid).collisionmode=value1
    tryfield$="materialindex"
    if field$=tryfield$ then entityprofile(entid).materialindex=value1
    tryfield$="debrisshape"
    if field$=tryfield$ then entityprofile(entid).debrisshapeindex=value1
    `
    rem physics setup
    tryfield$="physics"
    if field$=tryfield$ then entityprofile(entid).physics=value1
    tryfield$="phyweight"
    if field$=tryfield$ then entityprofile(entid).phyweight=value1
    tryfield$="phyfriction"
    if field$=tryfield$ then entityprofile(entid).phyfriction=value1
    tryfield$="explodable"
    if field$=tryfield$ then entityprofile(entid).explodable=value1
    `
    rem cone of sight
    tryfield$="coneheight"
    if field$=tryfield$ then entityprofile(entid).coneheight=value1
    tryfield$="coneangle"
    if field$=tryfield$ then entityprofile(entid).coneangle=value1
    `
    rem visual info
    tryfield$="texturepath"
    if field$=tryfield$ then entityprofile(entid).texpath$=value$
    tryfield$="textured"
    if field$=tryfield$ then entityprofile(entid).texd$=value$
    tryfield$="texturealtd"
    if field$=tryfield$ then entityprofile(entid).texaltd$=value$
    tryfield$="effect"
    if field$=tryfield$ then entityprofile(entid).effect$=value$
    tryfield$="transparency"
    if field$=tryfield$ then entityprofile(entid).transparency=value1
    tryfield$="reducetexture"
    if field$=tryfield$ then entityprofile(entid).reducetexture=value1
    tryfield$="castshadow"
    if field$=tryfield$ then entityprofile(entid).castshadow=value1
    `
    rem entity identity details
    tryfield$="strength"
    if field$=tryfield$ then entityprofile(entid).strength=value1
    tryfield$="lives"
    if field$=tryfield$ then entityprofile(entid).lives=value1
    tryfield$="speed"
    if field$=tryfield$ then entityprofile(entid).speed=value1
    tryfield$="hurtfall"
    if field$=tryfield$ then entityprofile(entid).hurtfall=value1
    `
    tryfield$="isimmobile"
    if field$=tryfield$ then entityprofile(entid).isimmobile=value1
    tryfield$="isobjective"
    if field$=tryfield$ then entityprofile(entid).isobjective=value1
    `
    tryfield$="ischaracter"
    if field$=tryfield$ then entityprofile(entid).ischaracter=value1
    tryfield$="cantakeweapon"
    if field$=tryfield$ then entityprofile(entid).cantakeweapon=value1
    tryfield$="isweapon"
    if field$=tryfield$ then entityprofile(entid).isweapon$=value$
    tryfield$="isammo"
    if field$=tryfield$ then entityprofile(entid).isammo=value1
    tryfield$="hasweapon"
    if field$=tryfield$ then entityprofile(entid).hasweapon$=value$
    tryfield$="ishealth"
    if field$=tryfield$ then entityprofile(entid).ishealth=value1
    tryfield$="isflak"
    if field$=tryfield$ then entityprofile(entid).isflak=value1
    `
    rem marker extras
    tryfield$="ismarker"
    if field$=tryfield$ then entityprofile(entid).ismarker=value1
    tryfield$="markerindex"
    if field$=tryfield$ then entityprofile(entid).markerindex=value1
    `
    rem light extras
    tryfield$="lightcolor"
    if field$=tryfield$ then entityprofile(entid).light.color=value1
    tryfield$="lightrange"
    if field$=tryfield$ then entityprofile(entid).light.range=value1
    `
    rem trigger extras
    tryfield$="areax"
    if field$=tryfield$ then entityprofile(entid).trigger.areax1=value1 : entityprofile(entid).trigger.areax2=value2
    tryfield$="areay"
    if field$=tryfield$ then entityprofile(entid).trigger.areay1=value1 : entityprofile(entid).trigger.areay2=value2
    tryfield$="areaz"
    if field$=tryfield$ then entityprofile(entid).trigger.areaz1=value1 : entityprofile(entid).trigger.areaz2=value2
    `
    rem entity body part list
    tryfield$="limbmax"
    if field$=tryfield$ then entityprofile(entid).limbmax=value1
    if entityprofile(entid).limbmax>0
     for q=0 to entityprofile(entid).limbmax-1
      tryfield$="limb"+str$(q)
      if field$=tryfield$
       entitybodypart(entid,q)=value1
       if value1=1
        rem record head seperately too
        entityprofile(entid).headlimb=q
       endif
      endif
     next q
    endif
    `
    rem entity decal refs
    tryfield$="decalmax"
    if field$=tryfield$ then entityprofile(entid).decalmax=value1
    if entityprofile(entid).decalmax>0
     for q=0 to entityprofile(entid).decalmax-1
      tryfield$="decal"+str$(q)
      if field$=tryfield$ then entitydecal$(entid,q)=value$
     next q
    endif
    `
    rem entity animation sets
    tryfield$="animmax"
    if field$=tryfield$ then entityprofile(entid).animmax=value1
    if entityprofile(entid).animmax>0
     for q=0 to entityprofile(entid).animmax-1
      tryfield$="anim"+str$(q)
      if field$=tryfield$ then entityanim(entid,q).start=value1 : entityanim(entid,q).finish=value2
     next q
    endif
    `
    rem more data
    tryfield$="quantity"
    if field$=tryfield$ then entityprofile(entid).quantity=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Localisation must change desc to local name
 if entityprofileheader(entid).desc$<>""
  if left$(entityprofileheader(entid).desc$,1)<>"%"
   tflocalfilename$="languagebank\"+language$+"\textfiles\library\"+entdir$+ent$
   tflocalfilename$=left$(tflocalfilename$,len(tflocalfilename$)-4)+".loc"
   if file exist(tflocalfilename$)=1
    dim tflocal$(1)
    load array tflocalfilename$,tflocal$()
    entityprofileheader(entid).desc$=tflocal$(0)
    undim tflocal$()
   endif
  endif
 endif
 `
 rem Translate entity references inside entity profile (token translations)
 if lower$(entityprofileheader(entid).desc$)="%key"
  entityprofileheader(entid).desc$=strarr$(472)
 endif
 if lower$(entityprofileheader(entid).desc$)="%light"
  entityprofileheader(entid).desc$=strarr$(473)
 endif
 if lower$(entityprofileheader(entid).desc$)="%remote door"
  entityprofileheader(entid).desc$=strarr$(474)
 endif
 if lower$(entityprofileheader(entid).desc$)="%teleporter in"
  entityprofileheader(entid).desc$=strarr$(615)
 endif
 if lower$(entityprofileheader(entid).desc$)="%teleporter out"
  entityprofileheader(entid).desc$=strarr$(616)
 endif
 if lower$(entityprofileheader(entid).desc$)="%lift"
  entityprofileheader(entid).desc$=strarr$(617)
 endif
 if lower$(entityprofile(entid).usekey$)="%key"
  entityprofile(entid).usekey$=strarr$(472)
 endif
 if lower$(entityprofile(entid).ifused$)="%light"
  entityprofile(entid).ifused$=strarr$(473)
 endif
 if lower$(entityprofile(entid).ifused$)="%remote door"
  entityprofile(entid).ifused$=strarr$(474)
 endif
 if lower$(entityprofile(entid).ifused$)="%teleporter in"
  entityprofile(entid).ifused$=strarr$(615)
 endif
 if lower$(entityprofile(entid).ifused$)="%teleporter out"
  entityprofile(entid).ifused$=strarr$(616)
 endif
 if lower$(entityprofile(entid).ifused$)="%lift"
  entityprofile(entid).ifused$=strarr$(617)
 endif
 `
 rem All profile defaults
 if entityprofile(entid).ismarker<>1
  if entityprofile(entid).lives<1 then entityprofile(entid).lives=1
 endif
 if entityprofile(entid).speed=0 then entityprofile(entid).speed=100
 if entityprofile(entid).hurtfall=0 then entityprofile(entid).hurtfall=100
 if entityprofile(entid).ischaracter=1
  if entityprofile(entid).quantity=0 then entityprofile(entid).quantity=1
 endif
 `
 rem Physics Data Defaults
 if entityprofile(entid).ismarker=0
  rem default physics settings (weight and friction done during object load (we need the obj size!)
  entityprofile(entid).phyalways=0
  entityprofile(entid).phyforcedamage=100
  entityprofile(entid).rotatethrow=1
  entityprofile(entid).explodedamage=100
  entityprofile(entid).phyweight=0
  entityprofile(entid).phyfriction=0
  rem health packs have no physics by default for A compatibility
  if entityprofile(entid).ishealth<>0
   entityprofile(entid).physics=0
  endif
 else
  entityprofile(entid).physics=0
 endif
 `
 rem Spawn defaults
 entityprofile(entid).spawnatstart=1
 entityprofile(entid).spawndelayrandom=0
 entityprofile(entid).spawnqtyrandom=0
 entityprofile(entid).spawnvel=0
 entityprofile(entid).spawnvelrandom=0
 entityprofile(entid).spawnangle=90
 entityprofile(entid).spawnanglerandom=0
 entityprofile(entid).spawnlife=0
 if entityprofile(entid).spawnmax>0
  entityprofile(entid).spawnupto=entityprofile(entid).spawnmax
  entityprofile(entid).spawnafterdelay=1
  if entityprofile(entid).ischaracter=1
   entityprofile(entid).spawnwhendead=1
  else
   entityprofile(entid).spawnwhendead=0
  endif
 else
  entityprofile(entid).spawnupto=0
  entityprofile(entid).spawnafterdelay=0
  entityprofile(entid).spawnwhendead=0
 endif
 `
 rem If animation data insufficient, make up rest with basic null sets
 if entityprofile(entid).animmax>0
  if entityprofile(entid).animmax<100
   rem AI animation code relies on standard animation-set-numbers
   for q=entityprofile(entid).animmax to 99
    entityanim(entid,q).start=0 : entityanim(entid,q).finish=1
   next q
   entityprofile(entid).animmax=100
  endif
 endif
 `
 rem Save entity profile as binary
 dim tempe(0) as entityprofiletype
 open to write 1,tprofile$
 write string 1,entityprofileheader(entid).desc$
 tempe(0)=entityprofile(entid)
 if memblock exist(1)=1 then delete memblock 1
 tempe(0).aiinit$=free string()
 tempe(0).aimain$=free string()
 tempe(0).aidestroy$=free string()
 tempe(0).aishoot$=free string()
 tempe(0).soundset$=free string()
 tempe(0).soundset1$=free string()
 tempe(0).usekey$=free string()
 tempe(0).ifused$=free string()
 tempe(0).ifusednear$=free string()
 tempe(0).model$=free string()
 tempe(0).texpath$=free string()
 tempe(0).texd$=free string()
 tempe(0).texaltd$=free string()
 tempe(0).effect$=free string()
 tempe(0).isweapon$=free string()
 tempe(0).hasweapon$=free string()
 make memblock from array 1,tempe(0)
 write memblock 1,1
 write string 1,entityprofile(entid).aiinit$
 write string 1,entityprofile(entid).aimain$
 write string 1,entityprofile(entid).aidestroy$
 write string 1,entityprofile(entid).aishoot$
 write string 1,entityprofile(entid).soundset$
 write string 1,entityprofile(entid).soundset1$
 write string 1,entityprofile(entid).usekey$
 write string 1,entityprofile(entid).ifused$
 write string 1,entityprofile(entid).ifusednear$
 write string 1,entityprofile(entid).model$
 write string 1,entityprofile(entid).texpath$
 write string 1,entityprofile(entid).texd$
 write string 1,entityprofile(entid).texaltd$
 write string 1,entityprofile(entid).effect$
 write string 1,entityprofile(entid).isweapon$
 write string 1,entityprofile(entid).hasweapon$
 for q = 0 to entityprofile(entid).animmax-1
  write file 1,entityanim(entid,q).start
  write file 1,entityanim(entid,q).finish
 next q
 for q = 0 to entityprofile(entid).decalmax-1
  write string 1,entitydecal$(entid,q)
 next q
 close file 1
 delete memblock 1
 undim tempe(0)
 `
else
 `
 rem load binary version of entity profile file
 dim tempe(0) as entityprofiletype
 open to read 1,tprofile$
 read string 1,tstr$ : entityprofileheader(entid).desc$=tstr$
 read memblock 1,1
 make array from memblock tempe(0),1
 entityprofile(entid)=tempe(0)
 read string 1,tstr$ : entityprofile(entid).aiinit$=tstr$
 read string 1,tstr$ : entityprofile(entid).aimain$=tstr$
 read string 1,tstr$ : entityprofile(entid).aidestroy$=tstr$
 read string 1,tstr$ : entityprofile(entid).aishoot$=tstr$
 read string 1,tstr$ : entityprofile(entid).soundset$=tstr$
 read string 1,tstr$ : entityprofile(entid).soundset1$=tstr$
 read string 1,tstr$ : entityprofile(entid).usekey$=tstr$
 read string 1,tstr$ : entityprofile(entid).ifused$=tstr$
 read string 1,tstr$ : entityprofile(entid).ifusednear$=tstr$
 read string 1,tstr$ : entityprofile(entid).model$=tstr$
 read string 1,tstr$ : entityprofile(entid).texpath$=tstr$
 read string 1,tstr$ : entityprofile(entid).texd$=tstr$
 read string 1,tstr$ : entityprofile(entid).texaltd$=tstr$
 read string 1,tstr$ : entityprofile(entid).effect$=tstr$
 read string 1,tstr$ : entityprofile(entid).isweapon$=tstr$
 read string 1,tstr$ : entityprofile(entid).hasweapon$=tstr$
 for q = 0 to entityprofile(entid).animmax-1
  read file 1,entityanim(entid,q).start
  read file 1,entityanim(entid,q).finish
 next q
 for q = 0 to entityprofile(entid).decalmax-1
  read string 1,entitydecal$(entid,q)
 next q
 close file 1
 delete memblock 1
 undim tempe(0)
 `
endif

rem fileexistelse
else
 rem File not exist, provide debug information (only if file specified (old entities can be renamed and still hang around inside FPMs)
 if len(entdir$+ent$)>len("entitybank\")
  debugfilename(entdir$+ent$,tprofile$)
 endif
endif

return

_entity_saveelementsdata:

rem Uses elementfilename$
if elementsfilename$="" then elementsfilename$="mapbank\testmap\map.ele"

rem Reduce list size if later elements blank
e=entityelementlist
while e>0
 if entityelement(e).maintype=0 then dec e else exit
endwhile
entityelementlist=e

rem Save entity element list
dw as DWORD
versionnumbersave=107
if file exist(elementsfilename$)=1 then delete file elementsfilename$
open to write 1,elementsfilename$
 write file 1,versionnumbersave
 write file 1,entityelementlist
 if entityelementlist>0
  for e=1 to entityelementlist
   if versionnumbersave>=101
    rem Version 1.01 - EA
    a=entityelement(e).maintype : write file 1,a
    a=entityelement(e).bankindex : write file 1,a
    a=entityelement(e).staticflag : write file 1,a
    a#=entityelement(e).x : write float 1,a#
    a#=entityelement(e).y : write float 1,a#
    a#=entityelement(e).z : write float 1,a#
    a#=entityelement(e).rx : write float 1,a#
    a#=entityelement(e).ry : write float 1,a#
    a#=entityelement(e).rz : write float 1,a#
    a$=entityelement(e).eleprof.name$ : write string 1,a$
    a$=entityelement(e).eleprof.aiinit$ : write string 1,a$
    a$=entityelement(e).eleprof.aimain$ : write string 1,a$
    a$=entityelement(e).eleprof.aidestroy$ : write string 1,a$
    a=entityelement(e).eleprof.isobjective : write file 1,a
    a$=entityelement(e).eleprof.usekey$ : write string 1,a$
    a$=entityelement(e).eleprof.ifused$ : write string 1,a$
    a$=entityelement(e).eleprof.ifusednear$ : write string 1,a$
    a=entityelement(e).eleprof.uniqueelement : write file 1,a
    a$=entityelement(e).eleprof.texd$ : write string 1,a$
    a$=entityelement(e).eleprof.texaltd$ : write string 1,a$
    a$=entityelement(e).eleprof.effect$ : write string 1,a$
    a=entityelement(e).eleprof.transparency : write file 1,a
    a=entityelement(e).editorfixed : write file 1,a
    a$=entityelement(e).eleprof.soundset$ : write string 1,a$
    a$=entityelement(e).eleprof.soundset1$ : write string 1,a$
    a=entityelement(e).eleprof.spawnmax : write file 1,a
    a=entityelement(e).eleprof.spawndelay : write file 1,a
    a=entityelement(e).eleprof.spawnqty : write file 1,a
    a=entityelement(e).eleprof.hurtfall : write file 1,a
    a=entityelement(e).eleprof.castshadow : write file 1,a
    a=entityelement(e).eleprof.reducetexture : write file 1,a
    a=entityelement(e).eleprof.speed : write file 1,a
    a$=entityelement(e).eleprof.aishoot$ : write string 1,a$
    a$=entityelement(e).eleprof.hasweapon$ : write string 1,a$
    a=entityelement(e).eleprof.lives : write file 1,a
    a=entityelement(e).spawn.max : write file 1,a
    a=entityelement(e).spawn.delay : write file 1,a
    a=entityelement(e).spawn.qty : write file 1,a
    a#=entityelement(e).eleprof.scale : write float 1,a#
    a#=entityelement(e).eleprof.coneheight : write float 1,a#
    a#=entityelement(e).eleprof.coneangle : write float 1,a#
    a=entityelement(e).eleprof.strength : write file 1,a
    a=entityelement(e).eleprof.isimmobile : write file 1,a
    a=entityelement(e).eleprof.cantakeweapon : write file 1,a
    a=entityelement(e).eleprof.quantity : write file 1,a
    a=entityelement(e).eleprof.markerindex : write file 1,a
    dw=entityelement(e).eleprof.light.color : dw=(dw<<8)>>8 : a=dw : write file 1,a
    a=entityelement(e).eleprof.light.range : write file 1,a
    a=entityelement(e).eleprof.trigger.areax1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areay1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areaz1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areax2 : write file 1,a
    a=entityelement(e).eleprof.trigger.areay2 : write file 1,a
    a=entityelement(e).eleprof.trigger.areaz2 : write file 1,a
    a$=entityelement(e).eleprof.basedecal$ : write string 1,a$
   endif
   if versionnumbersave>=102
    a=entityelement(e).eleprof.rateoffire : write file 1,a
    a=entityelement(e).eleprof.damage : write file 1,a
    a=entityelement(e).eleprof.accuracy : write file 1,a
    a=entityelement(e).eleprof.reloadqty : write file 1,a
    a=entityelement(e).eleprof.fireiterations : write file 1,a
    a=entityelement(e).eleprof.lifespan : write file 1,a
    a#=entityelement(e).eleprof.throwspeed : write float 1,a#
    a#=entityelement(e).eleprof.throwangle : write float 1,a#
    a=entityelement(e).eleprof.bounceqty : write file 1,a
    a=entityelement(e).eleprof.explodeonhit : write file 1,a
    a=entityelement(e).eleprof.weaponisammo : write file 1,a
    a=entityelement(e).eleprof.spawnupto : write file 1,a
    a=entityelement(e).eleprof.spawnafterdelay : write file 1,a
    a=entityelement(e).eleprof.spawnwhendead : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
   endif
   if versionnumbersave>=103
    rem V1 first draft - physics
    a=entityelement(e).eleprof.physics : write file 1,a
    a=entityelement(e).eleprof.phyweight : write file 1,a
    a=entityelement(e).eleprof.phyfriction : write file 1,a
    a=entityelement(e).eleprof.phyforcedamage : write file 1,a
    a=entityelement(e).eleprof.rotatethrow : write file 1,a
    a=entityelement(e).eleprof.explodable : write file 1,a
    a=entityelement(e).eleprof.explodedamage : write file 1,a
    a=entityelement(e).eleprof.phydw4 : write file 1,a
    a=entityelement(e).eleprof.phydw5 : write file 1,a
   endif
   if versionnumbersave>=104
    rem Addition of new physics field for BETA4
    a=entityelement(e).eleprof.phyalways : write file 1,a
   endif
   if versionnumbersave>=105
    rem Addition of new spawn fields for BETA8
    a=entityelement(e).eleprof.spawndelayrandom : write file 1,a
    a=entityelement(e).eleprof.spawnqtyrandom : write file 1,a
    a=entityelement(e).eleprof.spawnvel : write file 1,a
    a=entityelement(e).eleprof.spawnvelrandom : write file 1,a
    a=entityelement(e).eleprof.spawnangle : write file 1,a
    a=entityelement(e).eleprof.spawnanglerandom : write file 1,a
   endif
   if versionnumbersave>=106
    rem Addition of new fields for BETA10
    a=entityelement(e).eleprof.spawnatstart : write file 1,a
    a=entityelement(e).eleprof.spawnlife : write file 1,a
   endif
   if versionnumbersave>=107
    rem FPSCV104RC8 - forgot to save infinilight index (dynamic lights in final build never worked)
    a=entityelement(e).eleprof.light.index : write file 1,a
   endif
  next e
 endif
close file 1

return

_entity_deleteelementsdata:

rem Free any old elements
gosub _entity_deleteelements

rem Clear counter for new load
entityelementlist=0
entityelementmax=0

return

_entity_loadelementsdata:

rem Free any old elements
gosub _entity_deleteelementsdata

rem Uses elementfilename$
if elementsfilename$="" then elementsfilename$="mapbank\testmap\map.ele"

rem load entity element list
dw as DWORD
versionnumbersupported=107
if file exist(elementsfilename$)=1
 `
 open to read 1,elementsfilename$
  read file 1,versionnumberload
  if versionnumberload<100
   rem Pre-version data - development only
   entityelementlist=versionnumberload
   versionnumberload=100
  else
   read file 1,entityelementlist
  endif
  if versionnumberload<=versionnumbersupported
   if entityelementlist>0
    undim entityelement()
    undim entitydebug$()
    entityelementmax=entityelementlist
    dim entityelement(entityelementmax) as entitytype
    dim entitydebug$(entityelementmax)
    for e=1 to entityelementlist
     `
     rem actual file data
     if versionnumberload>=101
      rem Version 1.01
      read file 1,a : entityelement(e).maintype=a
      read file 1,a : entityelement(e).bankindex=a
      read file 1,a : entityelement(e).staticflag=a
      read float 1,a# : entityelement(e).x=a#
      read float 1,a# : entityelement(e).y=a#
      read float 1,a# : entityelement(e).z=a#
      read float 1,a# : entityelement(e).rx=a#
      read float 1,a# : entityelement(e).ry=a#
      read float 1,a# : entityelement(e).rz=a#
      read string 1,a$ : entityelement(e).eleprof.name$=a$
      read string 1,a$ : entityelement(e).eleprof.aiinit$=a$
      read string 1,a$ : entityelement(e).eleprof.aimain$=a$
      read string 1,a$ : entityelement(e).eleprof.aidestroy$=a$
      read file 1,a : entityelement(e).eleprof.isobjective=a
      read string 1,a$ : entityelement(e).eleprof.usekey$=a$
      read string 1,a$ : entityelement(e).eleprof.ifused$=a$
      read string 1,a$ : entityelement(e).eleprof.ifusednear$=a$
      read file 1,a : entityelement(e).eleprof.uniqueelement=a
      read string 1,a$ : entityelement(e).eleprof.texd$=a$
      read string 1,a$ : entityelement(e).eleprof.texaltd$=a$
      read string 1,a$ : entityelement(e).eleprof.effect$=a$
      read file 1,a : entityelement(e).eleprof.transparency=a
      read file 1,a : entityelement(e).editorfixed=a
      read string 1,a$ : entityelement(e).eleprof.soundset$=a$
      read string 1,a$ : entityelement(e).eleprof.soundset1$=a$
      read file 1,a : entityelement(e).eleprof.spawnmax=a
      read file 1,a : entityelement(e).eleprof.spawndelay=a
      read file 1,a : entityelement(e).eleprof.spawnqty=a
      read file 1,a : entityelement(e).eleprof.hurtfall=a
      read file 1,a : entityelement(e).eleprof.castshadow=a
      read file 1,a : entityelement(e).eleprof.reducetexture=a
      read file 1,a : entityelement(e).eleprof.speed=a
      read string 1,a$ : entityelement(e).eleprof.aishoot$=a$
      read string 1,a$ : entityelement(e).eleprof.hasweapon$=a$
      read file 1,a : entityelement(e).eleprof.lives=a
      read file 1,a : entityelement(e).spawn.max=a
      read file 1,a : entityelement(e).spawn.delay=a
      read file 1,a : entityelement(e).spawn.qty=a
      read float 1,a# : entityelement(e).eleprof.scale=a#
      read float 1,a# : entityelement(e).eleprof.coneheight=a#
      read float 1,a# : entityelement(e).eleprof.coneangle=a#
      read file 1,a : entityelement(e).eleprof.strength=a
      read file 1,a : entityelement(e).eleprof.isimmobile=a
      read file 1,a : entityelement(e).eleprof.cantakeweapon=a
      read file 1,a : entityelement(e).eleprof.quantity=a
      read file 1,a : entityelement(e).eleprof.markerindex=a
      read file 1,a : dw=a : dw=dw+0xFF000000 : entityelement(e).eleprof.light.color=dw
      read file 1,a : entityelement(e).eleprof.light.range=a
      read file 1,a : entityelement(e).eleprof.trigger.areax1=a
      read file 1,a : entityelement(e).eleprof.trigger.areay1=a
      read file 1,a : entityelement(e).eleprof.trigger.areaz1=a
      read file 1,a : entityelement(e).eleprof.trigger.areax2=a
      read file 1,a : entityelement(e).eleprof.trigger.areay2=a
      read file 1,a : entityelement(e).eleprof.trigger.areaz2=a
      read string 1,a$ : entityelement(e).eleprof.basedecal$=a$
     endif
     if versionnumberload>=102
      rem Version 1.02
      read file 1,a : entityelement(e).eleprof.rateoffire=a
      read file 1,a : entityelement(e).eleprof.damage=a
      read file 1,a : entityelement(e).eleprof.accuracy=a
      read file 1,a : entityelement(e).eleprof.reloadqty=a
      read file 1,a : entityelement(e).eleprof.fireiterations=a
      read file 1,a : entityelement(e).eleprof.lifespan=a
      read float 1,a# : entityelement(e).eleprof.throwspeed=a#
      read float 1,a# : entityelement(e).eleprof.throwangle=a#
      read file 1,a : entityelement(e).eleprof.bounceqty=a
      read file 1,a : entityelement(e).eleprof.explodeonhit=a
      read file 1,a : entityelement(e).eleprof.weaponisammo=a
      read file 1,a : entityelement(e).eleprof.spawnupto=a
      read file 1,a : entityelement(e).eleprof.spawnafterdelay=a
      read file 1,a : entityelement(e).eleprof.spawnwhendead=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
     endif
     if versionnumberload>=103
      rem Version 1.03 - V1 draft physics
      read file 1,a : entityelement(e).eleprof.physics=a
      read file 1,a : entityelement(e).eleprof.phyweight=a
      read file 1,a : entityelement(e).eleprof.phyfriction=a
      read file 1,a : entityelement(e).eleprof.phyforcedamage=a
      read file 1,a : entityelement(e).eleprof.rotatethrow=a
      read file 1,a : entityelement(e).eleprof.explodable=a
      read file 1,a : entityelement(e).eleprof.explodedamage=a
      read file 1,a : entityelement(e).eleprof.phydw4=a
      read file 1,a : entityelement(e).eleprof.phydw5=a
     endif
     if versionnumberload>=104
      rem Version 1.04 - BETA4 extra field
      read file 1,a : entityelement(e).eleprof.phyalways=a
     endif
     if versionnumberload>=105
      rem Version 1.05 - BETA8 extra fields
      read file 1,a : entityelement(e).eleprof.spawndelayrandom=a
      read file 1,a : entityelement(e).eleprof.spawnqtyrandom=a
      read file 1,a : entityelement(e).eleprof.spawnvel=a
      read file 1,a : entityelement(e).eleprof.spawnvelrandom=a
      read file 1,a : entityelement(e).eleprof.spawnangle=a
      read file 1,a : entityelement(e).eleprof.spawnanglerandom=a
     endif
     if versionnumberload>=106
      rem Version 1.06 - BETA10 extra fields
      read file 1,a : entityelement(e).eleprof.spawnatstart=a
      read file 1,a : entityelement(e).eleprof.spawnlife=a
     endif
     if versionnumberload>=107
      rem FPSCV104RC8 - forgot to save infinilight index (dynamic lights in final build never worked)
      read file 1,a : entityelement(e).eleprof.light.index=a
     endif
     `
     rem fill in the blanks if load older version
     ttentid=entityelement(e).bankindex
     if versionnumberload<103
      rem Version 1.03 - V1 draft physics (-1 means calculate at entobj-loadtime)
      entityelement(e).eleprof.physics=entityprofile(ttentid).physics
      entityelement(e).eleprof.phyweight=entityprofile(ttentid).phyweight
      entityelement(e).eleprof.phyfriction=entityprofile(ttentid).phyfriction
      entityelement(e).eleprof.phyforcedamage=entityprofile(ttentid).phyforcedamage
      entityelement(e).eleprof.rotatethrow=entityprofile(ttentid).rotatethrow
      entityelement(e).eleprof.explodable=entityprofile(ttentid).explodable
      entityelement(e).eleprof.phydw3=0
      entityelement(e).eleprof.phydw4=0
      entityelement(e).eleprof.phydw5=0
     endif
     if versionnumberload<104
      rem Version 1.04 - BETA4 extra field
      entityelement(e).eleprof.phyalways=entityprofile(ttentid).phyalways
     endif
     if versionnumberload<105
      rem Version 1.05 - BETA8
      entityelement(e).eleprof.spawndelayrandom=entityprofile(ttentid).spawndelayrandom
      entityelement(e).eleprof.spawnqtyrandom=entityprofile(ttentid).spawnqtyrandom
      entityelement(e).eleprof.spawnvel=entityprofile(ttentid).spawnvel
      entityelement(e).eleprof.spawnvelrandom=entityprofile(ttentid).spawnvelrandom
      entityelement(e).eleprof.spawnangle=entityprofile(ttentid).spawnangle
      entityelement(e).eleprof.spawnanglerandom=entityprofile(ttentid).spawnanglerandom
     endif
     if versionnumberload<106
      rem Version 1.06 - BETA10
      entityelement(e).eleprof.spawnatstart=entityprofile(ttentid).spawnatstart
      entityelement(e).eleprof.spawnlife=entityprofile(ttentid).spawnlife
     endif
     `
    next e
   endif
  else
   debugstring(strarr$(101),"")
  endif
 close file 1
 `
endif

rem and erase any elements that DO NOT have a valid profile (file moved/deleted)
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entid>0
  if len(entitybank$(entid))=0
   entityelement(e).bankindex=0
  endif
 endif
next e

return

_entity_setupelementobject:

rem place entity at correct position and orientation
if object exist(obj)=1
 `
 `tscale=entityelement(e).eleprof.scale EA does not support SCALE value in eleprof!
 tscale=entityprofile(entid).scale
 if tscale<>0 then scale object obj,tscale,tscale,tscale
 `
 if entityprofile(entid).fixnewy<>0
  rotate object obj,0,entityprofile(entid).fixnewy,0
  fix object pivot obj
 endif
 `
 position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
 rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
 set object speed obj,125
 `
 rem setup lighting properties of entity
 set object diffuse obj,rgb(128,128,128)
 set object ambience obj,rgb(255,255,255)
 set object emissive obj,0
 set object specular obj,0
 `
 rem Load and Apply ''unique'' FX effect
 if entityelement(e).staticflag=0
  if guseeffectonentitiesstate=1
   tfile$=entityelement(e).eleprof.effect$
   if tfile$<>""
    teffectid=loadinternaleffectunique(tfile$,1)
    entityelement(e).eleprof.usingeffect=teffectid
    entityelement(e).eleprof.uniqueelement=1
   endif
  else
   rem fastbone for quick speed test (if system supports Vertex Shader
   if entityprofile(entid).ischaracter=1
    tthisentobjshallbetextured=0
    if gignorefastbone=0
     if total object frames(obj)>1
      rem and MUST have animation to bone animate
      if object exist(obj)=1
       if get maximum vertex shader version()>=2.0
        teffectid=0
        teffectid=loadinternaleffectunique("effectbank\fastbone\fastbone.fx",1)
        if teffectid>0
         entityelement(e).eleprof.usingeffect=teffectid
         entityelement(e).eleprof.uniqueelement=1
         tthisentobjshallbetextured=1
        endif
       endif
      endif
     endif
    endif
    if tthisentobjshallbetextured=0
     rem this works, but if texture customised it gets wiped out I think (needs investigation)
     if entityelement(e).eleprof.texdid=0
      rem repair texture if not being uniquelement textured below
      entityelement(e).eleprof.texdid=entityprofile(entid).texdid
      texture object obj,entityelement(e).eleprof.texdid
     endif
    endif
   endif
  endif
 else
  rem if staic, universe needs this entity to be a shared FX (because the object will be deleted!)
  if guseeffectonentitiesstate=1
   if entityelement(e).eleprof.usingeffect>0
    entityelement(e).eleprof.uniqueelement=1
    `
    rem FPSCV105RC3 - illumination shader does not work with static entity (due to missing LM code)
    tttfile$=lower$(entityelement(e).eleprof.effect$)
    ttt$="illuminationent.fx"
    if lower$(right$(tttfile$,len(ttt$)))=ttt$
     rem change ENT shader to LM-based shader
     tttfile$="effectbank\illuminationmap\illuminationmap.fx"
     entityelement(e).eleprof.effect$=tttfile$
     teffectid=loadinternaleffect(tttfile$)
     if teffectid>0
      entityelement(e).eleprof.usingeffect=teffectid
      set object effect obj,entityelement(e).eleprof.usingeffect
     endif
     rem load correct textures
     tfullorhalfdivide=0
     tttentid=entityelement(e).bankindex
     texdir$=entityprofile(tttentid).texd$
     tfile$=tttfile$ : teffectuseslightmapstage=0 : gosub _common_makeeffecttextureset
     entityelement(e).eleprof.texdid=loadinternalimagecompressquality(texdir1$,1,tfullorhalfdivide)
     entityelement(e).eleprof.tex1id=loadinternalimagecompressquality(texdir2$,1,tfullorhalfdivide)
     entityelement(e).eleprof.tex2id=loadinternalimagecompressquality(texdir3$,1,tfullorhalfdivide)
     rem add the required LM stage
     texture object obj,0,entityelement(e).eleprof.texdid
     texture object obj,1,entityelement(e).eleprof.tex1id
     texture object obj,2,entityelement(e).eleprof.tex2id
    else
     for tstage=0 to entityelement(e).eleprof.texidmax
      if tstage=0 then texture object obj,tstage,entityelement(e).eleprof.texdid
      if tstage=1 then texture object obj,tstage,entityelement(e).eleprof.tex1id
      if tstage=2 then texture object obj,tstage,entityelement(e).eleprof.tex2id
      if tstage=3 then texture object obj,tstage,entityelement(e).eleprof.tex3id
      if tstage=4 then texture object obj,tstage,entityelement(e).eleprof.tex4id
     next tstage
    endif
   endif
    `
  endif
 endif
 `
 rem If element unique, can take its own texture, effect and transparency
 teletransparency=entityelement(e).eleprof.transparency
 if entityelement(e).eleprof.uniqueelement=1
  teffectid=entityelement(e).eleprof.usingeffect
  if teffectid>0
   set object effect obj,teffectid
  else
   texture object obj,0,entityelement(e).eleprof.texdid
  endif
 endif
 `
 rem Set entity element transparency also, so that it is placed correctly in render order
 set object transparency obj,teletransparency
 `
 rem If transparent, no need to Z write
 if teletransparency>0
  if teletransparency>=2
   disable object zwrite obj
   enable object zbias obj,0.0,-0.000001
  endif
 endif
 `
 rem pre-use step for characters
 if total object frames(obj)>0
  set object frame obj,0
  if entityprofile(entid).ischaracter=1
   if entityprofile(entid).animmax>=1
    teai=0 : if entityanim(entid,1).start>0 then teai=1
    tbaseframe=teai : gosub _entity_getactualframestart : tfstart=tactualframe
    tbaseframe=teai : gosub _entity_getactualframefinish : tffinish=tactualframe
    loop object obj,tfstart,tffinish
   else
    loop object obj : stop object obj
   endif
  endif
 endif
 `
 rem weapon and ammo are none collidable
 if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
  entityelement(e).collisionactive=0
  set object collision off obj
 else
  set object collision on obj
 endif
 `
 rem do not allow player to stop at entity characters (so can run through them)
 if entityprofile(entid).ischaracter=1
  entityelement(e).collisionactive=0
  set object collision off obj
 endif
 `
endif

rem child spawns should remain invisible for now
if entityelement(e).spawn.leaderid>0
 if entityelement(e).spawn.leader=0
  if object exist(obj)=1
   entityelement(e).collisionactive=0
   set object collision off obj
   hide object obj
  endif
 endif
endif

rem makrers by default are hidden
if entityprofile(entid).ismarker>0
 if object exist(obj)=1
  entityelement(e).collisionactive=0
  set object collision off obj
  hide object obj
 endif
endif

return

_entity_createelementasobject:

rem preset entity data
entityelement(e).obj=obj
entid=entityelement(e).bankindex
entityelement(e).profileobj=entitybankoffset+entid

rem delete any existing object and create new one
tgoaheadandsetup=0
if object exist(obj)=1 then delete object obj
if entityelement(e).profileobj>0
 if object exist(entityelement(e).profileobj)=1
  if entityelement(e).spawn.leader=1 and entityelement(e).spawn.max>0
   rem spawning entitiy leaders do not need visual obj (they are invisible makrings), but need obj for object XY ref
   make object triangle obj,0,0,0,0,0,0,0,0,0
   hide object obj
  else
   rem special clone which keeps the animation data in once place (smaller mem footprint)
   if entityelement(e).staticflag=1 and entityprofile(entid).ischaracter=1
    rem if static, and obj has animation (character) - hide it
    make object triangle obj,0,0,0,0,0,0,0,0,0
    hide object obj
   else
    rem FPSCV10X - old U57 clone does not copy multi-materials over
    if entityprofile(entid).texd$=""
     ent$=entitybank$(entid)
     entdir$="entitybank\"
     entpath$=getpath(ent$)
     tfile$=entdir$+entpath$+entityprofile(entid).model$
     if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
     if tdbofile$<>"" and file exist(tdbofile$)=1 then tfile$=tdbofile$
     if file exist(tfile$)=0 then tfile$=entityprofile(entid).model$
     if file exist(tfile$)=1
      load object tfile$,obj
     else
      clone object obj,entityelement(e).profileobj,1
     endif
    else
     clone object obj,entityelement(e).profileobj,1
    endif
    tgoaheadandsetup=1
   endif
  endif
 else
  rem some elements can be empty - result of editing
  make object triangle obj,0,0,0,0,0,0,0,0,0
  hide object obj
 endif
else
 rem some elements can be empty - result of editing
 make object triangle obj,0,0,0,0,0,0,0,0,0
 hide object obj
endif

rem Setup element object (position and orientations)
if tgoaheadandsetup=1
 gosub _entity_setupelementobject
else
 if obj>0
  if object exist(obj)=1
   position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
   rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
  endif
 endif
endif

rem FPSCV101 - static entities that do not specify a texture draw from local TGA (however when used inside UNIVERSE.DBO the relative location of the texture is lost)
rem so we must manually insert a texture so the static entity has the path to get the actual texture
if entityelement(e).staticflag=1 and entityprofile(entid).texd$=""
 if obj>0
  if object exist(obj)=1
   tprofileobjnum=entityelement(e).profileobj
   if tprofileobjnum>0
    if object exist(tprofileobjnum)=1
     tscanfile$=entdir$+entpath$+entityprofile(entid).model$
     if lower$(right$(tscanfile$,2))=".x"
      if file exist(tscanfile$)=0
       tscanfile$=left$(tscanfile$,len(tscanfile$)-2)+".dbo"
      endif
     endif
     ttrythisone$=findmaterialtexturesinmodelfile(tscanfile$,entdir$+entpath$)
     limbtexid=loadinternalimagecompressquality(ttrythisone$,5,0)
     if limbtexid>0
      entityelement(e).eleprof.texd$=ttrythisone$
      addfiletocollection(entityelement(e).eleprof.texd$)
      entityelement(e).eleprof.texdid=limbtexid
      texture object obj,limbtexid
     endif
    endif
   endif
  endif
 endif
endif

return

_entity_getgunidandflakid:

rem Use Weapon Name to get GUNID and FLAKID
if tgunid$<>""
 findgun$=lower$(tgunid$)
 gosub _gun_findweaponindexbyname
 tgunid=foundgunid
 tflakid$=gun(tgunid).settings.flakname$
 if tflakid$<>""
  flak$=lower$(tflakid$) : gosub _flak_findindex
  tflakid=tindex
 else
  tflakid=0
 endif
else
 tgunid=0 : tflakid=0
endif

return

_entity_fillelementfromprofile:
 `
 rem Name
 entityelement(e).eleprof.name$=entityprofileheader(entid).desc$
 `
 rem AI values
 entityelement(e).eleprof.aiinit$=entityprofile(entid).aiinit$
 entityelement(e).eleprof.aimain$=entityprofile(entid).aimain$
 entityelement(e).eleprof.aidestroy$=entityprofile(entid).aidestroy$
 entityelement(e).eleprof.aishoot$=entityprofile(entid).aishoot$
 `
 rem AI use vars
 entityelement(e).eleprof.usekey$=entityprofile(entid).usekey$
 entityelement(e).eleprof.ifused$=entityprofile(entid).ifused$
 entityelement(e).eleprof.ifusednear$=entityprofile(entid).ifusednear$
 `
 rem Spawn
 entityelement(e).eleprof.spawnatstart=entityprofile(entid).spawnatstart
 entityelement(e).eleprof.spawnmax=entityprofile(entid).spawnmax
 entityelement(e).eleprof.spawndelay=entityprofile(entid).spawndelay
 entityelement(e).eleprof.spawnqty=entityprofile(entid).spawnqty
 entityelement(e).eleprof.spawnupto=entityprofile(entid).spawnupto
 entityelement(e).eleprof.spawnafterdelay=entityprofile(entid).spawnafterdelay
 entityelement(e).eleprof.spawnwhendead=entityprofile(entid).spawnwhendead
 entityelement(e).eleprof.spawndelayrandom=entityprofile(entid).spawndelayrandom
 entityelement(e).eleprof.spawnqtyrandom=entityprofile(entid).spawnqtyrandom
 entityelement(e).eleprof.spawnvel=entityprofile(entid).spawnvel
 entityelement(e).eleprof.spawnvelrandom=entityprofile(entid).spawnvelrandom
 entityelement(e).eleprof.spawnangle=entityprofile(entid).spawnangle
 entityelement(e).eleprof.spawnanglerandom=entityprofile(entid).spawnanglerandom
 entityelement(e).eleprof.spawnlife=entityprofile(entid).spawnlife
 `
 rem Scale, Cone
 entityelement(e).eleprof.scale=entityprofile(entid).scale
 entityelement(e).eleprof.coneheight=entityprofile(entid).coneheight
 entityelement(e).eleprof.coneangle=entityprofile(entid).coneangle
 `
 rem Textre and Effect Data (zero to begin with
 entityelement(e).eleprof.uniqueelement=0
 entityelement(e).eleprof.texd$=entityprofile(entid).texd$
 entityelement(e).eleprof.texaltd$=entityprofile(entid).texaltd$
 entityelement(e).eleprof.effect$=entityprofile(entid).effect$
 entityelement(e).eleprof.transparency=entityprofile(entid).transparency
 entityelement(e).eleprof.castshadow=entityprofile(entid).castshadow
 entityelement(e).eleprof.reducetexture=entityprofile(entid).reducetexture
 `
 rem Strength and Quantity
 entityelement(e).eleprof.strength=entityprofile(entid).strength
 entityelement(e).eleprof.lives=entityprofile(entid).lives
 entityelement(e).eleprof.isimmobile=entityprofile(entid).isimmobile
 entityelement(e).eleprof.cantakeweapon=entityprofile(entid).cantakeweapon
 entityelement(e).eleprof.hasweapon$=entityprofile(entid).hasweapon$
 entityelement(e).eleprof.quantity=entityprofile(entid).quantity
 entityelement(e).eleprof.isobjective=entityprofile(entid).isobjective
 entityelement(e).eleprof.speed=entityprofile(entid).speed
 entityelement(e).eleprof.hurtfall=entityprofile(entid).hurtfall
 `
 rem Decal and Soundset Name
 entityelement(e).eleprof.basedecal$=entitydecal$(entid,0)
 entityelement(e).eleprof.soundset$=entityprofile(entid).soundset$
 entityelement(e).eleprof.soundset1$=entityprofile(entid).soundset1$
 `
 rem Marker Data
 entityelement(e).eleprof.markerindex=entityprofile(entid).markerindex
 entityelement(e).eleprof.light=entityprofile(entid).light
 entityelement(e).eleprof.trigger=entityprofile(entid).trigger
 `
 rem Data Extracted From GUN and FLAK
 tgunid$=entityprofile(entid).isweapon$
 gosub _entity_getgunidandflakid
 entityelement(e).eleprof.rateoffire=85
 entityelement(e).eleprof.weaponisammo=0
 if tgunid>0
  entityelement(e).eleprof.accuracy=gun(tgunid).settings.accuracy
  entityelement(e).eleprof.reloadqty=gun(tgunid).settings.reloadqty
  entityelement(e).eleprof.fireiterations=gun(tgunid).settings.iterate
  if tflakid=0
   entityelement(e).eleprof.damage=gun(tgunid).settings.damage
  else
   entityelement(e).eleprof.damage=flak(tflakid).profile.damage
   entityelement(e).eleprof.lifespan=flak(tflakid).profile.lifespan
   entityelement(e).eleprof.throwspeed=flak(tflakid).profile.zinc
   entityelement(e).eleprof.throwangle=flak(tflakid).profile.yinc
   entityelement(e).eleprof.bounceqty=flak(tflakid).profile.bounceonhit
   entityelement(e).eleprof.explodeonhit=flak(tflakid).profile.explodeonhit
   entityelement(e).eleprof.weaponisammo=tflakid
  endif
 endif
 `
 rem Physics Data
 entityelement(e).eleprof.physics=entityprofile(entid).physics
 entityelement(e).eleprof.phyalways=entityprofile(entid).phyalways
 entityelement(e).eleprof.phyweight=entityprofile(entid).phyweight
 entityelement(e).eleprof.phyfriction=entityprofile(entid).phyfriction
 entityelement(e).eleprof.phyforcedamage=entityprofile(entid).phyforcedamage
 entityelement(e).eleprof.rotatethrow=entityprofile(entid).rotatethrow
 entityelement(e).eleprof.explodable=entityprofile(entid).explodable
 entityelement(e).eleprof.explodedamage=entityprofile(entid).explodedamage
 `
 rem Copy over found data and or load it
 configureobj=0 : gosub _entity_configueelementforuse
 `
return

_entity_fillgrideleproffromprofile:
 `
 rem Name
 grideleprof.name$=entityprofileheader(entid).desc$
 `
 rem AI values
 grideleprof.aiinit$=entityprofile(entid).aiinit$
 grideleprof.aimain$=entityprofile(entid).aimain$
 grideleprof.aidestroy$=entityprofile(entid).aidestroy$
 grideleprof.aishoot$=entityprofile(entid).aishoot$
 `
 rem AI use vars
 grideleprof.usekey$=entityprofile(entid).usekey$
 grideleprof.ifused$=entityprofile(entid).ifused$
 grideleprof.ifusednear$=entityprofile(entid).ifusednear$
 `
 rem Spawn
 grideleprof.spawnatstart=entityprofile(entid).spawnatstart
 grideleprof.spawnmax=entityprofile(entid).spawnmax
 grideleprof.spawndelay=entityprofile(entid).spawndelay
 grideleprof.spawnqty=entityprofile(entid).spawnqty
 grideleprof.spawnupto=entityprofile(entid).spawnupto
 grideleprof.spawnafterdelay=entityprofile(entid).spawnafterdelay
 grideleprof.spawnwhendead=entityprofile(entid).spawnwhendead
 grideleprof.spawndelayrandom=entityprofile(entid).spawndelayrandom
 grideleprof.spawnqtyrandom=entityprofile(entid).spawnqtyrandom
 grideleprof.spawnvel=entityprofile(entid).spawnvel
 grideleprof.spawnvelrandom=entityprofile(entid).spawnvelrandom
 grideleprof.spawnangle=entityprofile(entid).spawnangle
 grideleprof.spawnanglerandom=entityprofile(entid).spawnanglerandom
 grideleprof.spawnlife=entityprofile(entid).spawnlife
 `
 rem Scale, Cone
 grideleprof.scale=entityprofile(entid).scale
 grideleprof.coneheight=entityprofile(entid).coneheight
 grideleprof.coneangle=entityprofile(entid).coneangle
 `
 rem Textre and Effect Data
 grideleprof.uniqueelement=0
 grideleprof.texd$=entityprofile(entid).texd$
 grideleprof.texaltd$=entityprofile(entid).texaltd$
 grideleprof.effect$=entityprofile(entid).effect$
 grideleprof.transparency=entityprofile(entid).transparency
 grideleprof.castshadow=entityprofile(entid).castshadow
 grideleprof.reducetexture=entityprofile(entid).reducetexture
 `
 rem Strength and Quantity
 grideleprof.strength=entityprofile(entid).strength
 grideleprof.lives=entityprofile(entid).lives
 grideleprof.isimmobile=entityprofile(entid).isimmobile
 grideleprof.cantakeweapon=entityprofile(entid).cantakeweapon
 grideleprof.hasweapon$=entityprofile(entid).hasweapon$
 grideleprof.quantity=entityprofile(entid).quantity
 grideleprof.isobjective=entityprofile(entid).isobjective
 grideleprof.hurtfall=entityprofile(entid).hurtfall
 grideleprof.speed=entityprofile(entid).speed
 `
 rem Decal and Sound Name
 grideleprof.basedecal$=entitydecal$(entid,0)
 grideleprof.soundset$=entityprofile(entid).soundset$
 grideleprof.soundset1$=entityprofile(entid).soundset1$
 `
 rem Marker Data
 grideleprof.markerindex=entityprofile(entid).markerindex
 grideleprof.light=entityprofile(entid).light
 grideleprof.trigger=entityprofile(entid).trigger
 `
 rem Data Extracted From GUN and FLAK
 tgunid$=entityprofile(entid).isweapon$
 gosub _entity_getgunidandflakid
 grideleprof.rateoffire=85
 grideleprof.weaponisammo=0
 if tgunid>0
  grideleprof.accuracy=gun(tgunid).settings.accuracy
  grideleprof.reloadqty=gun(tgunid).settings.reloadqty
  grideleprof.fireiterations=gun(tgunid).settings.iterate
  if tflakid=0
   grideleprof.damage=gun(tgunid).settings.damage
  else
   grideleprof.damage=flak(tflakid).profile.damage
   grideleprof.lifespan=flak(tflakid).profile.lifespan
   grideleprof.throwspeed=flak(tflakid).profile.zinc
   grideleprof.throwangle=flak(tflakid).profile.yinc
   grideleprof.bounceqty=flak(tflakid).profile.bounceonhit
   grideleprof.explodeonhit=flak(tflakid).profile.explodeonhit
   grideleprof.weaponisammo=tflakid
  endif
 endif
 `
 rem Physics Data
 grideleprof.physics=entityprofile(entid).physics
 grideleprof.phyalways=entityprofile(entid).phyalways
 grideleprof.phyweight=entityprofile(entid).phyweight
 grideleprof.phyfriction=entityprofile(entid).phyfriction
 grideleprof.phyforcedamage=entityprofile(entid).phyforcedamage
 grideleprof.rotatethrow=entityprofile(entid).rotatethrow
 grideleprof.explodable=entityprofile(entid).explodable
 grideleprof.explodedamage=entityprofile(entid).explodedamage
 `
return

_entity_createattachment:
 `
 rem Load all VWEAPS for each entity that wants weapon attachments
 entid=entityelement(e).bankindex
 entityelement(e).attachmentobj=0
 entityelement(e).attachmentbaseobj=0
 entityelement(e).attachmentweapontype=0
 entityelement(e).attachmentobjfirespotlimb=0
 if entityprofile(entid).ischaracter=1
  if object exist(eleobj+e)=1
   if entityprofile(entid).firespotlimb>-1
    `
    rem all vweaps (that are active)
    rem FPSCV104 - changed so MULTIPLAYER=ALL weapons, SINGLEPLAYER=only weapon being held (quicker/bugfree/load)
    ttattachindex=0
    for tgindex=1 to gunmax
     if gun(tgindex).activeingame=1
      tweaponname$=gun(tgindex).name$
      if tweaponname$<>""
       `
       rem FPSCV104 - either multiplayer or single player entity has this gun in their hands
       tthasweapon$=lower$(entityelement(e).eleprof.hasweapon$)
       if tthasweapon$=tweaponname$ or gmultiplayergame=1
        `
        rem go and load this gun (attached to calling entity instance)
        inc ttattachindex
        inc entityattachmentindex
        ttobj=entityattachmentsoffset+entityattachmentindex
        if ttattachindex=1 then entityelement(e).attachmentbaseobj=ttobj
        if object exist(ttobj)=1 then delete object ttobj
        tfile$="gamecore\Guns\"+tweaponname$+"\vweap.x"
        rem FPSCV10X some weapons do not have vweap.x models
        if file exist(tfile$)=1
         load object tfile$,ttobj : addfiletocollection(tfile$)
        else
         rem invisible weapon attachment
         make object triangle ttobj,0,0,0,0,0,0,0,0,0
        endif
        texuseid=loadinternaltexture("gamecore\Guns\"+tweaponname$+"\gun_D2.tga")
        set object transparency ttobj,1
        set object collision off ttobj
        texture object ttobj,texuseid
        hide object ttobj
        `
       endif
       `
      endif
     endif
    next tgindex
    rem Opportunity for default first weapon to be attached
    tobj=eleobj+e : gosub _entity_switchattachment
    `
   endif
  endif
 endif
 `
 rem Create blob shadow for characters
 if entityprofile(entid).ischaracter=1
  if object exist(eleobj+e)=1
   inc entityattachmentindex
   ttobj=entityattachmentsoffset+entityattachmentindex
   entityelement(e).attachmentblobobj=ttobj
   make object plain ttobj,40,40
   xrotate object ttobj,90
   set object light ttobj,0
   disable object zwrite ttobj
   set object cull ttobj,1
   position object ttobj,-50000,-50000,50000
   ttexid=loadinternaltextureex("gamecore\decals\blob\blob.png",5,1)
   texture object ttobj,ttexid
   set object transparency ttobj,2
  endif
 endif
 `
return

_entity_switchattachment:
 `
 rem uses tobj, e, entid, [hasweapon$ can be changed]
 thasweapon$=lower$(entityelement(e).eleprof.hasweapon$)
 tvweapobj=entityelement(e).attachmentobj
 `
 rem unglue old VWEAP (if any)
 if tvweapobj>0
  rem re-hide object
  if object exist(tvweapobj)=1
   unglue object tvweapobj
   position object tvweapobj,0,0,0
   hide object tvweapobj
  endif
 endif
 `
 rem reset entity so not carrying
 entityelement(e).attachmentobjfirespotlimb=0
 entityelement(e).attachmentweapontype=0
 entityelement(e).attachmentobj=0
 entityelement(e).currentweapon=0
 `
 rem pick new VWEAP model to attach
 tvweapobj=0
 ttattachindex=0
 if gmultiplayergame=1
  rem arena characters have all guns attached to them
  for tgindex=1 to gunmax
   if gun(tgindex).activeingame=1
    if gun(tgindex).name$<>"" then inc ttattachindex
    if lower$(gun(tgindex).name$)=thasweapon$ then tvweapobj=entityelement(e).attachmentbaseobj+(ttattachindex-1) : exit
   endif
  next tgindex
 else
  rem FPSCV10X - single play characters have one gun - but still need to return gunindex
  ttattachindex=1
  for tgindex=1 to gunmax
   if gun(tgindex).activeingame=1
    if lower$(gun(tgindex).name$)=thasweapon$ then tvweapobj=entityelement(e).attachmentbaseobj+(ttattachindex-1) : exit
   endif
  next tgindex
 endif
 tentid=entityelement(e).bankindex
 if tvweapobj>0
  rem FPSCV10X - removing VWEAP.X no longer crashes
  if object exist(tvweapobj)=0
   tvweapobj=0
  else
   if entityprofile(tentid).firespotlimb=-1
    tvweapobj=0
   else
    if object exist(tobj)=1
     if limb exist(tobj,entityprofile(tentid).firespotlimb)=0
      tvweapobj=0
     endif
    else
     tvweapobj=0
    endif
   endif
  endif
 endif
 if tvweapobj>0
  entityelement(e).attachmentweapontype=gun(tgindex).weapontype
  entityelement(e).currentweapon=tgindex
 endif
 `
 rem if new gun selected
 if tvweapobj>0
  rem new attached object
  entityelement(e).attachmentobj=tvweapobj
  rem glue new VWEAP to entity(character)
  position object tvweapobj,0,0,0
  glue object to limb tvweapobj,tobj,entityprofile(tentid).firespotlimb
  rem relocate firepsot within VWEAP model for entity use
  entityelement(e).attachmentobjfirespotlimb=0
  perform checklist for object limbs tvweapobj
  for tc=1 to checklist quantity()
   if lower$(checklist string$(tc))="firespot"
    entityelement(e).attachmentobjfirespotlimb=tc-1
    tc=checklist quantity()+1
   endif
  next tc
  rem finally show thw weapon (if not spawn child)
  if entityelement(e).spawn.leaderid=0
   show object tvweapobj
  else
   hide object tvweapobj
  endif
 endif
 `
return

_entity_iseleprofunique:
 `
 rem Entity unique if texture or effect different
 tokay=0
 if (len(entityprofile(entid).texd$)>0 or len(entityelement(e).eleprof.texd$)>0) and entityprofile(entid).texd$<>entityelement(e).eleprof.texd$ then tokay=1
 if (len(entityprofile(entid).texaltd$)>0 or len(entityelement(e).eleprof.texaltd$)>0) and entityprofile(entid).texaltd$<>entityelement(e).eleprof.texaltd$ then tokay=1
 if (len(entityprofile(entid).effect$)>0 or len(entityelement(e).eleprof.effect$)>0) and entityprofile(entid).effect$<>entityelement(e).eleprof.effect$ then tokay=1
 if tokay=1
  entityelement(e).eleprof.uniqueelement=1
 else
  entityelement(e).eleprof.uniqueelement=0
 endif
 `
return

_entity_updatetextureandeffectfromeleprof:
 `
 rem Texture and Effect (use entityprofile loader)
 storeentdefaults as entityprofiletype
 storeentdefaults=entityprofile(entid)
 entityprofile(entid).texd$=entityelement(e).eleprof.texd$
 entityprofile(entid).texaltd$=entityelement(e).eleprof.texaltd$
 entityprofile(entid).texdid=entityelement(e).eleprof.texdid
 entityprofile(entid).texaltdid=entityelement(e).eleprof.texaltdid
 entityprofile(entid).effect$=entityelement(e).eleprof.effect$
 entityprofile(entid).usingeffect=entityelement(e).eleprof.usingeffect
 entityprofile(entid).tex1id=entityelement(e).eleprof.tex1id
 entityprofile(entid).tex2id=entityelement(e).eleprof.tex2id
 entityprofile(entid).tex3id=entityelement(e).eleprof.tex3id
 entityprofile(entid).tex4id=entityelement(e).eleprof.tex4id
 entityprofile(entid).texidmax=entityelement(e).eleprof.texidmax
 entityprofile(entid).transparency=entityelement(e).eleprof.transparency
 entityprofile(entid).reducetexture=entityelement(e).eleprof.reducetexture
 gosub _entity_loadtexturesandeffect
 entityelement(e).eleprof.texd$=entityprofile(entid).texd$
 entityelement(e).eleprof.texaltd$=entityprofile(entid).texaltd$
 entityelement(e).eleprof.texdid=entityprofile(entid).texdid
 entityelement(e).eleprof.texaltdid=entityprofile(entid).texaltdid
 entityelement(e).eleprof.effect$=entityprofile(entid).effect$
 entityelement(e).eleprof.usingeffect=entityprofile(entid).usingeffect
 entityelement(e).eleprof.tex1id=entityprofile(entid).tex1id
 entityelement(e).eleprof.tex2id=entityprofile(entid).tex2id
 entityelement(e).eleprof.tex3id=entityprofile(entid).tex3id
 entityelement(e).eleprof.tex4id=entityprofile(entid).tex4id
 entityelement(e).eleprof.texidmax=entityprofile(entid).texidmax
 entityelement(e).eleprof.transparency=entityprofile(entid).transparency
 entityelement(e).eleprof.reducetexture=entityprofile(entid).reducetexture
 entityprofile(entid)=storeentdefaults
 `
return

_entity_isgrideleprofunique:
 `
 rem Entity unique if texture or effect different
 tokay=0
 if (len(entityprofile(entid).texd$)>0 or len(grideleprof.texd$)>0) and entityprofile(entid).texd$<>grideleprof.texd$ then tokay=1
 if (len(entityprofile(entid).texaltd$)>0 or len(grideleprof.texaltd$)>0) and entityprofile(entid).texaltd$<>grideleprof.texaltd$ then tokay=1
 if (len(entityprofile(entid).effect$)>0 or len(grideleprof.effect$)>0) and entityprofile(entid).effect$<>grideleprof.effect$ then tokay=1
 if tokay=1
  grideleprof.uniqueelement=1
 else
  grideleprof.uniqueelement=0
 endif
 `
return

_entity_updatetextureandeffectfromgrideleprof:
 `
 rem Texture and Effect (use entityprofile loader)
 storeentdefaults as entityprofiletype
 storeentdefaults=entityprofile(entid)
 entityprofile(entid).texd$=grideleprof.texd$
 entityprofile(entid).texaltd$=grideleprof.texaltd$
 entityprofile(entid).texdid=grideleprof.texdid
 entityprofile(entid).texaltdid=grideleprof.texaltdid
 entityprofile(entid).effect$=grideleprof.effect$
 entityprofile(entid).usingeffect=grideleprof.usingeffect
 entityprofile(entid).tex1id=grideleprof.tex1id
 entityprofile(entid).tex2id=grideleprof.tex2id
 entityprofile(entid).tex3id=grideleprof.tex3id
 entityprofile(entid).tex4id=grideleprof.tex4id
 entityprofile(entid).texidmax=grideleprof.texidmax
 entityprofile(entid).transparency=grideleprof.transparency
 entityprofile(entid).reducetexture=grideleprof.reducetexture
 gosub _entity_loadtexturesandeffect
 grideleprof.texd$=entityprofile(entid).texd$
 grideleprof.texaltd$=entityprofile(entid).texaltd$
 grideleprof.texdid=entityprofile(entid).texdid
 grideleprof.texaltdid=entityprofile(entid).texaltdid
 grideleprof.effect$=entityprofile(entid).effect$
 grideleprof.usingeffect=entityprofile(entid).usingeffect
 grideleprof.tex1id=entityprofile(entid).tex1id
 grideleprof.tex2id=entityprofile(entid).tex2id
 grideleprof.tex3id=entityprofile(entid).tex3id
 grideleprof.tex4id=entityprofile(entid).tex4id
 grideleprof.texidmax=entityprofile(entid).texidmax
 grideleprof.transparency=entityprofile(entid).transparency
 grideleprof.reducetexture=entityprofile(entid).reducetexture
 entityprofile(entid)=storeentdefaults
 `
return

_entity_configueelementforuse:
 `
 rem Resolve AI indexes from AI script filenames
 aifile$=entityelement(e).eleprof.aiinit$ : gosub _ai_findlibindex : entityelement(e).eleprof.aiinit=libindex
 aifile$=entityelement(e).eleprof.aimain$ : gosub _ai_findlibindex : entityelement(e).eleprof.aimain=libindex
 aifile$=entityelement(e).eleprof.aidestroy$ : gosub _ai_findlibindex : entityelement(e).eleprof.aidestroy=libindex
 aifile$=entityelement(e).eleprof.aishoot$ : gosub _ai_findlibindex : entityelement(e).eleprof.aishoot=libindex
 `
 rem prevent main AI from running in (multiplayer)
 if gmultiplayergame=1
  rem server entities by default
  entityelement(e).servercontrolled=1
  if entityprofile(entid).ischaracter=1
   rem characters are ALL possible players NO MAIN LOGIC - SERVER CONTROLLED ZOMBIE ENTITIES
   aifile$="default.fpi" : gosub _ai_findlibindex : entityelement(e).eleprof.aimain=libindex
  endif
 endif
 `
 rem Configure AI for element
 entityelement(e).active=1
 entityelement(e).dormant=1
 entityelement(e).collisionactive=1
 entityelement(e).ai.libinit=entityelement(e).eleprof.aiinit
 entityelement(e).ai.libmain=entityelement(e).eleprof.aimain
 entityelement(e).ai.libdestroy=entityelement(e).eleprof.aidestroy
 entityelement(e).ai.libshoot=entityelement(e).eleprof.aishoot
 entityelement(e).ai.libindex=entityelement(e).ai.libinit
 entityelement(e).mover.da=entityelement(e).ry
 entityelement(e).ai.waypoint.state=0
 entityelement(e).ai.alphafade=0
 entityelement(e).ai.state=0
 `
 rem Configure animation defaults
 if entityprofile(entid).ischaracter=1
  entityelement(e).animspeed=2.0
 else
  entityelement(e).animspeed=4.0
 endif
 `
 rem Spawn values
 entityelement(e).spawn.atstart=entityelement(e).eleprof.spawnatstart
 entityelement(e).spawn.max=entityelement(e).eleprof.spawnmax
 entityelement(e).spawn.delay=entityelement(e).eleprof.spawndelay
 entityelement(e).spawn.qty=entityelement(e).eleprof.spawnqty
 entityelement(e).spawn.upto=entityelement(e).eleprof.spawnupto
 entityelement(e).spawn.afterdelay=entityelement(e).eleprof.spawnafterdelay
 entityelement(e).spawn.whendead=entityelement(e).eleprof.spawnwhendead
 entityelement(e).spawn.delayrandom=entityelement(e).eleprof.spawndelayrandom
 entityelement(e).spawn.qtyrandom=entityelement(e).eleprof.spawnqtyrandom
 entityelement(e).spawn.vel=entityelement(e).eleprof.spawnvel
 entityelement(e).spawn.velrandom=entityelement(e).eleprof.spawnvelrandom
 entityelement(e).spawn.angle=entityelement(e).eleprof.spawnangle
 entityelement(e).spawn.anglerandom=entityelement(e).eleprof.spawnanglerandom
 entityelement(e).spawn.life=entityelement(e).eleprof.spawnlife
 `
 rem Spawn off means spawn-ready to be used, so..
 if entityelement(e).spawn.atstart=0 and entityelement(e).spawn.max=0
  entityelement(e).spawn.max=1
  if entityelement(e).spawn.afterdelay=0 and entityelement(e).spawn.whendead=0
   entityelement(e).spawn.afterdelay=1
  endif
  if entityelement(e).spawn.qty=0 then entityelement(e).spawn.qty=1
  if entityelement(e).spawn.upto=0 then entityelement(e).spawn.upto=1
 endif
 `
 rem Configure health from strength
 if entityelement(e).eleprof.strength>0
  entityelement(e).health=entityelement(e).eleprof.strength
 else
  entityelement(e).health=1
 endif
 `
 rem Moved from SETUP, as FX name can change here
 if guseeffectonentitiesstate=1
  tfile$=entityelement(e).eleprof.effect$
  if tfile$<>""
   if entityelement(e).staticflag=0
    rem dynamic entities cannot use scene FX, must be entity FX..
    rem for backwards EA compatibility with old entity eleprofs, bump.fx has become bumpent.fx
    if lower$(tfile$)="effectbank\bump\bump.fx" then tfile$="effectbank\bumpent\bumpent.fx"
    entityelement(e).eleprof.effect$=tfile$
    entityelement(e).eleprof.uniqueelement=1
   else
    rem if entity static, this routine called from UNIVERSE code to prepare static entities
    rem ENSURE the bumpent.fx is replaced with BUMP.FX as the former FX file would be wrong
    if lower$(tfile$)="effectbank\bumpent\bumpent.fx" then tfile$="effectbank\bump\bump.fx"
    if lower$(tfile$)="effectbank\bumpbone\bumpbone.fx" then tfile$="effectbank\bump\bump.fx"
    entityelement(e).eleprof.effect$=tfile$
   endif
  endif
 endif
 `
 rem Texture and Effect (use entityprofile loader)
 gosub _entity_iseleprofunique
 entobj=configureobj : gosub _entity_updatetextureandeffectfromeleprof
 `
 rem Resolve default weapon gun ids
 if entityelement(e).eleprof.hasweapon$<>""
  findgun$=lower$(entityelement(e).eleprof.hasweapon$) : gosub _gun_findweaponindexbyname
  entityelement(e).eleprof.hasweapon=foundgunid
  if foundgunid>0 and entityprofile(entid).isammo=0 then gun(foundgunid).activeingame=1
 else
  entityelement(e).eleprof.hasweapon=0
 endif
 `
return

_entity_createelements:

rem pre-create element data (load from eleprof)
for e=1 to entityelementlist
 entobj=0 : entid=entityelement(e).bankindex
 configureobj=0 : gosub _entity_configueelementforuse
next e

rem spawn all elements (one element with a max.spawn of 5 means we duplicate another 4 here)
countnewselementsize=0
for spawne=1 to entityelementlist
 if entityelement(spawne).staticflag=0
  inc countnewselementsize,1+entityelement(spawne).spawn.max
 endif
next spawne

dim newentityelement(countnewselementsize) as entitytype
newentityelementlist=0
for spawne=1 to entityelementlist
 if entityelement(spawne).staticflag=0
  for te=1 to 1+entityelement(spawne).spawn.max
   inc newentityelementlist
   newentityelement(newentityelementlist)=entityelement(spawne)
   if te=1
    rem leader
    newentityelement(newentityelementlist).spawn.leader=1
    newentityelement(newentityelementlist).spawn.leadercount=0
    newentityelement(newentityelementlist).spawn.leaderid=0
    newentityelement(newentityelementlist).spawn.x=entityelement(spawne).x
    newentityelement(newentityelementlist).spawn.y=entityelement(spawne).y
    newentityelement(newentityelementlist).spawn.z=entityelement(spawne).z
    newentityelement(newentityelementlist).active=1
    newentityelement(newentityelementlist).dormant=0
    theleader=newentityelementlist
   else
    rem follower - uses MAX range to group followers to each leader
    newentityelement(newentityelementlist).spawn.leader=0
    newentityelement(newentityelementlist).spawn.leadercount=0
    newentityelement(newentityelementlist).spawn.leaderid=theleader
    newentityelement(newentityelementlist).active=0
    newentityelement(newentityelementlist).dormant=1
    newentityelement(newentityelementlist).health=0
    newentityelement(newentityelementlist).eleprof.lives=0
   endif
  next te
 endif
next spawne
undim entityelement()
undim entitydebug$()
entityelementlist=newentityelementlist
entityelementmax=entityelementlist
dim entityelement(entityelementmax) as entitytype
dim entitybreadcrumbs(entityelementmax,50) as entitybreadcrumbstype
dim entitydebug$(entityelementmax)
for e=1 to entityelementmax
 entityelement(e)=newentityelement(e)
next e
undim newentityelement()

rem create instances for all elements (create dynamic entities only)
debugviewtext(302,strarr$(102))
eleobj=entityobjectoffset : ttick=0 : ttickmax=entityelementlist/3 : rem V106 faster build time ttickmax=1
for e=1 to entityelementlist
 obj=eleobj+e
 if obj>0
  if entityelement(e).staticflag=0
   inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(302,strarr$(103)+str$(e)+"/"+str$(entityelementlist)+" ("+entityprofile(tentid).model$+")")
   tentid=entityelement(e).bankindex
   if entityprofile(tentid).ismarker=0
    gosub _entity_createelementasobject
   endif
  endif
 endif
next e

rem after leader creations, do not need leader flag if entity does not spawn
for e=1 to entityelementlist
 if entityelement(e).spawn.leader=1
  tentid=entityelement(e).bankindex
  if entityelement(e).spawn.max=0
   entityelement(e).spawn.leader=0
  endif
 endif
next e

rem Create Entity Attachments
debugviewtext(304,strarr$(104))
entityattachmentindex=0
eleobj=entityobjectoffset : ttick=0 : ttickmax=entityelementlist/3 : rem V106 faster build time ttickmax=1
for e=1 to entityelementlist
 inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(306,str$(e)+"\"+str$(entityelementlist)+" "+entityelement(e).eleprof.name$)
 gosub _entity_createattachment
next e

rem if entity is server controlled, hide entity initially (multiplayer)
if gmultiplayergame=1
 for e=1 to entityelementlist
  if entityelement(e).servercontrolled=1
   obj=entityelement(e).obj
   if obj>0
    if object exist(obj)=1
     hide object tobj
    endif
   endif
  endif
 next e
endif

rem Assign characters as fake players and set default weapon
fakeplayercount=2
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ischaracter=1
  entityelement(e).fakeplayerid=fakeplayercount
  inc fakeplayercount
 endif
 entityelement(e).currentweapon=entityelement(e).eleprof.hasweapon
 entityelement(e).currentclipammo=9999
 entityelement(e).currentammo=0
next e
rem recreate array to new size
playermax=fakeplayercount-1
dim player(playermax) as playertype
dim playersound(playermax,520) as integer
dim playersoundset$(playermax) as string
dim playermovementstep(playermax) as integer
dim playerinventory(playermax,100) as inventorytype

rem Transfer sound sets to player data
fakeplayercount=2
playersoundset$(1)=""
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives>0
  playersoundset$(1)=entityelement(e).eleprof.soundset$
 endif
 if entityprofile(entid).ischaracter=1
  playersoundset$(fakeplayercount)=entityelement(e).eleprof.soundset$
  entityelement(e).fakeplrindex=fakeplayercount
  inc fakeplayercount
 endif
next e

rem Activate any decals
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).decalmax>0
  for tq=0 to entityprofile(entid).decalmax-1
   decalid=entitydecal(entid,tq)
   if decalid>0
    decal(decalid).active=1
   endif
  next tq
 endif
next e

rem Load any soundsets not belonging to characters or players
debugviewtext(306,strarr$(105))
for e=1 to entityelementlist
 entityelement(e).soundset=0
 entid=entityelement(e).bankindex
 tokay=0
 if entityprofile(entid).ischaracter=0 and entityprofile(entid).ismarker=0 then tokay=1
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives=0 then tokay=1
 if entityprofile(entid).ismarker=3 or entityprofile(entid).ismarker=4 then tokay=1
 if tokay=1
  if entityelement(e).eleprof.soundset$<>""
   rem load as 3D sound ready for playing or looping in game (generator)
   tfile$=entityelement(e).eleprof.soundset$
   if file exist(tfile$)=1
    addfiletocollection(tfile$)
    entityelement(e).soundset=loadinternalsoundcore(tfile$,1)
   endif
  endif
  if entityelement(e).eleprof.soundset1$<>""
   rem load as 3D sound ready for playing or looping in game (generator)
   tfile$=entityelement(e).eleprof.soundset1$
   if file exist(tfile$)=1
    addfiletocollection(tfile$)
    entityelement(e).soundset1=loadinternalsoundcore(tfile$,1)
   endif
  endif
 endif
next e

return

_entity_attachelementstogame:

rem associate dynamic entities with game universe (vislinking)
eleobj=entityobjectoffset
for e=1 to entityelementlist
 obj=eleobj+e
 if obj>0
  entid=entityelement(e).bankindex
  if entityelement(e).staticflag=0
   if object exist(obj)=1
    attach object to static obj
   endif
  endif
 endif
next e

rem was here
gosub _player_resetobjectives

return

_entity_calculateobjectivestotal:

rem count all objective entities
missiongoaltotal=0
for e=1 to entityelementlist
 mi=entityelement(e).eleprof.isobjective
 if missiongoaltotal<mi then missiongoaltotal=mi
next e

rem count all as complete
for mi=1 to 99 : playerobjective(mi)=1 : next mi

rem and clear those awaiting to be filled in my entity
for e=1 to entityelementlist
 mi=entityelement(e).eleprof.isobjective
 if mi>0 then playerobjective(mi)=0
next e

return

_entity_deleteelements:

rem Quick deletes
if entityelementlist>0
 delete objects entityobjectoffset+1, entityobjectoffset+entityelementlist
endif
if entityattachmentindex>0
 delete objects entityattachmentsoffset+1, entityattachmentsoffset+entityattachmentindex
endif

return

_entity_scanfornewentitiesnoload:

rem Scan for entities
entdir$="entitybank\"
empty array filelist$()
buildfilelist(entdir$,"")

rem If entities exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem entity name from folder
  ent$=filelist$(chkfile)
  `
  rem Check if filename valid
  if right$(ent$,4)=".fpe"
  `
  rem Check entity exists in bank
  tokay=1
  if entidmaster>0
   for entid=1 to entidmaster
    if entitybank$(entid)=ent$ then tokay=0
   next entid
  endif
  if tokay=1
    `
   rem Find Free entity Index
   freeentid=-1
   if entidmaster>0
    for entid=1 to entidmaster
     if entitybank$(entid)="" then freeentid=entid : exit
    next entid
   endif
   `
   rem New entity or Free One
   if freeentid=-1
    inc entidmaster : gosub _entity_validatearraysize
    entid=entidmaster
   else
    entid=freeentid
   endif
   `
   rem Load entity
   dim entitybank$(entid)
   entitybank$(entid)=ent$
   `
  endif
  `
  endif
  `
 next chkfile
endif

return


_entity_scanfornewentities:

rem Load all entity names
gosub _entity_scanfornewentitiesnoload

rem Load entities themselves
for entid=1 to endidmaster
 ent$=entitybank$(entid)
 entpath$=getpath(ent$)
 gosub _entity_load
next entid

return

_entity_addtoselection:

rem Load entity from file requester
set dir currententitydir$
ent$=browseropen$(9)
entdir$="entitybank\"
ent$=right$(ent$,len(ent$)-len(rootdir$+entdir$))
currententitydir$=get dir$()
set dir rootdir$
`
rem Check if filename valid
entnewloaded=0 : entid=0
if right$(ent$,4)=".fpe"
 `
 rem Check entity exists in bank
 tokay=1
 if entidmaster>0
  for entid=1 to entidmaster
   if entitybank$(entid)=ent$ then tokay=0 : tfoundid=entid : exit
  next entid
 endif
 if tokay=1
  `
  rem Find Free entity Index
  freeentid=-1
  if entidmaster>0
   for entid=1 to entidmaster
    if entityprofileheader(entid).desc$="" then freeentid=entid : exit
   next entid
  endif
  `
  rem New entity or Free One
  if freeentid=-1
   inc entidmaster : gosub _entity_validatearraysize
   entid=entidmaster
   entnewloaded=1
  else
   entid=freeentid
  endif
  `
  rem Load entity
  entitybank$(entid)=ent$
  entpath$=getpath(ent$)
  gosub _entity_load
  `
 else
  `
  rem already got, assign ID from existing
  entid=tfoundid
  `
 endif
 `
endif

return

_entity_delete:
 `
 rem Remove trace of entity (and object)
 tdelobj=entitybankoffset+entid
 if tdelobj>0
  if object exist(tdelobj)=1 then delete object tdelobj
  entityprofileheader(entid).desc$=""
  entitybank$(entid)=""
  entityprofile(entid).aiinit$=""
  entityprofile(entid).aimain$=""
  entityprofile(entid).aidestroy$=""
  entityprofile(entid).aishoot$=""
  entityprofile(entid).soundset$=""
  entityprofile(entid).soundset1$=""
  entityprofile(entid).usekey$=""
  entityprofile(entid).ifused$=""
  entityprofile(entid).ifusednear$=""
  entityprofile(entid).spawnatstart=0
  entityprofile(entid).spawnmax=0
  entityprofile(entid).spawnupto=0
  entityprofile(entid).spawnafterdelay=0
  entityprofile(entid).spawnwhendead=0
  entityprofile(entid).spawndelay=0
  entityprofile(entid).spawnqty=0
  entityprofile(entid).spawndelayrandom=0
  entityprofile(entid).spawnqtyrandom=0
  entityprofile(entid).spawnvel=0
  entityprofile(entid).spawnvelrandom=0
  entityprofile(entid).spawnangle=0
  entityprofile(entid).spawnanglerandom=0
  entityprofile(entid).spawnlife=0
  entityprofile(entid).model$=""
  entityprofile(entid).offx=0.0
  entityprofile(entid).offy=0.0
  entityprofile(entid).offz=0.0
  entityprofile(entid).rotx=0.0
  entityprofile(entid).roty=0.0
  entityprofile(entid).rotz=0.0
  entityprofile(entid).scale=0.0
  entityprofile(entid).fixnewy=0.0
  entityprofile(entid).forwardfacing=0
  entityprofile(entid).defaultheight=0.0
  entityprofile(entid).defaultstatic=0
  entityprofile(entid).collisionmode=0
  entityprofile(entid).materialindex=0
  entityprofile(entid).debrisshapeindex=0
  entityprofile(entid).coneheight=0.0
  entityprofile(entid).coneangle=0.0
  entityprofile(entid).hurtfall=0
  entityprofile(entid).texpath$=""
  entityprofile(entid).texd$=""
  entityprofile(entid).texdid=0
  entityprofile(entid).texaltd$=""
  entityprofile(entid).texaltdid=0
  entityprofile(entid).tex1id=0
  entityprofile(entid).tex2id=0
  entityprofile(entid).tex3id=0
  entityprofile(entid).tex4id=0
  entityprofile(entid).texidmax=0
  entityprofile(entid).effect$=""
  entityprofile(entid).usingeffect=0
  entityprofile(entid).castshadow=0
  entityprofile(entid).transparency=0
  entityprofile(entid).reducetexture=0
  entityprofile(entid).strength=0
  entityprofile(entid).lives=0
  entityprofile(entid).speed=0
  entityprofile(entid).isimmobile=0
  entityprofile(entid).ischaracter=0
  entityprofile(entid).cantakeweapon=0
  entityprofile(entid).isweapon$=""
  entityprofile(entid).isweapon=0
  entityprofile(entid).isammo=0
  entityprofile(entid).hasweapon$=""
  entityprofile(entid).hasweapon=0
  entityprofile(entid).ishealth=0
  entityprofile(entid).isflak=0
  entityprofile(entid).limbmax=0
  entityprofile(entid).headlimb=0
  entityprofile(entid).firespotlimb=0
  entityprofile(entid).animmax=0
  entityprofile(entid).quantity=0
  entityprofile(entid).ismarker=0
  entityprofile(entid).markerindex=0
  entityprofile(entid).isobjective=0
  entityprofile(entid).decalmax=0
  entityprofile(entid).bloodscorch=0
  entityprofile(entid).rateoffire=0
  entityprofile(entid).damage=0
  entityprofile(entid).accuracy=0
  entityprofile(entid).reloadqty=0
  entityprofile(entid).fireiterations=0
  entityprofile(entid).lifespan=0
  entityprofile(entid).throwspeed=0.0
  entityprofile(entid).throwangle=0.0
  entityprofile(entid).bounceqty=0
  entityprofile(entid).explodeonhit=0
  entityprofile(entid).weaponisammo=0
  entityprofile(entid).spare1=0
  entityprofile(entid).physics=0
  entityprofile(entid).phyalways=0
  entityprofile(entid).phyweight=0
  entityprofile(entid).phyfriction=0
  entityprofile(entid).phyforcedamage=0
  entityprofile(entid).rotatethrow=0
  entityprofile(entid).explodable=0
  entityprofile(entid).explodedamage=0
 endif
 `
return

`
` FUNCTION TO FIND ENTITY ELEMENT INDEX FROM OBJ VALUE
`
function findentityfromobj(objclicked)
 entitytoselect=0
 for e=1 to entityelementlist
  if objclicked=entityelement(e).obj
   entitytoselect=e : exit
  endif
 next e
endfunction entitytoselect

`
` FUNCTION TO FIND ALL TEXTURES IN MODEL FILE (for file collection)
`
function findmaterialtexturesinmodelfile(file$,texpath$)
 `
 rem To determine if a model file requires
 rem texture files, we scan the file for a
 rem match to the text .TGA or .JPG (and use texfile$)
 returntexfile$=""
 if file exist(file$)=1
 filesize=file size(file$)
 mbi=255
 open to read 11,file$
 make memblock from file mbi,11
 close file 11
 for b=0 to filesize-1
  if memblock byte(mbi,b+0)=asc(".")
   `
   tfoundpiccy=0
   if memblock byte(mbi,b+1)=asc("T") or memblock byte(mbi,b+1)=asc("t")
    if memblock byte(mbi,b+2)=asc("G") or memblock byte(mbi,b+2)=asc("g")
     if memblock byte(mbi,b+3)=asc("A") or memblock byte(mbi,b+3)=asc("a")
      tfoundpiccy=1
     endif
    endif
   endif
   if memblock byte(mbi,b+1)=asc("J") or memblock byte(mbi,b+1)=asc("j")
    if memblock byte(mbi,b+2)=asc("P") or memblock byte(mbi,b+2)=asc("p")
     if memblock byte(mbi,b+3)=asc("G") or memblock byte(mbi,b+3)=asc("g")
      tfoundpiccy=1
     endif
    endif
   endif
   `
   if tfoundpiccy=1
      rem trace back
      for c=b to b-255 step -1
       if memblock byte(mbi,c)>=asc(" ") and memblock byte(mbi,c)<=asc("z") and memblock byte(mbi,c)<>34
        rem part of filename
       else
        rem no more filename
        exit
       endif
      next c
      texfile$=""
      for d=c+1 to b+3
       texfile$=texfile$+chr$(memblock byte(mbi,d))
      next d
      addfiletocollection(texpath$+texfile$)
      if returntexfile$="" then returntexfile$=texpath$+texfile$
      inc b,4
   endif
   `
  endif
 next b
 delete memblock mbi
 endif
 `
endfunction returntexfile$

rem
rem MAP FILE FORMAT
rem

`
` Blank New
`

_mapfile_newmap:
 `
 rem Free arrays
 undim map()
 undim mapolay()
 undim olaylist()
 `
 rem Defaults
 layermax=20 : maxx=40 : maxy=40
 olaylistmax=100
 `
 rem Create arrays
 dim map(layermax,maxx,maxy)
 dim mapolay(layermax,maxx,maxy)
 dim olaylist(olaylistmax,50) as DWORD
 `
return

`
` Load
`

_mapfile_loadmap:
 `
 rem Free arrays
 undim map()
 undim mapolay()
 undim olaylist()
 `
 rem Load header data (need main mapdata for visdata)
 filename$=levelmapptah$+"header.dat"
 if file exist(filename$)=1
  if file size(filename$)=16
   rem V-EA Header
   open to read 1,filename$
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
   close file 1
  endif
  if file size(filename$)=32
   rem V-V1 Header
   open to read 1,filename$
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
    read file 1,gmultiplayergame
    read file 1,temp
    read file 1,temp
    read file 1,temp
   close file 1
  endif
 else
  layermax=20 : maxx=40 : maxy=40
  olaylistmax=100
 endif
 `
 rem Create arrays
 dim map(layermax,maxx,maxy)
 dim mapolay(layermax,maxx,maxy)
 dim olaylist(olaylistmax,50) as DWORD
 `
 rem Dump main map data
 filename$=levelmapptah$+"map.fpmb"
 if file exist(filename$)=1 then load array filename$,map()
 `
 rem Dump array data
 if file exist("mapbank\testmap\map.fpmo")=1 then load array "mapbank\testmap\map.fpmo",mapolay()
 if file exist("mapbank\testmap\map.fpml")=1 then load array "mapbank\testmap\map.fpml",olaylist()
 `
return

`
` Save
`

_mapfile_savemap:
 `
 rem Store old folder
 old$=get dir$()
 `
 rem Enter folder
 set dir "mapbank\testmap\"
 `
 rem Clear old files out (TEMP)
 if file exist("map.fpmb")=1 then delete file "map.fpmb"
 if file exist("header.dat")=1 then delete file "header.dat"
 if file exist("map.fpmo")=1 then delete file "map.fpmo"
 if file exist("map.fpml")=1 then delete file "map.fpml"
 `
 rem Create header file
 open to write 1,"header.dat"
  `
  rem EA
  rem map dimensions
  write file 1,layermax
  write file 1,maxx
  write file 1,maxy
  rem list sizes
  write file 1,olaylistmax
  `
  rem V1
  write file 1,gmultiplayergame
  write file 1,0
  write file 1,0
  write file 1,0
  `
 rem end of header
 close file 1
 `
 rem Dump array data
 save array "map.fpmb",map()
 save array "map.fpmo",mapolay()
 save array "map.fpml",olaylist()
 `
 rem Restore
 set dir old$
 `
return

`
` ProjectFilename FPM Saver (ZIP)
`

_mapfile_saveproject_fpm:
 `
 rem Delete any olf file
 if file exist(projectfilename$)=1 then delete file projectfilename$
 `
 rem Copy CFG to testgame area for saving with other files
 tttfile$="cfg.cfg"
 if file exist(get dir$()+"\editors\gridedit\"+tttfile$)=1
  if file exist("mapbank\testmap\"+tttfile$)=1 then delete file "mapbank\testmap\"+tttfile$
  copy file get dir$()+"\editors\gridedit\"+tttfile$,"mapbank\testmap\"+tttfile$
 endif
 `
 rem Create a FPM (zipfile)
 create file block 1, projectfilename$
 set file block key 1, "mypassword"
 set dir "mapbank\testmap\"
 add file to block 1, "header.dat"
 add file to block 1, "map.ele"
 add file to block 1, "map.ent"
 add file to block 1, "map.seg"
 add file to block 1, "map.way"
 add file to block 1, "map.fpmb"
 add file to block 1, "map.fpmo"
 add file to block 1, "map.fpml"
 add file to block 1, "cfg.cfg"
 set dir "..\.."
 save file block 1
 `
return

_mapfile_loadgamemap_fpm:
 `
 rem FPM for level loaded into mapbank\testmap
 projectfilename$=level$(level).fpm$
 gosub _mapfile_loadproject_fpm
 `
return

_mapfile_loadproject_fpm:
 `
 rem Ensure FPM exists
 if file exist(projectfilename$)=1
  `
  rem Store and switch folders
  tdirst$=get dir$() : set dir "mapbank\testmap\"
  `
  rem Delete key testmap file (if any)
  if file exist("header.dat")=1
   delete file "header.dat"
  endif
  `
  rem Retore folder to Files (for extraction)
  set dir tdirst$

  rem Read FPM into testmap area
  open file block projectfilename$,1,"mypassword"
  perform checklist for file block data 1
  tpath$=rootpath$+"mapbank\testmap\"
  for i = 1 to checklist quantity( )
   extract file from block 1, checklist string$( i ), tpath$
  next i
  close file block 1
  `
  rem If file still not present, extraction failed
  set dir tdirst$+"\mapbank\testmap\"
  if file exist("header.dat")=0
   rem inform user the FPM could not be loaded (corrupt file)
   tloadsuccessfully=0
  endif
  `
  rem if CFG file present, copy to editor folder for later use (stores FPG for us)
  if tloadsuccessfully=1
   tttfile$="cfg.cfg"
   if file exist(tttfile$)=1
    if file exist(tdirst$+"\editors\gridedit\"+tttfile$)=1 then delete file tdirst$+"\editors\gridedit\"+tttfile$
    copy file tttfile$,tdirst$+"\editors\gridedit\"+tttfile$
   endif
  endif
  `
  rem Retore and switch folders
  set dir tdirst$
  `
 else
  tloadsuccessfully=0
 endif
 `
return

_mapfile_save_fpl:
 `
 rem Delete any old file before saving
 levelfilename$="levelbank\level"+str$(level)+".zip"
 if file exist(levelfilename$)=1 then delete file levelfilename$
 create file block 1, levelfilename$
 set file block key 1, "mypassword"
 set dir "levelbank\testlevel\"
 add file to block 1, "header.dat"
 add file to block 1, "map.ent"
 add file to block 1, "map.way"
 add file to block 1, "map.fpmb"
 add file to block 1, "universe.eff"
 add file to block 1, "universe.dbo"
 add file to block 1, "universephy.dbo"
 add file to block 1, "universe.dbu"
 add file to block 1, "universe.ele"
 add file to block 1, "universe.lgt"
 tdds=0
 while tdds<65535
  if file exist("lightmaps\"+str$(tdds)+".dds")=1
   add file to block 1,"lightmaps\"+str$(tdds)+".dds"
  else
   if file exist("lightmaps\"+str$(tdds)+".png")=1
    add file to block 1,"lightmaps\"+str$(tdds)+".png"
   else
    exit
   endif
  endif
  inc tdds
 endwhile
 set dir "..\.."
 save file block 1
 addfiletocollection(levelfilename$)
 `
return

_mapfile_load_fpl:
 `
 rem Load if exists
 levelfilename$="levelbank\level"+str$(level)+".zip"
 if file exist(levelfilename$)=1
  `
  rem Read FPL into testlevel area
  open file block levelfilename$,1,"mypassword"
  perform checklist for file block data 1
  tpath$=rootpath$+"levelbank\testlevel\"
  for i = 1 to checklist quantity( )
   extract file from block 1, checklist string$( i ), tpath$
  next i
  close file block 1
  `
 endif
 `
return


rem
rem GAMEFLOW (DEFAULT PIPELINE FOR FPSC-V1)
rem

_gameflow_default:
 `
 rem Test Game Mode - hide camera until ready
 if gtestgamemodefromeditor=1
  gtestgamemodefromeditorokaypressed=0
  set camera view 0,0,1,1
  rem Ready With Test Game Engine
  open file map 1, "FPSTESTGAMEDIALOG"
  wait for file map event 1
  if get file map dword( 1, 0 ) = 1
   set file map dword 1, 12, 1
   set file map string$ 1, 1000, strarr$(377)
   wait for file map event 1
   while get file map dword ( 1, 12 ) = 1
    wait for file map event 1
   endwhile
  endif
  close file map 1
 endif
 rem Build Executable Game Mode
 if gcompilestandaloneexe=1
  rem Ready With Build Game Engine
  open file map 1, "FPSBUILDGAME"
  set file map dword 1, 40, 12
  set file map dword 1, 44, 1
  set file map string$ 1, 1000, strarr$(378)
  wait for file map event 1
  while get file map dword ( 1, 44 ) = 1
   wait for file map event 1
  endwhile
  close file map 1
 endif
 `
 rem App Loop
 loopapp=1
 while loopapp=1
  `
  rem Preapp Init
  gosub _ai_setkeywords
  gosub _ai_scanfornewscriptsonly
  gosub _ai_reset
  `
  rem Title screen
  controlSPACE=1
  controlESCAPE=1
  if gtestgamemodefromeditor=0 then gosub _screen_title_init
  if grealgameviewstate=1
   continueokay=0
   while continueokay=0
    gosub _screen_control
    sync
   endwhile
  else
   rem in test mode, we are the 'host'
   if gtestgamemodefromeditor<>0 then createorjoin=1
  endif
  `
  rem Obtain title screen info (multiplayer)
  if gmultiplayergame=1
   if gtestgamemodefromeditor<>0
    rem Test Game Mode
    playername$="testarenaplr"
    ipaddress$=""
   else
    rem Scan HUD array for name [and ip]
    for hudid=1 to hudmax
     if hud(hudid).maintype=8
      if hud(hudid).typemode=21 then playername$=hud(hudid).text$ : hudhaveplayername=1
      if hud(hudid).typemode=22 then ipaddress$=hud(hudid).text$
     endif
    next hidid
   endif
   rem Early init sets up connection (if it can)
   gosub _multi_earlyinit
  endif
  `
  rem until editor has flag set when building arena exe..
  gosub _multi_assetloader
  `
  rem Close title screen
  if gtestgamemodefromeditor=0 then gosub _screen_close
  `
  rem if not quitting
  if loopapp=1
   `
   rem Set first level
   controlSPACE=1
   controlESCAPE=0
   level=1
   `
   rem Start level loop
   looplevel=1
   while looplevel=1
    `
    rem [OPTIONAL] Triggers a 'saved game' dataset to load
    if loadsavedlevel$<>""
     saveloadfile$=loadsavedlevel$
     gosub _saveload_loadgame
     saveloadfile$=""
    endif
    `
    rem Loading level
    if gtestgamemodefromeditor=0 then gosub _screen_loading_init
    if grealgameviewstate=1
     gosub _screen_control
     sync
    endif
    `
    rem CORE : LOAD GAME DATA
    gosub _ai_reset
    gosub _ai_scanfornewscriptsonly
    gosub _main_game_loadgamedata
    `
    rem Only play if not building the executable
    if gcompilestandaloneexe=1
     `
     rem First action of core is to finishing loading of level
     gosub _load_game_scene
     gosub _main_game_freeleveldata
     `
     rem Review FPI screens
     gosub _screen_game_init
     gosub _screen_levelcomplete_init
     gosub _screen_gameover_init
     `
     rem Will load all levels to gather all files required for standalone
     inc level : if level>glevelmax then looplevel=0
     `
    else
     `
     rem First action of core is to finishing loading of level
     gosub _load_game_scene
     `
     rem Repeat an arema game
     repeatsamelevel=0
     repeat
      `
      rem Flag to control the repeat (multiaplayer)
      if gmultiplayergame=1
       if repeatsamelevel<>0
        rem Game has been repeated, so reset some small elements to reproduce exact restart (quicker than reload)
        gosub _multiplayer_repeatresetgame
        rem Reset flag for another new game
        repeatsamelevel=0
       else
        rem copy entire entityelement states at start (for repeat renewgame)
        tcopyorrestart=0 : gosub _gun_resetgunsettings
        tcopyorrestart=0 : gosub _entity_resetentitiestorestartstates
       endif
      endif
      `
      rem Prepare Game HUD After Loading
      gosub _screen_close
      gosub _screen_game_init
      `
      rem Give entities a blast of logic
      rem (but after HUD-creation of status-panels) (entAI adds HUDS)
      gosub _entity_blastinitentities
      `
      rem [OPTIONAL] saveload data overwrite default level settings
      if loadsavedlevel$<>""
       gosub _saveload_retrievesavedata
       loadsavedlevel$=""
      endif
      `
      rem CORE : PLAY LEVEL
      controlSPACE=0
      controlESCAPE=2
      showgamemenu=0
      levelwon=0
      startofgametime=timer()
      continueokay=0
      gamewarmupcount=30
      while continueokay=0
       if showgamemenu=0
        gosub _main_game_core
       else
        if gmultiplayergame=1 then gosub _main_game_core
        gosub _screen_control
        if len(loadsavedlevel$)<2 then sync
       endif
      endwhile
      controlSPACE=1
      controlESCAPE=0
      `
      rem If arena, pop up game win/lose screens (and repeat game choice)
      if gtestgamemodefromeditor<>0
       `
       rem Quick Exit from test arena mode
       repeatsamelevel=0
       `
      else
       `
       if gmultiplayergame=1
        `
        rem Stop ALL sounds from game
        for s=1 to 65535 : if sound exist(s)=1 : stop sound s : endif : next s
        `
        rem Ensure mouse button released totally
        while mouseclick()<>0 : sync : endwhile
        `
        rem ARENA GAME FINISHED
        rem levelwon (0-lost,1-won,2-skip)
        if levelwon=0 or levelwon=1
         if levelwon=0 then gosub _screen_gameover_init
         if levelwon=1 then gosub _screen_levelcomplete_init
         continueokay=0
         while continueokay=0
          gosub _screen_control
          sync
         endwhile
        endif
        `
        rem Absolutely leave leveloop after arena game
        looplevel=0
        `
       else
        `
        rem SINGLE PLAYER GAME FINISHED
        rem Record any player states
        gosub _player_savestate
        `
       endif
       `
      endif
      `
      rem Close down all HUDs
      gosub _screen_close
      `
     rem if AI has chosen to repeat level, repeatsamelevel will be set to 1
     until repeatsamelevel=0
     `
     rem CORE : FREE LEVEL DATA
     if gtestgamemodefromeditor<>0
      rem if test game, leave and let heap be removed entirely
      levelwon=2
      rem but multiplayer still needs freeing manually (or crash)
      if gmultiplayergame<>0 then gosub _multi_free
     else
      rem level free, or game free
      leavegamedataalone=1
      rem game free instead (removes usually retained AI and WEAPON arrays, etc)
      if levelwon=0 or levelwon=2 or (levelwon=1 and level+1>glevelmax)
       leavegamedataalone=0
      endif
      gosub _main_game_freeleveldata
     endif
     `
     rem If single player, do gameover/complete/nextlevel
     if gmultiplayergame=0
      `
      if levelwon=0
       `
       rem Game Over
       continueokay=0
       gosub _screen_gameover_init
       while continueokay=0
        gosub _screen_control
        sync
       endwhile
       gosub _screen_close
       `
       rem End level loop
       looplevel=0
       `
      endif
      if levelwon=1
       `
       rem Next level
       inc level : if level>glevelmax then levelwon=2
       `
      endif
      if levelwon=2
       `
       rem Game Complete
       if level>1 and level>glevelmax and gtestgamemodefromeditor=0
        continueokay=0
        gosub _screen_levelcomplete_init
        while continueokay=0
         gosub _screen_control
         sync
        endwhile
        gosub _screen_close
       endif
       `
       rem Level Quit - end level loop
       looplevel=0
       `
      endif
     endif
     `
    endif
    `
    rem TestGameFromEditor Mode
    if grealgameviewstate=0 and gcompilestandaloneexe=0
     rem Always terminate after the level has been won/lost
     looplevel=0 : loopapp=0
    endif
    `
   endwhile
   `
   rem QUICK-TEST-MODE : Leave after one pass
   if grealgameviewstate=0 then loopapp=0
   `
  endif
  `
 endwhile
 `
 rem Instruct Map Editor To Relaunch and Reload Settings
 if gtestgamemodefromeditor=1
  rem Inform user of potentiall ylong delay while unloading
  set current bitmap 0
  set text font "Verdana" : set text size 24 : ink rgb(255,255,255),0
  for sss=0 to 3
   center text screen width()/2,screen height()/2,strarr$(379)
   sync
  next sss
  rem TestGameFromEditor Mode
  open file map 1, "FPSEXCHANGE"
  set file map string$ 1, 1000, "FPSC-MapEditor.exe"
  set file map string$ 1, 1256, "-r"
  set file map dword 1, 994, 0
  set file map dword 1, 924, 1
  wait for file map event 1
  close file map 1
  rem Terminate
  timestampactivity(0,"Test Game Delete Exit")
  end
 endif
 `
return

rem
rem SCREEN TEMPLATES
rem

`
` TITLE
`
_screen_title_init:
 aifile$=titlefpi$
 gosub _screen_init
return

`
` LOADING
`
_screen_loading_init:
 aifile$=level$(level).fpi$
 gosub _screen_init
return

`
` GAME
`
_screen_game_init:
 aifile$=setupfpi$
 gosub _screen_init
return

`
` LEVEL COMPLETE
`
_screen_levelcomplete_init:
 aifile$=gamewonfpi$
 gosub _screen_init
return

`
` GAMEOVER
`
_screen_gameover_init:
 aifile$=gameoverfpi$
 gosub _screen_init
return

`
` SCREEN INPUT CONTROL
`
_screen_init:
 `
 rem Load AIFILE for screen
 inc aiindexmaster
 dim scriptbank$(aiindexmaster)
 aiindex=aiindexmaster : scriptbank$(aiindex)=aifile$
 aidir$="" : ai$=aifile$ : gosub _ai_load
 screenai=aiindex
 `
 rem Prepare Entity Zero
 obj=0 : e=0
 if array count(entityelement())<=0
  dim entityelement(e) as entitytype
 endif
 entityelement(e).active=1
 entityelement(e).ai.state=0
 `
 rem HUD Control
 hudselectionmade=0
 `
return

_screen_control:
 `
 rem Run Global AI Script (in entity element zero)
 if screenai>0
  obj=0 : e=0 : aiindex=screenai : gosub _ai_control
  if entityelement(e).active=0
   rem FPI has been ended
   continueokay=1
  endif
 endif
 `
 rem Run Any HUD activity
 gosub _ai_hud_view
 `
return

_screen_close:
 `
 rem Terminate screen AI
 if screenai>0
  aiindex=screenai
  gosub _ai_free
  screenai=0
 endif
 `
 rem Free HUDs
 hudmax=0
 `
 rem Reset HUD dependent vars
 internalloaderhud=0
 hudfadeoutoneatatime=0
 internalloaderhud=0
 internaleyehud=0
 internalfaderhud=0
 `
return

rem
rem UNIVERSE
rem

_universe_construct_skip:
 `
 rem compare this universe with last saved universe
 rem return flag as true if the universe is the same
 universeconstructskip=1
 `
 rem if no old file, no old data so no skip
 if file exist("levelbank\testlevel\old.dat")=0 then universeconstructskip=0 : return
 `
 rem check static entities/lights
 open to read 1,"levelbank\testlevel\old.dat"
  read file 1,oldolaylistmax
  read file 1,oldentityelementlist
  dim oldentityelement(oldentityelementlist) as entitytype
  for i=1 to oldentityelementlist
   read file 1,e
   if e>0
    read float 1,a# : oldentityelement(e).x=a#
    read float 1,a# : oldentityelement(e).y=a#
    read float 1,a# : oldentityelement(e).z=a#
    read float 1,a# : oldentityelement(e).rx=a#
    read float 1,a# : oldentityelement(e).ry=a#
    read float 1,a# : oldentityelement(e).rz=a#
    read float 1,a# : oldentityelement(e).eleprof.light.range=a#
    read file 1,tcolr
    read file 1,tcolg
    read file 1,tcolb
    tcol=rgb(tcolr,tcolg,tcolb)
    oldentityelement(e).eleprof.light.color=tcol
    rem current entity must be static, and be identical to old otherwise cannot skip
    if e<=entityelementlist
     if entityelement(e).staticflag=1
      if entityelement(e).x<>oldentityelement(e).x then universeconstructskip=0
      if entityelement(e).y<>oldentityelement(e).y then universeconstructskip=0
      if entityelement(e).z<>oldentityelement(e).z then universeconstructskip=0
      if entityelement(e).rx<>oldentityelement(e).rx then universeconstructskip=0
      if entityelement(e).ry<>oldentityelement(e).ry then universeconstructskip=0
      if entityelement(e).rz<>oldentityelement(e).rz then universeconstructskip=0
      if entityelement(e).eleprof.light.range<>oldentityelement(e).eleprof.light.range then universeconstructskip=0
      if entityelement(e).eleprof.light.color<>oldentityelement(e).eleprof.light.color then universeconstructskip=0
     else
      universeconstructskip=0 : i=oldentityelementlist
     endif
    else
     universeconstructskip=0 : i=oldentityelementlist
    endif
   endif
  next i
  if universeconstructskip=1
   if entityelementlist>oldentityelementlist
    for e=i to entityelementlist
     if entityelement(e).staticflag=1
      rem any new static entities must be used in new construction
      universeconstructskip=0
     endif
    next e
   endif
  endif
 close file 1
 `
 rem check map and overlays
 if universeconstructskip=1
  dim oldmap(layermax,maxx,maxy)
  dim oldolaylist(oldolaylistmax,50) as DWORD
  load array "levelbank\testlevel\oldmap.dat",oldmap()
  load array "levelbank\testlevel\oldolaylist.dat",oldolaylist()
  for lay=0 to layermax
   for y=0 to maxy-1
    for x=0 to maxx-1
     for olay=0 to 1
      if olay=0 then tolaymax=0
      if olay=1
       tolaymax=0 : olayindex=mapolay(lay,x,y)
       while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
       dec tolaymax
      endif
      if tolaymax>=0
       for olayti=0 to tolaymax
        if olay=0 then mapid=map(lay,x,y)
        if olay=1 then mapid=olaylist(olayindex,olayti)
        if olay=0 then oldmapid=oldmap(lay,x,y)
        if olay=1 then oldmapid=oldolaylist(olayindex,olayti)
        if mapid<>oldmapid
         rem there is a difference, must not skip construction
         universeconstructskip=0
        endif
       next olayti
      endif
     next olay
    next x
   next y
  next lay
 endif
 `
 rem free usages
 undim oldentityelement()
 undim oldmap()
 undim oldolaylist()
 `
return

_universe_saveforskipcheck:
 `
 rem save map, overlay and static entity info
 rem for above check as to whether to skip universe construction
 tfile$="levelbank\testlevel\old.dat" : if file exist(tfile$)=1 then delete file tfile$
 open to write 1,tfile$
  write file 1,olaylistmax
  write file 1,entityelementlist
  for e=1 to entityelementlist
   if entityelement(e).staticflag=1
    write file 1,e
    write float 1,entityelement(e).x
    write float 1,entityelement(e).y
    write float 1,entityelement(e).z
    write float 1,entityelement(e).rx
    write float 1,entityelement(e).ry
    write float 1,entityelement(e).rz
    write float 1,entityelement(e).eleprof.light.range
    write file 1,rgbr(entityelement(e).eleprof.light.color)
    write file 1,rgbg(entityelement(e).eleprof.light.color)
    write file 1,rgbb(entityelement(e).eleprof.light.color)
   else
    write file 1,0
   endif
  next e
 close file 1
 tfile$="levelbank\testlevel\oldmap.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,map()
 tfile$="levelbank\testlevel\oldolaylist.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,olaylist()
 `
return

_universe_construct:

rem Set size of possible node tree (cubeshaped)
set static universe maxx*100,(layermax+1)*100,maxy*100

rem Reset any lighting information
delete light map lights

rem Some global statistics for game world
totalnumberofcollisionboxes=0

rem Lightmapping
activatelightmapping=glightmappingstate
if segobjusedformapeditor=1 then activatelightmapping=0

rem Shadow maps for processing data
dim mapobj(layermax,maxx,maxy)
dim mapcsg(layermax,maxx,maxy)

rem Free old objects if any
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj

rem Construct scene
csgpassmax=3
staticlightcount=0
for csgpass=1 to csgpassmax
`
rem debug info
if csgpass=1 then debugviewtext(200,strarr$(155))
if csgpass=2 then debugviewtext(210,strarr$(156))
if csgpass=3 then debugviewtext(220,strarr$(157))
`
rem Reset workvars
segobj=segobjstart
highesty=0
`
rem Feature to fill void with floor/landscape/horizon
if 1 and segobjusedformapeditor=0
 `
 rem Fill void tiles with floor
 if csgpass=1
  `
  rem if default floor switched on
  if gusefloorstate=1
   `
   rem get map tile ID
   mapid=map(0,0,0) : mapselection=1
   if mapid>0 then gosub _gridedit_getmapvalues
   `
   rem void tile filler (automatic floor is at layer zero)
   mapscaler = 0 : mapground = 3 : maprotate = 0
   maporient = 0 : mapsymbol = 0 : maptile = 0
   gosub _universe_makemapvalues
   floormapid=mapid : lay=0
   for y=0 to maxy-1
    for x=0 to maxx-1
     if map(lay,x,y)=0
      map(lay,x,y)=mapid
     endif
    next x
   next y
   `
   rem create horizonplanes
   gosub _universe_createhorizonplanes
   `
  endif
  `
 endif
 if csgpass>1
  rem Skip horizon objects
  if gusefloorstate=1
   inc segobj,4
  endif
 endif
 `
endif
`
rem Start traversal through universe tiles
for lay=0 to layermax
 for y=0 to maxy-1
  for x=0 to maxx-1
   for olay=0 to 1
    `
    rem MAP and MAPOLAY
    if olay=0 then tolaymax=0
    if olay=1
     tolaymax=0 : olayindex=mapolay(lay,x,y)
     while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
     dec tolaymax
    endif
    if tolaymax>=0
     `
     for olayti=0 to tolaymax
      if olay=0 then mapid=map(lay,x,y)
      if olay=1 then mapid=olaylist(olayindex,olayti)
      if mapid<>0
       `
       gosub _gridedit_getmapvalues
       if object exist(selectionbankoffset+mapselection)=1
        `
        rem Set segment identity
        seg=mapselection
        `
        rem Pass 1 - Create
        if csgpass=1
         `
         rem report progress
         if treportprogressonlayer<>lay or treportprogressonlayerslice<>y
          tproggy#=(9.0/layermax)*lay
          debugviewtext(201+tproggy#,strarr$(158)+str$(lay)+strarr$(159)+str$(y)+"...")
          treportprogressonlayer=lay : treportprogressonlayerslice=y
         endif
         `
         rem check if segment uses CSG, in which case clone not instance
         tusingcsgforthisegment=0
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            tusingcsgforthisegment=1
           endif
          endif
         next tp
         `
         rem clone for manipulation of segment (clone too draining)
         if ghsrmode=1
          clone object segobj,selectionbankoffset+mapselection
         else
          rem when instance, transparent details come from origin (not for mapeditor preview though)
          if segobjusedformapeditor=0
           set object transparency selectionbankoffset+mapselection,4
          endif
          instance object segobj,selectionbankoffset+mapselection
         endif
         `
         rem setup segment for universe conversion
         set object collision off segobj
         position object segobj,50+(x*100),50+(lay*100),((y*-100)-50)
         if (100+(lay*100))>highesty then highesty=(100+(lay*100))
         mapatl=lay : mapatx=x : mapaty=y
         obj=segobj : gosub _segment_customisesinglesegment
         if olay=0 then mapobj(lay,x,y)=obj
         `
         rem initially hide all non-basic meshes
         for tlimb=segmentprofileheader(seg).lastmeshmax+1 to segmentprofileheader(seg).partmax
          if limb exist(segobj,tlimb)=1
           hide limb segobj,tlimb
          endif
         next tlimb
         `
         rem show multimesh replacements, hide base mesh in those cases
         for tlimb=0 to segmentprofileheader(seg).lastmeshmax
          tmultimesh=segmentprofile(seg,tlimb).multimeshmode
          if tmultimesh=1
           if limb visible(segobj,tlimb)=1
            if segmentprofile(seg,tlimb).multimeshstart>0
`             r=0 : rem rnd(2) hmm why did I rem this out :)
             r=rnd(2)
             if r=0 then tlimbchange=tlimb
             if r=1 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+0
             if r=2 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+1
             if limb exist(segobj,tlimbchange)=0 then tlimbchange=tlimb
             hide limb segobj,tlimb : show limb segobj,tlimbchange
            endif
           endif
          endif
         next tlimb
         `
        endif
        `
        rem Pass 2 - Add CSG, Lights and Entities
        if csgpass=2
         `
         rem add any csg punch references
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            rem check boundbox of CSGPUNCH with surrounding segments
            for surrl=lay-1 to lay+1
             for surry=y-1 to y+1
              for surrx=x-1 to x+1
               if surrl>=0 and surrl<layermax
                if surry>=0 and surry<40
                 if surrx>=0 and surrx<40
                   `
                   rem for each segment-limb (not this seg though)
                   mapid=map(surrl,surrx,surry)
                   if mapid<>0
                    gosub _gridedit_getmapvalues
                    if object exist(selectionbankoffset+mapselection)=1
                     surrseg=mapselection
                     surrobj=mapobj(surrl,surrx,surry)
                     for surrlimb=0 to segmentprofileheader(surrseg).lastmeshmax
                      rem only non-immune meshes
                      if segmentprofile(surrseg,surrlimb).csgimmune=0
                       rem first ensure meshes affected by a CSG must use base mesh, not multimesh
                       if segmentprofile(surrseg,surrlimb).multimeshstart>0
                        if limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0)=1 or limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1)=1
                         show limb surrobj,surrlimb
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1
                        endif
                       endif
                       rem if punch limb collides with surrounding segment-limb
                       tpactual=segmentprofile(seg,tp).actuallimb
                       if limb collision(segobj,tpactual,surrobj,surrlimb)=1 and limb visible(surrobj,surrlimb)=1
                        `
                        rem report progress
                        tproggy#=(9.0/layermax)*lay
                        debugviewtext(211+tproggy#,strarr$(160)+str$(lay)+","+str$(x)+","+str$(y))
                        `
                        rem make new limb
                        ttempobj1=lastsegobj+0
                        ttempobj2=lastsegobj+1
                        if object exist(ttempobj1)=1 then delete object ttempobj1
                        if object exist(ttempobj2)=1 then delete object ttempobj2
                        make object from limb ttempobj1,segobj,tpactual
                        make object from limb ttempobj2,surrobj,surrlimb
                        `
                        rem recreate object from CSG PUNCH MESH
                        lgx#=limb position x(segobj,tpactual)
                        lgy#=limb position y(segobj,tpactual)
                        lgz#=limb position z(segobj,tpactual)
                        position object ttempobj1,lgx#,lgy#,lgz#
                        texture object ttempobj1,segmentprofile(seg,tpactual).texid
                        `
                        rem recreate object from DEST NEIGHBOR MESH
                        lgx#=limb position x(surrobj,surrlimb)
                        lgy#=limb position y(surrobj,surrlimb)
                        lgz#=limb position z(surrobj,surrlimb)
                        position object ttempobj2,lgx#,lgy#,lgz#
                        texture object ttempobj2,segmentprofile(surrseg,surrlimb).texid
                        `
                        rem perform CSG Punch on neighboring limb now
                        perform csg difference ttempobj2,ttempobj1
                        `
`                        rem CSG meshes must cast shadows (unless flagged as off)
`                        if glightshadowsstate=1 then tshadow=3 else tshadow=0

`                        rem scene scadow casting disabled (for performance)
`                        if gdynamicshadowsstate=1 then tshadow=2
                        `
                        rem reapply effect if have one
                        if segmentprofile(surrseg,surrlimb).effectid>0
                         texture object ttempobj2,0,segmentprofile(surrseg,surrlimb).texdid
                         if segmentprofile(surrseg,surrlimb).texiid<>0 then texture object ttempobj2,1,segmentprofile(surrseg,surrlimb).texiid
                         if segmentprofile(surrseg,surrlimb).texnid<>0 then texture object ttempobj2,2,segmentprofile(surrseg,surrlimb).texnid
                         if segmentprofile(surrseg,surrlimb).texsid<>0 then texture object ttempobj2,3,segmentprofile(surrseg,surrlimb).texsid
                         set object effect ttempobj2,segmentprofile(surrseg,surrlimb).effectid
                        endif
                        `
                        rem add new limb to node tree now (polycol after csg)
                        tarbvalue=segmentprofile(surrseg,surrlimb).material.index
                        if tarbvalue=0 then tarbvalue=1
                        set object transparency ttempobj2,4
                        make static object ttempobj2,0,tarbvalue,tshadow,1
                        `
                        rem remove temp object
                        delete object ttempobj1
                        delete object ttempobj2
                        `
                        rem hide the segment-limb
                        hide limb surrobj,surrlimb
                        `
                       endif
                      endif
                     next surrlimb
                    endif
                   endif
                   `
                 endif
                endif
               endif
              next surrx
             next surry
            next surrl
           endif
          endif
         next tp
         `
         rem restore map data
         if olay=0 then mapid=map(lay,x,y)
         if olay=1 then mapid=olaylist(olayindex,olayti)
         gosub _gridedit_getmapvalues
         `
        endif
        `
        rem Pass 3 - Add To NodeTree
        if csgpass=3
         `
         rem prepare object with HSR process
         usesegobj=0
         if ghsrmode=1
          `
          rem report progress
          tproggy#=(9.0/layermax)*lay
          debugviewtext(221+tproggy#,strarr$(161)+str$(lay)+","+str$(x)+","+str$(y))
          `
          rem create super-ground-punch (arbitary usage)
`         groundpunchobj=64998
`         if object exist(groundpunchobj)=0
`          make object box groundpunchobj,80000,100,80000
`          position object groundpunchobj,0,-50,0
`          hide object groundpunchobj
`         endif
          `
          rem check boundbox of CSGPUNCH with surrounding segments
          for surrl=lay-1 to lay+1
           for surry=y-1 to y+1
            for surrx=x-1 to x+1
             if surrl>=0 and surrl<layermax
              if surry>=0 and surry<40
               if surrx>=0 and surrx<40
                 mapid=map(surrl,surrx,surry)
                 if mapid<>0
                  gosub _gridedit_getmapvalues
                  if object exist(selectionbankoffset+mapselection)=1
                   rem object bounding object to add to universe
                   surrobj=mapobj(surrl,surrx,surry)
                   if surrobj>0
                    perform csg clip segobj,surrobj
                   endif
                  endif
                 endif
               endif
              endif
             endif
            next surrx
           next surry
          next surrl
          `
          rem Now punch out ground (arbitary usage)
`         perform csg clip segobj,groundpunchobj
          `
         endif
         `
         rem make node tree addition
         for tlimb=0 to segmentprofileheader(seg).partmax
          `
          rem only visible meshes are used to make universe
          if limb exist(segobj,tlimb)=1
          if limb visible(segobj,tlimb)=1
           `
           rem shadow all except floor,wall,ceiling (and meshes with shadow switched off)
`           if glightshadowsstate=1 then tshadow=3 else tshadow=0
`           if gdynamicshadowsstate=1 then tshadow=2

           if tlimb=segmentprofile(seg).vis.f then tshadow=0
           if tlimb=segmentprofile(seg).vis.r then tshadow=0
           if tlimb=segmentprofile(seg).vis.wb then tshadow=0
           if tlimb=segmentprofile(seg).vis.wr then tshadow=0
           if tlimb=segmentprofile(seg).vis.wf then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owb then tshadow=0
           if tlimb=segmentprofile(seg).vis.owr then tshadow=0
           if tlimb=segmentprofile(seg).vis.owf then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbl then tshadow=0
           `
           rem set transparency for universe add
`           set object transparency segobj,segmentprofile(seg,tlimb).transparency
`           set object transparency segobj,1 `need alpha test active (depth-sort-via-alpha-test)
           set object transparency segobj,4
           `
           rem add mesh to universe
           tcolmode=segmentprofile(seg,tlimb).colmode
           tarbvalue=segmentprofile(seg,tlimb).material.index
           if segmentprofile(seg,tlimb).transparency=2 then tarbvalue=0 : rem FPSCV101 - no bullethole in trasparent(2) static
           if tcolmode=1 then inc totalnumberofcollisionboxes
           if segmentprofile(seg).vis.overlay=0
            if segmentprofile(seg).properties.kindof>0
             rem currently only corridors are true for this, and ARE ALL solid!
             rem 1straight,2corner,3tjunc,4cross,5deadend
             tportalblocker=2
            else
             tportalblocker=1
            endif
           else
            tportalblocker=0
           endif
           make static limb segobj,tlimb,tcolmode,tarbvalue,tshadow,tportalblocker
           `
          endif
          endif
          `
         next tlimb
         `
         rem hide original object (still used for SURROBJ HSR culling)
         hide object segobj
         `
        endif
        `
        rem PassEnd
        `
        rem Increment segment objid
        inc segobj
        `
        rem When run out of segments to build map, leave immediately
        if segobj>=universebuildobjendoffset
         rem end all loop conditions - no crash - just shortened level
         lay=layermax : y=maxy-1 : x=maxx-1
         olay=1 : olayti=tolaymax
        endif
        `
       endif
      endif
     next olayti
    endif
   next olay
  next x
 next y
next lay
`
rem When all objecta added (first pass)
if csgpass=1
 rem add a zero-size high object for top of universe (need clearance for player on roofs)
 make object box segobj,0,100,0 : position object segobj,0,highesty+50,0 : inc segobj
 rem record last segment object
 lastsegobj=segobj
endif
if csgpass=3
 if object exist(segobj)=1
  set object transparency segobj,4
  make static object segobj,0,0,0,1
  hide object segobj : inc segobj
 endif
endif
`
rem next pass
next csgpass

rem V102RC6 remove all segment objects to free up memory for next phase ( except the horizon polys )
if gusefloorstate=1 then inc segobjstart,4
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj
if gusefloorstate=1 then dec segobjstart,4

rem FPSCV104RC7 - new lightmapper
rem FPSCV105RC1 - added new flag 'glightmappingold'
useoldlightmapper=glightmappingold
usedarklightmapper=1-glightmappingold
if usedarklightmapper=1
 rem DarkLIGHTS Settings
 LM Start
endif

rem debug info
debugviewtext(230,strarr$(162))

rem add pure static entities to node tree now
eleobj=entityobjectoffset
ttick=0 : ttickmax=entityelementlist/10 : ttickmax=1
for e=1 to entityelementlist
 obj=eleobj+e
 entid=entityelement(e).bankindex
 tentid=entityelement(e).bankindex
 if obj>0
  rem add static entities to node tree now
  if entityelement(e).staticflag=1
   inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(232,strarr$(163)+str$(e)+"/"+str$(entityelementlist)+" ("+entityprofile(tentid).model$+")")
   if entityprofile(tentid).ismarker=0
    rem this next routine should texture, but because entobj is zero, no, need to use OBJ!!!
    configureobj=obj : gosub _entity_configueelementforuse
    gosub _entity_createelementasobject
    if object exist(obj)=1
     rem collision mode for static entities (0-poly,1-box,2-reduced) dynamic (3-cylinder,4-sphere)
     tcolmode=2 : rem default is to use a reduced mesh
     if entityprofile(tentid).collisionmode>0 and entityprofile(tentid).collisionmode<3
      tcolmode=entityprofile(tentid).collisionmode-1
     endif
     rem static entities must cast shadows (unless flagged as off)
`     if glightshadowsstate=1 then tshadow=3 else tshadow=0
`     if gdynamicshadowsstate=1 then tshadow=2
     tarbvalue=entityprofile(tentid).materialindex
     enable object zwrite obj
     set object transparency obj,4
     rem handle entities that animate
     useobj=obj
     make static object useobj,tcolmode,tarbvalue,tshadow,0
     delete object useobj
    endif
   endif
  endif
  rem add dynamic and static lights from entities
  if entityprofile(tentid).ismarker=2
   lgx#=entityelement(e).x
   lgy#=entityelement(e).y
   lgz#=entityelement(e).z
   lgrange#=entityelement(e).eleprof.light.range
   lgr#=rgbr(entityelement(e).eleprof.light.color)
   lgg#=rgbg(entityelement(e).eleprof.light.color)
   lgb#=rgbb(entityelement(e).eleprof.light.color)
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     lgtype=1 : gosub _lighting_adddynamiclight
     entityelement(e).eleprof.light.index=infinilightindex
    endif
   else
    if activatelightmapping=1
     if useoldlightmapper=1
      add light map light lgx#, lgy#, lgz#, lgrange#, lgr#, lgg#, lgb#, 100, 1
     endif
     if usedarklightmapper=1
      size# = lgrange#
      falloff# = size#/2
      radius# = size#+falloff#
      zerorange# = ( radius# * glightzerorange ) / 100.0
      atten# = glightatten / (radius#*radius#)
      outer# = 1.0 + falloff#
      brighter# = radius# / outer#
      lgr#=lgr#*brighter#
      lgg#=lgg#*brighter#
      lgb#=lgb#*brighter#
      LM Add Custom Point Light lgx#, lgy#, lgz#, radius#, zerorange#, atten#,lgr#/255.0, lgg#/255.0, lgb#/255.0
     endif
     lgtype=0 : gosub _lighting_adddynamiclight
     inc staticlightcount
    endif
    if gdynamicshadowsstate=1
     array insert at bottom shadowlight()
     shadowlight().x# = lgx#
     shadowlight().y# = lgy#
     shadowlight().z# = lgz#
     shadowlight().range# = lgrange#
    endif
   endif
  endif
 endif
next e

rem New portals section of game runner
debugviewtext(240,strarr$(164))
build static portals

rem Apply shadow lights to scene (which will compute shadows direct from node tree
if gdynamicshadowsstate=1
 debugviewtext(250,strarr$(165))
 set global shadow shades 1
 set global shadow color 0,0,0,128
` disabled scene shadows for performance reasons
` for tsli=1 to array count(shadowlight(0))
`  set shadow light tsli, shadowlight(tsli).x#, shadowlight(tsli).y#, shadowlight(tsli).z#, shadowlight(tsli).range#
` next tsli
endif

rem New lightmapping section of game runner
if activatelightmapping=1 and staticlightcount>0
 rem delete old lightmaps
 debugviewtext(259,strarr$(166))
 tl=0
 while tl<65535
  neither=0 : rem FPSCV105RC2 - lightmaps where not deleted after PNG was added
  tl$="levelbank\testlevel\lightmaps\"+str$(tl)+".dds"
  if file exist(tl$)=1 then delete file tl$ else inc neither
  tl$="levelbank\testlevel\lightmaps\"+str$(tl)+".png"
  if file exist(tl$)=1 then delete file tl$ else inc neither
  if neither=2 then exit
  inc tl
 endwhile
 rem add universe for lightmapping
 debugviewtext(260,strarr$(167))
 if useoldlightmapper=1
  add static objects to light map pool
  debugviewtext(270,strarr$(168))
  if glightmapsize>0
   create light maps glightmapsize,glightmapquality,"levelbank\testlevel\lightmaps\"
  else
   create light maps 8,100,"levelbank\testlevel\lightmaps\"
  endif
 endif
endif

rem Must be done 'after' lightmapping phase
if grealgameviewstate=0 and segobjusedformapeditor=0 and goptimizemode=1
 `
 rem Saving effects (as some scene geometry needs setting changes)
 debugviewtext(273,strarr$(169))
 filename$="levelbank\testlevel\universe.eff"
 if file exist(filename$)=1 then delete file filename$
 open to write 1,filename$
  write file 1,effectbankmax
  for eff=1 to effectbankmax
   write string 1,effectbank$(eff)
  next eff
  write string 1,thorizonplanetex$
 close file 1
 `
 rem Builds final universe reload file (even when test game)
 debugviewtext(275,strarr$(170))
 universefile$="levelbank\testlevel\universe.dbu" : if file exist(universefile$)=1 then delete file universefile$
 universefile$="levelbank\testlevel\universe.dbo" : if file exist(universefile$)=1 then delete file universefile$
 save static objects universefile$
 `
 rem FPSCV104RC9 - pregenerate physics universe (faster loading)
 phyunimesh$="levelbank\testlevel\universephy.dbo" : if file exist(phyunimesh$)=1 then delete file phyunimesh$
 universeobj=universebuildobjstartoffset-1
 load object "levelbank\testlevel\universe.dbo",universeobj
 make mesh from object universeobj,universeobj
 convert mesh to vertexdata universeobj
 delete object universeobj
 make object universeobj,universeobj,0
 delete mesh universeobj
 save object phyunimesh$,universeobj
 delete object universeobj
 `
 rem If DarkLIGHT lightmapper used
 if activatelightmapping=1 and staticlightcount>0 and usedarklightmapper=1
  `
  rem load and lightmap static universe
  universeobj=universebuildobjstartoffset-1
  if object exist(universeobj)=1 then delete object universeobj
  load object universefile$,universeobj
  if glightshadowsstate=0
   rem Quick Lightmapping
   LM Add Collision Object universeobj
  else
   rem Full Lightmapping
   LM Add Transparent Collision Object universeobj,1
  endif
  LM Add Light Map Object universeobj
  LM Build collision Data
  `
  rem ambient setting (full ambient control in scene)
  LM Set Ambient Light glightambientr/100.0,glightambientg/100.0,glightambientb/100.0
  if glightsunr<>0 or glightsung<>0 or glightsunb<>0
   LM Add Directional Light glightsunx,glightsuny,glightsunz,glightsunr/100.0,glightsung/100.0,glightsunb/100.0
  endif
  `
  rem settings
  LM Boost Curved Surface Quality glightmaxsize,(glightboost*1.0)
  `
  rem start the light mapping thread
  lm set light map name ""
  lm set light map file format 1 : rem DDS
  lm set light map folder "levelbank\testlevel\lightmaps\"
  quality#=glightquality/100.0
  if glightthreadmax=-2
   rem FPSCV105 - 090307 - new mode, to revert to non-thread approach (for some users stability)
   debugviewtext(270,strarr$(168))
   LM Build Light Maps glighttexsize,quality#,glightblurmode
  else
   LM Build Light Maps Thread glighttexsize,quality#,glightblurmode,glightthreadmax
   load dll "Kernel32.dll",1
   while LM Get Complete()=0
    debugviewtext(276,LM Get Status( )+"  "+str$(int(LM Get Percent()))+"%")
    call dll 1,"Sleep",1
   endwhile
   delete dll 1
  endif
  `
  rem close lightmapper
  LM Reset
  `
  rem If lightmaps are PNG (compressed and slow toload), convert to DDS
  rem NO measurable speed gain with DDS over PNG
  `if 0
  ` tl=0
  ` while tl<65535
  `  tl$="levelbank\testlevel\lightmaps\"+str$(tl)+".png"
  `  if file exist(tl$)=1
  `   tl2$="levelbank\testlevel\lightmaps\"+str$(tl)+".dds"
  `   tttempimage=imagebankoffset-1
  `   if image exist(tttempimage)=1 then delete image tttempimage
  `   load image tl$,tttempimage
  `   save image tl2$,tttempimage
  `   delete image tttempimage
  `  else
  `   exit
  `  endif
  `  inc tl
  ` endwhile
  `endif
  `
  rem save lightmapped universe
  if file exist(universefile$)=1 then delete file universefile$
  set object light universeobj,1
  set light mapping on universeobj,0 : rem DBP+ set light mapping on universeobj,0,1
  save object universefile$,universeobj
  delete object universeobj
  `
  rem load static universe back in
  load static objects universefile$,gdividetexturesize
  `
 endif
 `
 rem V106 RC3 Save lighting data (for uni-skip)
 gosub _version_universe_saveELEandLGT
 `
 rem Only perform these saves if BUILDING EXE
 if gcompilestandaloneexe=1
  `
  rem Version control on EXE Building
  gosub _version_universe_construct
  `
 endif
 `
 rem V106 save old map, overlay and static entity data for future test game pass
 gosub _universe_saveforskipcheck
 `
endif

return

_universe_destruct:

rem Remove universe and all constructed preview assets
delete static objects : set static universe maxx*100,(layermax+1)*100,maxy*100

return

_universe_camera:

rem Input source
tkeystate30=0 : tkeystate32=0 : tkeystate17=0 : tkeystate31=0 : tkeystate44=0
if inputsys.kscancode=87 then tkeystate17=1
if inputsys.kscancode=83 then tkeystate31=1
if inputsys.kscancode=65 then tkeystate30=1
if inputsys.kscancode=68 then tkeystate32=1
if inputsys.kscancode=90 then tkeystate44=1
cammovex#=inputsys.xmousemove
cammovey#=inputsys.ymousemove

rem Camera old information
cox#=camera position x()
coy#=camera position y()
coz#=camera position z()

rem Control camera movement
movement=0 : speed#=6.0
x#=camera angle x() : z#=camera angle z() : sy#=camera angle y() : y#=sy#
if tkeystate30=1 then dec y#,90 : movement=1
if tkeystate32=1 then inc y#,90 : movement=1
rotate camera 0,y#,0
if tkeystate17=1 or tkeystate30=1 or tkeystate32=1 then move camera speed# : movement=1
if tkeystate31=1 then move camera speed#*-1.0 : movement=1
rotate camera x#,sy#,z#

rem Float Key
if tkeystate44=1 then position camera camera position x(),camera position y()+4.0,camera position z() : grav#=-1.0

rem Camera new information
cmx#=camera position x()
cmy#=camera position y()-grav#
cmz#=camera position z()

rem Overall ellipse collision for camera
tcameraeyey#=20.0
if deactivatecollision=0
 if static volume(cox#,coy#-tcameraeyey#,coz#,cmx#,cmy#-tcameraeyey#,cmz#,1.0)=1
  cmx#=cox#+get static collision x()
  cmy#=coy#+get static collision y()
  cmz#=coz#+get static collision z()
  tcolmaterialtype=get static collision value()-1
  colmaterialtype=tcolmaterialtype
  grav#=1
 else
  inc grav#,1
 endif
endif

rem Non node tree collision floor stopper (and edge of universe stopper)
if cmx#<0.0 then cmx#=0.0
if cmx#>maxx*100.0 then cmx#=maxx*100.0
if cmy#<45.0 then cmy#=45.0
if cmz#<maxy*-100.0 then cmz#=maxy*-100.0
if cmz#>0.0 then cmz#=0.0

rem Update camera position
position camera cmx#,cmy#,cmz#
zrotate camera curveangle(0,camera angle z(0),1.75)
position listener cmx#/10.0,cmy#/10.0,cmz#/10.0
rotate listener 0,camera angle y(0),0

rem Camera rotation speeds
t=abs(cammovex#)+abs(cammovey#)
if t=1 then camrotspeed#=0.05
if t=2 then camrotspeed#=0.1
if t=3 then camrotspeed#=0.15
if t=4 then camrotspeed#=0.2
if t>=5 then camrotspeed#=0.25

rem Control camera view
camangx#=camera angle x()+(cammovey#*camrotspeed#)
camangy#=camera angle y()+(cammovex#*camrotspeed#)
if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<275 then camangx#=275.0
rotate camera camangx#,camangy#,camera angle z()

return

_universe_preparelimbflags:

rem Create limb flag array
limbflagmax=segmentprofileheader(seg).lastmeshmax
undim limbflag()
dim limbflag(limbflagmax)

rem Fill array with null limbs
for tlimb=0 to limbflagmax
 limbflag(tlimb)=0
next tlimb

return

_universe_createhorizonplanes:
 `
 rem TODO take MAXX and MAXY into account!
 `
 rem Load texture for horizon plane
 thorizonplanetex$=""
 thorizonplanetexid=segmentprofile(mapselection,0).texid
 if thorizonplanetexid<>0
  thorizonplanetex$=segmentprofile(mapselection,0).tex$
 else
  thorizonplanetexid=segmentprofile(mapselection,0).texdid
  if thorizonplanetexid<>0
   thorizonplanetex$=segmentprofile(mapselection,0).texd$
  else
   thorizonplanetex$="texturebank\common\ground_D2.tga"
   thorizonplanetexid=loadinternalimage(thorizonplanetex$)
  endif
 endif
 `
 rem Place horizon planes on four sides
 tdim=(40*100)/2.0 : tdimneg=tdim*-1 : tdimlong=tdim*3 : lay=0
 rem Left
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,tdimneg,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Right
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,(maxx*100)+tdim,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Top
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,tdim
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 rem Bottom
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,(maxy*-100)+tdimneg
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 `
 rem And place fog to finish horizon blur to sky (by colour)
 rem FPSCV104RC3 - fog is controlled by FPI elsewhere
 `fog on : fog distance 2000.0,4000.0 : fog color 0,0,0
 `
return

_universe_makemapvalues:
 `
 mapid = 0
 mapid = mapid + ( ( mapselection && %111111111111 ) << 20 )
 mapid = mapid + ( ( mapscaler && %1111 ) << 16 )
 mapid = mapid + ( ( mapground && %11 ) << 14 )
 mapid = mapid + ( ( maprotate && %11 ) << 12 )
 mapid = mapid + ( ( maporient && %11 ) << 10 )
 mapid = mapid + ( ( mapsymbol && %111111 ) << 4 )
 mapid = mapid + ( ( maptile && %1111 ) )
 rem mapid out
 `
return


`
` Player and AI Shared Code
`

_entity_getactualframe:
 `
 rem work out actual frame from base frame and entity-character state and weapon used
 rem only applies to characters with weapons
 if entityprofile(entid).ischaracter=1
  if entityelement(e).attachmentweapontype>0
   rem if weapon, use 50-99 range
   if tbasetype=1 then tactualframe=entityanim(entid,50+tbaseframe).start
   if tbasetype=2 then tactualframe=entityanim(entid,50+tbaseframe).finish
   rem if greater than pistol, apply an offset to final frame number
   if tbaseframe>=10 and tbaseframe<=22
    if tbaseframe=13 or tbaseframe=16
     tokay=1
    else
     tokay=0
    endif
   else
    tokay=1
   endif
   if tokay=1
    if entityelement(e).attachmentweapontype=2 then tactualframe=tactualframe+389
    if entityelement(e).attachmentweapontype=3 then tactualframe=tactualframe+778
    if entityelement(e).attachmentweapontype=4 then tactualframe=tactualframe+1167
    if entityelement(e).attachmentweapontype=5 then tactualframe=tactualframe+1556
   endif
  else
   rem if no weapon, we are done (NOWEAP)
   if tbasetype=1 then tactualframe=entityanim(entid,tbaseframe).start
   if tbasetype=2 then tactualframe=entityanim(entid,tbaseframe).finish
  endif
  rem assign crouch flag (profile of character for hit detect)
  if tbaseframe>=31 and tbaseframe<40 then entityelement(e).crouchprofile=1 else entityelement(e).crouchprofile=0
 else
  if tbasetype=1 then tactualframe=entityanim(entid,tbaseframe).start
  if tbasetype=2 then tactualframe=entityanim(entid,tbaseframe).finish
 endif
 `
return

_entity_getactualframestart:
 tbasetype=1 : gosub _entity_getactualframe
return

_entity_getactualframefinish:
 tbasetype=2 : gosub _entity_getactualframe
return

_player_determinevisibility:

rem used by an entity when looking at mex#,mey#,mez#
rem determine if player exposed to be visible to tmpx#,tmpy#,tmpz#,dist# and (e)
tvisibility=1
tvisibilityifbreak=0 : tvisibilityifbreakdist#=9999.99

rem deduct from 100 percent visible, if drop below zero, enemy cannot see plr
visprobcount=100

rem instant block if other object obstructs it
for tte=1 to entityelementlist
 if tte<>e
  if entityelement(tte).active=1 and entityelement(tte).dormant=0 and entityelement(tte).collisionactive=1
   tdistx#=entityelement(e).x-entityelement(tte).x
   tdisty#=entityelement(e).y-entityelement(tte).y
   tdistz#=entityelement(e).z-entityelement(tte).z
   ttdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if ttdist#<=dist# and entityelement(tte).obj>0
    ttdst#=intersect object(entityelement(tte).obj,tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
    if ttdst#>0
     if entityelement(tte).eleprof.transparency=0 then tvisibility=0
     if entityelement(tte).eleprof.transparency>0
      if ttdst#<tvisibilityifbreakdist#
       tvisibilityifbreak=tte
       tvisibilityifbreakdist#=ttdst#
      endif
     endif
     if tvisibility=0 then tte=entityelementlist+1
    endif
   endif
  endif
 endif
next tte

rem loose accuracy on exposure of player (if peeking, crouched, moving)
if tvisibility=1
 if peeklean#<>0.0 then dec visprobcount,10
 if movement=0 then dec visprobcount,25
 if crouchmode<>0 then dec visprobcount,10
endif

rem loose accuracy on distance
if tvisibility=1
 if dist#>1000 then dec visprobcount,10
 if dist#>2000 then dec visprobcount,50
endif

rem loose accuracy on light level of player
if tvisibility=1
 if dist#>200
  if array count(infinilight())>0
   tavlightcol#=(avlightcolr#+avlightcolg#+avlightcolb#)/3.0
   tavlightcol#=tavlightcol#/2.5
   tavlightcol=100-tavlightcol# : if tavlightcol<1 then tavlightcol=1
   tavlightcol=tavlightcol/2
   dec visprobcount,tavlightcol
  endif
 endif
endif

rem use visual probability count for final visibile check
if tvisibility=1
 if visprobcount<0 then tvisibility=0
endif

return

_player_leavetrail:
 `
 rem leave trail one per tile
 if trailaction=0
  trax1=trailx#/100
  tray1=traily#/100
  traz1=trailz#/100
  trax2=playertrial(playertrailmax).x/100
  tray2=playertrial(playertrailmax).y/100
  traz2=playertrial(playertrailmax).z/100
 else
  trax1=trailx#/5
  tray1=traily#/50
  traz1=trailz#/5
  trax2=playertrial(playertrailmax).x/5
  tray2=playertrial(playertrailmax).y/50
  traz2=playertrial(playertrailmax).z/5
 endif
 if trax1<>trax2 or tray1<>tray2 or traz1<>traz2
  `
  rem deposit new trail blob
  inc playertrailmax
  if playertrailmax>100 then playertrailmax=1
  playertrial(playertrailmax).time=timer()
  playertrial(playertrailmax).x=trailx#
  playertrial(playertrailmax).y=traily#
  playertrial(playertrailmax).z=trailz#
  `
  rem if in debug, create object to illustrate blob
  if gshowdebugtextingamestate=1
   `
   rem create fresh new blob
   tobj=gamdebugobjoffset+playertrailmax
   if object exist(tobj)=0 then make object cube tobj,10 : set object collision off tobj
   position object tobj,trailx#,traily#,trailz#
   set object emissive tobj,rgb(255,200,0)
   scale object tobj,100,100,100
   `
   rem discolour rest of blobs by their age
   tai=playertrailmax
   for ta=1 to 99
    dec tai : if tai<1 then tai=100
    tobj=gamdebugobjoffset+tai
    if object exist(tobj)=1
     set object emissive tobj,rgb(255-(ta*2.5),200-(ta*2),0)
     scale object tobj,100.0-(ta*0.95),100,100.0-(ta*0.95)
    endif
   next ta
   `
  endif
  `
 endif
 `
return

`
` Entities and AI Shared Code
`

_entity_controlrecalcdist:
 ttokay=0
 if entityelement(e).active=1
  if gmultiplayergame=0 then ttokay=1
  if gmultiplayergame=1 and PlayerCanStart=1 then ttokay=1
 endif
 if ttokay=1
  distx#=mex#-entityelement(e).x
  disty#=(mey#-phyeyeheight#)-entityelement(e).y
  distz#=mez#-entityelement(e).z
  dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  diffangle#=atanfull(distx#,distz#)
  if diffangle#<0 then diffangle#=diffangle#+360
 else
  dist#=9999999
 endif
return

_entity_conescanforentity:
 `
 rem e looking for another e of type tentitytype (1=weapon)
 entityelement(e).mover.viewconeused=10
 tfounde=0
 telex#=entityelement(e).x
 teley#=entityelement(e).y+65.0
 telez#=entityelement(e).z
 for te=1 to entityelementlist
  tokay=0
  if entityelement(te).active=1
   tentid=entityelement(te).bankindex
   if tentitytype=1
    if entityprofile(tentid).isweapon<>0 then tokay=1
   endif
  endif
  if tokay=1
   tdistx#=telex#-entityelement(te).x
   tdisty#=teley#-entityelement(te).y+10.0
   tdistz#=telez#-entityelement(te).z
   tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if tdist#<1000.0
    tmpx#=entityelement(te).x
    tmpy#=entityelement(te).y+6.0
    tmpz#=entityelement(te).z
    if static raycast(telex#,teley#,telez#,tmpx#,tmpy#,tmpz#)=0
     tfounde=te : te=entityelementlist
    endif
   endif
  endif
 next te
 `
return

_entity_playerhavekey:
 rem Is USEKEY Collected?
 tokay=0
 for te=1 to entityelementlist
  if entityelement(te).collected=1
   if lower$(entityelement(te).eleprof.name$)=lower$(entityelement(e).eleprof.usekey$)
    tokay=1 : exit
   endif
  endif
 next te
return

_entity_activatename:
 rem Activate All Entities that share tname$ (using tstate)
 for te=1 to entityelementlist
  if entityelement(te).active=1
   if lower$(entityelement(te).eleprof.name$)=lower$(tname$)
    entityelement(te).activated=tstate
    entityelement(te).logiccount=0 : entityelement(te).logiccountburst=5
    entityelement(te).dormant=0
   endif
  endif
 next te
return

_entity_activateallinzone:
 for te=1 to entityelementlist
  if entityelement(te).active=1 or entityelement(te).spawn.atstart=0
   tex=entityelement(te).x
   tey=entityelement(te).y
   tez=entityelement(te).z
   if tex>condx1 and tex<condx2
    if tey>condy1-5 and tey<condy2+5
     if tez<condz1 and tez>condz2
      entityelement(te).activated=tactivated
      entityelement(te).logiccount=0 : entityelement(te).logiccountburst=5
      entityelement(te).dormant=0
     endif
    endif
   endif
  endif
 next te
return

_entity_findname:
 rem Activate All Entities that share tname$ (using tstate)
 foundte=0
 for te=1 to entityelementlist
  if entityelement(te).active=1
   if lower$(entityelement(te).eleprof.name$)=lower$(tname$)
    foundte=te : exit
   endif
  endif
 next te
return

`
` AI and HUD Shared Code
`

_ai_hud_view:
 `
 rem Fill HUD with data based on type
 for hudid=1 to hudmax
  `
  rem STATUS or NUMERIC
  if hud(hudid).maintype=4 or hud(hudid).maintype=6
   if hud(hudid).typemode=1 then hud(hudid).text$=str$(player(1).lives)
   if hud(hudid).typemode=2 then hud(hudid).text$=str$(player(1).health)
   if hud(hudid).typemode=3
    if weaponammoindex>0
     if gun(gunid).settings.reloadqty>0
      if gun(gunid).settings.weaponisammo=1
       hud(hudid).text$=str$(weaponammo(weaponammoindex))
      else
       hud(hudid).text$=str$(weaponammo(weaponammoindex))+"\"+str$(weaponclipammo(weaponammoindex))
      endif
     else
      hud(hudid).text$=""
     endif
    else
     hud(hudid).text$=""
    endif
   endif
   if hud(hudid).typemode=4
    rem frags
    if ggameobjectivetype<>1
     fr$=str$(frags(iLocalEL))
     if ggameobjectivetype=2 then fr$=fr$+"\"+str$(ggameobjectivevalue)
    else
     fr$=""
    endif
    hud(hudid).text$=fr$
   endif
   if hud(hudid).typemode=5
    rem time
    if ggameobjectivetype=3
     fr$=str$((timer()-dwStartTime)/1024)+"\"+str$(ggameobjectivevalue)
    else
     fr$=""
    endif
    hud(hudid).text$=fr$
   endif
  endif
  `
  rem WEAPON IMAGE
  if hud(hudid).maintype=4
   if hud(hudid).typemode=3
    if weaponammoindex>0
     if weaponhud(weaponammoindex)>0
      if hud(hudid).image<>weaponhud(weaponammoindex)
       hud(hudid).image=weaponhud(weaponammoindex)
       if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
      endif
     endif
    else
     hud(hudid).image=0
    endif
   endif
  endif
  `
  rem WEAPON ZOOMSCOPE OVERRIDE
  if hud(hudid).maintype=5
   if hud(hudid).typemode=4
    if gun(gunid).zoomscope<>0
     hud(hudid).image=gun(gunid).zoomscope
    else
     hud(hudid).image=internalzoomhudimage
    endif
    if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
   endif
  endif
  `
  rem ANIM
  if hud(hudid).maintype=7
   if hud(hudid).typemode=1 then tnum#=(player(1).lives/100.0)*10.0
   if hud(hudid).typemode=2 then tnum#=(player(1).health/100.0)*10.0
   tnum=tnum#
   if tnum<0 then tnum=0
   if tnum>10 then tnum=10
   hud(hudid).image=hud(hudid).baseanim+tnum
   if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
  endif
  `
  rem IPLIST BOX
  if hud(hudid).maintype=9
   if hud(hudid).hide=0
    rem refresh list auto periodically
    if refreshipaddresstimer<=0
     gosub _ai_hud_refreshiplist
     refreshipaddresstimer=200
    else
     dec refreshipaddresstimer
    endif
    rem display list
    set text size 30
    tipx=hud(hudid).posx
    tipy=hud(hudid).posy+88
    if hudiplistmax=-1
     center text screen width()/2,(screen height()/2)-10,strarr$(631)
    else
     for ty=0 to hudiplistmax
      text tipx+45,tipy+(ty*20),str$(1+ty)
      text tipx+100,tipy+(ty*20),hudiplist$(ty,0)
      center text tipx+400,tipy+(ty*20),hudiplist$(ty,1)
     next ty
    endif
   endif
  endif
  `
  rem FADEOUT control
  if hud(hudid).fadeout>0
   if hudfadeoutoneatatime=0 then hudfadeoutoneatatime=hudid
   if hudid=hudfadeoutoneatatime
    hud(hudid).fadeout=hud(hudid).fadeout-5
    if hud(hudid).fadeout>0
     if hud(hudid).fadeout>100
      talpha#=255.0
     else
      talpha#=(255.0/100.0)*hud(hudid).fadeout
     endif
    else
     rem hudfadeoutoneatatime allows one at a time
     hudfadeoutoneatatime=0
     hud(hudid).fadeout=0
     hud(hudid).hide=1
     talpha#=0.0
    endif
    if hud(hudid).image>0 then set sprite alpha hudid,talpha#
   else
    if hud(hudid).image>0 then set sprite alpha hudid,0
   endif
  endif
  `
 next hudid
 `
 rem Display using direct paste (fastest)
 ink rgb(255,255,255),0
 for hudid=1 to hudmax
  if hud(hudid).hide=0
   if hud(hudid).maintype=6
    rem NUMERIC
    for tt=1 to len(hud(hudid).text$)
     ttnum=-1
     if mid$(hud(hudid).text$,tt)="." then ttnum=10
     if mid$(hud(hudid).text$,tt)="\" then ttnum=11
     if ttnum=-1 then ttnum=asc(mid$(hud(hudid).text$,tt))-asc("0")
     if ttnum<>-1
      ttnumy=ttnum/4 : ttnum=ttnum-(ttnumy*4) : ttbitx#=(1.0/64.0)*16 : ttbity#=(1.0/64.0)*16
      if hud(hudid).image>0
       set sprite texture coord hudid,0,(ttbitx#*ttnum),(ttbity#*ttnumy)
       set sprite texture coord hudid,1,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)
       set sprite texture coord hudid,2,(ttbitx#*ttnum),(ttbity#*ttnumy)+ttbity#
       set sprite texture coord hudid,3,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)+ttbity#
       paste sprite hudid,hud(hudid).posx+((tt-1)*12),hud(hudid).posy
      endif
     endif
    next tt
   else
    rem IMAGE+TEXT
    if hud(hudid).image>0
     tokay=1
     if gmultiplayergame=1
      if hud(hudid).maintype=1 and hud(hudid).typemode>0
       if hud(hudid).typemode=1 and goneshotkills=0 then tokay=0
       if hud(hudid).typemode=2 and ggameobjectivetype<>1 then tokay=0
       if hud(hudid).typemode=5 and ggameobjectivetype<>3 then tokay=0
      endif
     endif
     if tokay=1
      if hud(hudid).fadeout>0
       tfadeout=hud(hudid).fadeout : if tfadeout>100 then tfadeout=100
       paste sprite hudid,hud(hudid).posx,hud(hudid).posy-(100-tfadeout)
      else
       paste sprite hudid,hud(hudid).posx,hud(hudid).posy
      endif
     endif
    endif
    if hud(hudid).text$<>"" and hud(hudid).image=0
     tfont$=hud(hudid).font$ : if tfont$<>"" and tfont$<>tlastfont$ then set text font tfont$ : tlastfont$=tfont$
     tfontsize=hud(hudid).fontsize : if tfontsize<>0 and tfontsize<>tlastfontsize then set text size tfontsize : tlastfontsize=tfontsize
     center text hud(hudid).posx+(hud(hudid).sizex/2),(hud(hudid).posy+hud(hudid).sizey)+(hud(hudid).fadeout/5.0),hud(hudid).text$
    endif
   endif
  else
   if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
  endif
 next hudid
 `
 rem After Image Text pasting
 for hudid=1 to hudmax
  `
  rem EDIT BOX
  if hud(hudid).maintype=8
   if hud(hudid).hide=0

    if hud(hudid).typemode<10
     hud(hudid).typemode=hud(hudid).typemode+10
    else
     if hud(hudid).typemode<20
      `
      rem show current entry
      string$=entry$() : length=15
      if len(string$)>length then string$=left$(string$,length)
      set cursor hud(hudid).posx+18,hud(hudid).posy+14
      print string$;
      if rnd(1)=1 then print "_" else print ""
      `
      rem if IP selection not valid
      if returnkey()=1
       if hud(hudid).typemode=12
        tnc=0
        for tn=1 to len(string$)
         if mid$(string$,tn)="." then inc tnc
        next tn
        if tnc=3
         rem valid IP address - use this
        else
         rem numerical selection
         tnv=val(string$)
         if hudiplistmax>=0
          if tnv>=1 and tnv<=1+hudiplistmax
           rem valid entry using ID - obtain IPaddress from list
           string$=hudiplist$(tnv-1,1)
          else
           rem not a valid entry
           string$=""
          endif
         else
          rem not a valid entry
          string$=""
         endif
        endif
       endif
       hud(hudid).text$=string$
       if len(string$)>0
        hud(hudid).typemode=hud(hudid).typemode+10
       else
        hud(hudid).typemode=hud(hudid).typemode-10
       endif
      endif
      `
     endif
    endif
   endif
  endif
  `
  rem IPADDRESS BOX
  if hud(hudid).maintype=11
   if hud(hudid).hide=0
    set text size 24
    ink rgb(8,8,8),0
    center text hud(hudid).posx,hud(hudid).posy-8,serveripaddress$
    if left$(serveripaddress$,8)<>"192.168."
     if left$(localipaddress$,8)="192.168."
      center text hud(hudid).posx,screen height()-22,"YOU CAN ALSO PLAY WITHIN YOUR NETWORK WITH IP ADDRESS "+localipaddress$
     endif
    endif
    ink rgb(255,255,255),0
   endif
  endif
  `
  rem WINNERSNAME BOX
  if hud(hudid).maintype=12
   if hud(hudid).hide=0
    set text size 24
    rem list of players
    tylinevalue=hud(hudid).posy
    for el=1 to multiplayermax
     if multiplayeridlink(el)<>1
      center text hud(hudid).posx,tylinevalue,multiplayername$(el)+"    "+str$(frags(el))
      inc tylinevalue,30
     endif
    next el
   endif
  endif
  `
 next hudid
  `
 rem Handle HUD control
 for hudid=1 to hudmax
  `
  rem Special HUD Pointer
  if hud(hudid).maintype=2
   rem Can Display At Mouse Coordinate
   hud(hudid).posx=mousex()-((hud(hudid).width/2)*gratiox#)
   hud(hudid).posy=mousey()-((hud(hudid).height/2)*gratioy#)
   aihudpointerimagestore=hud(hudid).image
   rem Can Detect When Select HUD Item
   for thudid=1 to hudmax
    rem Only selectables
    hud(thudid).highlighted=0
    if hud(thudid).maintype=3
     if hud(hudid).posx>hud(thudid).posx
      if hud(hudid).posx<hud(thudid).posx+(hud(thudid).width*gratiox#)
       if hud(hudid).posy>hud(thudid).posy
        if hud(hudid).posy<hud(thudid).posy+(hud(thudid).height*gratioy#)
         hud(thudid).highlighted=1
        endif
       endif
      endif
     endif
    endif
   next thudid
   if mouseclick()=1
    for thudid=1 to hudmax
     if hud(thudid).highlighted=1
      hudselectionmade=hud(thudid).typemode
     endif
    next thudid
   endif
  endif
  `
  rem Delayed display, then hide
  if hud(hudid).hidedelay>0
   hud(hudid).hidedelay=hud(hudid).hidedelay-1
   if hud(hudid).hidedelay=0 then hud(hudid).hide=1
  endif
  `
  rem Radar Blip (v1.1)
  if hud(hudid).maintype=4 and hud(hudid).typemode=11
   `
   rem Mimic radar blip
   for e=1 to entityelementlist
    if entityelement(e).health>0
     tentid=entityelement(e).bankindex
     if entityprofile(tentid).ischaracter=1
      fundx#=entityelement(e).x-camera position x()
      fundy#=camera position z()-entityelement(e).z
      funangle#=atanfull(fundy#,fundx#)
      rrr#=funangle#-camera angle y()
      if hud(hudid).image>0
       paste sprite hudid,hud(hudid).posx-8+(cos(rrr#)*40),hud(hudid).posy-8+(sin(rrr#)*40)
      endif
     endif
    endif
   next e
   `
  endif
  `
 next hudid
 `
return

_ai_hud_refreshiplist:
 `
 rem update list from file(for now)
 gosub _ai_gamelist_refresh
 `
return

_ai_gamelist_add:
 `
 rem server adds to gamelist, uses addip$ and addname$
 action$="action=add&"
 serverid$="server_id="+guniquegamecode$+"&"
 ip$="ip="+addip$+"&" : ipfromadd$=ip$
 title$="title="+addname$+"&"
 data$="data=none"
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  idfromadd$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ip$+title$+data$)
  if val(idfromadd$)=0 then tryagain=1
  dec tryattempts
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_delete:
 `
 rem server deletes from gamelist
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  action$="action=delete&"
  serverid$="server_id="+guniquegamecode$+"&"
  return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ipfromadd$+"id="+idfromadd$)
  if return$="1" then serverhasremoveditselffromonlinelist=1
  if return$<>"1" then tryagain=1
  dec tryattempts
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_keepalive:
 `
 rem send this to keep game item listed in database
 HTTP CONNECT strarr$(619)
 action$="action=keepalive&"
 serverid$="server_id="+guniquegamecode$+"&"
 return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ipfromadd$+"id="+idfromadd$)
 HTTP DISCONNECT
 `
return

_ai_gamelist_refresh:
 `
 rem client views gamelist choices, fill array
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  action$="action=list&"
  serverid$="server_id="+guniquegamecode$
  return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$)
  if return$<>""
   c=1 : hudiplistmax=-1 : fromc=0
   repeat
    if asc(mid$(return$,c))=10
     if fromc>0
      thudiplist$=left$(return$,c-1)
      thudiplist$=right$(thudiplist$,len(thudiplist$)-fromc)
     else
      thudiplist$=left$(return$,c-1)
     endif
     for c1=1 to len(thudiplist$)
      if mid$(thudiplist$,c1)="," then exit
     next c1
     thudiplist1$=left$(thudiplist$,c1-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c1))
     for c2=1 to len(thudiplist$)
      if mid$(thudiplist$,c2)="," then exit
     next c2
     thudiplist2$=left$(thudiplist$,c2-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c2))
     for c3=1 to len(thudiplist$)
      if mid$(thudiplist$,c3)="," then exit
     next c3
     thudiplist3$=left$(thudiplist$,c3-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c3))
     for c4=1 to len(thudiplist$)
      if mid$(thudiplist$,c4)="," then exit
     next c4
     thudiplist4$=left$(thudiplist$,c4-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c4))
`     if thudiplist1$=thisgamecode$
      inc hudiplistmax
      hudiplist$(hudiplistmax,0)=thudiplist4$
      hudiplist$(hudiplistmax,1)=thudiplist3$
 `    endif
     fromc=c+1
    else
     rem skip char, finding end
    endif
    inc c
   until c>len(return$)
  else
   tryagain=1
   dec tryattempts
  endif
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_checkforfirewall:
 `
 rem FSCV105RC2 - server has a script to give is the real machine IP
 `http://www.fpscreator.com/gamehost/whatismyip.php
 serveripaddress$=""
 `
 rem added for 090307
 rem check three times to connect to FPSC gamelist server
 HTTP CONNECT strarr$(619)
 tryattempts=3
 repeat
  action$=""
  return$=HTTP REQUEST DATA("POST", "gamehost/whatismyip.php",action$)
  errorcodestring$=return$
  return$=lower$(return$)
  checkfor$="error code"
  if return$<>""
   for n=0 to len(return$)-len(checkfor$)-1
    if left$(right$(return$,(len(return$)-n)),len(checkfor$))=checkfor$
     rem error code returned when attempted to access HTTP command
     errorcode$=errorcodestring$
    endif
   next n
   if errorcode$="" and len(return$)>0
    rem FPSCV105RC2 - 100307 - puts the actual HOSTable IP address in serveripaddress$
    serveripaddress$=return$
    tryattempts=0
   endif
  endif
  dec tryattempts
 until tryattempts<=0 or len(errorcode$)=0
 HTTP DISCONNECT
 `
 rem if fail, report and exit
 if errorcode$<>""
  s$="Failed to establish a connection with the gamelist server. "
  s$=s$+"This could be caused by loss of internet connectivity, or the presence of a firewall."
  exit prompt s$,errorcode$
  end
 endif
 `
return

_ai_hud_add:

rem HUD Types based on name
workhudmake$=lower$(workhudmake$)

rem Existing HUD
if workhudname$>""
 for thudi=1 to hudmax
  if lower$(workhudname$)=lower$(hud(thudi).name$)
   hudid=thudi : exit
  endif
 next thudi
else
 thudi=hudmax+1
endif
if thudi>hudmax
 `
 rem New HUD
 inc hudmax : hudid=hudmax
 dim hud(hudmax) as hudtype
 `
 rem HUD Type
 hud(hudid).maintype=0
 if workhudmake$="display"
  hud(hudid).maintype=1
  hud(hudid).typemode=workhudtype : rem 0always,X-objectivetype(mutliplayer)
 endif
 if workhudmake$="pointer" then hud(hudid).maintype=2
 if workhudmake$="button"
  hud(hudid).maintype=3
  hud(hudid).typemode=workhudtype : rem 1new,2load,3save,4continue,5exit
 endif
 if workhudmake$="status"
  hud(hudid).maintype=4
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,4frags,5time,11blip
 endif
 if workhudmake$="internal"
  hud(hudid).maintype=5
  hud(hudid).typemode=workhudtype : rem 1loader,2eyehud,3fader,4zoom
  if workhudtype=1 then internalloaderhud=hudid
  if workhudtype=2 then internaleyehud=hudid
  if workhudtype=3 then internalfaderhud=hudid
  if workhudtype=4 then internalzoomhud=hudid : internalzoomhudimage=workhudimage
 endif
 if workhudmake$="numeric"
  hud(hudid).maintype=6
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,11blip
 endif
 if workhudmake$="anim"
  hud(hudid).maintype=7
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,11blip
  hud(hudid).baseanim=workhudimage
 endif
 if workhudmake$="edit"
  hud(hudid).maintype=8
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="list"
  hud(hudid).maintype=9
  hud(hudid).typemode=workhudtype
  refreshipaddresstimer=0
 endif
 if workhudmake$="ipaddress"
  hud(hudid).maintype=11
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="winnersname"
  hud(hudid).maintype=12
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="textprompt"
  hud(hudid).maintype=21
  hud(hudid).typemode=0
 endif
 `
 rem HUD Data
 hud(hudid).name$=workhudname$
 hud(hudid).posx=workhudx
 hud(hudid).posy=workhudy
 hud(hudid).posz=workhudz
 hud(hudid).sizex=workhudsizex
 hud(hudid).sizey=workhudsizey
 hud(hudid).sizez=workhudsizez
 hud(hudid).red=workhudred
 hud(hudid).green=workhudgreen
 hud(hudid).blue=workhudblue
 hud(hudid).image=workhudimage
 hud(hudid).font$=workhudfont$
 hud(hudid).fontsize=workhudsize
 hud(hudid).text$=workhudtext$
 hud(hudid).hide=workhudhide
 hud(hudid).hidedelay=0
 hud(hudid).highlighted=0
 `
 rem Calculate bounds of HUD (for selectability)
 if workhudsizex>0
  hud(hudid).width=workhudsizex
 else
  if hud(hudid).image>0
   hud(hudid).width=image width(hud(hudid).image)
  else
   if hud(hudid).font$<>"" then set text font hud(hudid).font$
   if hud(hudid).fontsize<>0 then set text size hud(hudid).fontsize
   hud(hudid).width=text width(hud(hudid).text$)
  endif
 endif
 if workhudsizey>0
  hud(hudid).height=workhudsizey
 else
  if hud(hudid).image>0
   hud(hudid).height=image height(hud(hudid).image)
  else
   if hud(hudid).font$<>"" then set text font hud(hudid).font$
   if hud(hudid).fontsize<>0 then set text size hud(hudid).fontsize
   hud(hudid).height=text height(hud(hudid).text$)
  endif
 endif
 `
 rem Offset position with size if image
 if hud(hudid).image>0
  hud(hudid).posx=hud(hudid).posx-((hud(hudid).width/2)*gratiox#)
  hud(hudid).posy=hud(hudid).posy-((hud(hudid).height/2)*gratioy#)
 endif
 `
 rem Update HUD sprites
 gosub _ai_hud_update
 `
endif

return

_ai_hud_update:
 `
 rem HUD Sprites
 set sprite 1,0,1
 sprite 1,-10000,-10000,1
 for hudid=1 to hudmax
  if hud(hudid).image>0
   sprite hudid,-10000,-10000,hud(hudid).image
   if hud(hudid).sizex>0
    size sprite hudid,hud(hudid).sizex*gratiox#,hud(hudid).sizey*gratioy#
   else
    size sprite hudid,hud(hudid).width*gratiox#,hud(hudid).height*gratioy#
   endif
   set sprite diffuse hudid,hud(hudid).red,hud(hudid).green,hud(hudid).blue
   if hud(hudid).fadeout>0
    rem else where
   else
    set sprite alpha hudid,255
   endif
  endif
 next hudid
 `
return

rem
rem VERSIONS (Full)
rem

_version_commandlineprompt:
 `
 rem Triggers use of file map messaging
 if lower$(cl$())="-t"
  gtestgamemodefromeditor=1
 endif
 `
return

_version_endofinit:

rem Ensure full game flag never set!!
`grealgameviewstate=0 `demo versions with noEXEsave do this

 rem Game Engine Demo would send this into filemap of OS
` filemapname$="FPSCComm"
` write filemap value filemapname$,42
` write filemap string filemapname$,"demo version"

return

_version_splashtext:
 `
 rem Update Splash Text
 open file map 2, "FPSSPLASH"
 set file map dword 2, 4, 1
 set file map string$ 2, 1000, strarr$(392)
 set file map dword 2, 8, 1
 wait for file map event 2
 close file map 2
 `
return

_version_onscreenlogos:
return

_version_permittestgame:
 `
 rem Map Editor launches test game
 open file map 1,"FPSEXCHANGE"
 set file map string$ 1, 1000, "FPSC-Game.exe"
 set file map string$ 1, 1256, "-t"
 set file map dword 1, 920, 1
 wait for file map event 1
 close file map 1
 `
return

_version_resourcewarning:
return

_version_universe_saveELEandLGT:
 `
 rem Save newer elements list (that includes scene dynamic entities)
 rem V106 also contains light indexes saved when universe is constructed
 elementsfilename$="levelbank\testlevel\universe.ele" : gosub _entity_saveelementsdata
 `
 rem Save LGT lighting data
 filename$="levelbank\testlevel\universe.lgt"
 if file exist(filename$)=1 then delete file filename$
 open to write 1,filename$
  tinfinimax=array count(infinilight())
  write file 1,tinfinimax
  for i=0 to tinfinimax
   write file 1,infinilight(i).used
   write file 1,infinilight(i).type
   write float 1,infinilight(i).x
   write float 1,infinilight(i).y
   write float 1,infinilight(i).z
   write float 1,infinilight(i).range
   write file 1,infinilight(i).id
   write float 1,infinilight(i).dist
   write file 1,infinilight(i).colrgb.r
   write file 1,infinilight(i).colrgb.g
   write file 1,infinilight(i).colrgb.b
   write file 1,infinilight(i).islit
  next i
 close file 1
 `
return

_version_universe_construct:
  `
  rem Save lighting data
  gosub _version_universe_saveELEandLGT
  `
  rem New entities may have been aded, resave map.ent for transfer to level area
  gosub _entity_savebank
  `
  rem Copy over key map data files this level required
  for tkey=1 to 4
   if tkey=1 then tfile$="levelbank\testlevel\header.dat" : tfile2$="mapbank\testmap\header.dat"
   if tkey=2 then tfile$="levelbank\testlevel\map.fpmb" : tfile2$="mapbank\testmap\map.fpmb"
   if tkey=3 then tfile$="levelbank\testlevel\map.ent" : tfile2$="mapbank\testmap\map.ent"
   if tkey=4 then tfile$="levelbank\testlevel\map.way" : tfile2$="mapbank\testmap\map.way"
   if file exist(tfile$)=1 then delete file tfile$
   copy file tfile2$,tfile$
  next tkey
  `
  rem Save ALL data in leveltest under a level file FPL (for use to extract new levels to play)
  gosub _mapfile_save_fpl
  `
return

_version_buildgame:
 `
 rem Is called when BUILD GAME selected from file menu
 gosub _interface_openbuildgame : gosub _interface_handlebuildgame :  gosub _interface_closebuildgame
 `
return

_version_main_game_buildexe:

rem Despot file collection
if file exist("..\buildfiles.ini")=1 then delete file "..\buildfiles.ini"
save array "..\buildfiles.ini",filecollection$()

rem Store root folder
rootpath$=get dir$()

rem Name without EXE
exename$=gbuildname$
if lower$(right$(exename$,4))=".exe"
 exename$=left$(exename$,len(exename$)-4)
endif

rem Path to EXE
if mid$(gbuildpath$,2)=":"
 exepath$=gbuildpath$
else
 exepath$=exedir$
endif
if right$(exepath$,1)<>"\" then exepath$=exepath$+"\"
if path exist(exepath$)=0 then exepath$=rootpath$+"\..\MyGames\"

rem FPSCV104RC7 - user can delete the MyGames folder?
if path exist(exepath$)=0
 set dir rootpath$ : set dir ".."
 make directory "MyGames"
endif

rem Create game folder
set dir exepath$
make directory exename$
set dir exename$
make directory "Files"
set dir "Files"

rem FPSCV10X, ensure gamesaves files are removed (if any)
if path exist("gamesaves")=1
 set dir "gamesaves"
 perform checklist for files
 for c=1 to checklist quantity()
  tfile$=checklist string$(c)
  if len(tfile$)>2
   if file exist(tfile$)=1 then delete file tfile$
  endif
 next c
 set dir ".."
endif

rem ensure file path exists (by creating folders)
filesmax=array count(filecollection$())
for fileindex=0 to filesmax
 olddir$=get dir$()
 src$=filecollection$(fileindex)
 srcstring$=src$
 while len(srcstring$)>0
  for c=1 to len(srcstring$)
   if mid$(srcstring$,c)="\" or mid$(srcstring$,c)="/"
    chunk$=left$(srcstring$,c-1)
    if len(chunk$)>0
     if path exist(chunk$)=0 then make directory chunk$
     set dir chunk$
    endif
    srcstring$=right$(srcstring$,len(srcstring$)-c)
    exit
   endif
  next c
  if c>len(srcstring$) then exit
 endwhile
 set dir olddir$
next fileindex

rem v107 - 070807 - also detect for any HUD.X copies, and also copy texture files in its folder
set dir rootpath$
for fileindex=0 to filesmax
 src$=filecollection$(fileindex)
 if right$(lower$(src$),6)="\hud.x"
  rem find all files in the folder that shares this file and add to collection
  addallfilestocollection(left$(src$,len(src$)-5))
 endif
next fileindex
filesmax=array count(filecollection$())

rem copy file collection to exe folder
set dir rootpath$
debugviewtext(-1,strarr$(393))
for fileindex=0 to filesmax
 src$=filecollection$(fileindex)
 dest$=exepath$+exename$+"\Files\"+src$
 if file exist(dest$)=1 then delete file dest$
 copy file src$,dest$
next fileindex

rem copy game engine and rename it
set dir rootpath$ : set dir ".."
dest$=exepath$+exename$+"\"+exename$+".exe"
if file exist(dest$)=1 then delete file dest$
copy file "FPSC-Game.exe",dest$

rem create a setup.ini file here reflecting game
dim setuparr$(999)
setupfile$=exepath$+exename$+"\setup.ini" : i=0
setuparr$(i)="[GAMERUN]" : inc i
setuparr$(i)="realgameview=1" : inc i
setuparr$(i)="dynamiclighting="+str$(gdynamiclightingstate) : inc i
setuparr$(i)="dynamicshadows="+str$(gdynamicshadowsstate) : inc i
setuparr$(i)="useeffects="+str$( guseeffectstate ) : inc i
setuparr$(i)="useeffectsonguns="+str$( guseeffectongunsstate ) : inc i
setuparr$(i)="useeffectsonscene="+str$( guseeffectonscenesstate ) : inc i
setuparr$(i)="useeffectsonentities="+str$( guseeffectonentitiesstate ) : inc i
setuparr$(i)="useeffectsonessentials="+str$( guseeffectsonessentials ) : inc i
setuparr$(i)="dividetexturesize="+str$( gdividetexturesize ) : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEMULTIPLAYER]" : inc i
setuparr$(i)="multiplayergame="+str$(gmultiplayergame) : inc i
setuparr$(i)="gameobjectivetype="+str$(ggameobjectivetype) : inc i
setuparr$(i)="gameobjectivevalue="+str$(ggameobjectivevalue) : inc i
setuparr$(i)="oneshotkills="+str$(goneshotkills) : inc i
setuparr$(i)="maxplayers="+str$(numberofplayers) : inc i
setuparr$(i)="spawnrandom="+str$(gspawnrandom) : inc i
setuparr$(i)="uniquegamecode="+guniquegamecode$ : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEDEBUG]" : inc i
setuparr$(i)="usesky=1" : inc i
setuparr$(i)="usefloor="+str$( gusefloorstate ) : inc i
setuparr$(i)="useenvsounds=1" : inc i
setuparr$(i)="useweapons=1" : inc i
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEPROFILE]" : inc i
setuparr$(i)="title="+titlefpi$ : inc i
setuparr$(i)="global="+setupfpi$ : inc i
setuparr$(i)="gamewon="+gamewonfpi$ : inc i
setuparr$(i)="gameover="+gameoverfpi$ : inc i
for num=1 to 11
 setuparr$(i)="key"+str$(num)+"="+str$(listkey(num)) : inc i
next num
for num=1 to 9
 setuparr$(i)="slot"+str$(num)+"="+gunslots$(num) : inc i
next num
setuparr$(i)="levelmax="+str$(glevelmax) : inc i
for num=1 to glevelmax
 setuparr$(i)="levelfpm"+str$(num)+"="+level$(num).fpm$ : inc i
 setuparr$(i)="levelfpi"+str$(num)+"="+level$(num).fpi$ : inc i
next num
if file exist(setupfile$)=1 then delete file setupfile$
save array setupfile$,setuparr$()
undim setuparr$()
`
rem Also save out the localisation ptr file
dim setuparr$(2)
setupfile$=exepath$+exename$+"\userdetails.ini"
setuparr$(0)="[LOCALIZATION]"
setuparr$(1)="language="+language$
save array setupfile$,setuparr$()
undim setuparr$()
`
rem Restore directory
set dir rootpath$

return

rem
rem ODE specific code
rem

_ode_init:

rem start ode
ode start : rem set to regular world stepping
ode set world gravity physicsgravx#,physicsgravy#,physicsgravz#
ode set world step 0.05 : rem needed for accuracy
softness#=2.5 : rem soft as the player (was 2.0)
ode set world erp (0.2)*softness#
ode set world cfm (10^-5)*softness#

rem make physics universe
if object exist(physicsuniverseobj)=1 then delete object physicsuniverseobj
phyunimesh$="levelbank\testlevel\universephy.dbo"
if file exist(phyunimesh$)=0
 load object "levelbank\testlevel\universe.dbo",physicsuniverseobj
 make mesh from object physicsuniverseobj,physicsuniverseobj
 convert mesh to vertexdata physicsuniverseobj
 delete object physicsuniverseobj
 make object physicsuniverseobj,physicsuniverseobj,0
 delete mesh physicsuniverseobj
 rem FPSCV104RC9-accelerate loading
 save object phyunimesh$,physicsuniverseobj
else
 load object phyunimesh$,physicsuniverseobj
endif
debugviewtext(321,"Created static geometry for physics universe")
ode create static triangle mesh physicsuniverseobj
delete object physicsuniverseobj
if physicsproto=1
 load static objects "levelbank\testlevel\universe.dbo",0
endif
debugviewtext(322,"Submitted geometry to physics engine")

rem create entity assignments
for e=1 to entityelementmax
 `
 rem Sentinel disables physics for common non-physics items (non-multiplayer)
 entid=entityelement(e).bankindex
 if physicson>0 and gmultiplayergame=0
  rem and promotes others to specific types (1-normal,2-ignorestatic,3-becomestatic)
  rem Weapons, Ammo, Non-Objects, Immobile
  if entityprofile(entid).isweapon<>0 or entityprofile(entid).isammo<>0
   entityelement(e).eleprof.physics=0
  else
   if entityprofile(entid).ischaracter=1
    entityelement(e).eleprof.physics=2
   endif
   if entityelement(e).eleprof.isimmobile=1
    entityelement(e).eleprof.physics=3
   endif
  endif
  if entityelement(e).obj=0
   entityelement(e).eleprof.physics=0
  endif
 else
  rem usually no physics (most made static after loadentities see gamemain)
  entityelement(e).eleprof.physics=0
  rem multiplayer needs 'windows' as physics objects
  if gmultiplayergame=1
   if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0
    if entityelement(e).eleprof.isimmobile=1
     entityelement(e).eleprof.physics=3
    endif
   endif
  endif
 endif
 `
 rem Safety trap, can cancel if entity not complet
 if entityelement(e).eleprof.physics<>0
  if entityelement(e).profileobj>0
   if object exist(entityelement(e).profileobj)=0
    entityelement(e).eleprof.physics=0
   endif
  else
   entityelement(e).eleprof.physics=0
  endif
 endif
 `
 rem apply physics creation of object
 if entityelement(e).eleprof.physics<>0
  rem for physics bodies that have a center of mass, entity positions need altering to reflect correct position
  tobj=entityelement(e).obj
`  if entityelement(e).eleprof.physics<>3 (not 2'characters' either) - only regular physics objs
  if entityelement(e).eleprof.physics=1
   if tobj>0
    if object exist(tobj)=1
     tprofileobj=entityelement(e).profileobj
     tadj#=object collision center y(tprofileobj)
     entityelement(e).y=entityelement(e).y+tadj#
     position object tobj,object position x(tobj),object position y(tobj)+tadj#,object position z(tobj)
    endif
   endif
  endif
  rem create the physics body (if not child spawn entities)
  tspawnhide=0
  if entityelement(e).spawn.leaderid>0
   if entityelement(e).spawn.leader=0
    tspawnhide=1
   endif
  endif
  if tspawnhide=0
   if entityelement(e).spawn.leader=1
    rem spawn master does not need physics object
    gosub _ode_ensurephysicsobjvalid
   else
    rem everything else has physics to create
    gosub _ode_setupewithphysics
   endif
  else
   rem still need to reserve all obj ids with E
   gosub _ode_ensurephysicsobjvalid
  endif
 endif
 `
next e

rem Report progress
debugviewtext(323,"Applied physics settings to dynamic elements")

rem eat any old ODE messages
while ODE COLLISION MESSAGE EXISTS()
 ODE COLLISION GET MESSAGE
endwhile

rem shadow light position for global shadow effect
set point light 0,-2000,10000,2000
set ambient light 75

rem no need for dbpro standard collision 'automated' system
SET GLOBAL COLLISION OFF

return

_ode_ensurephysicsobjvalid:
 `
 rem redim new size (takes tobj and e)
 tmax=array count(phyobjele())
 if tobj>tmax
  tmax=tobj
  dim phyobjvelocity#(tmax)
  dim phylasttravelled#(tmax)
  dim phylastfloorstop#(tmax)
  dim phyobjsounding(tmax)
  dim phyobjremove(tmax)
  dim phyobjele(tmax)
  dim shadowobj(tmax)
 endif
 rem setup inits
 phyobjvelocity#(tobj)=0
 phylasttravelled#(tobj)=0
 phylastfloorstop#(tobj)=0
 phyobjsounding(tobj)=0
 phyobjremove(tobj)=0
 phyobjele(tobj)=e
 shadowobj(tobj)=0
 `
return

_ode_loadmateriallist:
`
rem load material list
tfile$="audiobank\materials\materialdefault.txt"
addfiletocollection(tfile$)
if file exist(tfile$)=1
 `
 rem Load Data from file
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem load max materials
    tryfield$="materialmax" : if field$=tryfield$ then gmaterialmax=value1 : dim material(gmaterialmax) as materialsettingstype
    `
    rem load material data
    for m=0 to gmaterialmax
     tryfield$="matdesc"+str$(m) : if field$=tryfield$ then material(m).name$=value$
     tryfield$="matwave"+str$(m) : if field$=tryfield$ then material(m).tred0$=value$
     tryfield$="matwaves"+str$(m) : if field$=tryfield$ then material(m).scrape$=value$
     tryfield$="matwavei"+str$(m) : if field$=tryfield$ then material(m).impact$=value$
     tryfield$="matwaved"+str$(m) : if field$=tryfield$ then material(m).destroy$=value$
     tryfield$="matfreq"+str$(m) : if field$=tryfield$ then material(m).freq=value1
     tryfield$="matdecal"+str$(m) : if field$=tryfield$ then material(m).decal$=value$
    next m
    `
   endif
  endif
 next l
 undim data$()
endif
`
rem Fill in material defaults if info lacking
for m=0 to gmaterialmax
 if file exist(material(m).scrape$)=0 then material(m).scrape$=material(m).tred0$
 if file exist(material(m).impact$)=0 then material(m).impact$=material(m).tred0$
 if file exist(material(m).destroy$)=0 then material(m).destroy$=material(m).tred0$
 material(m).tred1$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A1.wav"
 material(m).tred2$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A2.wav"
 material(m).tred3$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A3.wav"
 material(m).tred0$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A4.wav"
 if material(m).freq=0 then material(m).freq=22000
next m
`
rem Load material sounds into memory
tbase=materialsoundoffset
for m=0 to gmaterialmax
 if material(m).name$<>""
  rem load tred sound (all five)
  snd$=material(m).tred0$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).noise=tbase
   inc tbase
  else
   material(m).noise=0
  endif
  rem load scrape
  snd$=material(m).scrape$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).scrapeid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).scrapeid=0
  endif
  rem load impact
  snd$=material(m).impact$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).impactid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).impactid=0
  endif
  rem load destroy
  snd$=material(m).destroy$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).destroyid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).destroyid=0
  endif
 endif
next m
materialsoundmax=(tbase-1)-materialsoundoffset
`
rem Load decals for materials
for m=0 to gmaterialmax
 material(m).decalid=0
 if material(m).name$<>""
  decal$=material(m).decal$
  gosub _decal_find
  if decalid<0 then decalid=0
  if decalid>0
   material(m).decalid=decalid
   decal(decalid).active=1
  endif
 endif
next m
`
return

_ode_triggermaterialsound:
 `
 rem when trigger, play a material sound
 if tsoundtrigger>0
  tvol#=100 : sbase=tsoundtrigger
  for tchannels=0 to 4
   ts=sbase+tchannels
   if sound exist(ts)=1
    if sound playing(ts)=0
     playinternalBC3dsound(ts,tsx#,tsy#,tsz#,25.0)
     set sound volume ts,80.0+(tvol#*0.2)
     if tspd#>2000 then set sound speed ts,tspd#
     exit
    endif
   endif
  next tchannels
 endif
 `
return

_ode_setupewithphysics:
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   tprofileobj=entityelement(e).profileobj
   if tprofileobj>0
    if object exist(tprofileobj)=1
     `
     rem prepare visual alighment for regular physics objects (not floaters or statics)
     if entityelement(e).eleprof.physics=1
      if entityprofile(entid).ischaracter=1
       rem FPSCV104RC9 - do not adjust X and Z as model offsets are not good indicators of center
       offset limb tprofileobj,0,0,object collision center y(tprofileobj)*-1,0
       offset limb tobj,0,0,object collision center y(tprofileobj)*-1,0
      else
       offset limb tprofileobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
       offset limb tobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
      endif
     endif
     set object collision off tobj
     `
     rem ensure entitydriven and pseudo-static start with null rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      rem record object angle before apply physics to object
      entityelement(e).rx=object angle x(tobj)
      entityelement(e).ry=object angle y(tobj)
      entityelement(e).rz=object angle z(tobj)
      rem must ensure default matrix in ODE is unrotated to begin with (RY controls angle)
      yrotate object tobj,0
     endif
     `
     rem physics object is static or dynamic
     if entityelement(e).eleprof.physics=3
      rem static (dynamic response identical to static behaviour)
      ode create dynamic box tobj : ode set response tobj,2 : ode set gravity tobj,0
     else
      rem dynamic
      if entityprofile(entid).collisionmode=3
       ode create dynamic cylinder tobj
      else
       if entityprofile(entid).collisionmode=4
        ode create dynamic sphere tobj
       else
        ode create dynamic box tobj
       endif
      endif
      rem pre-test code to assign internally (now done in mapeditor)
      `tfriction=(object size x(tobj)*75)+(object size y(tobj)*75)+(object size z(tobj)*75)
      `tweight=(object size x(tobj)*25)+(object size y(tobj)*25)+(object size z(tobj)*25)
      `entityelement(e).eleprof.phyfriction=tfriction
      `entityelement(e).eleprof.phyweight=tweight
      entityelement(e).floorposy=object position y(tobj)
      ode set contact fdir1 tobj, entityelement(e).eleprof.phyfriction
      ode set body mass tobj,entityelement(e).eleprof.phyweight
      rem some objects ignore static geom and gravity
      if entityelement(e).eleprof.physics=2 then ode set response tobj,1 : ode set gravity tobj,0
      rem stabalize the object
      ode set linear velocity tobj,0,0,0
      ode set angular velocity tobj,0,0,0
      `
      rem recalc adjustment for objects that must find the floor perfectly
      centx#=ODE GET BODY ADJUSTMENT X(tobj)
      centy#=ODE GET BODY ADJUSTMENT Y(tobj)
      centz#=ODE GET BODY ADJUSTMENT Z(tobj)
      rem FPSCV101 - compensate for character model issues with a hack
      if entityprofile(entid).ischaracter=1
      ` applyscalefactor#=(entityprofile(entid).scale/100.0)
      ` offset limb tobj,0,0,((object collision center y(tprofileobj)/applyscalefactor#)*-1)+centy#,0
       rem FPSCV104RC9 - AIKO model has bug, correct here
       offset limb tobj,0,0,(object collision center y(tprofileobj)*-1)+centy#,0
      else
       rem regular object full XYZ center needed
       offset limb tobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
      endif
     endif
     `
     rem ensure entitydriven and pseudo-static than uses RY for rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      ode set body rotation tobj,0,entityelement(e).ry,0
     endif
     `
    else
     hide object tobj
    endif
   else
    hide object tobj
   endif
  endif
 endif
 rem redim new size and init vars
 gosub _ode_ensurephysicsobjvalid
return

_ode_pushusingtvelandangle:
 `
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   rem only for regular physics objects, not entitydriven characters, or statics (doors)
   if entityelement(e).eleprof.physics=1
    tvel#=tvel*2.0
    if tvel<>0
     tvelx#=newxvalue(0,entityelement(e).ry,tvel#)
     tvelz#=newzvalue(0,entityelement(e).ry,tvel#)
     tangle#=sin(tangle)*tvel#
     tvelx#=tvelx#*cos(tangle)
     tvelz#=tvelz#*cos(tangle)
     ode set linear velocity tobj,tvelx#,tangle#,tvelz#
    endif
    if entityelement(e).eleprof.rotatethrow<>0
     trotate#=entityelement(e).eleprof.rotatethrow/10.0
     ode set angular velocity tobj,trotate#,0,trotate#
    endif
   endif
  endif
 endif
 `
return

_ode_switchoffe:
 `
 ttobj=entityelement(e).obj
 if ttobj>0
  if object exist(ttobj)=1
   if entityelement(e).eleprof.physics<>0
    if shadowobj(ttobj)=1
     set shadow shading off ttobj
     shadowobj(ttobj)=0
    endif
    ode destroy object ttobj
    rem restore rotation of object (ode influence deleted)
    rotate object ttobj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
   endif
  endif
 endif
 `
return

_ode_ensureeisnotpenetrated:
 rem performed when physics object activates its presence (COLON)
 todee=e : todeobj=entityelement(e).obj
 for tte=1 to entityelementmax
  ttobj=entityelement(tte).obj
  if entityelement(tte).eleprof.physics<>0 and ttobj>0
   ttdy#=object position y(ttobj)-object position y(todeobj)
   if abs(ttdy#)<250
    rem if Ys close enough, do complete distance test
    ttdx#=object position x(ttobj)-object position x(todeobj)
    ttdz#=object position z(ttobj)-object position z(todeobj)
    ttdd#=sqrt(abs(ttdx#*ttdx#)+abs(ttdz#*ttdz#)+abs(ttdy#*ttdy#))
    if ttdd#<object size(todeobj)+object size(ttobj)
     rem give a nudge so it uses its own physics body to work out how to get out (brutal but efective)
     ode set linear velocity ttobj,0,0.01,0
    endif
   endif
  endif
 next tte
return

_ode_playerborble:
 `
 rem can call this to force player to camerapositionx,y,z
 rem borble that rattles around inside player ellipse
 phycrouched#=10.0 : phystood#=40.0
 phycrouchedellipsevolumesize#=0.25
 phystoodellipsevolumesize#=1.0
 ellipsevolumesize#=phystoodellipsevolumesize#
 phyeyeheight#=phystood#
 ctx#=camerapositionx
 cty#=camerapositiony
 ctz#=camerapositionz
 `
 rem prepare object and physics
 if object exist(physicsplayerborble)=1
  ode destroy object physicsplayerborble
  delete object physicsplayerborble
 endif
 make object sphere physicsplayerborble,38
 color object physicsplayerborble,rgb(255,255,0)
 set object collision off physicsplayerborble
 position object physicsplayerborble,camerapositionx,(camerapositiony-phyeyeheight#)+1,camerapositionz
 if physicsdebug=1
  set object wireframe physicsplayerborble,1
  set object cull physicsplayerborble,0
 else
  hide object physicsplayerborble
 endif
 ode create dynamic sphere physicsplayerborble
 ode set contact fdir1 physicsplayerborble,500
 ode set body mass physicsplayerborble,physicsplayerweight#
 ode set linear velocity physicsplayerborble,0,0,0
 ode set angular velocity physicsplayerborble,0,0,0
 `
 rem ensure player has default gravity
 ode set gravity physicsplayerborble,1
 physuspendgravity=0
 phytotalmotioncount=0
 phytotalmotion#=0
 `
return

_ode_cleanup:

rem free universe
if physicsproto=1
 delete static objects
endif

rem free ode static collision
ode destroy object physicsuniverseobj
if object exist(physicsuniverseobj)=1
 delete object physicsuniverseobj
endif
ode destroy object physicsplayerborble
if object exist(physicsplayerborble)=1
 delete object physicsplayerborble
endif

rem free assignments
for e=1 to entityelementmax
 tobj=entityelement(e).obj
 if tobj>0
  if entityelement(e).eleprof.physics<>0
   if object exist(tobj)=1 then ode destroy object tobj
  endif
 endif
next e

rem end ode
ode end

rem free material sounds
gosub _ode_deletematerialsounds

return

_ode_deletematerialsounds:
 `
 rem delete all material sounds
 for s=materialsoundoffset to materialsoundoffset+materialsoundmax
  if sound exist(s)=1 then delete sound s
 next s
 `
return

`
` Player Controls
`

_ode_unmark:
 `
 rem remove player from viscol prior to movement (use vis from write state)
 tx=viscx#/25 : ty=viscy#/100 : tz=viscz#/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=-1 then viscolmap(tx,ty,tz)=0
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=-1 then viscolmap(ttx,tty,ttz)=0
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 `
return

_ode_mark:
 `
 rem place viscol data back after player movement
 tx=camerapositionx/25 : ty=camerapositiony/100 : tz=camerapositionz/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=0 then viscolmap(tx,ty,tz)=-1
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=0 then viscolmap(ttx,tty,ttz)=-1
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 viscx#=camerapositionx : viscy#=camerapositiony : viscz#=camerapositionz
 `
return

_ode_playerrelocations:
 `
 rem handle lift mechanism for player
 if meridinglift<>0
  tobj=entityelement(meridinglift-1).obj
  meridinglifty#=object position y(tobj)+60
  tmex#=camerapositionx : tmey#=camerapositiony : tmez#=camerapositionz
  tdstx#=object position x(tobj)-tmex#
  tdstz#=object position z(tobj)-tmez#
  tdstt#=sqrt(abs(tdstx#*tdstx#)+abs(tdstz#*tdstz#))
  position camera camerapositionx,meridinglifty#,camerapositionz
  camerapositionx=camera position x()
  camerapositiony=camera position y()
  camerapositionz=camera position z()
  gosub _ode_playerborble
  if tdstt#>90
   meridinglift=0
  endif
  grav#=0 : gravlasty#=tmey#
 endif
 `
 rem handle transporter mechanism for player
 if meridingtransporter=1
  rem player coord moved to new location, must deactivate camera collision for movement
  position camera tranmex#,tranmey#,tranmez#
  rotate camera 0,tranmeangley#,0
  cx#=camera position x() : cy#=camera position y() : cz#=camera position z()
  cox#=cx# : coy#=cy# : coz#=cz#
  camerapositionx=camera position x()
  camerapositiony=camera position y()
  camerapositionz=camera position z()
  gosub _ode_playerborble
  meridingtransporter=0
 endif
 if memovingx#<>0.0
  memovingx#=0.0
 endif
 if memovingy#<>0.0
  memovingy#=0.0
 endif
 if memovingz#<>0.0
  memovingz#=0.0
 endif
 `
return

_ode_playercamera:

rem Camera in control of player one
plrid=1

rem Key configuration
if gtestgamemodefromeditor=1
 rem Preset TEST GAME Keys
 plrkeyW=17
 plrkeyA=30
 plrkeyS=31
 plrkeyD=32
 plrkeyQ=16
 plrkeyE=18
 plrkeyC=46
 plrkeyZ=44
 plrkeyR=19
 plrkeySPACE=57
 plrkeyRETURN=28
 plrkeySHIFT=42
 plrkeyF12=88
else
 rem from BUILD GAME config keys
 plrkeyW=listkey(1)
 plrkeyS=listkey(2)
 plrkeyA=listkey(3)
 plrkeyD=listkey(4)
 plrkeySPACE=listkey(5)
 plrkeyC=listkey(6)
 plrkeyRETURN=listkey(7)
 plrkeyR=listkey(8)
 plrkeyQ=listkey(9)
 plrkeyE=listkey(10)
 plrkeySHIFT=listkey(11)
 plrkeyZ=44
 plrkeyF12=88
endif

rem Read keys from config, and use in player control actions
if keystate(plrkeyW)=1 then plrkeyW=1 else plrkeyW=0
if keystate(plrkeyA)=1 then plrkeyA=1 else plrkeyA=0
if keystate(plrkeyS)=1 then plrkeyS=1 else plrkeyS=0
if keystate(plrkeyD)=1 then plrkeyD=1 else plrkeyD=0
if keystate(plrkeyQ)=1 then plrkeyQ=1 else plrkeyQ=0
if keystate(plrkeyE)=1 then plrkeyE=1 else plrkeyE=0
if keystate(plrkeyC)=1 then plrkeyC=1 else plrkeyC=0
if keystate(plrkeyZ)=1 then plrkeyZ=1 else plrkeyZ=0
if keystate(plrkeyR)=1 then plrkeyR=1 else plrkeyR=0
if keystate(plrkeySPACE)=1 then plrkeySPACE=1 else plrkeySPACE=0
if keystate(plrkeyRETURN)=1 then plrkeyRETURN=1 else plrkeyRETURN=0
if keystate(plrkeySHIFT)=1 then plrkeySHIFT=1 else plrkeySHIFT=0

rem hard coded arrow keys
if upkey()=1 then plrkeyW=1
if leftkey()=1 then plrkeyA=1
if downkey()=1 then plrkeyS=1
if rightkey()=1 then plrkeyD=1

rem Camera old information
ctox#=ctx# : ctoy#=cty# : ctoz#=ctz#

rem camera eye height (eye drops to base of elipse when no health)
if player(plrid).health<=0
 if ellipsevolumesize#=1.0 and (plrkeyC)=0
  phyeyeheight#=phyeyeheight#-1.0
  if phyeyeheight#<10.0 then phyeyeheight#=10.0
 else
  phyeyeheight#=phycrouched#
 endif
endif

rem get latest camera position
camerapositionx=object position x(physicsplayerborble)
camerapositiony=object position y(physicsplayerborble)+phyeyeheight#
camerapositionz=object position z(physicsplayerborble)
realcx#=camerapositionx : realcy#=camerapositiony : realcz#=camerapositionz

rem Umark player pos in viscolmap
gosub _ode_unmark

rem Handle any sudden playe relocations (transportation)
gosub _ode_playerrelocations

rem flyforce bleeds into camforce X and Y and Z
if camflyforcex#<0 then tsig=-1 else tsig=1
tamount#=camflyforcex# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcex#=(camflyforcex#-tamount#)*0.8
camforcex#=camforcex#+tamount#
`if camflyforcey#<0 then tsig=-1 else tsig=1
`tamount#=camflyforcey# : if abs(tamount#)>60 then tamount#=60*tsig
`camflyforcey#=(camflyforcey#-tamount#)*0.8
`camforcey#=camforcey#+tamount#
if camflyforcez#<0 then tsig=-1 else tsig=1
tamount#=camflyforcez# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcez#=(camflyforcez#-tamount#)*0.8
camforcez#=camforcez#+tamount#

rem All controls when player has health
movement=0
if player(plrid).health>0
 `
 rem Peek controls (and adjustment)
 if ((plrkeyQ)=1 or (plrkeyE)=1) and onladder=0
  if peekfreeze=0
   if (plrkeyQ)=1 and peeklean#>-10.0 then peeklean#=peeklean#-4.0 : movement=1
   if (plrkeyE)=1 and peeklean#<10.0 then peeklean#=peeklean#+4.0 : movement=1
  endif
 else
  peeklean#=curvevalue(0,peeklean#,4.0)
  if abs(peeklean#)<1.0 then peeklean#=0.0 : peekfreeze=0
 endif
 `
 rem Gun Zoom Control
 if gunzoommode>0
  if gunzoommode>=1 and gunzoommode<=8 then inc gunzoommode
  if gunzoommode>=11 and gunzoommode<=19 then inc gunzoommode
  if gunzoommode<10
   plrzoomin#=gunzoommode : plrzoominchange=1
  endif
  if gunzoommode=10
   rem in full zoom
  endif
  if gunzoommode>10
   plrzoomin#=10-(gunzoommode-10) : plrzoominchange=1
  endif
 endif
 `
 rem Handle optical effect of zoom
 if plrzoominchange=1
  if plrzoomin#>1.0
   set camera fov 75.0-(plrzoomin#*7)-gunzoommag#
   if internalzoomhud>0 then hudid=internalzoomhud : hud(hudid).hide=0 : set sprite alpha hudid,(255.0/10.0)*plrzoomin#
  else
   set camera fov 75.0
   if internalzoomhud>0 then hudid=internalzoomhud : hud(hudid).hide=1
  endif
 endif
 plrzoominchange=0
 `
 rem crouch control
 if (plrkeyC)=1
  if crouchmode=0 and onladder=0 and jumpaction=0 then crouchmode=1
 else
  if crouchmode=1 then crouchmode=0
  if crouchmode=2 then crouchmode=3
 endif
 `
 rem Control camera movement
 if crouchmode<>0
  basespeed#=20
 else
  if (plrkeySHIFT)=1
   basespeed#=55
  else
   basespeed#=35
  endif
 endif
 if jumpaction=0
  rem regular speed from manouver
  speed#=basespeed#
 else
  rem fixed speed whilst jumping
  speed#=jumpspeed#
 endif
 `
 rem Movement (forward,backward,strafe)
 camerareachatrun#=0.0
 plrbasespeed#=basespeed#
 if jumpaction=0 then moveroty#=camera angle y() else moveroty#=jumpangle#
 if onladder=0
  if (plrkeyW)=0 and (plrkeyA)=0 and (plrkeyD)=0 and (plrkeyS)=0
   cameraspeed=0
  endif
  if peeklean#=0.0
   if (plrkeyW)=1
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90
     if (plrkeyD)=1 then inc moveroty#,90
    endif
   endif
   phyangle#=moveroty#
   if (plrkeyW)=1 or (plrkeyS)=1 or (plrkeyA)=1 or (plrkeyD)=1
    movement=1 : if crouchmode<>0 then movement=2
    tcameraspeed#=speed#*playerspeedratio#*(0.5+(cameradampen#/2.0))
` 100805 - removed as it creates jerkiness - perhaps research smoother way postV1
`    rem time slicer to even out chasing speed (multiplayer)
`    if gmultiplayergame=1
`     timeslice#=(1.0/30.0)*(timer()-cameratimeslice)
`     tcameraspeed#=tcameraspeed#*timeslice#
`     cameratimeslice=timer()
`    endif
    if cameraspeed<tcameraspeed# then inc cameraspeed,5
    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
   endif
  endif
  if camerareachatrun#<cameraspeed/3.0 then camerareachatrun#=cameraspeed/3.0
  if camerareachatrun#<0 then camerareachatrun#=0
 else
`ladder?
`  phyangle#=moveroty#
`  if (plrkeyW)=1
`   movement=1
`   tcameraspeed#=speed#
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
`  if (plrkeyS)=1
`   movement=1 : onladder=0
`   tcameraspeed#=speed#*-1
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
 endif
 `
 rem Only suspend gravity if total movement small
 tmotionx#=ode get body linear velocity x(physicsplayerborble)
 tmotiony#=ode get body linear velocity y(physicsplayerborble)
 tmotionz#=ode get body linear velocity z(physicsplayerborble)
 tmotion#=abs(tmotionx#)+abs(tmotiony#)+abs(tmotionz#)
 phytotalmotion#=phytotalmotion#+tmotion#
 inc phytotalmotioncount
 if phytotalmotioncount>20
  phytotalmotion#=phytotalmotion#/phytotalmotioncount
  if phytotalmotion#<10.0
   physuspendgravity=1
  else
   physuspendgravity=0
  endif
  phytotalmotioncount=0
  phytotalmotion#=0
 endif
 rem update gravity with current motion
 grav#=tmotiony#
 rem suspend so can stand on slopes/stairs
 if movement<>0 or jumpaction=1 then physuspendgravity=0
 if physuspendgravity=1 or onladder=1
  ode set gravity physicsplayerborble,0
  if physuspendgravity=1 then grav#=0
 else
  ode set gravity physicsplayerborble,1
 endif
 if physicsdebug=1 then print "GRAVITY VALUE=";grav#
 `
 rem pretend movement
 camvelx#=newxvalue(0,phyangle#,cameraspeed)
 camvely#=grav#
 camvelz#=newzvalue(0,phyangle#,cameraspeed)
 `
 rem Jump Control
 if onladder=0
  if player(plrid).health>0
   if (plrkeySPACE)=1 and jumpaction=0 and meridinglift=0 and crouchmode=0 and jumpactionnorepeat=0 and grav#>-1
    jumpspeed#=speed# : jumpangle#=camera angle y() : leapedlanded=1
    camvely#=0 : camforcey#=50.0*(0.5+(cameradampen#/2.0))
    jumpmotionx#=tmotionx#
    jumpmotionz#=tmotionz#
    if playersound(plrid,10)>0
     broadcast3dsound(camerapositionx,camerapositiony,camerapositionz,5.0)
     play sound playersound(plrid,10)
    endif
    jumpaction=1 : jumpactionnorepeat=5
   endif
  endif
 endif
 if jumpactionnorepeat>0
  if jumpactionnorepeat>1 then dec jumpactionnorepeat
  if jumpactionnorepeat=1 and grav#<0 then jumpactionnorepeat=0
 endif
 if jumpaction<>0
  camvelx#=jumpmotionx# : camvelz#=jumpmotionz#
 endif
 `
 rem and apply any force here
 camvelx#=camvelx#+camforcex# : camforcex#=0
 camvely#=camvely#+camforcey# : camforcey#=0
 camvelz#=camvelz#+camforcez# : camforcez#=0
 `
else
 `
 rem player has no health
 cameraspeed=0
 camvelx#=0 : camforcex#=0
 camvely#=0 : camforcey#=0
 camvelz#=0 : camforcez#=0
 movement=0
 grav#=0
 `
endif

rem Is player moving or not
player(plrid).state.moving=movement

rem Mark player position is viscolmap
gosub _ode_mark

return

_ode_playeraftermove:

rem Camera in control of player one (unmark as slide may change pos)
plrid=1
gosub _ode_unmark
movement=player(plrid).state.moving

rem Collisions
colmaterialtype=-1
tgravitydefeated=0

rem Check for physicsobjects collisions (and perform physics collision sounds)
gosub _ode_sounds

rem control player interaction
if gmultiplayergame=1 then gosub _multi_plrradial

rem Special Get Out of Jail Free collision key
if inkey$()<>"K" then tkickout=0
if inkey$()="K" and tkickout=0
 if playertrailmax>0
  trailx#=playertrial(playertrailmax).x
  traily#=playertrial(playertrailmax).y
  trailz#=playertrial(playertrailmax).z
  dec playertrailmax : if playertrailmax<1 then playertrailmax=100
  if playertrial(playertrailmax).time=0
   inc playertrailmax : if playertrailmax>100 then playertrailmax=1
  else
   camerapositionx=trailx#
   camerapositiony=traily#+phyeyeheight#
   camerapositionz=trailz#
   position camera camerapositionx,camerapositiony,camerapositionz
   cx#=camera position x() : cy#=camera position y() : cz#=camera position z()
   cox#=cx# : coy#=cy# : coz#=cz#
   gosub _ode_playerborble
   meridingtransporter=0
   meridinglift=0
  endif
 endif
 tkickout=1
endif

rem Ellipse Collision with static scene
if deactivatecollision=0 and skipcol=0
 `
 rem check ellipse against movement
 ctx#=camerapositionx+(camvelx#/4.0)
 cty#=camerapositiony
 ctz#=camerapositionz+(camvelz#/4.0)
 rem check if can rouch down from stood
 if crouchmode=1
  if static volume(ctox#,ctoy#-28,ctoz#,ctx#,(cty#-28)-15,ctz#,0.25)=1
   if physicsdebug=1 then print "willgetstyckifcrouch"
  else
   ellipsevolumesize#=phycrouchedellipsevolumesize#
   phyeyeheight#=phycrouched#
   cty#=camerapositiony-12
   ctoy#=ctoy#-12
   crouchmode=2
  endif
 endif
 rem check if can stand up from crouch
 if crouchmode=3
  if static volume(ctox#,(ctoy#-9)+5,ctoz#,ctx#,(cty#-9)+40+5,ctz#,0.25)=1
   if physicsdebug=1 then print "willhitheadifgetup"
  else
   ellipsevolumesize#=phystoodellipsevolumesize#
   phyeyeheight#=phystood#
   cty#=camerapositiony+30+5
   ctoy#=ctoy#+30+5
   crouchmode=0
  endif
 endif
 rem determine center of ellipse (crouch and stood) (need contact with floor=walksound)
 if phyeyeheight#=phystood# then ellipsecentery#=35 else ellipsecentery#=23
 `
 rem ellipse test for final player mode (stood or crouch)
 if static volume(ctox#,ctoy#-ellipsecentery#,ctoz#,ctx#,cty#-ellipsecentery#,ctz#,ellipsevolumesize#)=1
  if physicsdebug=1 then print "volumecollision"
  adjx#=get static collision x()
  adjy#=get static collision y()
  adjz#=get static collision z()
  colmaterialtype=get static collision value()-1
  sctx#=ctx#
  scty#=cty#
  sctz#=ctz#
  ctx#=ctox#+adjx#
  cty#=ctoy#+adjy#
  ctz#=ctoz#+adjz#
  tstaticfloor=get static collision floor()
  if tstaticfloor=1 and grav#<0 then tgravitydefeated=1
  if jumpaction<>0 and camvely#>5.0 and cty#-scty#<0.0 then camvely#=camvely#*-1 : jumpaction=0
  if abs(ctx#-sctx#)+abs(ctz#-sctz#)>8
   rem event when collision hits something solid (not floor)
   camvelx#=ctx#-camerapositionx
   camvely#=cty#-camerapositiony
   camvelz#=ctz#-camerapositionz
   jumpmotionx#=0 : jumpmotionz#=0 : jumpaction=0
   if cameraspeed>5 then cameraspeed=5
   if camvely#>0 then camvely#=0
   rem wipe out flyforce too as hit something to stop hero
   camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
  endif
 endif
 `
 rem If gravity defeated by player
 if tgravitydefeatedbyphy<>0
  rem if object entity driven, player can be moved by it
  if entityelement(tgravitydefeatedbyphye).eleprof.physics=2
   if camerastoodonphyobj=0
    lcamerastoodonphyobjmovingx#=object position x(tgravitydefeatedbyphy)
    lcamerastoodonphyobjmovingz#=object position z(tgravitydefeatedbyphy)
   endif
   camerastoodonphyobj=tgravitydefeatedbyphy
  else
   camerastoodonphyobj=0
  endif
  rem record stood on phy obj
  if jumpactionnorepeat>1
   rem when in jump mode, and touching phyobj, do not interfere with a defeat flag
  else
   tgravitydefeated=1
  endif
 else
  rem when not detect phy obj, keep record until
  if tgravitydefeated=1
   rem stood on static floor (must have walked off phy obj)
   camerastoodonphyobj=0
  endif
 endif
 if camerastoodonphyobj<>0
  camerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)-lcamerastoodonphyobjmovingx#
  camerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)-lcamerastoodonphyobjmovingz#
  rem only influence of object beneath player borble
  if object position y(camerastoodonphyobj)<object position y(physicsplayerborble)
   camvelx#=camvelx#+(camerastoodonphyobjmovingx#*10)
   camvelz#=camvelz#+(camerastoodonphyobjmovingz#*10)
  endif
  lcamerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)
  lcamerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)
 endif
 if tgravitydefeated=1
  if physicsdebug=1 then print "andgravitydefeated"
  rem a few cycles grace at start of level (avoid urg sound when retstart)
  if newlevelobjectivevoid=0
   rem player lands after a jump
   if (grav#<-60.0 and jumpaction=0) or (grav#<-40.0 and jumpaction<>0)
    rem player urg sound
    if playersound(plrid,11)>0
     broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0)
     play sound playersound(plrid,11)
    endif
    rem deck plate sound too
    leapedlanded=1
   endif
   rem determine if fall hurt player
   if cty#<gravlasty#-playerhurtfall
    rem avoid hurt when using stairs
    tokayhurt=0
    if (abs(camvelx#)+abs(camvelz#)/2.0)<15.0
     tokayhurt=1
    else
     rem raycast behind plr (stairs would be there)
     tpmb#=-100.0
     tppx#=newxvalue(camerapositionx,camera angle y(),tpmb#)
     tppz#=newzvalue(camerapositionz,camera angle y(),tpmb#)
     tdst#=static raycast(camerapositionx,camerapositiony-phyeyeheight#,camerapositionz,tppx#,camerapositiony-phyeyeheight#,tppz#)
     if tdst#=0 then tokayhurt=1
    endif
    if gmultiplayergame=0
     rem cannot hurt by falling in arena game
     if tokayhurt=1
      rem level substantial different from last stood on ground
      tdamage=1+((abs(cty#-gravlasty#)-playerhurtfall)/5.0)
      gosub _player_takedamage
     endif
    endif
   endif
  endif
  rem record last ground player stood on
  gravlasty#=cty#
  rem landing sound
  jumpaction=0
 else
  if movement<>0 then onladder=0
 endif
 `
 rem Jump ends when camera starts decending
 if camvely#<0.0 then jumpaction=0
 `
 rem debug object
 if physicsdebug=1
  if object exist(98789)=0
   make object sphere 98789,20
   set object cull 98789,0
   set object wireframe 98789,1
   set object collision off 98789
  else
   position object 98789,ctx#,cty#-ellipsecentery#,ctz#
   scale object 98789,100,300*ellipsevolumesize#,100
  endif
 endif
 `
endif

rem ladder control
if onladder=1
` rem climb ladder mode
` cx#=onladderx# : cz#=onladderz#
` if movement<>0
`  grav#=camera angle x()/10.0
`  if grav#<-3.0 then grav#=-3.0
`  if grav#>3.0 then grav#=3.0
` else
`  grav#=0.0
` endif
` rem ladder grasp will kill jump action
` jumpaction=0
endif

rem new barrier code using physics force
if ctx#<25.0 then camvelx#=10.0
if ctz#>-25.0 then camvelz#=-10.0
if ctx#>(maxx*100.0)-25 then camvelx#=-10.0
if ctz#<(maxy*-100.0)+25 then camvelz#=10.0

rem Camera rotation speeds
if showgamemenu=0
 cammovex#=mousemovex() : cammovey#=mousemovey()
else
 cammovex#=0 : cammovey#=0
endif
t=abs(cammovex#)+abs(cammovey#)
if t=1 then camrotspeed#=0.05
if t=2 then camrotspeed#=0.1
if t=3 then camrotspeed#=0.15
if t=4 then camrotspeed#=0.2
if t>=5 then camrotspeed#=0.25
if plrzoomin#>0 then camrotspeed#=camrotspeed#/plrzoomin#

rem Control camera view (even when no health)
camangx#=camera angle x()+((cammovey#*camrotspeed#))
camangy#=camera angle y()+((cammovex#*camrotspeed#))
rem FPSXCV104RC5 - zoom mode wobble based on accuracy
if plrzoomin#<>0.0
 plrzoomaccuracyangle#=wrapvalue(plrzoomaccuracyangle#+((2+rnd(4)+(11-plrzoomin#))/10.0))
 camangx#=camangx#+cos(plrzoomaccuracyangle#*2.0)*plrzoomaccuracy#*plrzoomin#*0.008*(sin(plrzoomaccuracyangle#)*1.2)
 camangy#=camangy#+sin(plrzoomaccuracyangle#*4.0)*plrzoomaccuracy#*plrzoomin#*0.005
endif
camangxweight#=85*cameradampen#
if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<360-camangxweight# then camangx#=camangxweight#*-1

rem used to swoosh to an angle (picking up object off-center)
if camturntofacemode>0
 camangy#=curveangle(camturntoface#,camangy#,10.0)
 dec camturntofacemode
endif

rem final camera rotation update
rotate camera camangx#,camangy#,camera angle z()

rem Mark player position in viscolmap
gosub _ode_mark

rem leave a trial for any enemies to follow
trailaction=0 : trailx#=camerapositionx : traily#=camerapositiony-phyeyeheight# : trailz#=camerapositionz
gosub _player_leavetrail

rem apply a visual adjustment to camera
if player(plrid).health>0 and peeklean#<>0.0
 peekadjx#=newxvalue(0,camera angle y(0)+90,peeklean#)
 peekadjz#=newzvalue(0,camera angle y(0)+90,peeklean#)
 if static raycast(camerapositionx,camerapositiony,camerapositionz,camerapositionx+peekadjx#,camerapositiony,camerapositionz+peekadjz#)=0
  camerapositionx=camerapositionx+peekadjx#
  camerapositionz=camerapositionz+peekadjz#
 else
  peekfreeze=1
 endif
endif

rem if sharp upward velocity (20+), and not jump
if jumpaction=0
 if camvely#>10
  rem ensure it is dampened so small floor features not send player high (window/door sills,etc)
  camvely#=10.0
 endif
endif

rem if borble ever leaves camera vicinity (ODE bug) restore
if physicsplayerborble>0
 if physicsdebug=1
  print "camera"
  print "x=";camerapositionx
  print "y=";camerapositiony
  print "z=";camerapositionz
  print
 endif
 if object exist(physicsplayerborble)=1
  if physicsdebug=1
   print "borble"
   print "x=";object position x(physicsplayerborble)
   print "y=";object position y(physicsplayerborble)
   print "z=";object position z(physicsplayerborble)
   print
   print "volume"
   print "x=";ctx#
   print "y=";cty#
   print "z=";ctz#
   print
  endif
  tborbdistx#=abs(object position x(physicsplayerborble)-camerapositionx)
  tborbdisty#=abs(object position y(physicsplayerborble)-camerapositiony)
  tborbdistz#=abs(object position z(physicsplayerborble)-camerapositionz)
  tborbdist1#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  if physicsdebug=1
   print "borble distance=";tborbdist1#
  endif
  tborbdistx#=abs(ctx#-camerapositionx)
  tborbdisty#=abs(cty#-camerapositiony)
  tborbdistz#=abs(ctz#-camerapositionz)
  tborbdist2#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  if physicsdebug=1
   print "volume distance=";tborbdist2#
  endif
  if tborbdist1#>100 or tborbdist2#>100
   if physicsdebug=1
    print "Camera seperated from collision system"
   endif
  endif
 endif
endif

rem apply new velocities for future movement
if player(plrid).health>0
 rem cap these velocities to prevent borble fling away
 if camvelx#<-60 then camvelx#=-60
 if camvelx#>60 then camvelx#=60
 if camvely#<-60 then camvely#=-60
 if camvely#>60 then camvely#=60
 if camvelz#<-60 then camvelz#=-60
 if camvelz#>60 then camvelz#=60
 ode set linear velocity physicsplayerborble,camvelx#,camvely#,camvelz#
 ode set angular velocity physicsplayerborble,0,0,0
else
 rem ensures player does not slide away after died
 ode set linear velocity physicsplayerborble,0,0,0
 ode set angular velocity physicsplayerborble,0,0,0
endif

rem calculate some simply shake movement
camshakey#=0.0
if abs(camshake#)<>0
 camshakedir=1-camshakedir
 if camshakedir=0
  camshakey#=camshakey#+camshake#
 else
  camshakey#=camshakey#-camshake#
 endif
 if abs(camshake#)<1.0
  camshake#=0.0
 else
  camshake#=camshake#*0.9
 endif
endif

rem arena-eyes adjustment
if gmultiplayergame=1
 if crouchmode=0
  arenaadjustd#=-5.0
 else
  arenaadjustd#=2.0
 endif
else
 arenaadjustd#=0
endif
if movement<>0
 camerawobble#=wrapvalue(camerawobble#+24.0)
 if (plrkeySHIFT)=1
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.50)
 else
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.25)
 endif
else
 arenaadjust#=curvevalue(arenaadjustd#,arenaadjust#,5.0)
 camerawobble#=0.0
endif

rem finally update camera with smoothing (cty# is absolute staticvolume camypos)
finalcamy#=curvevalue(camerapositiony,camera position y(),2.0)
if finalcamy#>cty#-8 then finalcamy#=cty#-8
if playersystemdisabled=0
 position camera curvevalue(camerapositionx,camera position x(),2.0),finalcamy#+arenaadjust#+(camshakey#/10.0),curvevalue(camerapositionz,camera position z(),2.0)
endif

rem update listener
gosub _ode_listener

return

_ode_listener:
 `
 rem handle player with affecting listener properties (full CPU intense)
 if 0
  position listener camera position x(0)/10.0,camera position y(0)/10.0,camera position z(0)/10.0
  rotate listener 0,camera angle y(0),0
 else
  rem quick approx. of listener position (CPU friendly)
  roughx=camera position x(0)/10.0 : roughx=(roughx/5)*5
  roughy=camera position y(0)/10.0 : roughy=(roughy/5)*5
  roughz=camera position z(0)/10.0 : roughz=(roughz/5)*5
  if roughx<>lastroughx or roughy<>lastroughy or roughz<>lastroughz
   lastroughx=roughx : lastroughy=roughy : lastroughz=roughz
   position listener roughx,roughy,roughz
  endif
  `rotate listener 0,camera angle y(0),0  `want my rotspeed back!
  roughaa=camera angle y(0)/45.0
  if roughaa<>lastroughaa
   rotate listener 0,roughaa*45,0
   lastroughaa=roughaa
  endif
 endif
 `
return

_ode_playerpickup:

rem Track which object closest
tclosestpickable=0
if tclosestpickable=0
 bestdst#=99999.9 : bestay#=360 : beste=0
 for e=1 to entityelementmax
  if entityelement(e).eleprof.physics=1 and entityelement(e).active=1
   tobj=entityelement(e).obj
   if tobj>0
    if object exist(tobj)=1
     tdx#=object position x(tobj)-camerapositionx
     tdy#=(object position y(tobj)+(object size(tobj)/2))-camerapositiony
     tdz#=object position z(tobj)-camerapositionz
     td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     tda#=wrapvalue(atanfull(tdx#,tdz#)-camera angle y())
     tday#=wrapvalue(atanfull(tdy#,td#)+camera angle x())
     if tda#>180 then tda#=360-tda#
     if tday#>180 then tday#=360-tday#
     if tda#<15 and tday#<70
      if td#<camerareachmax#
       if entityelement(e).eleprof.phyweight<cameracarryweight#
        if tday#<bestay#
         bestdst#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
         minsize#=25.0+(object size(tobj)/2)
         if bestdst#<minsize# then bestdst#=minsize#
         bestay#=tday# : beste=e : bestang#=atanfull(tdx#,tdz#)
        endif
       endif
      endif
     endif
    endif
   endif
  endif
 next e
 if beste>0
  tclosestpickable=beste
 endif
endif

rem PLR pickup/drop/throw
if camerapickup=1
 if keystate(20)=1 or mouseclick()=2
  if camerapickupkeyrelease=0
   camerapickupkeyrelease=1
   if camerapicked=0
    if tclosestpickable>0
     `
     rem if object being stood on
     bendarm#=0 : armretract#=0
     if camerastoodonphyobj=entityelement(beste).obj
      rem try to push object away - can eventually pick it up
      thx#=newxvalue(0,camera angle y(),10.0)
      thy#=ode get body linear velocity y(entityelement(beste).obj)
      thz#=newzvalue(0,camera angle y(),10.0)
      ode set linear velocity entityelement(beste).obj,thx#,thy#,thz#
      rem this kicks the object forward to grab it again
      camerapickupkeyrelease=0
      rem realise player might fall - use gravity again
      physuspendgravity=0 : camforcey#=5.0
     else
      rem if not, pick up the object
      camerareach#=bestdst#
      camturntofacemode=5 : camturntoface#=bestang#
      camerapickedangle#=camturntoface#
      camerapickede=beste : camerapicked=entityelement(camerapickede).obj
      ode set body rotation camerapicked,-1,-1,-1 : rem special hack to reset GRAB rotation matrix feature
      ode set body rotation camerapicked,0,0,0
      if cameradampenactive=1
       rem if player must slow down when carrying, dampen is the factor
       cameradampen#=cameracarryweight#/entityelement(camerapickede).eleprof.phyweight
       if cameradampen#<0.1 then cameradampen#=0.1
       if cameradampen#>1.0 then cameradampen#=1.0
      endif
      rem put weapon away
      if gunid<>0 then gunmode=31 : gunselectionafterhide=0
      rem object reduces mess so not pushing other objects around (inc player)
      ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight/10.0
      rem player takes on mass of object
      ode set body mass physicsplayerborble,physicsplayerweight#+entityelement(camerapickede).eleprof.phyweight
      rem ensure new shadow depth created for object that needs to cast 75.depth area
      shadowobj(camerapicked)=2
     endif
     `
    endif
   else
    camerapickeddrop=1
   endif
  endif
 else
  camerapickupkeyrelease=0
 endif
endif
rem if anything hides it, drop it
if camerapicked>0
 if object visible(camerapicked)=0
  camerapickedthrown=0
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif
if camerapicked>0
 rem work out difference between actual and ideal position
 tdx#=holdx#-object position x(camerapicked)
 tdy#=(holdy#-object position y(camerapicked))-0.75
 tdz#=holdz#-object position z(camerapicked)
 tdd1#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
 rem and work out movement of item by mouse
 tdx#=abs(holdx#-lastholdx#)
 tdy#=abs(holdy#-lastholdy#)
 tdz#=abs(holdz#-lastholdz#)
 tdd2#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
 tmv#=curvevalue(tdd2#,tmv#,10.0)
 if cameraholding=1
  rem if confirmed as carrying
  tdx1#=holdx#-camera position x()
  tdy1#=holdy#-camera position y()
  tdz1#=holdz#-camera position z()
  tdx2#=object position x(camerapicked)-camera position x()
  tdy2#=object position y(camerapicked)-camera position y()
  tdz2#=object position z(camerapicked)-camera position z()
  rem work out difference in angles
  tbendarm1#=atanfull(tdx1#,tdz1#)
  tbendarm#=(atanfull(tdx2#,tdz2#)-tbendarm1#)
  if tdd1#>=2.0
   rem bend arm if resistance between actual and ideal
   if tmv#<1.0 then bendarm#=bendarm#+tbendarm#
   rem retract arm if stress greater than retraction value
   if tdd1#>armretract# then armretract#=tdd1#
  endif
  rem only once held, see if head inside item
  tamountinside#=object size(camerapicked)-sqrt(abs(tdx2#*tdx2#)+abs(tdy2#*tdy2#)+abs(tdz2#*tdz2#))
  if tamountinside#>0
   if tamountinside#>5 then tamountinside#=5
   if bendarm#<0.0
    bendarm#=bendarm#-(tamountinside#*2)
   else
    bendarm#=bendarm#+(tamountinside#*2)
   endif
  endif
 else
  rem confirm carrying?
  if tdd1#<8.0 then cameraholding=1
 endif
 rem retract arm if carry item into wall/obstacle
 bendreduce#=50.0
 if bendarm#<0 and cammovex#<0 then bendreduce#=50.0+(cammovex#*3)
 if bendarm#>0 and cammovex#>0 then bendreduce#=50.0-(cammovex#*3)
 if bendreduce#<1.0 then bendreduce#=1.0
 bendarm#=curvevalue(0,bendarm#,bendreduce#)
 armretract#=curvevalue(0,armretract#,50.0)
 rem carry
 holdangley#=camera angle y()+bendarm#
 lastholdx#=holdx# : lastholdy#=holdy# : lastholdz#=holdz#
 holdx#=newxvalue(camerapositionx,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
 holdy#=newxvalue(camerapositiony-(object size(camerapicked)/3.0),0-camera angle x(),(camerareach#+camerareachatrun#)-armretract#)-((entityelement(camerapickede).eleprof.phyweight/100.0)*(1.0-cameradampen#))
 holdz#=newzvalue(camerapositionz,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
 tangle#=wrapvalue(camera angle y()-camerapickedangle#)
 ode set body rotation camerapicked,0,tangle#,0
 bendspeed#=4.0
 tholdforcex#=(holdx#-object position x(camerapicked))*bendspeed#
 tholdforcey#=(holdy#-object position y(camerapicked))*bendspeed#
 tholdforcez#=(holdz#-object position z(camerapicked))*bendspeed#
 rem if arm is bend to far, drop item with zero velocity
 if abs(bendarm#)>50 then camerapickeddrop=1 : tholdforcex#=0 : tholdforcey#=0 : tholdforcez#=0
 ode set linear velocity camerapicked,tholdforcex#,tholdforcey#,tholdforcez#
 rem set shadow on carried object
 entityelement(camerapickede).floorposy=camerapositiony-(object size(camerapicked)*3)
 rem throw
 if mouseclick()=1 then camerapickeddrop=1 : camerapickedthrown=1
 rem drop
 if camerapickeddrop=1
  rem restore object and pickup states
  camerapickeddrop=0
  if camerapickedthrown=1
   rem calc throw distance, elevation and final velocity
   throwdistance#=(entityelement(camerapickede).eleprof.phyweight/1000.0)
   tthrowheight#=((camerathrowelev#+sin(camera angle x())*-100)/throwdistance#)
   throwdistance#=camerathrow#/throwdistance#
   taddx#=camvelx# : taddy#=camvely# : taddz#=camvelz#
   ode set linear velocity camerapicked, taddx#+sin(camera angle y())*throwdistance#,taddy#+tthrowheight#,taddz#+cos(camera angle y())*throwdistance#
   if entityelement(camerapickede).eleprof.rotatethrow<>0
    trotate#=entityelement(camerapickede).eleprof.rotatethrow
    ode set angular velocity camerapicked, ((rnd(1)*2.0)-1.0)*trotate#, 0, ((rnd(1)*2.0)-1.0)*trotate#
   endif
   rem reset throw
   camerapickedthrown=0
  endif
  rem restore object max
  ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight
  rem player restores mass
  ode set body mass physicsplayerborble,physicsplayerweight#
  rem reset final values for camera pickup
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif

return

_ode_sounds:
 `
 rem Collision with objects causes borble to change player position
 tgravitydefeatedbyphy=0
 while ODE COLLISION MESSAGE EXISTS()
  `
  rem collision event
  ODE COLLISION GET MESSAGE
  phya=ODE GET OBJECT A() : phyb=ODE GET OBJECT B()
  `
  rem player phyobject stood on another phy object
  tdownward#=0.0 : ttouchedobj=0 : toverallveldiff#=0
  if (phya=physicsplayerborble and phyb<>0) then tdownward#=ODE GET OBJECT A VELOCITY Y() : ttouchedobj=phyb : toverallveldiff#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y())+abs(ODE GET OBJECT B VELOCITY Z())
  if (phyb=physicsplayerborble and phya<>0) then tdownward#=ODE GET OBJECT B VELOCITY Y() : ttouchedobj=phya : toverallveldiff#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y())+abs(ODE GET OBJECT A VELOCITY Z())
  if ttouchedobj<>0 and ttouchedobj=camerapicked then lastttouchede=ttouchede
  if ttouchedobj<>0 and ttouchedobj<>camerapicked
   ttouchede=phyobjele(ttouchedobj)
   if ttouchede>0
    entid=entityelement(ttouchede).bankindex
    colmaterialtype=entityprofile(entid).materialindex-1
    if tdownward#<2.0
     rem player landed on physics object, so register this and use gravity again
     tgravitydefeatedbyphy=ttouchedobj
     tgravitydefeatedbyphye=ttouchede
     physuspendgravity=0
    endif
    ttspeedatwhichurt#=120.0
    if toverallveldiff#>ttspeedatwhichurt#
     if ttouchede<>lastttouchede
      rem player damage if entity moving at force (uses phyforcedamage)
      tdamage=((toverallveldiff#-ttspeedatwhichurt#)/10.0) : if tdamage<1 then tdamage=1
      magnifydamage#=entityelement(ttouchede).eleprof.phyforcedamage/100.0
      tdamage=tdamage*magnifydamage# : gosub _player_takedamage
      lastttouchede=ttouchede
     endif
    else
     rem object not hitting player any more
     if lastttouchede=ttouchede
      lastttouchede=0
     endif
    endif
   endif
  endif
  `
  rem sounds processd here too
  bangobj=0
  bangcontact=0
  phyvelocity#=0
  phytotalvelocity#=0
  phyhorizontalscrape=0
  if phya<>0
   bangobj=phya : bangotherobj=phyb
   phyvelocity#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y()/4)+abs(ODE GET OBJECT A VELOCITY Z())
   phyvelocity#=phyvelocity#+abs(ODE GET OBJECT A ANGULAR VELOCITY X())+abs(ODE GET OBJECT A ANGULAR VELOCITY Y())+abs(ODE GET OBJECT A ANGULAR VELOCITY Z())
   if bangobj<>physicsplayerborble
    bangcontact=ODE GET OBJECT A CONTACT()
    if bangcontact<>0
     phyfloorstop#=ODE GET OBJECT A VELOCITY Y()
     if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
      phyhorizontalscrape=1
     endif
     phylastfloorstop#(bangobj)=phyfloorstop#
    endif
   endif
   phyvelocitya#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocitya#=0
  endif
  if phyb<>0
   bangobj=phyb : bangotherobj=phya
   phyvelocity#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y()/4)+abs(ODE GET OBJECT B VELOCITY Z())
   phyvelocity#=phyvelocity#+abs(ODE GET OBJECT B ANGULAR VELOCITY X())+abs(ODE GET OBJECT B ANGULAR VELOCITY Y())+abs(ODE GET OBJECT B ANGULAR VELOCITY Z())
   if bangobj<>physicsplayerborble
    bangcontact=ODE GET OBJECT B CONTACT()
    if bangcontact<>0
     phyfloorstop#=ODE GET OBJECT B VELOCITY Y()
     if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
      phyhorizontalscrape=1
     endif
     phylastfloorstop#(bangobj)=phyfloorstop#
    endif
   endif
   phyvelocityb#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocityb#=0
  endif
  if bangobj<>0 and bangobj<>physicsplayerborble and bangobj<>camerapicked
   phyimpact#=abs(phyvelocity#-phyobjvelocity#(bangobj))
   phyimpactstop#=phyobjvelocity#(bangobj)-phyvelocity#
   phyobjvelocity#(bangobj)=phyvelocity#
   rem deal with damage of colliding objects
   phymagnitude#=0
   rem ensure player is not a damaging physics object (as stealth may require sliding along windows)
   e1=0 : e1m#=0
   if bangobj>0 and bangobj<>physicsplayerborble
    e1=phyobjele(bangobj) : if e>0 then e1m#=entityelement(e1).health*5
   endif
   e2=0 : e2m#=0
   if bangotherobj>0 and bangotherobj<>physicsplayerborble
    e2=phyobjele(bangotherobj) : if e2>0 then e2m#=entityelement(e2).health*5
   endif
   rem or very weak objects that will break under duress (duress caused by size and speed of fragile object)
   if e1m#>20 then e1m#=20
   if e2m#>20 then e2m#=20
   if bangcontact=1
    if phyvelocitya#>e1m# and e1>0 and entityelement(e1).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
    if phyvelocityb#>e2m# and e2>0 and entityelement(e2).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
   endif
   rem collision with raised velocity
   if phytotalvelocity#>20.0
    if phya<>0 and phyb<>0
     if bangobj=physicsplayerborble or bangotherobj=physicsplayerborble
      rem if window strength 1-4, player CAN smash it through by running into it
      if e1>0 and entityelement(e1).health>=5 then e1=0
      if e2>0 and entityelement(e2).health>=5 then e2=0
     endif
     rem only deal damage to immobile objects (as movable ones can get out the way before damage)
`     if e1>0 and entityelement(e1).eleprof.isimmobile=1 then e2=0 : phymagnitude#=object size(bangotherobj)
 `    if e2>0 and entityelement(e2).eleprof.isimmobile=1 then e1=0 : phymagnitude#=object size(bangobj)
     rem FPSCV104RC7 - moving entities CAN cause damage if damage force high enough
     if e1>0
      magnifydamage#=entityelement(e1).eleprof.phyforcedamage/12.0
      phymagnitude#=magnifydamage#
     endif
     if e2>0
      magnifydamage#=entityelement(e2).eleprof.phyforcedamage/12.0
      if magnifydamage#>phymagnitude#
       phymagnitude#=magnifydamage#
      endif
     endif
    endif
   endif
   `
   rem bangobj e
   e=phyobjele(bangobj)
   if e>0
    rem entity profile id
    entid=entityelement(e).bankindex
    rem only deal damage if neither object part of player-carry-collisio n
    if camerapicked>0 and (bangobj=camerapicked or bangotherobj=camerapicked)
     phymagnitude#=0.0
    endif
    rem only allow damage if other object is NOT a debris fragment
    if bangotherobj>0 and bangotherobj<=array count(phyobjele())
     if phyobjele(bangotherobj)=0 then phymagnitude#=0.0
    endif
    rem if magnitude high enough, cause damage
    if phymagnitude#>10.0
     rem damage both objects involved in impact
     tdamage=(phymagnitude#-10.0) : tdamagesource=0 : timpacttype=1
     if tdamage>2 and tdamagebybangcount=0
      rem entity damage here
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
      if e1>0 then e=e1 : entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
      if e2>0 then e=e2 : entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
     endif
     rem bangobj e refresh
     e=phyobjele(bangobj)
     entid=entityelement(e).bankindex
    endif
    rem deal with sound
    matindex=entityprofile(entid).materialindex-1
    if matindex>=0 and matindex<=gmaterialmax
     rem monitor travelling value
     ttravelled#=0.0
     if phyhorizontalscrape=1
      rem as long as no sudden stopping, continue travel value for scrape
      if bangobj=phya then ttravelled#=phyvelocitya#
      if bangobj=phyb then ttravelled#=phyvelocityb#
     endif
     rem impact controls volume
     tvol#=100 : rem (phyimpact#-1.0)*10.0 : if tvol#>100.0 then tvol#=100.0
     tspd#=material(matindex).freq+rnd(material(matindex).freq/10.0)
     sbase=0
     rem only play impact if slowed/stopped and was
     if phyimpactstop#>0 and phyimpact#>4.0
      sbase=material(matindex).impactid
     endif
     if ttravelled#>10.0
      if phylasttravelled#(bangobj)>10.0
       rem continuation of travel, switch to scrape
       sbase=material(matindex).scrapeid
       tvol#=ttravelled#*2.0 : if tvol#>100.0 then tvol#=100.0
      endif
     endif
     phylasttravelled#(bangobj)=ttravelled#
     rem play sound of material impact
     if sbase>0
      for tchannels=0 to 4
       s=sbase+tchannels
       if sound exist(s)=1
        if sound playing(s)=0 and phyobjsounding(bangobj)=0
         playinternalBC3dsound(s,object position x(bangobj),object position y(bangobj),object position z(bangobj),25.0)
         phyobjsounding(bangobj)=5
         set sound volume s,80.0+(tvol#*0.2)
         if tspd#>2000 then set sound speed s,tspd#
         exit
        endif
       endif
      next tchannels
     endif
    endif
    if phyimpact#>2.0
     rem adjust entity floor position (for shadow calc)
     entityelement(e).floorposy=object position y(bangobj)-(object size y(bangobj)/2)
     rem recalc adjustment for objects that must find the floor perfectly
     if entityelement(e).eleprof.physics=1
      centx#=ODE GET BODY ADJUSTMENT X(bangobj)
      centy#=ODE GET BODY ADJUSTMENT Y(bangobj)
      centz#=ODE GET BODY ADJUSTMENT Z(bangobj)
      tprofileobj=entityelement(e).profileobj
      offset limb bangobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
     endif
    endif
    if phyobjsounding(bangobj)>0 then phyobjsounding(bangobj)=phyobjsounding(bangobj)-1
   else
    rem physics object has no entity (can only be debris particle)
    if phya>0 and phya<physicsuniverseobj
     if object in screen(phya)=0
      rem remove from simulation if not in screen
      ode destroy object phya
      hide object phya
     endif
    endif
    if phyb>0 and phyb<physicsuniverseobj
     if object in screen(phyb)=0
      rem remove from simulation if not in screen
      ode destroy object phyb
      hide object phyb
     endif
    endif
    `
   endif
   `
  endif
  `
 endwhile
 `
 rem Reduce bang damage counter (so bang damage does not machine gun and drain all entity health)
 if tdamagebybangcount>0
  dec tdamagebybangcount
 endif
 `
 rem also handle shadows
 gosub _ode_shadowcontrol
 `
return

_ode_shadowcontrol:
 `
 rem for out of universe error if no debug cursor reset
 if physicsdebug=0 then set cursor 0,0
 `
 rem adjust shadows of all physics objects
 for e=1 to entityelementmax
  tobj=entityelement(e).obj
  tflag=0
  tentid=entityelement(e).bankindex
  if entityelement(e).eleprof.physics=1 and tobj>0 then tflag=1
`  if gdynamicshadowsstate=1 and entityelement(e).eleprof.castshadow=1
  if tflag=1
   `
   rem activate object shadow (if camera can see its floor)
   if entityprofile(tentid).ischaracter=1 then tflag=0
   if tflag=1
    if gdynamicshadowsstate>0
     if shadowobj(tobj)=2
      rem reset shadow for carrying
      shadowobj(tobj)=0
     endif
     if shadowobj(tobj)=0
      if camerapositiony>entityelement(e).floorposy
       if object size z(tobj)<0.1
        rem ultra thin objects (glass) cannot cast shadow yet
       else
        tobjshadowreach#=ode get body height(tobj)
        if camerapicked=tobj
         rem the 75 is for when carrying the object
         tobjshadowreach#=tobjshadowreach#+75
        else
         rem the 4.5 is for the very top of objects to find and penetrate the floor (min thickness 5.0 units)
         tobjshadowreach#=tobjshadowreach#+4.5
        endif
        set shadow shading off tobj
        set shadow shading on tobj,-1,tobjshadowreach#,gdynamicshadowsstate-1
        shadowobj(tobj)=1
       endif
      endif
     endif
     if shadowobj(tobj)=1
      if camerapositiony<entityelement(e).floorposy
       rem keep self-shadow by switching off, then on but with small non-intrusive range
       set shadow shading off tobj
       set shadow shading on tobj,-1,1.0,gdynamicshadowsstate-1
       shadowobj(tobj)=0
      endif
     endif
    endif
   endif
   `
   rem if object needs destroying, do it here
   if phyobjremove(tobj)<>0
    rem used when want to disturb another phy obj (ie move up slightly, then remove on next pass)
    if phyobjremove(tobj)=1
     rem this will nudge anything sitting on obj
     ode set linear velocity phyobjremove(tobj),0,10,0
     phyobjremove(tobj)=2
    else
     if phyobjremove(tobj)=2
      rem this will nudge anything sitting on obj further
      ode set linear velocity phyobjremove(tobj),0,5,0
      phyobjremove(tobj)=3
     else
      rem this finally removes the phy obj from the simulation
      gosub _ode_switchoffe
      phyobjremove(tobj)=0
      rem and then hide the object if not already hidden
      hide object tobj
     endif
    endif
   endif
   `
   rem serious error, object has left the universe (through hole in geom!)
   if showfpsinrealgame=2
    if object position y(tobj)<-20
     position object tobj,object position x(tobj),-25,object position z(tobj)
     print "Object ";e;entityelement(e).eleprof.name$;" has left the universe at ";str$(int(object position x(tobj)));",";str$(int(object position z(tobj)))
    endif
   endif
   `
  endif
 next e
 `
return

_ode_applyforce:
 `
 rem takes todee,tdx#,tdy#,tdz#,todeforce#,todefalloff#,tpx#,tpy#,tpz#
 tobj=entityelement(todee).obj
 if tobj>0
  td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
  tdx#=tdx#/td# : tdy#=tdy#/td# : tdz#=tdz#/td#
  todeforce#=todeforce#*10.0 : rem equate to non-physics force
  tbulletforce#=(todeforce#/500.0)*(500.0-td#)*todefalloff#
  tbulletforce#=tbulletforce#+(todeforce#*(1.0-todefalloff#))
  massconsideration#=entityelement(todee).eleprof.phyweight/200.0
  if massconsideration#<1.0 then massconsideration#=1.0
  tbulletforce#=tbulletforce#/massconsideration#
  tdx#=tdx#*tbulletforce#
  tdy#=tdy#*tbulletforce#
  tdz#=tdz#*tbulletforce#
  rem limit force to size of object units of velocity (max)
  if object size(tobj)<21
   tmax#=20.0+((object size(tobj)/21.0)*40.0)
  else
   tmax#=60.0
  endif
  ttt#=(abs(tdx#)+abs(tdy#)+abs(tdz#))/3.0
  if ttt#>tmax# then ttt#=ttt#/tmax# else ttt#=1.0
  tdx#=tdx#/ttt# : tdy#=tdy#/ttt# : tdz#=tdz#/ttt#
  if twithpointforce=1
   ode add force tobj,tdx#,tdy#,tdz#,tpx#,tpy#,tpz#
  else
   tda#=atanfull(tdx#,tdz#)
   ode set linear velocity tobj,tdx#,tdy#,tdz#
   tspinforce#=tbulletforce#/50.0
   ode set angular velocity tobj,sin(tda#)*(10*tspinforce#),0,cos(tda#)*(10*tspinforce#)
  endif
 endif
 `
return

_ode_applypointforce:
 `
 rem apply point force (tpx#,tpy#,tpz#)
 twithpointforce=1
 gosub _ode_applyforce
 `
return

_ode_entitydrivenphysics:
 `
 rem use entity data to drive object via physics (character)
 todeobj=entityelement(todee).obj
 tmvx#=entityelement(todee).x-object position x(todeobj)
 todeentid=entityelement(todee).bankindex
 tmvszy#=(object size y(todeobj)/2)*(entityprofile(todeentid).scale/100.0)
 tmvy#=(entityelement(todee).y+tmvszy#+thover#)-object position y(todeobj)
 tmvz#=entityelement(todee).z-object position z(todeobj)
 tstress#=sqrt(abs(tmvx#)+abs(tmvy#)+abs(tmvz#))
 ode set linear velocity todeobj,tmvx#*4,tmvy#*4,tmvz#*4
 if entityelement(todee).norotate=0
  ode set body rotation todeobj,0,entityelement(todee).ry,0
 else
  ode set body rotation todeobj,0,0,0
 endif
 `
return

_ode_entitydrivenstaticphysics:
 `
 rem as above but for the pseudo-static objects (door/window)
 todeobj=entityelement(todee).obj
 if entityelement(todee).norotate=0
  ode set body rotation todeobj,0,entityelement(todee).ry,0
 else
  ode set body rotation todeobj,0,0,0
 endif
 `
return

_ode_update:
 `
 rem debug info on entities
 if physicsdebug=1
  for e=1 to entityelementmax
   if entityelement(e).active=1
    if entityelement(e).eleprof.physics<>0
     tobj=entityelement(e).obj
     if tobj>0
      if object exist(tobj)=1
       if object in screen(tobj)=1
        center text object screen x(tobj),object screen y(tobj),"size="+str$(object size(tobj))
        center text object screen x(tobj),object screen y(tobj)+16,"weight="+str$(entityelement(e).eleprof.phyweight)
        if e=tclosestpickable
         center text object screen x(tobj),object screen y(tobj)-16,"CLOSEST="+str$(camerareach#)
        endif
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 `
 rem update physics
 for phy=1 to 2 : ode update : next phy
 `
 rem for next run - debug readouts
 if physicsdebug=1 then set cursor 0,0
 `
return

rem
rem Particles (debris, fragments, particles, damage)
rem

_part_init:

rem Setup particles
gosub _part_initexploders

rem Setup fragment objects

rem SCIFI
rem Crate
debrisshapeindex=1
i=debrisshapeindex
bitdetails(debrisshapeindex).max=6
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cratec\crate_c"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=-15
bitoffset(i,3).x#=15 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=0
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=15
bitoffset(i,5).x#=-15 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=0
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=30 : bitoffset(i,6).z#=0
rem Gas Canister
debrisshapeindex=2
i=debrisshapeindex
bitdetails(debrisshapeindex).max=2
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cylindera\cylinder_a"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=24 : bitoffset(i,2).z#=0
rem Cylinder
debrisshapeindex=3
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cylinderb\cylinder_b"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=3 : bitoffset(i,2).y#=17 : bitoffset(i,2).z#=6
bitoffset(i,3).x#=-8 : bitoffset(i,3).y#=17 : bitoffset(i,3).z#=3
bitoffset(i,4).x#=-3 : bitoffset(i,4).y#=17 : bitoffset(i,4).z#=-8
bitoffset(i,5).x#=8 : bitoffset(i,5).y#=17 : bitoffset(i,5).z#=-5
`
rem WW2
rem Bottle
debrisshapeindex=4
i=debrisshapeindex
bitdetails(debrisshapeindex).max=3
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\itemb\item_b"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=7 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=14 : bitoffset(i,3).z#=0
rem CrateC
debrisshapeindex=5
i=debrisshapeindex
bitdetails(debrisshapeindex).max=7
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratec\crate_c"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=-15 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=-15
bitoffset(i,4).x#=15 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=0
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=15
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=15 : bitoffset(i,6).z#=15
bitoffset(i,7).x#=0 : bitoffset(i,7).y#=30 : bitoffset(i,7).z#=0
rem CrateE
debrisshapeindex=6
i=debrisshapeindex
bitdetails(debrisshapeindex).max=6
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratee\crate_e"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=-15 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=-15
bitoffset(i,4).x#=15 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=0
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=15
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=30 : bitoffset(i,6).z#=0
rem CrateF
debrisshapeindex=7
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratef\crate_f"
bitoffset(i,1).x#=-16 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=-11
bitoffset(i,2).x#=-16 : bitoffset(i,2).y#=2 : bitoffset(i,2).z#=6
bitoffset(i,3).x#=16 : bitoffset(i,3).y#=1 : bitoffset(i,3).z#=0
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=10 : bitoffset(i,4).z#=2
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=5 : bitoffset(i,5).z#=-4
rem CylinderF
debrisshapeindex=8
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cylinderf\cylinder_f"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=12 : bitoffset(i,2).z#=-6
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=13 : bitoffset(i,3).z#=5
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=24 : bitoffset(i,4).z#=-10
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=24 : bitoffset(i,5).z#=8

rem Load the fragment objects (three sets of each)
fragmento=fragmentobjectoffset
for debrisshapeindex=1 to 8
 `
 rem use original to get fragment complete size
 o$=bitdetails(debrisshapeindex).file$+".x"
 addfiletocollection(o$)
 load object o$,fragmento
 bitdetails(debrisshapeindex).sizex=object size x(fragmento)
 bitdetails(debrisshapeindex).sizey=object size y(fragmento)
 bitdetails(debrisshapeindex).sizez=object size z(fragmento)
 delete object fragmento
 `
 rem mark start of fragment objects sequence (seeder,3xallfragments)
 bitdetails(debrisshapeindex).fragmentobjstart=fragmento
 `
 rem create object seeder
 make object cone fragmento,10
 make mesh from object fragmento,fragmento
 for o=1 to 8 : add limb fragmento,o,fragmento : next o
 delete mesh fragmento
 hide object fragmento
 inc fragmento
 `
 rem load original
 for o=1 to bitdetails(debrisshapeindex).max
  o$=bitdetails(debrisshapeindex).file$+"_chunk"+str$(o)+".x"
  addfiletocollection(o$)
  load object o$,fragmento
  hide object fragmento
  inc fragmento
 next o
 `
 rem instance two more sets
 for n=1 to 2
  for o=1 to bitdetails(debrisshapeindex).max
   fragmentorig=bitdetails(debrisshapeindex).fragmentobjstart+1+(o-1)
   clone object fragmento,fragmentorig
   hide object fragmento
   inc fragmento
  next o
 next n
 `
next debrisshapeindex
fragmentobjectoffsetmax=fragmento-1

return

_part_free:
 `
 rem Delete particles and fragments
 for o=fragmentobjectoffset to fragmentobjectoffsetmax
  if object exist(o)=1
   ode destroy object o
   rem V105 delete object o
  endif
 next o
 `
 rem V106 RC3 quicker this way
 delete objects fragmentobjectoffset,fragmentobjectoffsetmax
 `
 rem Delete explosion objects
 gosub _part_freeexploders
 `
return

_part_movedebrisifinray:
 `
 rem ray is x1#,y1#,z1#,wallhitx#,wallhity#,wallhitz#
 for o=fragmentobjectoffset to fragmentobjectoffsetmax
  if object visible(o)=1
   if intersect object(o,x1#,y1#,z1#,wallhitx#,wallhity#,wallhitz#)<>0
    tix#=wallhitx#-x1# : tiy#=wallhity#-y1# : tiz#=wallhitz#-z1#
    tnorm#=(abs(tix#)+abs(tiy#)+abs(tiz#))/3.0
    tix#=tix#/tnorm# : tiy#=tiy#/tnorm# : tiz#=tiz#/tnorm#
    ode set linear velocity o,tix#*tforce#,tiy#*tforce#,tiz#*tforce#
   endif
  endif
 next o
 `
return

_part_createfragment:
 `
 rem takes debrisshapeindex,frox,y,z,a#,debrissize,x,y,z# (and new froobjtocopy)
 debrisscalex#=(debrissizex#/bitdetails(debrisshapeindex).sizex)*100.0
 debrisscaley#=(debrissizey#/bitdetails(debrisshapeindex).sizey)*100.0
 debrisscalez#=(debrissizez#/bitdetails(debrisshapeindex).sizez)*100.0
 `
 rem seeder obj placement
 frbo=bitdetails(debrisshapeindex).fragmentobjstart
 position object frbo,frox#,froy#,froz#
 `yrotate object frbo,froa#
 set object to object orientation frbo,frocopyorientfrom
 scale object frbo,debrisscalex#,debrisscaley#,debrisscalez#
 `
 rem cycle through fragment instances (3 copies avail)
 fragmentchoose=bitdetails(debrisshapeindex).choice+1
 if fragmentchoose>2 then fragmentchoose=0
 bitdetails(debrisshapeindex).choice=fragmentchoose
 fragmentchoose=fragmentchoose*bitdetails(debrisshapeindex).max
 `
 rem place fragments using seeder limbs
 frchi=bitdetails(debrisshapeindex).choice
 stparte=e : stparttobj=tobj
 for o=1 to bitdetails(debrisshapeindex).max
  fragmento=bitdetails(debrisshapeindex).fragmentobjstart+1+(o-1)+fragmentchoose
  ode destroy object fragmento
  tfx#=bitoffset(debrisshapeindex,o).x#
  tfy#=bitoffset(debrisshapeindex,o).y#
  tfz#=bitoffset(debrisshapeindex,o).z#
  offset limb frbo,o,tfx#,tfy#,tfz#
  position object fragmento,limb position x(frbo,o),limb position y(frbo,o),limb position z(frbo,o)
  rotate object fragmento,limb direction x(frbo,o),limb direction y(frbo,o),limb direction z(frbo,o)
  rem maybe a scale of *0.9 will reduce fling-away effect
  scale object fragmento,debrisscalex#*0.8,debrisscaley#*0.8,debrisscalez#*0.8
  select bitdetails(debrisshapeindex).collisionmode
   case 2 : ode create dynamic box fragmento : endcase
   case 3 : ode create dynamic cylinder fragmento : endcase
   case 4 : ode create dynamic sphere fragmento : endcase
  endselect
  ode set contact fdir1 fragmento,50
  ode set body mass fragmento,10
  if debrisexplodable=1
   ode add force fragmento,0,-1,0,object position x(fragmento),object position y(fragmento)+object size y(fragmento),object position z(fragmento)
   ode set angular velocity fragmento,2.5+rnd(10)/10.0,1.5+rnd(5)/10.0,rnd(2)/10.0
  else
   ode set linear velocity fragmento,0,-20,0
   ode set angular velocity fragmento,0,0,0
  endif
  texture object fragmento,debristextureused
  if debrisexplodable=1
   set blend mapping on fragmento, 1, explosionscorch, 3, 6
  else
   set blend mapping on fragmento, 1, explosionstressed, 3, 7
  endif
  tobj=fragmento : e=0
  gosub _ode_ensurephysicsobjvalid
  show object fragmento
 next o
 e=stparte : tobj=stparttobj
 `
return

_part_initexploders:
 `
 rem Load spark, fire and smoke
 tfile$="gamecore\debris\spark.tga" : explodedecalspark=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\fire.tga" : explodedecalfire=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\smoke.tga" : explodedecalsmoke=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\scorched.tga" : explosionscorch=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\stressed.tga" : explosionstressed=loadinternalimagecompressquality(tfile$,5,1)
 `
 rem Create Explosion Decals
 texplodersnd=1
 o=explodedecalobjstart
 tsndid=explodesoundoffset
 for exploderindex=1 to explodermax
  `
  rem Set vars and load sound
  exploder(exploderindex).obj=o
  exploder(exploderindex).explode=0
  tfile$="gamecore\debris\explosionfuel"+str$(texplodersnd)+".wav" : addfiletocollection(tfile$)
  inc texplodersnd : if texplodersnd>5 then texplodersnd=1
  load sound tfile$,tsndid
  exploder(exploderindex).explodesound=tsndid
  inc tsndid
  `
  for oi=0 to 16
   make object plain o,100,100
   if oi=0 then texture object o,explodedecalspark
   if oi>=1 and oi<=3 then texture object o,explodedecalfire
   if oi>=4 then texture object o,explodedecalsmoke
   set object transparency o,2
   disable object zwrite o
   hide object o
   inc o
  next oi
 next exploderindex
 explodedecalobjmax=o-1
 explodesoundmax=tsndid-1
 `
return

_part_freeexploders:
 `
 rem Delete Explosion Decals
 for o=explodedecalobjstart to explodedecalobjmax
  if object exist(o)=1
   ode destroy object o
   rem V105 delete object o
  endif
 next o
 `
 rem V106 RC3 quicker this way
 delete objects explodedecalobjstart,explodedecalobjmax
 `
 rem Delete sounds
 for tsndid=explodesoundoffset to explodesoundmax
  if sound exist(tsndid)=1
   delete sound tsndid
  endif
 next tsndid
 `
return

_part_triggerexplosion:
 `
 rem Find free exploder
 for exploderindex=1 to explodermax
  if exploder(exploderindex).explode=0 then exit
 next exploderindex
 if exploderindex<explodermax
  rem visual
  exploder(exploderindex).explode=1
  exploder(exploderindex).x=frox#
  exploder(exploderindex).y=froy#
  exploder(exploderindex).z=froz#
  rem audio
  ts=exploder(exploderindex).explodesound
  if sound exist(ts)=1
   rem make explosion X times larger (ie closer)
   tscamx#=camera position x(0)
   tscamy#=camera position y(0)
   tscamz#=camera position z(0)
   tscamx#=(frox#-tscamx#)
   tscamy#=(froy#-tscamy#)
   tscamz#=(froz#-tscamz#)
   tvol=100-(sqrt(abs(tscamx#*tscamx#)+abs(tscamy#*tscamy#)+abs(tscamz#*tscamz#))/200.0)
   if tvol<0 then tvol=0
   if tvol>100 then tvol=100
   broadcast3dsound(frox#,froy#,froz#,100.0)
   set sound volume ts,tvol
   play sound ts
  endif
 endif
 `
return

_part_controlexploders:
 `
 rem Handle all explosions in progress
 for exploderindex=1 to explodermax
  select exploder(exploderindex).explode
   case 1:
    o=exploder(exploderindex).obj
    show object o+0 : position object o+0,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+1 : position object o+1,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+2 : position object o+2,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+3 : position object o+3,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    for oi=4 to 13
     o=exploder(exploderindex).obj+oi
     position object o,exploder(exploderindex).x+(cos(((o-5)*20)-180)*50),exploder(exploderindex).y+((sin(((o-5)*20)-180)*20)),exploder(exploderindex).z
     scale object o,25+rnd(25),25+rnd(25),25+rnd(25)
     zrotate object o,rnd(360)
     show object o
    next oi
    for oi=14 to 16
     o=exploder(exploderindex).obj+oi
     position object o,exploder(exploderindex).x+(cos(((o-15)*20)-180)*25),exploder(exploderindex).y+rnd(10),exploder(exploderindex).z
     scale object o,50+rnd(50),50+rnd(50),50+rnd(50)
     zrotate object o,rnd(360)
     show object o
    next oi
    for oi=0 to 16
     o=exploder(exploderindex).obj+oi
     point object o,camera position x(),camera position y(),camera position z()
     move object o,20 : rem get out of flat wall
    next oi
    exploder(exploderindex).explode=2
    exploder(exploderindex).dist#=15
    exploder(exploderindex).smoke#=0
    exploder(exploderindex).fade#=100
   endcase
  endselect
  if exploder(exploderindex).explode>0
   rem flash
   exploder(exploderindex).fade#=exploder(exploderindex).fade#-10
   if exploder(exploderindex).fade#<1 then exploder(exploderindex).fade#=0
   sparkfade#=100-((90-exploder(exploderindex).fade#)*40)
   if sparkfade#<0 then sparkfade#=0
   if sparkfade#>100 then sparkfade#=100
   set alpha mapping on exploder(exploderindex).obj+0,sparkfade#
   set alpha mapping on exploder(exploderindex).obj+1,exploder(exploderindex).fade#/1.1 : s#=120+(25-(exploder(exploderindex).fade#/4))
   scale object exploder(exploderindex).obj+1,s#,s#,s#
   set alpha mapping on exploder(exploderindex).obj+2,exploder(exploderindex).fade#/1.5 : s#=100+(25-(exploder(exploderindex).fade#/4))
   scale object exploder(exploderindex).obj+2,s#,s#,s#
   set alpha mapping on exploder(exploderindex).obj+3,exploder(exploderindex).fade#/2.0 : s#=80+(25-(exploder(exploderindex).fade#/4))
   scale object exploder(exploderindex).obj+3,s#,s#,s#
   rem smoke
   exploder(exploderindex).dist#=exploder(exploderindex).dist#+0.1
   exploder(exploderindex).smoke#=exploder(exploderindex).smoke#+2.0
   if exploder(exploderindex).smoke#>=100
    for oi=0 to 16
     o=exploder(exploderindex).obj+oi
     hide object o
    next oi
    exploder(exploderindex).explode=0
   else
    for oi=4 to 16
     o=exploder(exploderindex).obj+oi
     if oi>=14 then up#=0.3 else up#=0.05
     position object o,object position x(o),object position y(o)+up#,object position z(o)
     set alpha mapping on o,100.0-exploder(exploderindex).smoke#
    next oi
   endif
  endif
 next exploderindex
 `
return

rem
rem MULTIPLAYER
rem

`
` Init
`
_multi_earlyinit:
 `
 rem Validate playername here
 for c=1 to len(playername$)
  if c>1 and asc(mid$(playername$,c))=10 or asc(mid$(playername$,c))=13
   playername$=left$(playername$,c-1)
   exit
  endif
 next c
 `
 rem Used to get Network Detect and Firewall permission as soon as possible
 if createorjoin=1
  rem create a tcp server
  MULTIPLAYER CREATE TCP SERVER servername$
  if glocalserveroverride$=""
   rem FPSCV105RC2 - use already validated server IP address
   `ipaddress$=MULTIPLAYER GET IP ADDRESS() ` sometimes returned local or router IP (no good)
   `for c=1 to len(ipaddress$)
   ` if mid$(ipaddress$,c)=":" then ipaddress$=left$(ipaddress$,c-1) : exit
   `next c
   ipaddress$=serveripaddress$
  else
   ipaddress$=glocalserveroverride$
  endif
  rem add to gamelist
  addip$=ipaddress$
  addname$=playername$
  gosub _ai_gamelist_add
 else
  rem join a tcp server
  MULTIPLAYER CONNECT TO TCP SERVER playername$, ipaddress$
 endif
 `
 rem Create Deadreckoning vectors
 for t=10+0 to 10+(16*5) : r=make vector3(t) : next t
 `
 rem Memblock allocations for vary-byte tranfser
 mb_move=101 : make memblock mb_move, 48
 mb_write=102 : make memblock mb_write, 48
 `
return

_multi_assetloader:
 `
 rem Load talk sound ping
 talkpingsound=loadinternalsoundcore("audiobank\misc\talkping.wav",0)
 lastplayedtalkindex=talkindex
 `
return

_multi_start:
 `
 rem optional visuals
 if createorjoin=1
  if left$(ipaddress$,8)="192.168."
   set window title strarr$(632)+" ["+ipaddress$+"] "+strarr$(633)
  else
   set window title strarr$(632)+" ["+ipaddress$+"] "+strarr$(634)
  endif
 else
  set window title playername$+" ["+ipaddress$+"]"
 endif
 `
 rem Scan all start positions of characters (these will be the respawn points)
 gosub _multi_initrespawnarray
 `
 rem parts that are re-called if game session is repeated
 gosub _multi_restart
 `
return

_multi_restartprepare:
 `
 rem hide all characters initially in MP game
 for e=1 to entityelementmax
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1
   entityelement(e).active=0
   entityelement(e).dormant=1
   entityelement(e).eleprof.cantakeweapon=0
   obj=entityelement(e).profileobj
   if obj>0
    if object exist(obj)=1
     hide object obj
    endif
   endif
   obj=entityelement(e).obj
   if obj>0
    if object exist(obj)=1
     hide object obj
    endif
   endif
   tobj2=entityelement(e).attachmentobj
   if tobj2>0
    if object exist(tobj2)=1
     hide object tobj2
    endif
   endif
  endif
 next e
 `
return

_multi_restart:
 `
 rem called after start and any restarting of game session
 rem Init var
 lagmon#=200
 dwLocalPlayerID=0
 iLocalEL=0
 PlayerCanStart=0
 PlayerCanStartStage=0
 Servergameisfull=0
 gtalkytoaster=0
 gterminationcountdown=0
 `
 rem Wipe out talk array
 talkindex=0 : for ti=0 to 10 : talkscript$(ti)="" : talkscriptcount(ti)=0 : next ti
 `
 rem Clear multiplayer link list
 for el=1 to 16 : multiplayeridlink(el)=1 : next el
 for el=1 to 16 : multiplayerplrindex(el)=0 : next el
 for el=1 to 16 : characterchosen(el)=0 : characterchoiceentityindex(el)=0 : next el
 `
 rem Clear out all STATE data (as old game if any might mess new game)
 for el=1 to 16
  stategetready(el)=0
  statex(el)=0
  statey(el)=0
  statez(el)=0
  statea(el)=0
  stateanim(el)=0
  stateanimdir(el)=0
  statecolmaterialtype(el)=0
  stateanimwait(el)=0
  statewhodidit(el)=0
  stateplayagain(el)=0
  stateviewy(el)=0
  statesviewdy(el)=0
  stateweapon(el)=0
  stateannounce(el)=0
  statesx(el)=0
  statesy(el)=0
  statesz(el)=0
  statesa(el)=0
  statesvel(el)=0
  statetx(el)=0
  statety(el)=0
  statetz(el)=0
  statedx(el)=0
  statedy(el)=0
  statedz(el)=0
  statemove(el)=0
  statelag(el)=0
  statemsgap(el)=0
  statemytimer(el)=0
  statecodeupdate(el,0)=0
  statecodeupdate(el,1)=0
  statecodeupdate(el,2)=0
  statecodeupdate(el,3)=0
  statecodeupdate(el,4)=0
  stateraycastpace(el)=0
 next el
 `
 rem Reset frag and laststore counts
 for el=1 to multiplayermax
  frags(el)=0 : for ti=0 to 4 : statecodeupdate(el,ti)=-1 : next ti
 next el
 `
 rem begin the multiplayer game INIT
 if createorjoin=1
  rem setup server player
  multiplayeridlinkmax=1 : iLocalEL=1
  multiplayeridlink(iLocalEL)=0
  multiplayername$(iLocalEL)=playername$
  multiplayerplrindex(iLocalEL)=1
  gosub _multi_identifycharactersinentities
  gosub _multi_andwho
  characterchosen(iLocalEL)=characterchoice
  characterchoiceentityindex(iLocalEL)=characterlistentity(characterchoice)
  rem player position and angle from player() data
  gosub _multi_setlocalstart
  rem set new server players health on server
  plrindex=multiplayerplrindex(iLocalEL) : te=characterchoiceentityindex(iLocalEL)
  player(plrindex).health=entityelement(te).eleprof.strength
  rem if test game, give a fake health in case no character to use
  if gtestgamemodefromeditor=1 then player(plrindex).health=100
  rem hoster can be part of game now
  PlayerCanStart=1 : dwStartTime=timer()
 else
  rem join a tcp server
  setupvoicechat=0
 endif
 `
 rem init burst time (lagmon# bursts)
 dwBurstTime=timer()
 `
 rem set as initialised
 multiplayerinitialised=1
 `
return

_multi_initrespawnarray:
 `
 rem init
 respawnmax=0
 for e=1 to entityelementmax
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1
   rem record psosition
   inc respawnmax
   respawn(respawnmax).e=e
   respawn(respawnmax).x=entityelement(e).x
   respawn(respawnmax).y=entityelement(e).y
   respawn(respawnmax).z=entityelement(e).z
   respawn(respawnmax).ry=entityelement(e).ry
  endif
 next e
 `
return

_multi_playertorespawnpos:
 `
 rem if no respawn data, use an available place to start from
 if respawnmax=0
  rem Find player start location
  playerstartx#=0 : gosub _player_setstartposonly
 else
  rem uses TE, return to origin, or random
  ttries=9
  rsiadd=0
  while ttries>0
   rsi=0
   if gspawnrandom=0 or randomposnotworkatlocalstart=1
    for rsi=1 to respawnmax
     if respawn(rsi).e=te then exit
    next rsi
   else
    rsi=trandomvalue
   endif
   if rsi>0
    rem start pos
    rsi=rsi+rsiadd : rsi=1+((rsi-1) mod respawnmax)
    if rsi<1 then rsi=1
    if rsi>respawnmax then rsi=respawnmax
    playerstartx#=respawn(rsi).x
    playerstarty#=respawn(rsi).y
    playerstartz#=respawn(rsi).z
    playerstartry#=respawn(rsi).ry
    rem ensure it is not filled, exclude self from check
    tokay=1
    for ttel=1 to multiplayermax
     if ttel<>iLocalEL
      if multiplayeridlink(ttel)<>1
       tte=characterchoiceentityindex(ttel)
       ttdx#=abs(entityelement(tte).x-playerstartx#)
       ttdy#=abs(entityelement(tte).y-playerstarty#)
       ttdz#=abs(entityelement(tte).z-playerstartz#)
       ttdd#=sqrt((ttdx#*ttdx#)+(ttdy#*ttdy#)+(ttdz#*ttdz#))
       if ttdd#<100 then tokay=0 : exit
      endif
     endif
    next ttel
    if tokay=1
     ttries=0
    else
     inc rsiadd
    endif
   endif
   dec ttries
  endwhile
 endif
 `
return

_multi_setlocalstart:
 `
 rem have characterchoiceentityindex(iLocalEL)
 te=characterchoiceentityindex(iLocalEL)
 if te>0
  rem assign weapon to player
  tentid=entityelement(te).bankindex
  weaponindex=entityprofile(tentid).hasweapon
  tqty=10 : pi=0
  gosub _player_obtainaweapon
  autoloadgun=weaponindex
 endif
 `
 rem Copy again to make sure the weapon is given back after repos (die and spawn)
 tcopyorrestart=0 : gosub _gun_resetgunsettings
 `
 rem Place player at start position (randomize and lifecode using TE ensures identical LOCALSTARTs)
 randomize te
 trandomvalue=1+rnd(respawnmax-1)
 tlifecode=te
 randomposnotworkatlocalstart=1
 el=iLocalEL : gosub _multi_resetplrpos
 randomposnotworkatlocalstart=0
 camerapositionx=statex(iLocalEL)
 camerapositiony=statey(iLocalEL)+phyeyeheight#+21.0
 camerapositionz=statez(iLocalEL)
 position camera camerapositionx,camerapositiony,camerapositionz
 `
return

_multi_free:
 `
 rem Free Deadreckoning vectors
 for t=10+0 to 10+(16*5) : r=delete vector3(t) : next t
 `
 rem Delet memblocks
 if mb_move>0
  if memblock exist(mb_move)=1
   delete memblock mb_move
  endif
  mb_move=0
 endif
 if mb_write>0
  if memblock exist(mb_write)=1
   delete memblock mb_write
  endif
  mb_write=0
 endif
 `
 rem terminate connection session
 MULTIPLAYER DISCONNECT
 multiplayerinitialised=0
 `
 rem delete from gamelist
 if createorjoin=1
  gosub _ai_gamelist_delete
 endif
 createorjoin=0
 `
 rem Restore normal text
 set text to normal
 `
return

_multiplayer_repeatresetgame:
 `
 rem remove weapon from characters of previous game
 for el=1 to multiplayermax
  if multiplayeridlink(el)<>1
   rem Remove old weapon from model
   e=characterchoiceentityindex(el)
   entityelement(e).eleprof.hasweapon$=""
   gosub _entity_switchattachment
   rem Hide characters initially
   tobj=entityelement(e).obj
   if tobj>0
    if object exist(tobj)=1
     hide object tobj
    endif
   endif
  endif
 next el
 `
 rem clear viscolmap
 gosub _entity_fillviscolmap
 `
 rem Game has been repeated, so reset some small elements to reproduce exact restart (quicker than reload)
 gosub _player_resetobjectives
 gosub _player_startpos
 `
 rem Reset weapons
 tcopyorrestart=1 : gosub _gun_resetgunsettings
 `
 rem Reset entities
 tcopyorrestart=1 : gosub _entity_resetentitiestorestartstates
 `
 rem Restart multiplayer game session (causes all players to reselect characters)
 gosub _multi_restart
 `
 rem restore text to in-game style and size
 set text size 16 : set text to normal
 `
return


`
` Control
`

_multi_control:
 `
 if gterminationcountdown=0
  `
  rem unmark
  gosub _multi_unmark
  `
  rem Feed local data into states
  if multiplayerprototest=0
   if iLocalEL>0
    plrindex=multiplayerplrindex(iLocalEL)
    if weaponammoindex>0
     stateweapon(iLocalEL)=gunid
    else
     stateweapon(iLocalEL)=0
    endif
    if stateanimwait(iLocalEL)>0
     rem and wait for click to respawn
     player(plrindex).health=0
     if mouseclick()<>0 or (spacekey()=1 and gtalkytoaster=0)
      stateplayagain(iLocalEL)=1
      if createorjoin=2
       rem if client, send this click to server
       MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
       write memblock byte 102, 0, 212
       write memblock byte 102, 2, stateplayagain(iLocalEL)
       write memblock dword 102, 4, multiplayeridlink(iLocalEL)
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
      endif
     endif
    else
     if stategetready(iLocalEL)>0
      rem regular activity frozen until player touches ground
      stategetready(iLocalEL)=stategetready(iLocalEL)-1
     else
      statex(iLocalEL)=camerapositionx
      statey(iLocalEL)=(camerapositiony-phyeyeheight#)-20.0
      statez(iLocalEL)=camerapositionz
      statedx(iLocalEL)=statex(iLocalEL)
      statedy(iLocalEL)=statey(iLocalEL)
      statedz(iLocalEL)=statez(iLocalEL)
      stateviewy(iLocalEL)=wrapvalue(camera angle y())
     endif
     rem 1-spanw,2-idle,3-walk,4-strafeL,5-strafeR,6-run,32-crouchidle,33-crouchmove,12-'a' death,92-freeformidle,7-reload
     te=characterchoiceentityindex(iLocalEL)
     stateanimdir(iLocalEL)=0
     if player(plrindex).health>0
      if jumpaction<>0
       stateanim(iLocalEL)=92
      else
       statecolmaterialtype(iLocalEL)=colmaterialtype
       if crouchmode<>0
        if movement=1
         stateanim(iLocalEL)=33
         if (plrkeyS)=1 then stateanimdir(iLocalEL)=1
        else
         stateanim(iLocalEL)=32
        endif
       else
        if movement=1
         if (plrkeyA)=1
          stateanim(iLocalEL)=4
         else
          if (plrkeyD)=1
           stateanim(iLocalEL)=5
          else
           if (plrkeySHIFT)=1
            stateanim(iLocalEL)=6
           else
            stateanim(iLocalEL)=3
           endif
           if (plrkeyS)=1 then stateanimdir(iLocalEL)=1
          endif
         endif
        else
         if gunmode>=121 and gunmode<131
          stateanim(iLocalEL)=7
         else
          stateanim(iLocalEL)=2
         endif
        endif
       endif
      endif
     endif
    endif
   endif
  endif
  `
  rem Can detect NEW PLAYER here
  dwid as DWORD
  for i = 0 to MULTIPLAYER GET PLAYER COUNT()
   if i>0
    dwid=MULTIPLAYER GET PLAYER ID( i-1 )
   else
    dwid=0
   endif
   gotel=0 : freeel=0
   for el=1 to 16
    if multiplayeridlink(el)=1 and freeel=0 then freeel=el
    if multiplayeridlink(el)=dwid
     gotel=el : exit
    endif
   next el
   if gotel=0
    if freeel>0
     rem New Player for multiplayer-server-player list
     multiplayeridlink(freeel)=dwid
     multiplayeri(freeel)=i-1
     multiplayerisnew(freeel)=3
     tname$=MULTIPLAYER GET PLAYER NAME( i-1 )
     for c=1 to len(tname$)
      if asc(mid$(tname$,c))=10 or asc(mid$(tname$,c))=13
       tname$=left$(tname$,c-1)
       exit
      endif
     next c
     multiplayername$(freeel)=tname$
     if freeel>multiplayeridlinkmax then multiplayeridlinkmax=freeel
     rem add player() and update multiplayerplrindex
     el=freeel : gosub _multi_addplayer
     rem joining prompt, only if later in game
     if PlayerCanStart=1
      stateannounce(el)=500
     endif
     rem reset frag for new plr
     frags(el)=0
    else
     rem a 17th DP-plr tried to get into my 16 plr max session
    endif
   else
    rem continually refresh internal index reference
    if i>0
     rem when a client leave and reenters, the playerlist() list is changed!
     multiplayeri(gotel)=i-1
    endif
   endif
  next i
  rem clean up players no longer in game
  for el=1 to multiplayeridlinkmax
   if multiplayeridlink(el)<>1
    if el>1 and getindexfromid(multiplayeridlink(el))=0
     rem this player EL left the game or was kicked out
     multiplayeridlink(el)=1
     multiplayeri(el)=-1
     rem leaving prompt
     stateannounce(el)=-500
     rem remove visual player from game
     te=characterchoiceentityindex(el)
     rem ensure cannot shoot entity after plr gone from game
     entityelement(te).collisionactive=0
     tobj=entityelement(te).obj
     if tobj>0 then hide object tobj
     tobj2=entityelement(te).attachmentobj
     if tobj2>0 then hide object tobj2
     tobj3=entityelement(te).attachmentblobobj
     if tobj3>0 then hide object tobj3
     rem remove players identity from character list and allow the slot to be reused
     if characterchosen(el)>0
      characterchosen(el)=0 : Servergameisfull=0
      characterchoiceentityindex(el)=0
     endif
    endif
   endif
  next el
  `
  rem server or client
  gosub _common
  if createorjoin=1
   gosub _server
  else
   gosub _client
  endif
  gosub _playersend
  `
  rem Handle dead reckoning
  for el=1 to multiplayeridlinkmax
   if el<>iLocalEL
    if multiplayeridlink(el)<>1
     if statelag(el)>0 then gosub _packet_move_dedrec
     gosub _packet_rotate_dedrec
    endif
   endif
  next el
  `
  rem this is where we assign server-controlled EL data to actual entity drones
  if multiplayerprototest=0 and showgamemenu=0
   if showfpsinrealgame=1 or showfpsinrealgame=2 then set cursor 0,100
   for el=1 to multiplayeridlinkmax
    if showfpsinrealgame=2 then print el;" - ISNEW:";multiplayerisnew(el);" - ";
    if multiplayerisnew(el)=0 or el=iLocalEL
     te=characterchoiceentityindex(el)
     tentid=entityelement(te).bankindex
     if showfpsinrealgame=2 then print "ID:";multiplayeridlink(el);
     if multiplayeridlink(el)<>1 and te>0
      plrindex=multiplayerplrindex(el)
      tobj=entityelement(te).obj
      if showfpsinrealgame=1 then print multiplayername$(el);" ";str$(frags(el));" (";statelag(el);")"
      if showfpsinrealgame=2 then print " - H:";player(plrindex).health;" - TE:";te;" ";tobj;" ";multiplayername$(el);
      if tobj>0
       entityelement(te).x=statex(el)
       entityelement(te).y=statey(el)
       entityelement(te).z=statez(el)
       entityelement(te).mover.da=stateviewy(el)
       if stateanim(el)<>1+entityelement(te).animdo
        entityelement(te).animonce=0
        entityelement(te).animset=stateanim(el)
        entityelement(te).animdir=stateanimdir(el)
        if stateanimwait(el)>0 then entityelement(te).animonce=1
       endif
       if el=iLocalEL
        hide object tobj
        set object collision off tobj
        entityelement(te).active=0
        entityelement(te).dormant=1
        entityelement(te).collisionactive=0
        te=characterchoiceentityindex(el)
        tobj2=entityelement(te).attachmentobj
        if tobj2>0 then hide object tobj2
       else
        show object tobj
        entityelement(te).active=1
        entityelement(te).dormant=0
        if player(plrindex).health>0
         entityelement(te).collisionactive=1
        else
         entityelement(te).collisionactive=0
        endif
        rem if this plr entity is dead, make sure the corpse finds the floor
        if player(plrindex).health=0
         rem pause dead character
         stte=e : stentid=entid
         e=te : entid=entityelement(e).bankindex
         tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
         e=stte : entid=stentid
         if object frame(tobj)>=tffinish-2.0 and object frame(tobj)<=tffinish
          stop object tobj
         endif
         rem set dead guy final resting pose
         tppy#=entityelement(te).y
         tppa#=entityelement(te).ry
         if entityelement(te).animdo=14
          tpmb#=55.0
         else
          tpmb#=-55.0
         endif
         tppx#=newxvalue(entityelement(te).x,tppa#,tpmb#)
         tppz#=newzvalue(entityelement(te).z,tppa#,tpmb#)
         tdst#=static raycast(tppx#,tppy#+70.0,tppz#,tppx#,tppy#-505.0,tppz#)
         tlowestmove=0
         if abs(tdst#-70.0)>5.0
          if tdst#<70
           rem head through slope - push away
           tlowestmove=1
          else
           rem head hovering in thin air - push fore
           tlowestmove=2
          endif
         endif
         if tlowestmove<>0
          if tlowestmove=1
           entityelement(te).x=newxvalue(entityelement(te).x,tppa#,(tpmb#/15.0)*-1)
           entityelement(te).z=newzvalue(entityelement(te).z,tppa#,(tpmb#/15.0)*-1)
          else
           entityelement(te).x=newxvalue(entityelement(te).x,tppa#,(tpmb#/15.0))
           entityelement(te).z=newzvalue(entityelement(te).z,tppa#,(tpmb#/15.0))
          endif
          tppx#=entityelement(te).x : tppz#=entityelement(te).z
          tdst#=static raycast(tppx#,tppy#+5.0,tppz#,tppx#,tppy#-505.0,tppz#)
          tthisy#=tppy#-(tdst#-5.0)
          if tthisy#<entityelement(te).y
           entityelement(te).y=entityelement(te).y-6
           if entityelement(te).y<tthisy#
            entityelement(te).y=tthisy#
           endif
          endif
          statex(el)=entityelement(te).x
          statey(el)=entityelement(te).y
          statez(el)=entityelement(te).z
         endif
        endif
        if showfpsinrealgame=2
         if object in screen(tobj)=1
          center text object screen x(tobj),object screen y(tobj)-40,multiplayername$(el)+"["+str$(stateanim(el))+"] "+characterlist$(characterchosen(el))+"("+str$(characterchoiceentityindex(el))+")"
          if createorjoin=1
           center text object screen x(tobj),object screen y(tobj)-10,"HEALTH="+str$(player(plrindex).health)+"FRAGS="+str$(frags(el))
          endif
         endif
        else
         if object in screen(tobj)=1 and object visible(tobj)=1
          if stateraycastpace(el)=0
           tokay=1 : gosub _multi_caniseeplr
           if tokay=1 then stateraycastpace(el)=1
          endif
          if stateraycastpace(el)>=1
           stateraycastpace(el)=stateraycastpace(el)+1
           if stateraycastpace(el)>10
            tokay=1 : gosub _multi_caniseeplr
            if tokay=1
             stateraycastpace(el)=1
            else
             stateraycastpace(el)=0
            endif
           endif
          endif
          if stateraycastpace(el)>0
           center text object screen x(tobj),object screen y(tobj),multiplayername$(el)
          endif
         else
          stateraycastpace(el)=0
         endif
        endif
        remstart was here but moved to entity visual code
        rem blob shadow control (all other non local plrs)
        if entityelement(te).attachmentblobobj>0
         if object exist(entityelement(te).attachmentblobobj)=1
          tplrindex=multiplayerplrindex(el)
          if player(tplrindex).health>0
           dst#=static raycast(entityelement(te).x,entityelement(te).y+5,entityelement(te).z,entityelement(te).x,entityelement(te).y-50,entityelement(te).z)
          else
           dst#=0.0
          endif
          if dst#>0
           dst#=dst#-5.0
           position object entityelement(te).attachmentblobobj,entityelement(te).x,(entityelement(te).y-dst#)+0.5,entityelement(te).z
           show object entityelement(te).attachmentblobobj
           tsc#=(100.0-dst#) : scale object entityelement(te).attachmentblobobj,tsc#,tsc#,tsc#
          else
           hide object entityelement(te).attachmentblobobj
          endif
         endif
        endif
        remend
       endif
      endif
     endif
    endif
    if showfpsinrealgame=2 then print
   next el
   if showfpsinrealgame=2
    el=iLocalEL : center text screen width()/2,screen height()-40,multiplayername$(el)+"["+str$(stateanim(el))+"] "+str$(characterchosen(el))+":"+characterlist$(characterchosen(el))+"("+str$(characterchoiceentityindex(el))+")"+" FRAGS="+str$(frags(el))
   endif
   `
  endif
  `
  rem mark positions in viscolmap
  gosub _multi_mark
  `
 endif
 `
 rem announcements
 anngap=25
 if showgamemenu=0
  tylinevalue=screen height()-(anngap*2)
  if gterminationcountdown>0
   set cursor 0,tylinevalue
   print strarr$(635);
   dec gterminationcountdown
   if gterminationcountdown<2
    tserverendsreason=1
    gosub _multi_serverendedgame
    mpgameinprogress=0
    continueokay=1
   endif
  else
   if PlayerCanStart=0
    set cursor 0,tylinevalue
    print strarr$(636);
`    if gmultiplayergame=1 and multiplayerinitialised=1 and multiplayersystemdisabled=0 then print "OK..";
`    print "(";str$(PlayerCanStartStage);","+str$(MULTIPLAYER GET PLAYER COUNT())+","+str$(dwLocalPlayerID)+","+str$(gterminationcountdown)+")";
   else
    for el=1 to multiplayeridlinkmax
     if multiplayeridlink(el)=1
      if stateannounce(el)<0
       set cursor 0,tylinevalue
       stateannounce(el)=stateannounce(el)+1
       print multiplayername$(el)+" "+strarr$(637)+" (";stateannounce(el);")";
       dec tylinevalue,anngap
      endif
     else
      if stateannounce(el)=0
       rem X killed Y (Y represents this)
       if stateanimwait(el)>=10
        set cursor 0,tylinevalue
        sourceel=statewhodidit(el)
        print multiplayername$(sourceel)+" "+strarr$(638)+" "+multiplayername$(el);
        dec tylinevalue,anngap
       endif
      else
       if el<>iLocalEL
        rem slowly joining game
        if stateannounce(el)>0
         set cursor 0,tylinevalue
         stateannounce(el)=stateannounce(el)-1
         print multiplayername$(el)+" "+strarr$(639);
         dec tylinevalue,anngap
        endif
       else
        stateannounce(el)=0
       endif
      endif
     endif
    next el
    rem Click to restart
    if stateanimwait(iLocalEL)>0
     set cursor 0,tylinevalue
     print strarr$(640);str$(stateanimwait(iLocalEL));
     dec tylinevalue,anngap
    endif
    rem Talk scripts (going backwards)
    if talkindex>0
     for ti=talkindex-1 to 0 step -1
      if talkscriptcount(ti)>0
       talkscriptcount(ti)=talkscriptcount(ti)-1
       set cursor 0,tylinevalue
       print multiplayername$(talkscriptwho(ti))+talkscript$(ti);
       dec tylinevalue,anngap
      endif
     next ti
    endif
    for ti=10 to talkindex step -1
     if talkscriptcount(ti)>0
      talkscriptcount(ti)=talkscriptcount(ti)-1
      set cursor 0,tylinevalue
      print multiplayername$(talkscriptwho(ti))+talkscript$(ti);
      dec tylinevalue,anngap
     endif
    next ti
    rem Monitor for ping
    if talkpingsound>0
     if talkindex<>lastplayedtalkindex
      lastplayedtalkindex=talkindex
      if sound exist(talkpingsound)=1
       play sound talkpingsound
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem capture and kill local player if they fall out of universe MP style
 if camerapositiony<-200
  tdamage=65535 : e=characterchoiceentityindex(iLocalEL)
  if entityelement(e).health>0
   gosub _multi_dealentityedamage
  endif
 endif
 `
return

_multi_caniseeplr:
 `
 rem can i see the plr to write their name on screen (tokay=0=no)
 if static raycast(camerapositionx,camerapositiony,camerapositionz,entityelement(te).x,entityelement(te).y+5.0,entityelement(te).z)=0
  tokay=1
  for tte=1 to entityelementlist
   if entityelement(tte).active=1
    if entityelement(tte).eleprof.isimmobile=1
     if entityelement(tte).collisionactive=1
      ttentid=entityelement(tte).bankindex
      if entityprofile(ttentid).isweapon=0 and entityprofile(ttentid).isammo=0 and entityprofile(ttentid).ischaracter=0
       ttobj=entityelement(tte).obj
       if ttobj>0
        tdst#=intersect object(ttobj,camerapositionx,camerapositiony,camerapositionz,entityelement(te).x,entityelement(te).y+5.0,entityelement(te).z)
        if tdst#<>0 then tokay=0 : exit
       else
        rem some entities are zero OBJ value
       endif
      endif
     endif
    endif
   endif
  next tte
 else
  tokay=0
 endif
 `
return

_multi_unmark:
 `
 rem remove old marker from viscolmap
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   tx=statetx(el) : ty=statety(el) : tz=statetz(el)
   if viscolmap(tx,ty,tz)=-1 then viscolmap(tx,ty,tz)=0
  endif
 next el
 `
return

_multi_mark:
 `
 rem write new marker to viscolmap
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   tx=statedx(el)/25 : ty=statedy(el)/100 : tz=statedz(el)/-25
   if ty>=0 and ty<=viscoly
    if tx>=0 and tz>=0
     if tx<=viscolx and tz<=viscolz
      if viscolmap(tx,ty,tz)=0
       statetx(el)=tx : statety(el)=ty : statetz(el)=tz
       viscolmap(tx,ty,tz)=-1
      endif
     endif
    endif
   endif
  endif
 next el
 `
return

`
` MP Subroutines
`

_common:
 `
 rem update MSgap counts
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   `
   rem keep tabs on players lag
   statemsgap(el)=timer()-statemytimer(el)
   `
   rem when looping sound too old, stop it
   e=characterchoiceentityindex(el)
   if entityelement(e).firesoundloopremote<>0
    if timer()-entityelement(e).firesoundlooptime>500
     stop sound entityelement(e).firesoundloopremote
     entityelement(e).firesoundloopremote=0
    endif
   endif
   `
   rem auto-footfalls when players in motion
   if (stateanim(el)>=3 and stateanim(el)<=6) or (stateanim(el)>=33 and stateanim(el)<=36)
    movement=1
    if stateanim(el)=6 then basespeed#=70 else basespeed#=50
    if stateanim(el)>=33 and stateanim(el)<=36 then basespeed#=15 : movement=2
    colmaterialtype=statecolmaterialtype(el) : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
    if plrid>1 then gosub _player_playfootfall
   endif
   `
   rem reduce invincibility counter
   if entityelement(e).invincibleactive>0
    entityelement(e).invincibleactive=entityelement(e).invincibleactive-1
   endif
   `
  endif
 next el
 `
 rem CAPTURE for debug purposes CONTROLS
 if showfpsinrealgame=2
  set cursor 0,0
  print "startlogging=";startlogging;" (";loginfoindex;")"
  if inkey$()="#" and startlogging=0 then startlogging=1
  if inkey$()="'" and startlogging=2 then startlogging=3
  if startlogging=1
   dim loginfo$(1001)
   loginfoindex=0
   startofrecording=timer()
   startlogging=2
  endif
  rem startlogging=2 inside message loop reporting activity
  if startlogging=3
   if file exist("multiplayerlogfile.txt")=1 then delete file "multiplayerlogfile.txt"
   save array "multiplayerlogfile.txt",loginfo$(0)
   undim loginfo$(0)
   startlogging=0
  endif
 endif
 `
 rem CAPTURE FORMATTING
 if startlogging=2
  if MULTIPLAYER MESSAGE EXISTS ( )
   loginfo$(loginfoindex)="["+str$((timer()-startofrecording)/1000)+"s]"
   inc loginfoindex : if loginfoindex>=1000 then startlogging=3
  endif
 endif
 `
 rem Reset so server will always send to ALL clients
 MULTIPLAYER SEND MESSAGE TO 0
 `
 rem get messages (clientplayers(createorjoin=0) also accepts server messages)
 while MULTIPLAYER MESSAGE EXISTS ( )
  `
  rem One message at a time
  MULTIPLAYER GET MESSAGE
  dwPlayerID = MULTIPLAYER GET MESSAGE PLAYER FROM( )
  `
  rem Message memblock slice up
  dwMessageCode=0
  if MULTIPLAYER GET MESSAGE TYPE( ) = 3
   MULTIPLAYER GET MESSAGE MEMBLOCK mb_move
   dwCode = memblock byte( mb_move, 0 )
   dwMessageCode=3
  endif
  `
  rem CAPTURE for debug purposes
  treportonmessage=0
  if startlogging=2
   if treportonmessage=0
    el=getelfromid(dwPlayerID) : tt$=" from "+multiplayername$(el)
    loginfo$(loginfoindex)=str$(dwMessageCode)+" "+right$(str$(1000+dwCode),3)+" "+tt$
    inc loginfoindex
    if loginfoindex>=1000
     startlogging=3
    endif
   endif
  endif
  `
  rem Handle both server and client comms here
  if (createorjoin=1 and dwPlayerID<>0) or createorjoin=2
   `
   rem message from server to client only
   if createorjoin=2
    if MULTIPLAYER GET MESSAGE TYPE( ) = 2
     tname$=MULTIPLAYER GET MESSAGE STRING()
     if left$(tname$,2)<>">>"
      el=getelfromid(0)
      for c=1 to len(tname$)
       if asc(mid$(tname$,c))=10 or asc(mid$(tname$,c))=13
        tname$=left$(tname$,c-1)
        exit
       endif
      next c
      multiplayername$(el)=tname$
     endif
    endif
   endif
   `
   rem string can also be a talkytoaster message
   if MULTIPLAYER GET MESSAGE TYPE( ) = 2
    ttalk$=MULTIPLAYER GET MESSAGE STRING()
    if left$(ttalk$,2)=">>"
     for c=1 to len(ttalk$)
      if asc(mid$(ttalk$,c))=10 or asc(mid$(ttalk$,c))=13
       ttalk$=left$(ttalk$,c-1)
       exit
      endif
     next c
     rem copy rest of talk to string
     talkscript$(talkindex)=ttalk$
     talkscriptcount(talkindex)=200
     el=getelfromid(dwPlayerID) : talkscriptwho(talkindex)=el
     inc talkindex : if talkindex>10 then talkindex=0
     if createorjoin=1
      rem if server receives talkmessage, must send out to all clients
      el=getelfromid(dwPlayerID)
      MULTIPLAYER SEND FROM PLAYER dwPlayerID
      MULTIPLAYER SEND MESSAGE STRING ttalk$,0x0080
     endif
    endif
   endif
   `
   rem message changes states on server
   if dwMessageCode=3 and (dwCode=0 or dwCode=4 or dwCode=5 or dwCode=9)
    el=getelfromid(dwPlayerID)
    if el>0
     if createorjoin=2 and dwPlayerID=dwLocalPlayerID
      rem a quick and easy report on received packet times
      locallagtime=timer()-timestampforlagtest
      timestampforlagtest=timer()
     else
      `
      rem MESSAGE FROM OTHER CLIENTS/SERVER
      ttransmitpos=0 : ttransmitanim=0 : ttransmitshot=0
      `
      rem Take new data and update state data
      if dwCode=0
       rem movement
       a = memblock byte( mb_move, 1 )*2
       x = memblock word( mb_move, 2 )
       y = memblock word( mb_move, 4 )
       z = memblock word( mb_move, 6 )*-1
       rem movement
       if multiplayeridlink(el)<>1
        statelag(el)=statemsgap(el)
        statemytimer(el)=timer()
        px#=x : py#=y : pa#=a : pz#=z
        rem If this plr is newly joined, reset to this new position coming in
        if multiplayerisnew(el)=3 then multiplayerisnew(el)=2
        gosub _packet_move
        ttransmitpos=1
       endif
      endif
      if dwCode=4
       rem anim and viewy and colmaterialtype
       viewy = memblock byte( mb_move, 1 )*2
       anim = memblock byte( mb_move, 2 )
       tcolmattype = memblock byte( mb_move, 3 )
       animdir = memblock byte( mb_move, 4 )
       statecolmaterialtype(el)=tcolmattype-1
       stateanim(el)=anim : pviewy#=viewy
       stateanimdir(el)=animdir
       gosub _packet_viewyanim
       ttransmitanim=1
      endif
      if dwCode=5
       rem player shot gun event
       ttransmitshot=1
       rem discharge sound (single fire, or automatic loop sound)
       e=characterchoiceentityindex(el)
       tgunid=entityelement(e).currentweapon
       tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
       if tsndid>0
        if gun(tgunid).action.automatic.s>0
         if entityelement(e).firesoundloopremote>0
          if entityelement(e).firesoundloopremote<>tsndid
           stop sound entityelement(e).firesoundloopremote
           entityelement(e).firesoundloopremote=0
          endif
         endif
         if entityelement(e).firesoundloopremote=0
          play sound tsndid,gun(tgunid).sound.fireloopend
          loop sound tsndid,0,gun(tgunid).sound.fireloopend
          entityelement(e).firesoundloopremote=tsndid
         endif
         entityelement(e).firesoundlooptime=timer()
        else
         play sound tsndid
        endif
        posinternal3dsound(tsndid,entityelement(e).x,entityelement(e).y,entityelement(e).z)
        broadcast3dsound(entityelement(e).x,entityelement(e).y,entityelement(e).z,25.0)
       endif
       rem visual decal
       tdecalmode=6
       entityelement(e).decalindex=1
       entityelement(e).decalmode=tdecalmode
       if entityelement(e).currentweapon>0
        rem override decal if gun specifies non-fire-flare
        tgunid=entityelement(e).currentweapon
        if gun(tgunid).decalid>0
         entityelement(e).decalindex=gun(tgunid).decalid*-1
        endif
       else
        entityelement(e).decalindex=0
       endif
      endif
      if dwCode=9
       rem movement
       if multiplayeridlink(el)<>1
        a = memblock byte( mb_move, 1 )*2
        x = memblock word( mb_move, 2 )
        y = memblock word( mb_move, 4 )
        z = memblock word( mb_move, 6 )*-1
        statelag(el)=statemsgap(el)
        statemytimer(el)=timer()
        px#=x : py#=y : pa#=a : pz#=z
        rem If this plr is newly joined, reset to this new position coming in
        if multiplayerisnew(el)=3 then multiplayerisnew(el)=2
        gosub _packet_move
        ttransmitpos=1
        rem and anim
        viewy = memblock byte( mb_move, 8 )*2
        anim = memblock byte( mb_move, 9 )
        tcolmattype = memblock byte( mb_move, 10 )
        animdir = memblock byte( mb_move, 11 )
        statecolmaterialtype(el)=tcolmattype-1
        stateanim(el)=anim : pviewy#=viewy
        stateanimdir(el)=animdir
        gosub _packet_viewyanim
        ttransmitanim=1
       endif
      endif
      `
      rem If server intercepts this, send new client data out to other clients
      if createorjoin=1
       if ttransmitpos=1 or ttransmitanim=1 or ttransmitshot=1
        MULTIPLAYER SEND FROM PLAYER dwPlayerID
        MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
        gosub _multi_transmitplayerdata
        MULTIPLAYER SEND MESSAGE TO 0
        rem ensure this non-prioritystuff gets sent at least one in five
        if guarenteedloadonmove>4 then guarenteedloadonmove=0
       endif
      endif
      `
     endif
    endif
   endif
   `
  endif
  `
  rem
  rem MEMBLOCK COMMUNICATIONS
  rem
  if dwMessageCode=3
   `
   rem
   rem SERVER Only Actions
   rem
   if createorjoin=1
    `
    rem INIT - server inits everything to requesting client
    if dwCode=1
     rem server will reject init immediately if game is FULL
     MULTIPLAYER SEND FROM PLAYER dwPlayerID
     if Servergameisfull=0
      rem name of server player (priority)
      MULTIPLAYER SEND MESSAGE STRING multiplayername$(1),0x0080
      rem show client list of available characters
      gosub _multi_showlistofavailchars
     else
      rem server game is full
      rem no more slots, max players reached (copied from below)
      write memblock byte 102, 0, 103
      write memblock dword 102, 4, 1
      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
      inc guarenteedbytes,8 : inc unreliablebytes,0
     endif
    endif
    rem REQUEST CHARACTER - server sends permission to client to use requested character
    if dwCode=3
     rem server says yes you can use that character
     tokay=1 : tfreeslot=0
     tcl = memblock dword( mb_move, 4 )
     for tcc=0 to numberofplayers-1
      if characterchosen(1+tcc)=tcl
       tokay=0
      endif
      if characterchosen(1+tcc)=0 then tfreeslot=1
     next tcc
     MULTIPLAYER SEND FROM PLAYER dwPlayerID
     if tfreeslot=1
      if tokay=1
       rem record clients choice on the server
       el=getelfromid(dwPlayerID) : characterchosen(el)=tcl
       gosub _multi_identifycharactersinentities
       characterchoiceentityindex(el)=characterlistentity(tcl)
       rem set new joiner players health on server
       te=characterchoiceentityindex(el)
       plrindex=multiplayerplrindex(el) : player(plrindex).health=entityelement(te).eleprof.strength
       rem if test game, give a fake health in case no character to use
       if gtestgamemodefromeditor=1 then player(plrindex).health=100
       rem go ahead and start clients game
       write memblock byte 102, 0, 102
       write memblock dword 102, 4, tcl
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
       rem transmit health values of all players too
       for tel=1 to multiplayeridlinkmax
        if multiplayeridlink(tel)<>1
         plrindex=multiplayerplrindex(tel) : tvalue=player(plrindex).health
         MULTIPLAYER SEND FROM PLAYER multiplayeridlink(tel)
         write memblock byte 102, 0, 201
         write memblock dword 102, 4, multiplayeridlink(tel)
         write memblock dword 102, 8, tvalue
         rem priority communication
         MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
         inc guarenteedbytes,12 : inc unreliablebytes,0
        endif
       next tel
       rem transmit positions and other player details as they are right now
       for el=1 to multiplayeridlinkmax
        if multiplayeridlink(el)<>1
         rem transmit position and anim (playercode specifies the WHO)
         for tfourtimes=1 to 4
          guarenteedloadonmove=5 : rem ensure inital positions guarenteed
          ttransmitpos=1 : ttransmitanim=0
          MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
          gosub _multi_transmitplayerdata
         next tfourtimes
         guarenteedloadonmove=5 : rem ensure inital positions guarenteed
         ttransmitpos=0 : ttransmitanim=1
         MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
         gosub _multi_transmitplayerdata
         te=characterchoiceentityindex(el)
         rem update all clients with this change (sneak lifecode in as well) (send from server)
         MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
         write memblock byte 102, 0, 211
         write memblock byte 102, 1, entityelement(te).lifecode
         write memblock dword 102, 4, multiplayeridlink(el)
         write memblock dword 102, 8, stateweapon(el)
         MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
         inc guarenteedbytes,12 : inc unreliablebytes,0
        endif
       next el
       rem restore EL just in case
       el=getelfromid(dwPlayerID)
       rem update Servergameisfull flag
       tfreeslot=0
       for tcc=0 to numberofplayers-1
        if characterchosen(1+tcc)=0 then tfreeslot=1
       next tcc
       if tfreeslot=0 then Servergameisfull=1
      else
       rem client cannot have this character, ask client to choose another
       gosub _multi_showlistofavailchars
      endif
     else
      rem no more slots, max players reached
      write memblock byte 102, 0, 103
      write memblock dword 102, 4, 1
      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
      inc guarenteedbytes,8 : inc unreliablebytes,0
     endif
    endif
    rem REQUEST A HIT
    if dwCode=21
     rem shot and damage
     tlifecode = memblock byte( mb_move, 1 )
     te = memblock word( mb_move, 2 )
     tdamage = memblock word( mb_move, 4 )
     sourcee = memblock word( mb_move, 6 )
     rem only deal remote damage if lifecode of current entity and shot-id is same
     if entityelement(te).lifecode=tlifecode
      gosub _multi_dealdamagedirect
     else
      el=getelfromid(dwPlayerID)
      tlifecodenotmatch=el
      tlifecodenotmatcha=entityelement(te).lifecode : tlifecodenotmatchb=tlifecode
     endif
    endif
    rem FINISHEDGAME - server is informed of client winning by local mission AI
    if dwCode=105
     rem broadcast to clients
     winnerel=getelfromid(memblock dword(mb_move, 4))
     tbroadcastresult=winnerel
     gosub _multi_informallplayersofcomplete
     rem declare winner/loser
     gosub _multi_declarewinorlose
    endif
    rem HEALTHUPDATE (also handled below for all)
    if dwCode=201
     rem newcode - server can never be told the players health is subzero
     tplayerhealth=memblock dword(mb_move, 8)
     if tplayerhealth<=0
      rem Server was informed by Client that its health was subzero
      el=getelfromid(memblock dword(mb_move, 4))
      tclientinformedhealthsubzero=el
     else
      rem get for benefit of server
      gosub _get_playerhealth
     endif

` other clients do NOT need to know their fellows health values
`     rem from server so do not need to broadcast back out
`     if dwPlayerID<>dwLocalPlayerID
`      rem update all clients with this players new health
`      MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
`      rem Update client player health
`      write memblock byte 102, 0, 201
`      write memblock dword 102, 4, multiplayeridlink(el)
`      write memblock dword 102, 8, player(plrindex).health
`      MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
`      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
`      MULTIPLAYER SEND MESSAGE TO 0
`      inc guarenteedbytes,12 : inc unreliablebytes,0
`     endif

    endif
    rem WEAPONCHANGED - client changed weapon
    if dwCode=211
     rem get plr affected and store in state (on server)
     tlifecode=memblock byte(mb_move, 1)
     el=getelfromid(memblock dword(mb_move, 4))
     stateweapon(el)=memblock dword(mb_move, 8)
     te=characterchoiceentityindex(el)
     entityelement(te).lifecode=tlifecode
     rem update all clients with this change
     MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
     write memblock byte 102, 0, 211
     write memblock byte 102, 1, entityelement(te).lifecode
     write memblock dword 102, 4, multiplayeridlink(el)
     write memblock dword 102, 8, stateweapon(el)
     MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
     MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
     MULTIPLAYER SEND MESSAGE TO 0
     inc guarenteedbytes,12 : inc unreliablebytes,0
     rem handle weapon change in game
     gosub _multi_changeweapon
    endif
    if dwCode=212
     rem get plr affected and store in state (on server)
     el=getelfromid(memblock dword(mb_move, 4))
     stateplayagain(el)=memblock byte(mb_move, 2)
    endif
    rem REQUEST TRIGGER SEND - client used an mptrigger
    if dwCode=251
     rem get trigger and perform on server first
     mptrigger=memblock byte(mb_move,1)
     mptriggervalue1=memblock word(mb_move, 2)
     rem server performs directly (for server player)
     gosub _multi_performtrigger
     rem server sends all triggers to clients (using dwPlayerID to show who did triggering)
     gosub _multi_serversendtriggers
    endif
    `
   endif
   `
   rem
   rem CLIENT
   rem
   if createorjoin=2
    `
    rem Messages JUST for this one client (or all clients)
    if dwPlayerID=dwLocalPlayerID
     rem POPULATE - client updates entities with server-controlled-entities
     if dwCode=2
      PlayerCanStartStage=3
      x = memblock dword( mb_move,  4 )
      y = memblock dword( mb_move,  8 )
      z = memblock dword( mb_move, 12 )
      e = memblock dword( mb_move, 16 )
      entityelement(e).servercontrolled=1
      entityelement(e).x=x
      entityelement(e).y=y
      entityelement(e).z=z
     endif
     rem ASKIFCANUSECHARACTER - client chooses character
     if dwCode=101
      rem Choose which character you want to be
      numberofplayers=memblock byte( mb_move, 4 )
      if numberofplayers>0
       tdwplr as DWORD
       for tcc=0 to numberofplayers-1
        tdwplr=memblock dword( mb_move, 5+(tcc*5) )
        tcl=memblock byte( mb_move, 9+(tcc*5) )
        el=getelfromid(tdwplr) : characterchosen(el)=tcl
        gosub _multi_identifycharactersinentities
        characterchoiceentityindex(el)=characterlistentity(tcl)
       next tcc
       rem select from character selection screen
       gosub _multi_andwho
       rem client asks server if can use this character
       MULTIPLAYER SEND FROM PLAYER dwPlayerID
       write memblock byte 102, 0, 3
       write memblock dword 102, 4, characterchoice
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
      else
       rem odd error server has a game of zero players
       exit prompt "MPError","Zero Players" : end
      endif
     endif
     rem READY - client is told if it can use the selected character
     if dwCode=102
      rem JOIN PLAYER STARTS - create space in player array
      characterchosen(iLocalEL)=characterchoice
      te=characterlistentity(characterchoice)
      characterchoiceentityindex(iLocalEL)=te
      multiplayerplrindex(iLocalEL)=1
      multiplayername$(iLocalEL)=playername$
      rem start position of this local dude
      gosub _multi_setlocalstart
      rem start joiners game
      PlayerCanStartStage=4
      PlayerCanStart=1
     endif
     rem CANNOT PLAY - client is told they cannot play for some reason
     if dwCode=103
      tcannotplayreason=memblock byte( mb_move, 4 )
      gosub _multi_cannotplay
      mpgameinprogress=0
      continueokay=1
     endif
     rem FINISHEDGAME - client is told a winner has been found (and pass in final frag count too)
     if dwCode=104
      el=getelfromid(dwPlayerID)
      frags(el)=memblock word(mb_move, 2)
      winnerel=getelfromid(memblock dword(mb_move, 4))
      gosub _multi_declarewinorlose
     endif
    else
     rem Messages for all clients (not original client sender though)
     rem CHARACTER CONFIRM - intercept character confirmation, so other clients know what identity the player uses
     if dwCode=102
      el=getelfromid(dwPlayerID)
      tcharacterchoice=memblock byte( mb_move, 4 )
      characterchosen(el)=tcharacterchoice
      characterchoiceentityindex(el)=characterlistentity(tcharacterchoice)
     endif
     if dwCode=252
      rem TRIGGER EVENT - using trigger code and value(s)
      mptrigger=memblock byte(mb_move,1)
      mptriggervalue1=memblock word(mb_move, 2)
      gosub _multi_performtrigger
     endif
    endif
    `
    rem PLAYER DETAIL CHANGE - player health change
    if dwCode=201
     rem simply update health (also handled above for broadcast by server)
     gosub _get_playerhealth
    endif
    if dwCode=202
     rem PLAYDIEANIM - usually from being killed
     el=getelfromid(memblock dword(mb_move, 4))
     sourceel=getelfromid(memblock dword(mb_move, 8))
     gosub _multi_dieanim
    endif
    if dwCode=203
     rem update health negatively, and if local player, arg and redhud
     gosub _get_playerhurt
    endif
    if dwCode=204
     rem REPOSIITON - usually after die anim
     trandomvalue=memblock byte(mb_move, 1)
     tlifecode=memblock byte(mb_move, 2)
     el=getelfromid(dwPlayerID)
     gosub _multi_resetplrpos
     rem restart weapon inventory
     if el=iLocalEL
      tcopyorrestart=1 : gosub _gun_resetgunsettings
     endif
     rem update entities locally around player
     tupdatelocalentities=el
    endif
    if dwCode=205
     rem NEWFRAGVALUE - informs who has new frag value and who they killed to get the update
     tnewfrag=memblock byte(mb_move,1)
     killerel=getelfromid(memblock dword(mb_move, 4))
     victimel=getelfromid(memblock dword(mb_move, 8))
     frags(killerel)=tnewfrag
    endif
    if dwCode=211
     rem simply update weapon used by plr (also handled above for broadcast by server)
     tlifecode=memblock byte(mb_move,1)
     el=getelfromid(memblock dword(mb_move, 4))
     stateweapon(el)=memblock dword(mb_move, 8)
     rem also lifecode piggy backs a ride
     te=characterchoiceentityindex(el)
     entityelement(te).lifecode=tlifecode
     rem handle weapon change in game
     gosub _multi_changeweapon
    endif
    `
   endif
   `
   rem
   rem BOTH
   rem
`   rem Messages JUST for this one client (or all clients)
`   if dwPlayerID=dwLocalPlayerID
`    rem From itself - ignore
`   else
`    rem ROCKET FIRED - client updates FLAK with rocket event
`    if dwCode=11
`     a = memblock byte( mb_move, 1 ) * 2
`     x = memblock word( mb_move, 2 )
`     y = memblock word( mb_move, 4 )
`     riaplr = memblock dword( mb_move, 6 )
`     rix#=x : riy#=y : ria#=a : rii=memblock byte( mb_move, 10 )
`     rem do not remote-fire own rockets!!
`     if riaplr<>dwLocalPlayerID
``      gosub _proto_fire
`     endif
`     rem if server intercepts a fire, send to other clients
`     if createorjoin=1
`      iLocalELAction=ri
`     endif
`    endif
`   endif
`   rem ROCKET COLLIDED - so trigger explosion
`   if dwCode=12
`    rii = memblock dword( mb_move, 4 )
`    for ri=1 to rocketmax
`     if rocket(ri).owner=dwPlayerID
`      if rocket(ri).rii=rii
`       rocket(ri).rocketmode=2 : rocket(ri).exploderadius=2 : exit
`      endif
`     endif
`    next ri
`   endif
   `
  endif
  `
  rem update entities locally around player
  if tupdatelocalentities>0
   el=tupdatelocalentities
   if el=iLocalEL
    mex#=statex(el) : mey#=statey(el) : mez#=statez(el)
    gosub _entity_blastinitentities
   endif
   tupdatelocalentities=0
  endif
  `
 endwhile
 `
 if showfpsinrealgame=2
  set cursor 0,250
  if tlifecodenotmatch<>0
   print "lifecodenotmatch(el=";tlifecodenotmatch;") ";multiplayername$(tlifecodenotmatch)
   print "entis:";tlifecodenotmatcha
   print "asked:";tlifecodenotmatchb
  endif
  if tclientinformedhealthsubzero<>0
   print "tclientinformedhealthsubzero(el=";tclientinformedhealthsubzero;") ";multiplayername$(tclientinformedhealthsubzero)
  endif
 endif
 `
 rem Restore all server sends (so no client is excluded)
 MULTIPLAYER SEND MESSAGE TO 0
 `
return

_multi_changeweapon:
 `
 rem uses el
 tgunid=stateweapon(el)
 e=characterchoiceentityindex(el)
 tweap$=gun(tgunid).name$
 tobj=entityelement(e).obj
 entid=entityelement(e).bankindex
 if entityprofile(entid).ischaracter=1
  if object exist(tobj)=1
   if entityprofile(entid).firespotlimb>-1
    rem switch weapon carried and force reset of animation account for possible weapon
    entityelement(e).eleprof.hasweapon$=tweap$
    gosub _entity_switchattachment
    entityelement(e).animset=entityelement(e).animdo+1
   endif
  endif
 endif
 `
return

_multi_transmitplayerdata:
 `
 rem prepare
 if ttransmitpos=1
  a=wrapvalue(statea(el))/2
  x=statedx(el) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
  y=statedy(el) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
  z=statedz(el)*-1 : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
 endif
 if ttransmitanim=1
  viewy=wrapvalue(stateviewy(el))/2
  anim=stateanim(el)
  tcolmat=1+statecolmaterialtype(el)
  animdir=stateanimdir(el)
 endif
 `
 rem if both pos and anim/viewy, ship as single packet
 if ttransmitpos=1 and ttransmitanim=1
  `
  rem Both POS+ANIM message
  write memblock byte mb_move, 0, 9
  write memblock byte mb_move, 1, a
  write memblock word mb_move, 2, x
  write memblock word mb_move, 4, y
  write memblock word mb_move, 6, z
  write memblock byte mb_move, 8, viewy
  write memblock byte mb_move, 9, anim
  write memblock byte mb_move, 10, tcolmat
  write memblock byte mb_move, 11, animdir
  if guarenteedloadonmove>4
   MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,12
   inc guarenteedbytes,12 : inc unreliablebytes,0
  else
   MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,12
   inc guarenteedbytes,0 : inc unreliablebytes,12
  endif
  `
 else
  `
  rem send out position (non-priority)
  if ttransmitpos=1
   write memblock byte mb_move, 0, 0
   write memblock byte mb_move, 1, a
   write memblock word mb_move, 2, x
   write memblock word mb_move, 4, y
   write memblock word mb_move, 6, z
   if guarenteedloadonmove>4
    rem ensure at least one out of five move messages will be guarenteed if bombed with priority traffic
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,8
    inc guarenteedbytes,8 : inc unreliablebytes,0
   else
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
    inc guarenteedbytes,0 : inc unreliablebytes,8
   endif
  endif
  `
  rem send out viewy and animation (non-priority)
  if ttransmitanim=1
   write memblock byte mb_move, 0, 4
   write memblock byte mb_move, 1, viewy
   write memblock byte mb_move, 2, anim
   write memblock byte mb_move, 3, tcolmat
   if guarenteedloadonmove>4
    rem ensure at least one out of five move messages will be guarenteed if bombed with priority traffic
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,8
    inc guarenteedbytes,8 : inc unreliablebytes,0
   else
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
    inc guarenteedbytes,0 : inc unreliablebytes,8
   endif
  endif
  `
 endif
 `
 rem send out the shot-event (non-priority)
 if ttransmitshot=1
  write memblock byte mb_move, 0, 5
  MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
  inc guarenteedbytes,0 : inc unreliablebytes,8
 endif
 `
return

_multi_showlistofavailchars:
 `
 rem send list of chars to client from server
 MULTIPLAYER SEND FROM PLAYER dwPlayerID
 write memblock byte 102, 0, 101
 rem server also sends who client has picked as their character
 write memblock byte 102, 4, numberofplayers
 for tcc=0 to numberofplayers-1
  write memblock dword 102, 5+(tcc*5), multiplayeridlink(1+tcc)
  write memblock byte 102, 9+(tcc*5), characterchosen(1+tcc)
 next tcc
 amount=4+4+(numberofplayers*5)
 MULTIPLAYER SEND MESSAGE memblock 102,0x0080,amount
 inc guarenteedbytes,amount : inc unreliablebytes,0
 `
return

_multi_addplayer:
 `
 rem find free 'used' server player slot
 plrindex=0
 for ti=1 to playermax
  if player(ti).serverplayer=2
   plrindex=ti
  endif
 next ti
 if plrindex=0
  rem add player to array (use el)
  playermax=playermax+1
  dim player(playermax) as playertype
  dim playersound(playermax,220) as integer
  dim playersoundset$(playermax) as string
  dim playermovementstep(playermax) as integer
  dim playerinventory(playermax,100) as inventorytype
  plrindex=playermax
 endif
 rem set new player and slot
 multiplayerplrindex(el)=plrindex
 player(plrindex).serverplayer=1
 `
return

_server:
 `
 rem pretent FPI script tailoed for arena logic
 for e=1 to entityelementmax
  if entityelement(e).servercontrolled=1
   rem go through server-linked-players
   for mel=1 to multiplayeridlinkmax
    if multiplayeridlink(mel)<>1
     `
     rem Entity Info
     entid=entityelement(e).bankindex
     `
     rem pause while death/respawn happens (animwait set when death occurs)
     if entityprofile(entid).ischaracter=1
      if stateanimwait(mel)>0
       stateanimwait(mel)=stateanimwait(mel)-1
       if stateplayagain(mel)<>1 and stateanimwait(mel)=0 then stateanimwait(mel)=1
       if stateanimwait(mel)=0
        stateplayagain(mel)=0
        el=mel : plrindex=multiplayerplrindex(el)
        player(plrindex).health=100
        trandomvalue=1+rnd(respawnmax-1)
        tlifecode=rnd(255)
        gosub _multi_resetplrpos
        rem restart weapon inventory
        if el=iLocalEL
         tcopyorrestart=1 : gosub _gun_resetgunsettings
        endif
        rem update entities locally around player
        tupdatelocalentities=el
        rem server sends out 204 (to trigger respawn of dead player)
        MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
        write memblock byte 102, 0, 204
        write memblock byte 102, 1, trandomvalue
        write memblock byte 102, 2, tlifecode
        write memblock dword 102, 4, multiplayeridlink(el)
        MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
        inc guarenteedbytes,8 : inc unreliablebytes,0
        rem update all clients with this players new health
        tvalue=player(plrindex).health
        for tel=1 to multiplayeridlinkmax
         if multiplayeridlink(tel)<>1
          MULTIPLAYER SEND FROM PLAYER multiplayeridlink(tel)
          rem Update client player health
          write memblock byte 102, 0, 201
          write memblock dword 102, 4, multiplayeridlink(el)
          write memblock dword 102, 8, tvalue
          MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
          inc guarenteedbytes,12 : inc unreliablebytes,0
         endif
        next tel
       endif
      endif
     endif
     `
    endif
   next mel
  endif
 next e
 `
 rem update entities locally around player
 if tupdatelocalentities>0
  el=tupdatelocalentities
  if el=iLocalEL
   mex#=statex(el) : mey#=statey(el) : mez#=statez(el)
   gosub _entity_blastinitentities
  endif
  tupdatelocalentities=0
 endif
 `
 rem Server Monitors for objective completion
 tnumberofcurrentplayers=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   inc tnumberofcurrentplayers
  endif
 next el
 `
 tbroadcastresult=0
 if ggameobjectivetype=1
  rem any client/serverplayer can signal they have completed the mission (local AI message)
 endif
 if ggameobjectivetype=2
  rem server ends game when a player reaches desired frags
  if tnumberofcurrentplayers>1
   for el=1 to multiplayeridlinkmax
    if multiplayeridlink(el)<>1
     if frags(el)>=ggameobjectivevalue
      tbroadcastresult=el
      exit
     endif
    endif
   next el
  endif
 endif
 if ggameobjectivetype=3
  rem server monitors time and ends game when time expired
  if ((timer()-dwStartTime)/1024)>=ggameobjectivevalue
   highestel=1
   if tnumberofcurrentplayers>1
    for el=2 to multiplayeridlinkmax
     if multiplayeridlink(el)<>1
      if frags(el)>frags(highestel) then highestel=el
     endif
    next el
   endif
   tbroadcastresult=highestel
  endif
 endif
 if tbroadcastresult>0
  rem and then broadcast to clients
  winnerel=tbroadcastresult
  gosub _multi_informallplayersofcomplete
  rem announce as winner/loser directly
  gosub _multi_declarewinorlose
 endif
 `
 rem Send a keepalive trigger to master database every 10 minutes
 if (timer()-tenminutetimer)>600000
  gosub _ai_gamelist_keepalive
  tenminutetimer=timer()
 endif
 `
return

_multi_mptrigger:
 `
 if createorjoin=1
  rem if server player does trigger, direct do and send triggers out
  dwPlayerID=multiplayeridlink(iLocalEL)
  gosub _multi_serversendtriggers
 else
  rem send trigger message to server
  MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
  write memblock byte 102, 0, 251
  write memblock byte 102, 1, mptrigger
  write memblock word 102, 2, mptriggervalue1
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
return

_multi_serversendtriggers:
 `
 rem uses mptrigger, mptriggervalue1
 rem send trigger message to all clients (from server)
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   MULTIPLAYER SEND FROM PLAYER dwPlayerID
   write memblock byte 102, 0, 252
   write memblock byte 102, 1, mptrigger
   write memblock word 102, 2, mptriggervalue1
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
   inc guarenteedbytes,8 : inc unreliablebytes,0
  endif
 next el
 `
return

_multi_performtrigger:
 `
 rem perform locally, immediately
 `
 rem 1 - plrtake
 if mptrigger=1
  te=mptriggervalue1
  if te>0
   rem hide object
   tobj=entityelement(te).obj
   if tobj>0
    if object exist(tobj)=1 then hide object tobj : set object collision off tobj
   endif
   rem if child of spawn leader, reset spawn count
   tspawne=entityelement(te).spawn.leaderid
   if tspawne=0 then tspawne=te
   entityelement(tspawne).spawn.leadercount=entityelement(tspawne).spawn.delay
   rem remove entity
   entityelement(te).beenkilled=1
   entityelement(te).active=0
   rem clear entity from col map
   tx=entityelement(te).x/25
   ty=entityelement(te).y/100
   tz=entityelement(te).z/-25
   if tx>=0 and ty>=0 and tz>=0
    if tx<=viscolx and ty<=viscoly and tz<=viscolz
     if viscolmap(tx,ty,tz)=te then viscolmap(tx,ty,tz)=0
    endif
   endif
  endif
 endif
 `
 rem 2 - process logic instantly (colon/coloff)
 if mptrigger=2
  rem Command entity to process logic immediately (open doors/close doors/etc)
  te=mptriggervalue1
  if te>0
   entityelement(te).active=1
   entityelement(te).dormant=0
   entityelement(te).logiccount=0
   entityelement(te).logictimestamp=timer()
   ste=e : e=te : gosub _entity_addetoprioritylist : e=ste
  endif
 endif
 `
return

_client:
 `
 rem go through server-linked-players
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   te=characterchoiceentityindex(el)
   entid=entityelement(te).bankindex
   if entityprofile(entid).ischaracter=1
    if stateanimwait(el)>10
     stateanimwait(el)=stateanimwait(el)-1
    endif
   endif
  endif
 next mel
 `
 rem Handle local ID assignment when client comes online
 if MULTIPLAYER GET PLAYER COUNT()>=1
  if dwLocalPlayerID=0
   rem AT VERY START OF JOINING STAGE
   PlayerCanStartStage=1
   rem establish local player ID
   dwLocalPlayerID=MULTIPLAYER GET PLAYER ID(0)
   dwStartJoinTime=timer()
   rem Trigger server to send all init states (priority)
   write memblock byte 102, 0, 1
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,4
   inc guarenteedbytes,4 : inc unreliablebytes,0
  else
   rem find and fill local player index
   PlayerCanStartStage=2
   if iLocalEL=0
    for el=1 to multiplayeridlinkmax
     if multiplayeridlink(el)=dwLocalPlayerID
      iLocalEL=el : statemytimer(el)=timer() : exit
     endif
    next el
   endif
`  rem server ends (only when actually started game) - also wanted if host gone when joiner arrives
`  if PlayerCanStart=1
   rem server ends 5 second after started the join phase (or could have never been there)
   if timer()-dwStartJoinTime>5000
    if MULTIPLAYER GET CONNECTION()=0
     rem Terminate game if server player leaves
     gterminationcountdown=10
    endif
   endif
  endif
  rem if not voice setup, do it now
  if setupvoicechat=0
   setupvoicechat=1
  endif
 endif
 `
return

_playersend:
 `
 rem player sends data to server (only sends if client data changed since last send)
 if PlayerCanStart=1 or createorjoin=1
  `
  rem Regular burst of moveanim info
  if timer()-dwBurstTime>lagmon#
   rem reset bursttime counter (non-priority)
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
   dwBurstTime=timer()
   rem movement (if changed)
   tsendpos=0
   tcodesignaturex=(statex(iLocalEL)-(int(statex(iLocalEL)/500)*500))*1
   tcodesignaturey=(statey(iLocalEL)-(int(statey(iLocalEL)/500)*500))*500
   tcodesignaturez=(statez(iLocalEL)-(int(statez(iLocalEL)/500)*500))*25000
   tcodesignature=tcodesignaturex+tcodesignaturey+tcodesignaturez
   if statecodeupdate(iLocalEL,0)<>tcodesignature
    statecodeupdate(iLocalEL,0)=tcodesignature : tsendpos=1
   endif
   rem angle and animation and materialstoodon (if changed)
   tsendanim=0
   tcodesignature=stateviewy(iLocalEL)+(statecolmaterialtype(iLocalEL)*256)+(stateanim(iLocalEL)*(256*256))+(stateanimdir(iLocalEL)*123)
   if statecodeupdate(iLocalEL,4)<>tcodesignature
    statecodeupdate(iLocalEL,4)=tcodesignature : tsendanim=1
   endif
   if tsendpos=1 and tsendanim=1
    rem send both in one packet
    write memblock byte mb_move, 0, 9
    write memblock byte mb_move, 1, wrapvalue(statea(iLocalEL))/2
    x=statex(iLocalEL) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
    y=statey(iLocalEL) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
    z=abs(statez(iLocalEL)) : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
    write memblock word mb_move, 2, x
    write memblock word mb_move, 4, y
    write memblock word mb_move, 6, z
    write memblock byte mb_move, 8, wrapvalue(stateviewy(iLocalEL))/2
    write memblock byte mb_move, 9, stateanim(iLocalEL)
    write memblock byte mb_move, 10, 1+statecolmaterialtype(iLocalEL)
    write memblock byte mb_move, 11, stateanimdir(iLocalEL)
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,12
    inc guarenteedbytes,0 : inc unreliablebytes,12
   else
    rem one or the other
    if tsendpos=1
     write memblock byte mb_move, 0, 0
     write memblock byte mb_move, 1, wrapvalue(statea(iLocalEL))/2
     x=statex(iLocalEL) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
     y=statey(iLocalEL) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
     z=abs(statez(iLocalEL)) : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
     write memblock word mb_move, 2, x
     write memblock word mb_move, 4, y
     write memblock word mb_move, 6, z
     MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
     inc guarenteedbytes,0 : inc unreliablebytes,8
    endif
    if tsendanim=1
     write memblock byte mb_move, 0, 4
     write memblock byte mb_move, 1, wrapvalue(stateviewy(iLocalEL))/2
     write memblock byte mb_move, 2, stateanim(iLocalEL)
     write memblock byte mb_move, 3, 1+statecolmaterialtype(iLocalEL)
     write memblock byte mb_move, 4, stateanimdir(iLocalEL)
     MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
     inc guarenteedbytes,0 : inc unreliablebytes,8
    endif
   endif
   rem current health (if changed locally - if changed by server, update() is also updated)
   plrindex=multiplayerplrindex(iLocalEL)
   tcodesignature=player(plrindex).health
   if statecodeupdate(iLocalEL,2)<>tcodesignature
    statecodeupdate(iLocalEL,2)=tcodesignature
    rem client cannot send a health of zero (it could interfere with respawn)
    if player(plrindex).health>0
     write memblock byte 102, 0, 201
     write memblock dword 102, 4, multiplayeridlink(iLocalEL)
     write memblock dword 102, 8, player(plrindex).health
     MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
     inc guarenteedbytes,12 : inc unreliablebytes,0
    endif
   endif
   rem current weapon (if changed)
   plrindex=multiplayerplrindex(iLocalEL)
   tcodesignature=stateweapon(iLocalEL)
   if statecodeupdate(iLocalEL,3)<>tcodesignature
    statecodeupdate(iLocalEL,3)=tcodesignature
    te=characterchoiceentityindex(iLocalEL)
    write memblock byte 102, 0, 211
    write memblock byte 102, 1, entityelement(te).lifecode
    write memblock dword 102, 4, multiplayeridlink(iLocalEL)
    write memblock dword 102, 8, stateweapon(iLocalEL)
    MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
    inc guarenteedbytes,12 : inc unreliablebytes,0
   endif
   `
  endif
  `
 endif
 `
return

_multi_playershoots:
 `
 rem Trigger a shot flash and sound on other clients
 MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
 write memblock byte mb_move, 0, 5
 MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
 inc guarenteedbytes,0 : inc unreliablebytes,8
 `
return

_multi_dieanim:
 rem work out relative direction to throw entity from entity angle
 sourcete=characterchoiceentityindex(sourceel)
 brayx1#=entityelement(sourcete).x
 brayz1#=entityelement(sourcete).z
 tdir=0
 te=characterchoiceentityindex(el)
 distx#=entityelement(te).x-brayx1# : distz#=entityelement(te).z-brayz1#
 tentitya#=wrapvalue(atanfull(distx#,distz#))-wrapvalue(stateviewy(el))
 if tentitya#<0.0 then tentitya#=tentitya#+360.0
 if tentitya#>=360.0 then tentitya#=tentitya#-360.0
 if tentitya#>180-45 and tentitya#<180+45
  tdir=1
 else
  if tentitya#>315 or tentitya#<45
   tdir=2
  else
   if tentitya#>45 and tentitya#<180-45
    tdir=4
   else
    tdir=3
   endif
  endif
 endif
 rem Choose a good die anim (based on direction of shooter)
 stateanim(el)=12 : stateanimdir(el)=0
 if tdir=1 then stateanim(el)=12
 if tdir=2 then stateanim(el)=15
 if tdir=3 then stateanim(el)=21
 if tdir=4 then stateanim(el)=18
 rem Wipe out local health (so corpose can switch off radial collision)
 tplrindex=multiplayerplrindex(el) : player(tplrindex).health=0
 rem EL play die animation, timing it to end before a restart
 stateanimwait(el)=200
 rem ensure cannot respawn until plr has clicked to respawn
 stateplayagain(el)=0
 rem store who did it
 statewhodidit(el)=sourceel
 rem and freeze activity of states (which counts down after animwait is zero)
 stategetready(el)=50
 rem trigger sound for death-froan (excluded from regular takedamage subroutine)
 tplrid=entityelement(te).fakeplayerid : tsnd=15
 if playersound(tplrid,tsnd)>0
  if tplrid=1
   broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0)
   play sound playersound(tplrid,tsnd)
  else
   playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(te).x,entityelement(te).y,entityelement(te).z,10.0)
  endif
 endif
return

_multi_resetplrpos:
 `
 rem find spawn points from multiplayer spawn array (uses trandomvalue) (uses randomposnotworkatlocalstart=1)
 te=characterchoiceentityindex(el)
 gosub _multi_playertorespawnpos
 `
 rem give lifecode to plr
 entityelement(te).lifecode=tlifecode
 `
 rem make plr invincible at start for a while
 entityelement(te).invincibleactive=150
 `
 rem Spawn sound (using real entity plr index (for sound))
 plrindex=entityelement(te).fakeplrindex
 gosub _player_spawnsound
 `
 rem uses el
 statex(el)=playerstartx#
 statey(el)=playerstarty#
 statez(el)=playerstartz#
 statea(el)=playerstartry#
 stateanim(el)=2
 stateanimdir(el)=0
 stateanimwait(el)=0
 stateweapon(el)=0
 statesx(el)=statex(el)
 statesy(el)=statey(el)
 statesz(el)=statez(el)
 statesa(el)=statea(el)
 statedx(el)=statex(el)
 statedy(el)=statey(el)
 statedz(el)=statez(el)
 multiplayerisnew(el)=1
 px#=statex(el)
 py#=statey(el)
 pz#=statez(el)
 pa#=statea(el)
 gosub _packet_move
 if el=iLocalEL
  rem local plr - remove old plr marker and restart to new position
  gosub _player_unmark
  gosub _player_restart
 else
  rem non-local plr repositioning, ensure object is updated here (to defeat universe cull)
  tobj=entityelement(te).obj
  if tobj>0
   if object exist(tobj)=1
    position object tobj,statex(el),statey(el),statez(el)
   endif
  endif
 endif
 `
 rem Fill updates with blanks to repeat playersend info (fixes firing with no gun bug)
 for ti=0 to 4 : statecodeupdate(el,ti)=-1 : next ti
 `
return

_multi_dealdamagedirect:
 `
 rem find out which player was hit (TE) (takes sourcee)
 plrindex=0 : plrel=0 : tplrcntmax=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   if characterchoiceentityindex(el)=te and plrel=0 then plrindex=multiplayerplrindex(el) : plrel=el
   inc tplrcntmax
  endif
 next el
 el=plrel
 rem no damage needed if being respawned (so do not get killed twice in close proximity)
 if plrel>0 and stateanimwait(plrel)>0 then plrindex=0
 rem update all clients with new health reading
 if plrindex>0
  player(plrindex).health=player(plrindex).health-tdamage
  if player(plrindex).health<=0 or (goneshotkills=1 and tdamage>0)
   `
   rem Server Registers a Kill
   sourceel=0
   if sourcee>0
    rem increment frag count
    for sourceel=1 to multiplayeridlinkmax
     if characterchoiceentityindex(sourceel)=sourcee then exit
    next sourceel
    rem only if you did not kill yourself
    if sourceel<>el then frags(sourceel)=frags(sourceel)+1
    `
    rem only need to send frag to the guy who wants to know what he has
    MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
    write memblock byte 102, 0, 205
    write memblock byte 102, 1, frags(sourceel)
    write memblock dword 102, 4, multiplayeridlink(sourceel)
    write memblock dword 102, 8, multiplayeridlink(el)
    MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
    inc guarenteedbytes,12 : inc unreliablebytes,0
    `
   endif
   `
   rem Play die animation
   player(plrindex).health=0
   gosub _multi_dieanim
   rem inform player that they have been killed (who triggers dieanim)
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
   write memblock byte 102, 0, 202
   write memblock dword 102, 4, multiplayeridlink(el)
   write memblock dword 102, 8, multiplayeridlink(sourceel)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
   inc guarenteedbytes,12 : inc unreliablebytes,0
   `
  endif
  `
  rem Update client player health
  if tplrcntmax>1
   tvalue=player(plrindex).health
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
   write memblock byte 102, 0, 203
   write memblock dword 102, 4, multiplayeridlink(el)
   write memblock dword 102, 8, tvalue
   MULTIPLAYER SEND MESSAGE TO 2+multiplayeri(el)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
   MULTIPLAYER SEND MESSAGE TO 0
   inc guarenteedbytes,12 : inc unreliablebytes,0
  endif
  `
  rem if EL was hit, and is local, show damage by visual and sound
  if el=iLocalEL then gosub _multi_showplrdamage
  `
 endif
 `
return

_multi_dealentityedamage:
 `
 rem damage comes from caller of this subroutine
 sourcee=characterchoiceentityindex(iLocalEL)
 `
 rem replaces direct entity damage, by sending message to server (which will deduct the health)
 if createorjoin=1
  rem server player can deal damage direct, and then inform clients
  te=e : gosub _multi_dealdamagedirect
 else
  rem uses E which is the entity that has been damaged (client tells server to deal damage)
  MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
  write memblock byte 102, 0, 21
  write memblock byte 102, 1, entityelement(e).lifecode
  write memblock word 102, 2, e
  write memblock word 102, 4, tdamage
  write memblock word 102, 6, sourcee
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
return

_get_playerhealth:
 rem can be assigned high and low (any value)
 el=getelfromid(memblock dword(mb_move, 4))
 plrindex=multiplayerplrindex(el)
 tplayerhealth=memblock dword(mb_move, 8)
 player(plrindex).health=tplayerhealth
 if el=iLocalEL
  rem when own health adjusted remotely, ensure now sent BACK to server
  statecodeupdate(iLocalEL,2)=tplayerhealth
 endif
return

_multi_showplrdamage:
 rem hurt sound and visual
 tpe=characterchoiceentityindex(el)
 plrindex=entityelement(tpe).fakeplrindex
 tdamage=0 : gosub _player_takedamage
 rem no lives (multiplayer)
 if player(plrindex).lives<1 then player(plrindex).lives=1
return

_get_playerhurt:
 rem can only be assigned lower (as though shot)
 el=getelfromid(memblock dword(mb_move, 4))
 plrindex=multiplayerplrindex(el)
 tplayerhealth=memblock dword(mb_move, 8)
 if tplayerhealth>player(plrindex).health and memblock dword(mb_move, 4)=dwLocalPlayerID
  rem damage dealt by server to affected player cannot go UP
  rem fixes health value glitch where server messages are higher than latest local value
 else
  player(plrindex).health=tplayerhealth
  if el=iLocalEL
   rem when own health adjusted remotely, ensure now sent BACK to server
   statecodeupdate(iLocalEL,2)=tplayerhealth
  endif
 endif
 if el=iLocalEL then gosub _multi_showplrdamage
return

_multi_plrradial:
 `
 if multiplayerinitialised=1
  raddmin#=30
  for radel=1 to multiplayermax
   if radel<>iLocalEL
    if multiplayeridlink(radel)<>1
     tplrindex=multiplayerplrindex(radel)
     if tplrindex>0
      if player(tplrindex).health>0
       tte=characterchoiceentityindex(radel)
       if entityelement(tte).invincibleactive=0
        radx#=statedx(radel)-camerapositionx
        rady#=statedy(radel)-(camerapositiony-phyeyeheight#)
        radz#=statedz(radel)-camerapositionz
        if abs(rady#)<75
         radd#=sqrt(abs(radx#*radx#)+abs(radz#*radz#))
         if radd#<raddmin#
          rada#=atanfull(radx#,radz#)
          camvelx#=newxvalue(0,rada#,-5.0)
          camvelz#=newzvalue(0,rada#,-5.0)
          exit
         endif
        endif
       endif
      endif
     endif
    endif
   endif
  next radel
 endif
 `
return

_packet_move:
 `
 rem if newly joined, no history to curve from (avoids crazy rush across universe from 0,0,0)
 if multiplayerisnew(el)>0 and multiplayerisnew(el)<3
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz#
  statedx(el)=px# : statedy(el)=py# : statedz(el)=pz#
  multiplayerisnew(el)=multiplayerisnew(el)-1
 endif
 `
 rem move or no move
 if abs(statex(el)-px#)>1.0 or abs(statey(el)-py#)>1.0 or abs(statez(el)-pz#)>1.0
  eloff=((el-1)*5) : debugel=el
  statedx(el)=px# : statedy(el)=py# : statedz(el)=pz#
  statex(el)=statesx(el) : statey(el)=statesy(el) : statez(el)=statesz(el)
  cpx#(1)=statex(el) : cpy#(1)=statey(el) : cpz#(1)=statez(el) : set vector3 10+eloff,cpx#(1),cpy#(1),cpz#(1)
  tdx#=px#-statex(el)
  tdz#=statez(el)-pz#
  td#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))/2.0
  if statesvel(el)=0.0 then statesa(el)=atanfull(tdx#,tdz#)
  ix#=newxvalue(statex(el),statesa(el),td#)
  iy#=statey(el)
  iz#=newzvalue(statez(el),statesa(el)+180,td#)
  cpx#(2)=ix# : cpy#(2)=iy# : cpz#(2)=iz# : set vector3 11+eloff,cpx#(2),cpy#(2),cpz#(2)
  cpx#(3)=px# : cpy#(3)=py# : cpz#(3)=pz# : set vector3 12+eloff,cpx#(3),cpy#(3),cpz#(3)
  ix#=newxvalue(px#,pa#,td#)
  iy#=py#
  iz#=newzvalue(pz#,pa#+180,td#)
  cpx#(4)=ix# : cpy#(4)=iy# : cpz#(4)=iz# : set vector3 13+eloff,cpx#(4),cpy#(4),cpz#(4)
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz# : statesa(el)=pa#
  statesvel(el)=1.0
  statemsgap(el)=0
  statemove(el)=1
 else
  rem no movement, but update direction from static pose
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz# : statesa(el)=pa#
  statesvel(el)=0.0
  statemsgap(el)=0
  statemove(el)=0
 endif
 `
return

_packet_viewyanim:
 `
 rem turn or no turn
 statesviewdy(el)=pviewy#
 `
return

_packet_move_dedrec:
 `
 rem move position to follow spline based on time
 if statemove(el)=1
  if 1
   rem direct point to point
   timespan#=(1.0/200.0)*statemsgap(el)
   if timespan#>1.0 then timespan#=1.0 : statemove(el)=0
   eloff=((el-1)*5)
   cpx#=x vector3(10+eloff)
   cpy#=y vector3(10+eloff)
   cpz#=z vector3(10+eloff)
   rem move position of plr
   statex(el)=cpx#+((statesx(el)-cpx#)*timespan#)
   statey(el)=cpy#+((statesy(el)-cpy#)*timespan#)
   statez(el)=cpz#+((statesz(el)-cpz#)*timespan#)
  else
   rem catmulrom spline (changed vector numbers since)
`   lastx#=statex(el) : lasty#=statez(el)
`   timespan#=(2.0/statelag(el))*statemsgap(el)
`   eloff=((el-1)*5)
`   if timespan#>=0.0 and timespan#<1.0
`    CATMULLROM VECTOR3 5+eloff,1+eloff,1+eloff,2+eloff,3+eloff,timespan#
`    statex(el)=x vector3(5+eloff)
`    statey(el)=y vector3(5+eloff)
`    statez(el)=z vector3(5+eloff)
`    dfx#=statex(el)-lastx#
`    dfy#=lasty#-statez(el)
`    if abs(dfx#)+abs(dfy#)>0.01
`     statea(el)=wrapvalue(atanfull(dfx#,dfy#))
`    endif
`   else
`    if timespan#>=1.0 and timespan#<2.0
`     CATMULLROM VECTOR3 5+eloff,1+eloff,2+eloff,3+eloff,4+eloff,timespan#-1.0
`     statex(el)=x vector3(5+eloff)
`     statey(el)=y vector3(5+eloff)
`     statez(el)=z vector3(5+eloff)
`     dfx#=statex(el)-lastx#
`     dfy#=lasty#-statez(el)
`     if abs(dfx#)+abs(dfy#)>0.01
 `     statea(el)=wrapvalue(atanfull(dfx#,dfy#))
 `    endif
 `   endif
 `  endif
  endif
 endif
 `
return

_packet_rotate_dedrec:
 rem turn angle over time
 stateviewy(el)=curveangle(statesviewdy(el),stateviewy(el),8.0)
return

`
` User Interface Subroutines (screens/prompts)

_multi_identifycharactersinentities:
 `
 rem fill characters with names from characters in level
 tcharid=0
 characterlistentity(0)=0
 for te=1 to entityelementmax
  tentid=entityelement(te).bankindex
  if entityprofile(tentid).ischaracter=1
   inc tcharid : characterlist$(tcharid)=entityelement(te).eleprof.name$
   characterlistentity(tcharid)=te
  endif
 next te
 rem and adjust max players if not enough characters in level
 if numberofplayers>tcharid then numberofplayers=tcharid
 if tcharid>=2 and numberofplayers<2 then numberofplayers=2
 `
return

_multi_andwho:
 `
 rem first determine which entities the characters are
 gosub _multi_identifycharactersinentities
 `
 rem who is left
 characterlist(0)=0
 for tcl=1 to multiplayermax
  characterlist(tcl)=0
  for tcc=0 to numberofplayers-1
   if characterchosen(1+tcc)=tcl
    characterlist(tcl)=1
   endif
  next tcc
 next tcl
 `
 rem set text for choice
 set text size 12+((screen width()-320.0)/320.0)*6.0
 set text to normal
 `
 rem offer choice
 gap#=screen height()/20
 characterchoice=0
 if numberofplayers>=2
  repeat
   t$=strarr$(641)
   ink rgb(0,0,0),0 : center text screen width()/2,(gap#*2),t$
   ink rgb(255,255,255),0 : center text (screen width()/2)-1,(gap#*2)-1,t$
   for tcl=1 to numberofplayers
    t$=str$(tcl)+". "+characterlist$(tcl)
    ink rgb(0,0,0),0 : center text screen width()/2,(gap#*5)+((tcl-1)*gap#),t$
    if characterlist(tcl)=0 then ink rgb(255,255,255),0 else ink rgb(64,64,64),0
    center text (screen width()/2)-1,(gap#*5)+((tcl-1)*gap#)-1,t$
   next tcl
   k$=inkey$() : if k$>="1" and k$<="8" then characterchoice=(asc(k$)-asc("0"))
   sync
  until characterchoice>=1 and characterchoice<=numberofplayers
 else
  rem choose only character (if any)
  if numberofplayers=1
   characterchoice=1
  else
   characterchoice=0
  endif
 endif
 `
 rem restore text to in-game style and size
 set text size 16 : set text to normal
 `
return

_multi_cannotplay:
 `
 rem input tcannotplayreason
 repeat
  if tcannotplayreason=1 then t$=strarr$(642)
  if tcannotplayreason=2 then t$=strarr$(643)
  cls 0 : center text screen width()/2,(screen height()/2)-20,t$
  center text screen width()/2,(screen height()/2)+20,strarr$(644)
  sync
 until spacekey()=1
 `
return

_multi_missioncomplete:
 `
 rem announce as winner/loser directly
 winnerel=iLocalEL
 tbroadcastresult=iLocalEL
 if createorjoin=1
  rem broadcast that server has won to other players
  gosub _multi_informallplayersofcomplete
 else
  rem client must tell server to tell other players
  MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
  write memblock byte 102, 0, 105
  write memblock dword 102, 4, multiplayeridlink(tbroadcastresult)
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
 rem declare last after broascast(s)
 gosub _multi_declarewinorlose
 `
return

_multi_informallplayersofcomplete:
 `
 rem takes tbroadcastresult as EL winner
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
   write memblock byte 102, 0, 104
   write memblock word 102, 2, frags(el)
   write memblock dword 102, 4, multiplayeridlink(tbroadcastresult)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
   inc guarenteedbytes,8 : inc unreliablebytes,0
  endif
 next el
 `
return

_multi_declarewinorlose:
 `
 rem uses winnerel to determine winner identity
 if winnerel=iLocalEL
  tserverendsreason=2
 else
  tserverendsreason=3
 endif
 gosub _multi_serverendedgame
 mpgameinprogress=0
 continueokay=1
 `
return

_multi_serverendedgame:
 `
 rem setup vars for win/lose channel (0-lost,1-skip,2-won)
 if tserverendsreason=1
  levelwon=2 : rem skip
 else
  if tserverendsreason=2
   levelwon=1 : rem won
  else
   if tserverendsreason=3
    levelwon=0 : rem lost
   else
    levelwon=2 : rem skip
   endif
  endif
 endif
 `
return

`
` MP Functions
`

function getindexfromid(idin as dword)
 index=0
 for i = 1 to MULTIPLAYER GET PLAYER COUNT( )
  if MULTIPLAYER GET PLAYER ID( i-1 )=idin
   index=i : exit
  endif
 next i
endfunction index

function getelfromid(idin as dword)
 gotel=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)=idin
   gotel=el : exit
  endif
 next el
endfunction gotel
`
` SAVE LOAD SUBROUTINES
`
_saveload_maindialogloop:
 `
 rem loop to control save/load dialog
 gosub _saveload_savebox_load
 saveload.slotselected=0
 saveloadmousex=(screen width()/4)*3
 saveloadmousey=screen height()/2
 while saveload.slotselected=0
  gosub _saveload_savebox_run
  inc saveloadmousex,mousemovex() : inc saveloadmousey,mousemovey()
  if saveloadmousex<saveload.saveloadx then saveloadmousex=saveload.saveloadx
  if saveloadmousex>saveload.saveloadx+560 then saveloadmousex=saveload.saveloadx+560
  if saveloadmousey<saveload.saveloady then saveloadmousey=saveload.saveloady
  if saveloadmousey>saveload.saveloady+310 then saveloadmousey=saveload.saveloady+310
  paste image aihudpointerimagestore,saveloadmousex,saveloadmousey,1
  sync
 endwhile
 aifreezemouseclicks=0
 if saveload.loadswitch=1
  if saveload.slotselected>0 then gosub _saveload_savebox_doload
 else
  if saveload.slotselected>0 then gosub _saveload_savebox_dosave
 endif
 gosub _saveload_savebox_free
 `
return

_saveload_savebox_init:
 `
 rem Setup at veru start of game
 saveload.saveloadimg=530 : rem between muzzle flash and image bank
 saveload.saveloadx=(screen width()-600)/2
 saveload.saveloady=(screen height()-350)/2
 `
return

_saveload_savebox_earlygrab:
 `
 rem Grab screen and reduce to JPG file
 get image saveload.saveloadimg+3,(screen width()/2)-128,(screen height()/2)-128,(screen width()/2)+128,(screen height()/2)+128
 `
return

_saveload_savebox_initlist:
 `
 rem Create folder if not exist
 if path exist("gamesaves")=0 then make directory "gamesaves"
 `
 rem Load screen previews
 ttfile$="gamesaves\saveload.arr"
 if file exist(ttfile$)=1
  load array ttfile$,saveloadslot$()
 else
  for tclr=1 to 9 : saveloadslot$(tclr)=strarr$(645) : next tclr
 endif
 `
return

_saveload_savebox_load:
 `
 rem Load interface gfx
 saveload.saveloaddir$="languagebank\"+language$+"\gamecore\huds\saveload\"
 load image saveload.saveloaddir$+"saveload-base.tga",saveload.saveloadimg+1
 load image saveload.saveloaddir$+"areyousure.tga",saveload.saveloadimg+2
 `
 rem Create folder if not exist and init the list
 gosub _saveload_savebox_initlist
 `
 rem Load screen previews
 for sloti=1 to 9
  ttfile$="gamesaves\scrshot"+str$(sloti)+".jpg"
  if file exist(ttfile$)=1
   load image ttfile$,saveload.saveloadimg+10+sloti
  else
   if image exist(saveload.saveloadimg+10+sloti)=1 then delete image saveload.saveloadimg+10+sloti
  endif
 next sloti
 `
 rem Text for saveload box
 set text size 18 : set text font "arial"
 `
 rem Reset
 saveload.areyousure=0
 `
return

_saveload_savebox_free:
 `
 rem Free usages
 delete image saveload.saveloadimg+1
 delete image saveload.saveloadimg+2
 for sloti=1 to 9
  if image exist(saveload.saveloadimg+10+sloti)=1 then delete image saveload.saveloadimg+10+sloti
 next sloti
 `
return

_saveload_savebox_run:
 `
 rem Mouse coords
 tmmx=saveloadmousex : tmmy=saveloadmousey
 `
 rem Refresh saveload box
 paste image saveload.saveloadimg+1,saveload.saveloadx,saveload.saveloady
 `
 rem Slot names
 ink rgb(32,32,32),0
 if saveload.areyousure=0 then saveload.slothighlight=0
 for sloti=1 to 9
  thoverhighlight=0
  saveload.liney=saveload.saveloady+20+(sloti*27)
  if tmmx>=saveload.saveloadx+20 and tmmx<=saveload.saveloadx+300
   if tmmy>=saveload.liney and tmmy<saveload.liney+26
    if saveload.areyousure=0 then thoverhighlight=1
   endif
  endif
  if thoverhighlight=1
   if saveload.loadswitch=0 or saveloadslot$(sloti)<>strarr$(645)
    saveload.slothighlight=sloti
    ink rgb(255,255,255),0
   endif
  else
   ink rgb(32,32,32),0
  endif
  text saveload.saveloadx+25,saveload.liney+4,str$(sloti)+"  "+saveloadslot$(sloti)
 next sloti
 `
 rem Preview
 if saveload.slothighlight>0
  slotimg=saveload.saveloadimg+10+saveload.slothighlight
  if image exist(slotimg)=1 then paste image slotimg,saveload.saveloadx+320,saveload.saveloady+40,1
 endif
 `
 rem Title of box
 ink rgb(255,255,255),0
 if saveload.loadswitch=1
  center text saveload.saveloadx+300,saveload.saveloady+6,strarr$(646)
 else
  center text saveload.saveloadx+300,saveload.saveloady+6,strarr$(647)
 endif
 `
 rem Are You Sure prompt
 if saveload.areyousure=1
  tareyousurex=saveload.saveloadx+50
  tareyousurey=saveload.saveloady+130
  paste image saveload.saveloadimg+2,tareyousurex,tareyousurey
  rem choice detection
  tyesnochoice1=0 : tyesnochoice2=0
  if tmmy>=tareyousurey+15 and tmmy<tareyousurey+45
   if tmmx>=tareyousurex+400 and tmmx<=tareyousurex+450 then tyesnochoice1=1 : tyesnochoice2=0
   if tmmx>=tareyousurex+450 and tmmx<=tareyousurex+500 then tyesnochoice1=0 : tyesnochoice2=1
  endif
  if saveload.loadswitch=1 then suretext$=strarr$(648)+" "+saveloadslot$(saveload.slothighlight)+"?" else suretext$=strarr$(649)+" "+saveloadslot$(saveload.slothighlight)+"?"
  ink rgb(32,32,32),0 : text tareyousurex+30,tareyousurey+22,suretext$
  ink rgb(tyesnochoice1*255,tyesnochoice1*255,tyesnochoice1*255),0 : text tareyousurex+400,tareyousurey+22,strarr$(650)
  ink rgb(tyesnochoice2*255,tyesnochoice2*255,tyesnochoice2*255),0 : text tareyousurex+450,tareyousurey+22,strarr$(651)
  rem select one
  if mouseclick()=1 and (tyesnochoice1=1 or tyesnochoice2=1)
   saveload.areyousure=0 : while mouseclick()=1 : endwhile
   if tyesnochoice1=1 then saveload.slotselected=saveload.slothighlight
  endif
  rem Escape from confirmer box
  if escapekey()=1 then saveload.areyousure=0 : while escapekey()=1 : endwhile
 else
  rem Select slot
  if mouseclick()=1 and saveload.slothighlight>0
   rem Slot X selected
   sloti=saveload.slothighlight
   if saveloadslot$(sloti)=strarr$(645)
    if saveload.loadswitch=0
     saveload.slotselected=saveload.slothighlight
    endif
   else
    rem overwrite?
    saveload.areyousure=1
   endif
  endif
  if escapekey()=1
   saveload.slotselected=-1
   while escapekey()=1 : endwhile
  endif
 endif
 `
return

_saveload_savebox_dosave:
 `
 rem Fill details
 tname$=strarr$(652)+" "+str$(level)
 tdate$=left$(get time$(),5)+"-"+left$(get date$(),5)
 tnameanddate$=tname$+" "+tdate$
 `
 rem Make entry in slot list and save
 ttfile$="gamesaves\saveload.arr"
 if file exist(ttfile$)=1 then delete file ttfile$
 saveloadslot$(saveload.slotselected)=tnameanddate$
 save array ttfile$,saveloadslot$()
 `
 rem Save JPG to slot
 ttfile$="gamesaves\scrshot"+str$(saveload.slotselected)+".jpg"
 if file exist(ttfile$)=1 then delete file ttfile$
 save image ttfile$,saveload.saveloadimg+3,1
 `
 rem Actual slot filename
 saveloadfile$="gamesaves\slot"+str$(saveload.slotselected)+".dat"
 `
return

_saveload_savebox_doload:
 `
 rem Actual slot filename
 saveloadfile$="gamesaves\slot"+str$(saveload.slotselected)+".dat"

return


`
` SAVELOAD Actual Save and Load Game
`



_saveload_savegame:
 `
 rem CREATE SAVEGAMEDATA FROM GAME DATA
 gosub _saveload_storesavedata
 `
 rem SAVE
 if file exist(saveloadfile$)=1 then delete file saveloadfile$
 open to write 1,saveloadfile$
 version#=1.04 : write float 1,version#
 if version#<=1.04
  rem V104
  rem Player
  a#=saveloadgameposition.level : write float 1,a#
  a#=saveloadgameposition.playerx : write float 1,a#
  a#=saveloadgameposition.playery : write float 1,a#
  a#=saveloadgameposition.playerz : write float 1,a#
  a#=saveloadgameposition.playerry : write float 1,a#
  a#=saveloadgameposition.playerhealth : write float 1,a#
  a#=saveloadgameposition.playerlives : write float 1,a#
  a#=saveloadgameposition.playerinventorymax : write float 1,a#
  a#=saveloadgameposition.missiongoaltotal : write float 1,a#
  rem Inventory
  for lsi=0 to 100
   a#=saveloadgamepositionplayerinventory(lsi).new : write float 1,a#
   a#=saveloadgamepositionplayerinventory(lsi).drop : write float 1,a#
   a#=saveloadgamepositionplayerinventory(lsi).index : write float 1,a#
  next lsi
  rem Objectives
  for lsi=0 to 99
   a#=saveloadgamepositionplayerobjective(lsi) : write float 1,a#
  next lsi
  rem Entities
  a#=entityelementmax : write float 1,a#
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).spawnleaderid : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ailibindex : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aistate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aioldstate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).active : write float 1,a#
   a#=saveloadgamepositionentity(lsi).dormant : write float 1,a#
   a#=saveloadgamepositionentity(lsi).beenkilled : write float 1,a#
   a#=saveloadgamepositionentity(lsi).x : write float 1,a#
   a#=saveloadgamepositionentity(lsi).y : write float 1,a#
   a#=saveloadgamepositionentity(lsi).z : write float 1,a#
   a#=saveloadgamepositionentity(lsi).rx : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ry : write float 1,a#
   a#=saveloadgamepositionentity(lsi).rz : write float 1,a#
   a#=saveloadgamepositionentity(lsi).floorposy : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animset : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animdo : write float 1,a#
   a#=saveloadgamepositionentity(lsi).currentammo : write float 1,a#
   a#=saveloadgamepositionentity(lsi).health : write float 1,a#
   a#=saveloadgamepositionentity(lsi).collected : write float 1,a#
   a#=saveloadgamepositionentity(lsi).activated : write float 1,a#
   a#=saveloadgamepositionentity(lsi).collisionactive : write float 1,a#
  next lsi
  rem Weapons
  for lsi=0 to 10
   a#=saveloadgamepositionweaponslot(lsi).pref : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).got : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).invpos : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponammo : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponclipammo : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponhud : write float 1,a#
  next lsi
 endif
 close file 1
 `
return

_saveload_loadgame:
 `
 rem LOAD
 open to read 1,saveloadfile$
 read float 1,version#
 if version#<=1.04
  rem V104
  rem Player
  read float 1,a# : saveloadgameposition.level=a#
  read float 1,a# : saveloadgameposition.playerx=a#
  read float 1,a# : saveloadgameposition.playery=a#
  read float 1,a# : saveloadgameposition.playerz=a#
  read float 1,a# : saveloadgameposition.playerry=a#
  read float 1,a# : saveloadgameposition.playerhealth=a#
  read float 1,a# : saveloadgameposition.playerlives=a#
  read float 1,a# : saveloadgameposition.playerinventorymax=a#
  read float 1,a# : saveloadgameposition.missiongoaltotal=a#
  rem Inventory
  dim saveloadgamepositionplayerinventory(100) as inventorytype
  for lsi=0 to 100
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).new=a#
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).drop=a#
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).index=a#
  next lsi
  rem Objectives
  dim saveloadgamepositionplayerobjective(99)
  for lsi=0 to 99
   read float 1,a# : saveloadgamepositionplayerobjective(lsi)=a#
  next lsi
  rem Entities
  read float 1,a# : entityelementmax=a#
  dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).spawnleaderid=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ailibindex=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aistate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aioldstate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).active=a#
   read float 1,a# : saveloadgamepositionentity(lsi).dormant=a#
   read float 1,a# : saveloadgamepositionentity(lsi).beenkilled=a#
   read float 1,a# : saveloadgamepositionentity(lsi).x=a#
   read float 1,a# : saveloadgamepositionentity(lsi).y=a#
   read float 1,a# : saveloadgamepositionentity(lsi).z=a#
   read float 1,a# : saveloadgamepositionentity(lsi).rx=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ry=a#
   read float 1,a# : saveloadgamepositionentity(lsi).rz=a#
   read float 1,a# : saveloadgamepositionentity(lsi).floorposy=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animset=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animdo=a#
   read float 1,a# : saveloadgamepositionentity(lsi).currentammo=a#
   read float 1,a# : saveloadgamepositionentity(lsi).health=a#
   read float 1,a# : saveloadgamepositionentity(lsi).collected=a#
   read float 1,a# : saveloadgamepositionentity(lsi).activated=a#
   read float 1,a# : saveloadgamepositionentity(lsi).collisionactive=a#
  next lsi
  rem Weapons
  dim saveloadgamepositionweaponslot(10) as saveloadgamepositionweaponslottype
  for lsi=0 to 10
   read float 1,a# : saveloadgamepositionweaponslot(lsi).pref=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).got=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).invpos=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponammo=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponclipammo=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponhud=a#
  next lsi
 endif
 close file 1
 `
 rem Immediate data required (prior to level loading) - 'saveload_retrievesavedata' used after level loaded
 level=saveloadgameposition.level
 `
return

_saveload_storesavedata:
 `
 rem Move player data from actual game to the game data structures
 player(1).x=camerapositionx
 player(1).y=camerapositiony-phyeyeheight#
 player(1).z=camerapositionz
 `
 rem Create savedata arrays and copy game data to them
 saveloadgameposition.level=level
 saveloadgameposition.playerx=player(1).x
 saveloadgameposition.playery=player(1).y
 saveloadgameposition.playerz=player(1).z
 saveloadgameposition.playerry=camera angle y(0)
 saveloadgameposition.playerhealth=player(1).health
 saveloadgameposition.playerlives=player(1).lives
 saveloadgameposition.playerinventorymax=player(1).inventorymax
 saveloadgameposition.missiongoaltotal=missiongoaltotal
 rem Inventory
 dim saveloadgamepositionplayerinventory(100) as inventorytype
 for lsi=0 to 100
  saveloadgamepositionplayerinventory(lsi).new=playerinventory(lsi).new
  saveloadgamepositionplayerinventory(lsi).drop=playerinventory(lsi).drop
  saveloadgamepositionplayerinventory(lsi).index=playerinventory(lsi).index
 next lsi
 rem Objectives
 dim saveloadgamepositionplayerobjective(99)
 for lsi=0 to 99
  saveloadgamepositionplayerobjective(lsi)=playerobjective(lsi)
 next lsi
 rem Entities
 dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
 for lsi=0 to entityelementmax
  saveloadgamepositionentity(lsi).spawnleaderid=entityelement(lsi).spawn.leaderid
  saveloadgamepositionentity(lsi).ailibindex=entityelement(lsi).ai.libindex
  saveloadgamepositionentity(lsi).aistate=entityelement(lsi).ai.state
  saveloadgamepositionentity(lsi).aioldstate=entityelement(lsi).ai.oldstate
  saveloadgamepositionentity(lsi).active=entityelement(lsi).active
  saveloadgamepositionentity(lsi).dormant=entityelement(lsi).dormant
  saveloadgamepositionentity(lsi).beenkilled=entityelement(lsi).beenkilled
  saveloadgamepositionentity(lsi).x=entityelement(lsi).x
  saveloadgamepositionentity(lsi).y=entityelement(lsi).y
  saveloadgamepositionentity(lsi).z=entityelement(lsi).z
  tttobj=entityelement(lsi).obj
  if tttobj>0
   if object exist(tttobj)=1
    saveloadgamepositionentity(lsi).rx=object angle x(tttobj)
    saveloadgamepositionentity(lsi).ry=object angle y(tttobj)
    saveloadgamepositionentity(lsi).rz=object angle z(tttobj)
   endif
  endif
  saveloadgamepositionentity(lsi).floorposy=entityelement(lsi).floorposy
  saveloadgamepositionentity(lsi).animset=entityelement(lsi).animset
  saveloadgamepositionentity(lsi).animdo=entityelement(lsi).animdo
  saveloadgamepositionentity(lsi).currentammo=entityelement(lsi).currentammo
  saveloadgamepositionentity(lsi).health=entityelement(lsi).health
  saveloadgamepositionentity(lsi).collected=entityelement(lsi).collected
  saveloadgamepositionentity(lsi).activated=entityelement(lsi).activated
  saveloadgamepositionentity(lsi).collisionactive=entityelement(lsi).collisionactive
 next lsi
 rem Weapons
 dim saveloadgamepositionweaponslot(10) as saveloadgamepositionweaponslottype
 for lsi=0 to 10
  saveloadgamepositionweaponslot(lsi).pref=weaponslot(lsi).pref
  saveloadgamepositionweaponslot(lsi).got=weaponslot(lsi).got
  saveloadgamepositionweaponslot(lsi).invpos=weaponslot(lsi).invpos
  saveloadgamepositionweaponslot(lsi).weaponammo=weaponammo(lsi)
  saveloadgamepositionweaponslot(lsi).weaponclipammo=weaponclipammo(lsi)
  saveloadgamepositionweaponslot(lsi).weaponhud=weaponhud(lsi)
 next lsi
 `
return

_saveload_retrievesavedata:
 `
 rem Create savedata arrays and copy game data to them
 `level=saveloadgameposition.level (already done when loaded savedata)
 player(1).x=saveloadgameposition.playerx
 player(1).y=saveloadgameposition.playery
 player(1).z=saveloadgameposition.playerz
 player(1).health=saveloadgameposition.playerhealth
 player(1).lives=saveloadgameposition.playerlives
 player(1).inventorymax=saveloadgameposition.playerinventorymax
` missiongoaltotal=saveloadgameposition.missiongoaltotal
 rem Inventory
 for lsi=0 to 100
  playerinventory(lsi).new=saveloadgamepositionplayerinventory(lsi).new
  playerinventory(lsi).drop=saveloadgamepositionplayerinventory(lsi).drop
  playerinventory(lsi).index=saveloadgamepositionplayerinventory(lsi).index
 next lsi
 rem Objectives (FPSCV104RC4 - put back for this version)
 rem and also added to to objective countdown which resets objectives
 gsaveloadobjectivesloaded=1
 for lsi=0 to 99
  playerobjective(lsi)=saveloadgamepositionplayerobjective(lsi)
 next lsi
 rem Entities
 for lsi=1 to entityelementmax
  `
  entityelement(lsi).spawn.leaderid=saveloadgamepositionentity(lsi).spawnleaderid
  entityelement(lsi).active=saveloadgamepositionentity(lsi).active
  entityelement(lsi).dormant=saveloadgamepositionentity(lsi).dormant
  entityelement(lsi).beenkilled=saveloadgamepositionentity(lsi).beenkilled
  `
  lsientid=entityelement(lsi).bankindex
  if entityprofile(lsientid).ischaracter=0
   `entityelement(lsi).ai.libindex=saveloadgamepositionentity(lsi).ailibindex
   if entityprofile(lsientid).ismarker>0
    entityelement(lsi).ai.state=saveloadgamepositionentity(lsi).aistate
   endif
   `entityelement(lsi).ai.oldstate=saveloadgamepositionentity(lsi).aioldstate
   entityelement(lsi).x=saveloadgamepositionentity(lsi).x
   entityelement(lsi).y=saveloadgamepositionentity(lsi).y
   entityelement(lsi).z=saveloadgamepositionentity(lsi).z
   `entityelement(lsi).rx=saveloadgamepositionentity(lsi).rx : rem see below
   `entityelement(lsi).ry=saveloadgamepositionentity(lsi).ry
   `entityelement(lsi).rz=saveloadgamepositionentity(lsi).rz
   entityelement(lsi).floorposy=saveloadgamepositionentity(lsi).floorposy
   `entityelement(lsi).animset=saveloadgamepositionentity(lsi).animset
   `entityelement(lsi).animdo=saveloadgamepositionentity(lsi).animdo
   `entityelement(lsi).collisionactive=saveloadgamepositionentity(lsi).collisionactive
  endif
  entityelement(lsi).currentammo=saveloadgamepositionentity(lsi).currentammo
  entityelement(lsi).health=saveloadgamepositionentity(lsi).health
  entityelement(lsi).collected=saveloadgamepositionentity(lsi).collected
  entityelement(lsi).activated=saveloadgamepositionentity(lsi).activated
  `
 next lsi
 rem Weapons
 for lsi=0 to 10
  weaponslot(lsi).pref=saveloadgamepositionweaponslot(lsi).pref
  weaponslot(lsi).got=saveloadgamepositionweaponslot(lsi).got
  weaponslot(lsi).invpos=saveloadgamepositionweaponslot(lsi).invpos
  weaponammo(lsi)=saveloadgamepositionweaponslot(lsi).weaponammo
  weaponclipammo(lsi)=saveloadgamepositionweaponslot(lsi).weaponclipammo
  weaponhud(lsi)=saveloadgamepositionweaponslot(lsi).weaponhud
 next lsi
 `
 rem Refresh game objects and player with new level states
 playerstartx#=player(1).x
 playerstarty#=player(1).y
 playerstartz#=player(1).z
 playerstartry#=saveloadgameposition.playerry
 playerstarthasweapon=0
 gosub _player_restart
 `
 rem Now refresh gun
 gosub _gun_loadonlypresent
 `
 rem Go through all entities and remove those which are no longer in level
 for e=1 to entityelementmax
  `
  rem entity identity
  entid=entityelement(e).bankindex
  obj=entityelement(e).obj
  `
  rem ignore characters (and spawned objects) (complex setups) unless removing them
  tentityhasbeenkilledsoremove=0 : if entityelement(e).beenkilled=1 then tentityhasbeenkilledsoremove=1
  if (entityprofile(entid).ischaracter=0 and entityelement(e).spawn.leaderid=0) or tentityhasbeenkilledsoremove=1
  `
  rem clear entity from col map
  thadcolbit=0
  tx=entityelement(e).x/25
  ty=entityelement(e).y/100
  tz=entityelement(e).z/-25
  if tx>=0 and ty>=0 and tz>=0
   if tx<=viscolx and ty<=viscoly and tz<=viscolz
    if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0 : thadcolbit=1
   endif
  endif
  if obj>0
   if object exist(obj)=1
    if entityelement(e).eleprof.physics<>0
     gosub _ode_switchoffe
    else
     set object collision off obj
    endif
   endif
  endif
  `
  if entityelement(e).active<>0 and tentityhasbeenkilledsoremove=0
   rem update object in relation to this entity
   if obj>0
    rem object itself
    if object exist(obj)=1
     rem position from entity pos, but rotation direct from savedata
     position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
     rotate object obj,saveloadgamepositionentity(e).rx,saveloadgamepositionentity(e).ry,saveloadgamepositionentity(e).rz
     rem create the physics body (if not child spawn entities)
     tspawnhide=0
     if entityelement(e).spawn.leaderid>0
      if entityelement(e).spawn.leader=0
       tspawnhide=1
      endif
     endif
     if tspawnhide=0
      if entityelement(e).spawn.leader=1
       rem spawn master does not need physics object
       gosub _ode_ensurephysicsobjvalid
      else
       rem everything else has physics to create
       gosub _ode_setupewithphysics
      endif
     else
      rem still need to reserve all obj ids with E
      gosub _ode_ensurephysicsobjvalid
     endif
     rem ensure animation is the same
     entityelement(e).animdo=1+entityelement(e).animset
    endif
   endif
   rem replace in colmap
   if thadcolbit=1
    tx=entityelement(e).x/25
    ty=entityelement(e).y/100
    tz=entityelement(e).z/-25
    if tx>=0 and ty>=0 and tz>=0
     if tx<=viscolx and ty<=viscoly and tz<=viscolz
      viscolmap(tx,ty,tz)=e
     endif
    endif
   endif
  else
   rem destroy this entity for good
   entityelement(e).active=0
   entityelement(e).dormant=0
   rem hide the object
   if obj>0
    if object exist(obj)=1
     hide object obj
     if tentityhasbeenkilledsoremove=1
      rem if it has been killed - drain health to zero
      entityelement(e).eleprof.cantakeweapon=0
      entityelement(e).health=0
      entityelement(e).ai.state=0
      entityelement(e).activated=0
      entityelement(e).obj=0
     endif
    endif
   endif
   rem stop any looping sound
   gosub _ai_stopentsounds
  endif
  `
  rem ignore characters
  endif
  `
 next e
 `
return      
