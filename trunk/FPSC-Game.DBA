rem FIRST PERSON GAME CREATOR GAME ENGINE - V1.20
rem Copyright (c) 2005, 2010 The Game Creators Ltd
rem
rem Used Under Public License:
rem  1. You CANNOT mae 'game creation' or 'level editor' software with this code
rem  2. You CANNOT make a 'game engine' for the purpose of selling it as an engine
rem  3. You CAN make a GAME with this source code for the purpose of selling it
rem
rem Requires DBPro Upgrade 7.5, and additionally requires:
rem plugins-licensed\DBProGameFX.dll
rem plugins-licensed\EnhancementsFREE.dll
rem plugins-licensed\EnhancementsOV.dll
rem plugins-licensed\DarkAI.dll
rem plugins-licensed\LightMapper.dll
rem plugins-user\DBProMultiplayerPlusDebug.dll
rem plugins-user\DBProODEDebug.dll
rem
rem For effortless multiplayer fun, ensure your firewall unblocks:
rem Port 2303 both UDP and TCP.
rem
rem NOTE: If you are compiling with your OWN project DBPROJ (remember Display Settings=HIDDEN)
rem
rem To produce a smaller, faster EXE, change the SETUP.INI in the Compiler folder to:
rem [DIRECTIVES]
rem RemoveSafetyCode=Yes
rem SafeArrays=No
rem
rem DBPro: http://darkbasicpro.thegamecreators.com
rem FPSC: http://www.fpscreator.com
rem
rem Credit to Airslide for help with Dark AI when it went into Fenix Mod
rem Credit to Hockeykid for his continued help integrating Dark AI
rem Credit to Robert Knox for help fixing up the engine and adding a cool HUD system
rem Credit to Flatlander for his code fixes and tireless alpha testing.
rem Credit to S4Real for continued support and some nice performance tweaks.

_start_engine:

rem Init app
sync on : sync rate 0

rem Get Actual screen resolution from desktop resolution
rem Scene Commander - renamed SW and SH to ScreenW and ScreenH as names too short.
if ScreenW=0 or ScreenH=0
 load dll "user32.dll",1
  ScreenW=call dll(1,"GetSystemMetrics",0)
  ScreenH=call dll(1,"GetSystemMetrics",1)
 delete dll 1
endif
global vsync

rem alpha v1.6 call kernel32 dll for better performance freq
Kernel32 =1
load dll "kernel32.dll",Kernel32
memptr = make memory(16)
call dll Kernel32, "QueryPerformanceFrequency", memptr
perftimer() = *memptr
delete dll Kernel32

Rem Scene Commander globals

Rem flashlight
global flashlighton=0 as boolean
global flashlightrange=350
global flashlightred=255:flashlightgreen=255:flashlightblue=255

rem wobble
global wobble#=0.0

rem new deaths
global tiltondeath=0
global tilton=0
global tiltspeed#=0.0
global temptilt=0
global thud=0
global tiltbounce=10
global justdone=0
rem video
global unskip=0
rem player forced actiona
global playeraction=0
global forcemove=0
rem allow force damage
global forcedamageon=1
rem guns
global crosshairon=1
global forcedslot=0
rem armour
global armour=100
global armouron=0
global armx=18
global army=8
global bodyon=0
rem air
global airon=0
global airleft=100
global airmax=100
global drowntime=2000
global airtime=2000
global airtimer=timer()
global drowntimer=timer()
global airx=24
global airy=8
global instantdrown=1
global lastsetair=0
global drowned=0
rem god mode
global isimmune=0
rem new syncrate
global syncrate as integer
rem control keys
global arrowkeyson=1
global jumponkey=1
global crouchonkey=1
global peekonkeys=1
global walkonkeys=1
global runkeys=1
rem compass - knxrb
global compassOn = 0
global compassX = 80
global compassY: compassY = screen height()- 80
global spritesPasted = 0
global gameStarted = 0
global madeCompass = 0
global needleSpin = 0
global compassSpin = 1
global compassobject=666666
global needleobject=666667
rem dark ai radar
global darkradar=0
global radarx:radarx=screen width()-80
global radary:radary=screen height()-80
global maderadar=0
global rotateblip=1
global radarrange=45
global radarobject=666669
global blipstart=666670
rem player speed mod
global speedmod#=100.0
rem radar/compass object as objective
global objectivemode=0
global istheobjective=0
global objectivex=80
global objectivey: objectivey=screen height() - 80
global madeobjective=0
global objectiveobject=666691
global maxslots=10
Rem Scene Commander water performance
Global waterflec=400
rem Scene Commander culling
global cullmode=1
global cullmodi=650
global plrfootfall=1
global forcealtswap=0
global moveplrx#=0.0
global moveplry#=0.0
global moveplrz#=0.0
global lastfired=0
global lastfiredtime=0
global noholster=1
global noairon=0
global drowndamage=1
global pickrange#=75.0
global lastpickrange#=75.0
global laststrength#=4000.0
global lastthrow#=100.0
global flashr=255
global flashg=255
global flashb=255
global flashrange=600
global spotflash=0
global playerdammult#=0.0
global resetonreload=0
global ecam=0
global lastcam=0
global custstart=0
global custend=0
global plrreloading=0
global lockangle=9999
global fieldoffire=45
global plrcamoffsetx#=0.0
global plrcamoffsety#=0.0
global plrcamoffsetz#=0.0
global plroffsetanglex#=0.0
global plroffsetangley#=0.0
global plroffsetanglez#=0.0
global linkx=0
global linky=0
global linkz=0
global plrcamoffseton=0
global playeraccmult#=1.0
global eplayercam=0
global showflak as boolean:showflak=1
global decalrange=800
global cullmodelast=cullmode
global cullmodechange=0
Rem Scene Commander - made global as otherwise it is being ignored in functions
global weaponammoindex=0
global ammooffset=0
global timeelapsed#=0.0

`global syncrate=80 rem rem out to fix speed
global plrdistance#=0.0
global spareselectkey=0
Rem Scene Commander, player maximum velocity reached, mainly for debug.
global pmaxX#=0.0
global pmaxY#=0.0
global pmaxZ#=0.0
global sizechange=0
global firstturnjump=0
global alwaysshowair as boolean:alwaysshowair=0
Rem Scene Commander - mouse button timers, for tracking firing and also for conditions which seemed a logical extention condition.
global lmbheld=0
global lmbheldtime=0
global rmbheld=0
global rmbheldtime=0
global jamadjust=0
global screengrabtimer=timer()
global forcecrouch=0

rem scene commander - average FPS for smoother movement
global nextave=1
dim fpsstore(80):for f=1 to 80:fpsstore(f)=80:next f

Rem Scene Commander end variables

if exeroot$<>"" then set dir exeroot$
rem Special build flags for 'genre' switch
global fpgchud$ : fpgchud$=""
global fpgchuds$ : fpgchuds$=""
global fpgcgenre : fpgcgenre=0
if runengineinframe=1
 rem FPSC - 260210 - engine in frame to run FPSC in an ActiveX frame
 fpgchud$="gun"
 fpgchuds$="guns"
 fpgcgenre=1
else
 if path exist("files\gamecore\equipment")=1
  rem FPGC - Equipment Only Genre (no weapons)
  fpgchud$="equipment"
  fpgchuds$="equipment"
  fpgcgenre=0
 else
  rem ONLY if not educational equipment based (not FPGC)
  if path exist("files\gamecore\guns")=1
   rem FPSC - Shooter Genre
   fpgchud$="gun"
   fpgchuds$="guns"
   fpgcgenre=1
  endif
 endif
 if fpgchud$=""
  exit prompt "Genre Unknown", "Init Error" : end
 endif
endif

Global exeroot$ : exeroot$=get dir$()

rem V118 - 110810 - knxrb - Hud Layers
global hudHName$ as string = ""

rem v118 - 110511 - cinematic hands global boolean flags and one tracking variable(terry cox) >>>>
global disablefirebutton as boolean : disablefirebutton = 0
global preventplrselectinggun as boolean : preventplrselectinggun = 0
global startcinematichands as boolean : startcinematichands = 0
global cinematichandsloop as boolean : cinematichandsloop = 0
global newweapon as boolean : newweapon = 0
global trackingcinematichandsloop as integer : trackingcinematichandsloop = 1
global disableblockingbutton as boolean : disableblockingbutton = 0
rem cinematic hands <<<<

rem - Global array for string variables
type uservar
 used as boolean
 name as string
 value as float
 newsystem as boolean
endtype
dim uservars() as uservar

Rem Hockeykid - 250210 - Dark AI added type for containers/layers
type containertype
   y# as float
   id as integer
endtype
global dim container(20) as containertype

Rem Hockeykid - 250210 - Dark AI global Variables
Global darkaiuni = 200000
Global plrkeyRheld : plrkeyRheld=0

rem NEXTGENBRANCH : DarkVoices
nextgenbranch=1

rem App Independent Data
dim filecollection$()

rem Time stamp outside level scope reset
global timestampactivitymax=0
global timestampactivityflagged=0
global timestampactivityindex=0
dim timestampactivity$(1000)
rem speed up
global timebasepercycle# as float : timebasepercycle#=0
global timebasepercyclestamp as DWORD : timebasepercyclestamp=timer()


rem FPGC - 090909 - mising media collector
dim missingmedia$(0)
empty array missingmedia$()
global missingmediacounter : missingmediacounter=0

rem FPSCV104RC9 - loading time readout to file
global gloadreportstate : gloadreportstate=0
global gloadreporttime : gloadreporttime=0
global gloadreportlasttime : gloadreportlasttime=0
global gloadreportindex : gloadreportindex=0
global loadreportarraydimmed : loadreportarraydimmed=0
Rem SAVE MEMORY! loadreport is rarley used! lets only dim the array when its being used!
`dim loadreport$(100000)

Rem Hockeykid - 250210 - Entity DarkAI
type darkaitype
 Rem save game
 daidestx as float
 daidestz as float
 daihasdest as integer
 Rem Misc
 control as integer
 follow as integer
 isdoor as integer
 aistop as integer
 state as integer
 running as boolean
 action as integer
 strafebuildup as integer
 runbuildup as integer
 useaim as integer
 aiy as float
 throwing as integer
 active as integer
 Rem Paths
 path as integer
 Rem Action mode
 actionmode as integer
 Rem Alert flags
 ehit as integer
 ambushed as integer
 ambushx# as float
 ambushy# as float
 ambushz# as float
 beenhurt as integer
 autoattackoff as integer
 Rem Delay Timers
 delay as integer
 delay2 as integer
 Rem Waypoints
 waypointstart as integer
 waypointfinish as integer
 waypointcurrent as integer
 waypointlast as integer
 waypointindex as integer
 waypointinc as integer
 Rem Call Teammates
 called as integer
 calldelay as integer
 calldelay2 as integer
 Rem Safe Zones
 issafezone as integer
 Rem Sounds
 hearingrange as integer
 Rem Teams
 team as integer
 Rem Melee
 meleedamage as integer
 Rem Cover
 movingtocover as integer
 coverx as float
 coverz as float
endtype

rem Scene Commander - set up new animation textures
global animationimagestart=666699
type ani
img as integer
entid as integer
speed as integer
looped as integer
paused as integer
endtype

dim animations(10) as ani

for f=1 to 10
animations(f).img=animationimagestart+f
next f


Rem Hockeykid - 160310 - Dark AI path type
Type pathtype
 id as integer
 x as float
 y as float
 z as float
Endtype

Rem Hockeykid - 300310 - Dark AI sound type
Type aisoundtype
 alive as integer
 x as float
 y as float
 z as float
 time as integer
 team as integer
Endtype

Rem Hockeykid - 050410 - Safe Zone UDT
Type AISafeZoneType
 x as float
 y as float
 z as float
 occupied as integer
Endtype

Rem Hockeykid - 250610 - Ai Factions
Global FactionArrayMax : FactionArrayMax=20
Global mutualfactionoff : mutualfactionoff=0
Type aifactiontype
 team as integer
 enemy as integer
 ally as integer
 neutral as integer
endtype

Rem Hockeykid - 040310 - Adding X10'a performance meter
rem Resource meter structures
dim resourcemeter(5)
dim resourcemeter#(5)
dim resourcemeterdest#(5)

rem FPGC - 050909 - game memory tracker (test game creates, editor uses to show in meter)
type gamememtabletype
 name$ as string
 memused as integer
endtype
dim gamememtable(0) as gamememtabletype
empty array gamememtable()
global gamememactuallyused : gamememactuallyused=0
global gamememactuallyusedrt  :gamememactuallyusedrt=0
global gamememresourceid : gamememresourceid=0
global mymousex as integer : mymousex=screen width()/2
global mymousey as integer : mymousey=screen height()/2

rem Data structure to old player save data
type saveplayerstatetype
 lives as integer
 health as integer
 weaponindexholding as integer
endtype
saveplayerstate as saveplayerstatetype
global hudhaveplayername as integer : hudhaveplayername=0
global localipaddress$ : localipaddress$=""
global serveripaddress$ : serveripaddress$=""
global playername$ : playername$=""
global soundfrequencymodifier : soundfrequencymodifier=0
Rem Team Death Match - Code used by kind permission on Plystire.
global showkills$ as byte
global allowscope$ as byte
global allowchat$ as byte
global serverhostname as string
global alwaysrun as integer
global cap as boolean
cap =0
global multi_match_type as byte
type team_frag
   teamname as string
   teamscore as integer
endtype
dim team_frags(0) as team_frag
empty array team_frags(0)
rem V109 BETA3 - added to control change to player jump height
global playerdefaultjumpheight : playerdefaultjumpheight=50.0 rem changed

rem V118 - store range, aspect and fov globally!
global realrange# : realrange#=9000.0
global realaspect# : realaspect#=4.0/3.0
global realfov# : realfov#=75.0
`
` FPSCV10X SAVE LOAD Data Structures
type saveloadtype
 saveloaddir$
 slothighlight
 saveloadimg
 saveloadx
 saveloady
 liney
 slotselected
 areyousure
 loadswitch
endtype
saveload as saveloadtype
dim saveloadslot$(9)

` FPGC Pause Mode Globals
`dim frozenframes#(65535)

type frozen
frames as integer
endtype

` FPSCV10X Game Position Data Structure
type saveloadgamepositiontype
 level
 playerx
 playery
 playerz
 playerrx
 playerry
 playerhealth
 playerlives
 playerinventorymax
 missiongoaltotal
 playerholdinggun
 meridinglift
 ambience
endtype
type saveloadgamepositionentitytype
 daistate as integer
 daidestx as float
 daidestz as float
 daihasdest as integer
 isdai as integer
 daiteam as integer
 spawnleaderid as integer
 ailibindex as integer
 aistate$ as string
 aioldstate$ as string
 active as integer
 dormant as integer
 beenkilled as integer
 x as float
 y as float
 z as float
 rx as float
 ry as float
 rz as float
 orx as float
 ory as float
 orz as float
 floorposy as float
 animset as integer
 animdo as integer
 animframe as float
 currentammo as integer
 health as integer
 collected as integer
 activated as integer
 collisionactive as integer
 actualtarget as integer
 waypointstate as integer
 waypointcurrent as integer
 waypointtracker as integer
 waypointdirection as integer
 waypointxstart as float
 waypointystart as float
 waypointzstart as float
 waypointxinc as float
 waypointyinc as float
 waypointzinc as float
 aiusinginternalai as integer
 aioldwaypointstate as integer
 aioldanimframe as float
 aiolddestanimframe as float
 spawnatstart as integer
 spawnupto as integer
 decalindex as integer
 decalmode as integer
 tsoundset0state as integer
 tsoundset1state as integer
 physics as integer
 alttextureused as integer
 videotexture as integer
 rem V118 - 120810 - knxrb - etimer fix from Scene Commander
 etimerpaused as integer
 etimer as integer
 lastdamagetimer as integer
 lastdamagepaused as integer
 animatespeed as float rem (markblosser)
 entitydammult# as float rem Scene Commander
 ishidden as integer rem Scene Commander
 cullstate as integer rem Scene Commander
 usefade as boolean rem Scene Commander
 onradar as integer rem Scene Commander
 radardistance as integer rem Scene Commander
 shotby as integer rem Scene Commander
 shotbyammo$ as string rem Scene Commander
 isimmune as integer
 camuse as integer
 camoffsetx as integer
 camoffsety as integer
 camoffsetz as integer
 offsetanglex as float
 offsetangley as float
 offsetanglez as float
 camrotx as integer
 camroty as integer
 camrotz as integer
 positionchanged as integer
 cullimmobile as integer
 isanobjective as integer
 objectiveradarrange as integer
 objectivecurrentrange as integer
 entityacc as float
 soundplaying as integer
 frozen as frozen
 delaydestroy as integer
 delaydestroytimer as integer
 delaytimeactive as integer

endtype
type saveloadgamepositionweaponslottype
 pref got invpos
 noselect
 weaponammo
 weaponclipammo
 weaponhud
endtype
saveloadgameposition as saveloadgamepositiontype
dim saveloadgamepositionplayerinventory(100) as inventorytype
dim saveloadgamepositionplayerobjective(99) as integer
dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
rem AirMod - Line Modified for Alternate Fire
dim saveloadgamepositionweaponslot(20) as saveloadgamepositionweaponslottype
`dim saveloadgamepositionweaponslot(10) as saveloadgamepositionweaponslottype
global gsaveloadobjectivesloaded : gsaveloadobjectivesloaded=0
global mefrozentype : mefrozentype=0
global mefrozen : mefrozen=0

rem V109 BETA5 - 060408 - moved from per-level area
rem Material settings outside level-loop (loaded once per game)
type materialsettingstype
 name$ as string
 tred0$ as string
 tred1$ as string
 tred2$ as string
 tred3$ as string
 noise as integer
 scrape$ as string
 scrapeid as integer
 impact$ as string
 impactid as integer
 destroy$ as string
 destroyid as integer
 freq as integer
 decal$ as string
 decalid as integer
 usedinlevel as integer
endtype
dim material(100) as materialsettingstype
global gmaterialmax=0

rem Debris usage on a per-game basis
dim debrisshapeindexused(8) as integer

rem Flak Profile Structure
type flakprofiletype
 lifespan as float
 xinc as float
 yinc as float
 zinc as float
 xspeed as float
 yspeed as float
 zspeed as float
 weight as float
 spinx as float
 bounceonhit as integer
 explodeonhit as integer
 damage as integer
 script$ as string
 collisionmode as integer
 physics as integer
 phyweight as integer
 phyfriction as integer
endtype

rem Flak Sound Data Structure
type flaksoundtype
 sndbounce$ as string
 sndbounceid as integer
 sndexplode$ as string
 sndexplodeid as integer
endtype

rem Flak Data Structure
type flaktype
 obj as integer
 name$ as string
 exponfloor$ as string
 exponfloorid as integer
 expinair$ as string
 expinairid as integer
 profile as flakprofiletype
 sound as flaksoundtype
 throwangle as integer
 throwforward as integer
 throwheight as integer
 usedinlevel as integer
 libindex as integer
 noexplode as integer
 blood as integer
 stick as integer
 sticklife as integer
 stickobj as integer
endtype
dim flak(flakmax) as flaktype
global flakmax=0
dim flakbank$(100)
global flakbankmax=0

rem lee - 140310 - declare former counters as floats (for timer based calcs)
global gamewarmupcount as float
global gunflashcount as float
global gunbrasscount as float
global gunsmokecount as float
global guntimercount as float

rem Init FPSC then leap to SETUP.INI loader
leavegamedataalone=0
gosub _FPSC_Full_Data_Init
goto _FPSC_Setup

rem Subroutine to completely construct FPSCData
_FPSC_Full_Data_Init:

`
` Performance globals
`

rem performance counters
global gprogressmax as integer
global dim perf(20) as DWORD
global gameperftimetracker as DWORD
global gameperftimestamp as DWORD
global gameperftimestamp2 as DWORD
global gameperftimestamplocal as DWORD
global gameperftotalcountTOP as DWORD
global gameperftotalcount as DWORD
global gameperflighting as DWORD
global gameperfplayer as DWORD
global gameperfentities1 as DWORD
global gameperfentities2 as DWORD
global gameperfentities3 as DWORD
global gameperfentities4 as DWORD
global gameperfentities5 as DWORD
global gameperfentities as DWORD
global gameperfai as DWORD
global gameperfgun as DWORD
global gameperfmisc as DWORD
global gameperfdebug as DWORD
global gameperfresttosync as DWORD
global gameperfphysics as DWORD
global gameperfsync as DWORD
global deactivatecollision=0
global entitysystemdisabled=0
global lightingsystemdisabled=0
gameperftimetracker=timer()

Rem Water
Global waterobj : waterobj=11
Global wateron : wateron=0
Global oldwaterheight# : oldwaterheight#=-1.0
Global prevwaterheight# : prevwaterheight#=-1.0
Global waterheight# : waterheight#=-1.0
Global tupdatewater : tupdatewater=0
Global waterfx : waterfx=11
Global waterbump# : waterbump#=0.2
Global playerunderwater : playerunderwater=0
Global tnearsurfaceofwater : tnearsurfaceofwater=100
Global waterred : waterred=255
Global watergreen : watergreen=255
Global waterblue : waterblue=255
Global excludewatercams : excludewatercams=0
Rem Scene Commander
Global watercurrent=0
Global waterflow=1

global createdestroymode
global createdestroye

rem logic control
global logicprioritycount=0
global logicprioritymax#=0.0

rem memory counters
dim mshot(500)
global mshoti=0
global mshotmem=0
global mshotfirst=0
global mshotmemlargest=0
global lastmshoti=0
global lastmshotmem=0
rem TDM - Plystire
global r# as byte
global g# as byte
global b# as byte
global autoswap as byte
global messagetime as integer
rem workload counters
dim wshot(400,4)
dim wshotmax(4)
global wshoti=0

rem raw text for HUD
global grawtextr=255
global grawtextg=0
global grawtextb=255
global grawtextx=50
global grawtexty=50
global grawtextsize : grawtextsize=0
global grawtextsizelast : grawtextsizelast=0
global grawtextfont$ : grawtextfont$=""
global grawtextfontlast$ : grawtextfontlast$=""
global grawtext$
global grawtextcount as float : grawtextcount=0

`
`AI Arrays
`
dim ischaracter(0)
Rem Also dim path array
dim points(0) as pathtype
Rem Dim sounds
dim aisound(100) as aisoundtype
Rem declare factions
dim aifaction(FactionArrayMax,FactionArrayMax) as aifactiontype
`
` Editors Data
`

rem Input Control System Data Structure
type inputsystemtype
 activemouse as integer
 xmouse as integer
 ymouse as integer
 xmousemove as integer
 ymousemove as integer
 wheelmousemove as integer
 mclick as integer
 lockdown as integer
 k$ as string
 mmx as integer
 mmy as integer
 localx# as float
 localy# as float
 kscancode as integer
 keypress as integer
 keycontrol as integer
 keyreturn as integer
 keyshift as integer
 keyleft as integer
 keyright as integer
 keyup as integer
 keydown as integer
 keyspace as integer
 constructselection as integer
 dorotation as integer
 domirror as integer
 doflip as integer
 doload as integer
 dosave as integer
 doopen as integer
 donew as integer
 donewarena as integer
 dosaveas as integer
 dosaveandrun as integer
 domodepaint as integer
 domodeselect as integer
 domodeart as integer
 domodeentity as integer
 domodewaypoint as integer
 dowaypointview as integer
 doentityrotate as integer
 dozoomin as integer
 dozoomout as integer
 doshrouddecrease as integer
 doshroudincrease as integer
 doshroudfull as integer
 doscrollleft as integer
 doscrollright as integer
 doscrollup as integer
 doscrolldown as integer
 domapresize as integer
 dolayerchange as integer
 dogroundmode as integer
 doundo as integer
 doredo as integer
 domapview as integer
 dozoomview as integer
 doautozoomview as integer
 dozoomviewmovex as integer
 dozoomviewmovey as integer
 dozoomviewmovez as integer
 dozoomviewrotatex as integer
 dozoomviewrotatey as integer
 dozoomviewrotatez as integer
 dosinglelayer as integer
 dopickmapid as integer
 doartresize as integer
 undoredoevent as integer
 undokeypress as integer
 tselcontrol as integer
 tselcut as integer
 tselcopy as integer
 tselfloor as integer
 tselpaste as integer
 tseldelete as integer
 tselwipe as integer
 tselsaveselection as integer
endtype
inputsys as inputsystemtype
global gplayercanpressenterhere as integer

rem UndoRedo list data structure
type undoredotype
 event as integer
 x as integer
 y as integer
 z as integer
 a as integer
 b as integer
endtype

rem Empty list with a single null event
dim undoredolist(0) as undoredotype
empty array undoredolist(0)
array insert at top undoredolist()

rem Browser Folder History
dim browserfolderhistory$(10)
global localdesc$=""

rem Globals for FPG handling
global currentSMFPGtype as integer : currentSMFPGtype=1
global currentSMFPG$ : currentSMFPG$="mygame.fpg"
global currentAMFPGtype as integer : currentAMFPGtype=2
global currentAMFPG$ : currentAMFPG$="myarena.fpg"
global currentFPGtype as integer : currentFPGtype=currentSMFPGtype
global currentFPG$ : currentFPG$=currentSMFPG$

rem Other structres
dim taunt$ ( 30 ) `TDM - Plystire
dim gunslots$ ( 10 )
dim listkey ( 32 )
dim list$( 100 )

rem Level handling
type leveltype
 fpm$ as string
 fpi$ as string
endtype

rem Project working on
global projectfilename$ : projectfilename$=""
global projectmodified : projectmodified=0

rem File List Buffer Array (multipurpose)
dim filelist$(0)
`
` Global Data and Arrays
`
rem additional globals for BUILD GAME speed-ups
global globalsmallsound=0 : rem used in BUILD GAME (set to soundid for small cloned sound) - 11/11/08
global currentlyintheAISCIPTloader=0 : rem used in BUILD GAME (AI SCRIPT so ignore images from AI scripts during build)

rem Resource Banks
global meshbankmax=0
global meshbankoffset=1000
dim meshbank$(100)
global texturebankmax=0
global texturebankoffset=1000
dim texturebank$(100)
global effectbankmax=0
global effectbankoffset=1000
dim effectbank$(100)
dim objecteffect(65535) : rem FPGC - 250310 - used to track which objects are using effects (for post processing)
global gfastboneeffectshaderidmax : gfastboneeffectshaderidmax=0
dim gfastboneeffectshaderid(1) as integer
dim soundbank$(10)
global soundbankmax=0
global soundbankoffset=1
global materialsoundoffset=10001
global materialsoundmax=0
global explodesoundoffset=11001
global explodesoundmax=0
dim prefabbank$(100)
dim prefabbanklocal$(100)
global prefabbankmax=100
dim selectionbank$(100)
dim selectionbanklocal$(100)
global entitybankmax=100
dim entitybank$(entitybankmax)
global particlebankmax=0
global particlebankoffset=1
dim gunbank$(100)
global gunbankmax=0
dim muzzlebank$(100)
global muzzlebankmax=0
dim brassbank$(100)
global brassbankmax=0
dim smokebank$(100)
global smokebankmax=0
dim smokely#(30) as float
`
rem Image order important for texture order
global imagebankmax=0
global muzzlebankoffset=500
global imagebankoffset=550
global effectmenuimagestart=400
dim imagebank$(500)
`
rem Object Resource Offsets (COMMON)
global realviewobjectoffset=1000
global realviewobjectoffsetend=0
global entityattachmentsoffset=8900 : rem FPSCV104 - changed from 9900 - extra 1000 for guns/shadows
global entityattachmentindex=0
global entityworkobjectoffset=10099
global entityobjectoffset=10100
global hudbankoffset=16050
global gunbankoffset=16100
global brassbankoffset=16150
global smokebankoffset=16200
global flakbankoffset=16300
global flakelementoffset=16350
global decalbankoffset=16450
global decalelementoffset=16500
global fragmentobjectoffset=17000
global fragmentobjectoffsetmax
global explodedecalobjstart=17500
global explodedecalobjmax
global explosionscorch
global explosionstressed
global editorwaypointoffset=18000
global editorwaypointoffsetmax=18499
global debugobjectoffset=18500
global editormarkeroffset=19000
`global editormarkeroffsetmax=19999
global editormarkeroffsetmax=19200
global gamdebugobjoffset=19300
global selectionbankoffset=20000
global entitybankoffset=30000
global gamehudimagesoffset=64500
global editorimagesoffset=65000
global editordrawlastimagesoffset=75000
global temporarymeshobject=65500
global physicsuniverseobj=65533
global physicsplayerborble=65534
rem Universe Builing Object Resources for entire universe
global universebuildobjstartoffset=70001
global universebuildobjendoffset=166000
global flakstickbankoffset=166001
global endofallobjectsoffset=166202

`
` Segment Data
`

rem Segment Profile Data Structure
type segmentprofileheadertype
 partmax as integer
 lastmeshmax as integer
 preventai as integer
endtype
rem V110 - 160508 - added flag to control portal generation
`type segmentprofilevistype overlay f r wb wr wf wl owb owr owf owl ctl ctr cbr cbl octl octr ocbr ocbl endtype
type segmentprofilevistype overlay f r wb wr wf wl owb owr owf owl ctl ctr cbr cbl octl octr ocbr ocbl portalmode endtype
type segmentprofileblueprinttype
 mode as integer
 symbol as integer
 floorsizey as integer
 sidesizex as integer
 sidesizey as integer
 sidesizez as integer
endtype
type segmentprofileproperties
 groundmode as integer
 kindof as integer
endtype
type materialtype
 index as integer
endtype
type segmentprofiletype
 partmode as integer
 meshname$ as string
 meshid as integer
 actuallimb as integer
 offx as float
 offy as float
 offz as float
 rotx as float
 roty as float
 rotz as float
 tex$ as string
 texd$ as string
 texn$ as string
 texs$ as string
 effect$ as string
 texid as integer
 texdid as integer
 texiid as integer
 texnid as integer
 texsid as integer
 effectid as integer
 transparency as integer
 colmode as integer
 vis as segmentprofilevistype
 blueprint as segmentprofileblueprinttype
 properties as segmentprofileproperties
 csgmesh$ as string
 csgmode as integer
 csgimmune as integer
 lightmode as integer
 multimeshmode as integer
 multimeshstart as integer
 material as materialtype
endtype
global segobjusedformapeditor=0
global segobjusedforsegeditor=0
global segidmastermax : segidmastermax=100
dim segmentprofileheader(segidmastermax) as segmentprofileheadertype
dim segmentprofile(segidmastermax,64) as segmentprofiletype

`
` Map Data
`

rem Prepare map data and texture
layermax=20 : maxx=40 : maxy=40
dim map(layermax,maxx,maxy)
mapid as DWORD
mapselection as DWORD
mapscaler as DWORD
mapground as DWORD
maprotate as DWORD
maporient as DWORD
mapsymbol as DWORD
maptile as DWORD

rem Visible-Col-Map used for per-cycle quick entity collision checks
viscolx=160 : viscoly=20 : viscolz=160
dim viscolmap(viscolx,viscoly,viscolz)

rem Prepare entity reference map (references entityelementlist indexes)
dim refmap(layermax,maxx,maxy) as DWORD
newptrbase as DWORD
refptrbase as DWORD
ptrbase as DWORD
refptr as DWORD
ptr as DWORD

rem Map Overlay (stacked segment list)
dim mapolay(layermax,maxx,maxy)
global olaylistmax : olaylistmax=100
dim olaylist(olaylistmax,50) as DWORD

rem Default settings
gridzoom#=1.0
`global shroudsize : shroudsize=10 : rem now taken from SETUP.INI so lower end machines can restore shroud to 5! MOVED TO REST OF SETUP VARS
gridground=0
gridselection=1
nogridsmart=-1
gridlayer=5
bufferlayer=-1
gridlayershowsingle=0
grideditartwidth=1
grideditartwidthx=1
grideditartwidthy=1
locallibrarysegidmaster=0
locallibraryentidmaster=0
locallibraryentindex=0
dim locallibraryent(locallibraryentindex)

rem Grid Entity globals
gridentitylight as entitylighttype
gridentitytrigger as entitytriggertype

rem Master Mesh Data Structure
type mapentriestype vertmax1 vertmax2 indexmax1 indexmax2 endtype
type mastermeshtype obj buffer layer worldx worldy endtype

rem Create master mesh array
mastermeshmax=0
mastermeshsize=1
mastermeshsets=1
firstmeshobject=101
currentmeshobject=firstmeshobject
dim mapentries(mastermeshsize,mastermeshsets,40,40) as mapentriestype
dim mastermesh(mastermeshsize,mastermeshsets) as mastermeshtype

rem FPGC - 030909 - resource counter to help prevent kids adding crazy amounts of stuff
global editorresourcecounter# : editorresourcecounter#=0
global editorresourcecounterpacer : editorresourcecounterpacer=0

`
` Entity Data
`

rem Entity Profile Data Structure
type entityprofileheadertype
 desc$ as string
endtype
type entityanimtype
 start as integer
 finish as integer
 found as integer
endtype
type entityfootfall
 keyframe as integer
 soundtype as integer
endtype
type entitylighttype
 index as integer
 islit as integer
 color as DWORD
 range as integer
 offsetup as integer
 offsetz as integer
endtype
type entitytriggertype
 areax1 as integer
 areax2 as integer
 areay1 as integer
 areay2 as integer
 areaz1 as integer
 areaz2 as integer
endtype
type entityprofiletype
 aiinit$ as string
 aimain$ as string
 aidestroy$ as string
 aishoot$ as string
 soundset$ as string
 soundset1$ as string
 usekey$ as string
 ifused$ as string
 ifusednear$ as string
 spawnatstart as integer
 spawnmax as integer
 spawnupto as integer
 spawnafterdelay as integer
 spawnwhendead as integer
 spawndelay as integer
 spawnqty as integer
 spawndelayrandom as integer
 spawnqtyrandom as integer
 spawnvel as integer
 spawnvelrandom as integer
 spawnangle as integer
 spawnanglerandom as integer
 spawnlife as DWORD
 model$ as string
 offx as float
 offy as float
 offz as float
 rotx as float
 roty as float
 rotz as float
 scale as float
 fixnewy as float
 forwardfacing as integer
 defaultheight as float
 defaultstatic as integer
 collisionmode as integer
 materialindex as integer
 debrisshapeindex as integer
 coneheight as float
 coneangle as float
 hurtfall as integer
 texpath$ as string
 texd$ as string
 texdid as integer
 texaltd$ as string
 texaltdid as integer
 tex1id as integer
 tex2id as integer
 tex3id as integer
 tex4id as integer
 texidmax as integer
 effect$ as string
 usingeffect as integer
 castshadow as integer
 transparency as integer
 reducetexture as integer
 strength as integer
 lives as integer
 speed as integer
 isimmobile as integer
 ischaracter as integer
 cantakeweapon as integer
 isweapon$ as string
 isweapon as integer
 isammo as integer
 hasweapon$ as string
 hasweapon as integer
 ishealth as integer
 isflak as integer
 limbmax as integer
 headlimb as integer
 spine as integer
 spine2 as integer
 firespotlimb as integer
 animmax as integer
 footfallmax as integer
 quantity as integer
 ismarker as integer
 markerindex as integer
 islightmarker as integer
 isobjective as integer
 light as entitylighttype
 trigger as entitytriggertype
 decalmax as integer
 bloodscorch as integer
 rateoffire as integer
 damage as integer
 accuracy as integer
 reloadqty as integer
 fireiterations as integer
 lifespan as float
 throwspeed as float
 throwangle as float
 bounceqty as integer
 explodeonhit as integer
 weaponisammo as integer
 raisefactor as integer
 physics as integer
 phyalways as integer
 phyweight as integer
 phyfriction as integer
 phyforcedamage as integer
 rotatethrow as integer
 explodable as integer
 explodedamage as integer
 headframestart as integer
 headframefinish as integer
 decaloffsetangle as float
 decaloffsetdist as float
 decaloffsety as float
 noragdoll as integer
 nothrowscript as integer
 reserve2 as integer
 reserve3 as integer
 reserve4 as integer
 reserve5 as integer
 custombiped as boolean
Rem Scene Commander scaling/both limb and overall.
 LC as integer
 RC as integer
 LF as integer
 RF as integer
 LT as integer
 RT as integer
 LH as integer
 RH as integer
 LFA as integer
 RFA as integer
 LUA as integer
 RUA as integer
 SP3 as integer
 NECK as integer
endtype
global animmax=200
global footfallmax=200
global entidmastermax=100
dim entitybodypart(100,100) as integer
dim entityanim(100,animmax) as entityanimtype
dim entityfootfall(100,footfallmax) as entityfootfall
dim entityprofileheader(100) as entityprofileheadertype
dim entityprofile(100) as entityprofiletype
dim entitydecal$(100,100) as string
dim entitydecal(100,100) as integer

rem AirMod - Advanced Blood Effects >>
#constant BLOODMAX 10
type entitybloodtype
 x# as float
 y# as float
 z# as float
 oldx# as float
 oldy# as float
 oldz# as float
 angley# as float
 anglex# as float
 delay as integer
 spawndelay as integer
 active as boolean
 mode as integer
endtype
dim entityblood(100,BLOODMAX) as entitybloodtype
rem AirMod - Done <<

rem Waypoint Component of entity element
type aiwaypointtype
 state as integer
 current as integer
 tracker as integer
 direction as integer
 timefrom as DWORD
 xstart as float
 ystart as float
 zstart as float
 xinc as float
 yinc as float
 zinc as float
 timeslice as DWORD
endtype

rem AI Component of entity element
type aistatustype
 libinit as integer
 libmain as integer
 libdestroy as integer
 libshoot as integer
 libindex as integer
 state$ as string rem GUI-X9 (String States)
 alphafade as float
 destalphafade as float
 alphafadeupdate as integer
 headangle as float
 headdestangle as float
 headdownangle as float
 waypoint as aiwaypointtype
 usinginternalai as integer
 oldstate$ as string rem GUI-X9 (String States)
 oldalphafade as float
 oldwaypointstate as integer
 headshot as integer
 oldanimframe as float
 olddestanimframe as float
endtype

rem SPAWN Component of entity element
type spawntype
 atstart as integer
 max as integer
 delay as integer
 qty as integer
 upto as integer
 afterdelay as integer
 whendead as integer
 delayrandom as integer
 qtyrandom as integer
 vel as integer
 velrandom as integer
 angle as integer
 anglerandom as integer
 life as DWORD
 leader as integer
 leadercount as float
 leaderid as integer
 x as float
 y as float
 z as float
endtype

rem FORCE Component of entity element
type forcetype
 active as integer
 ix as float
 iy as float
 iz as float
endtype

rem MOVEMENT Component of entity element
type movertype
 moved as integer
 stepcount as float
 dx as float
 dy as float
 dz as float
 da as float
 ix as float
 iy as float
 iz as float
 grav as float
 gravlasty as float
 inmotion as integer
 viewconeused as float
 run as integer
 strafe as integer
 slidevel as float
endtype

rem Decal Particle Structure
type decalparticletype
 offsety as float
 scale as integer
 randomstartx as float
 randomstarty as float
 randomstartz as float
 linearmotionx as float
 linearmotiony as float
 linearmotionz as float
 randommotionx as float
 randommotiony as float
 randommotionz as float
 mirrormode as integer
 camerazshift as float
 scaleonlyx as float
 lifeincrement as float
 alphaintensity as float
 rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
 animated as integer
endtype
global gotparticle as decalparticletype

rem Entity Element Custom Profile Data
type entityeleproftype
 name$ as string
 aiinit$ as string
 aiinit as integer
 aimain$ as string
 aimain as integer
 aidestroy$ as string
 aidestroy as integer
 aishoot$ as string
 aishoot as integer
 usekey$ as string
 ifused$ as string
 ifusednear$ as string
 scale as float
 coneheight as float
 coneangle as float
 uniqueelement as integer
 texd$ as string
 texdid as integer
 texaltd$ as string
 texaltdid as integer
 tex1id as integer
 tex2id as integer
 tex3id as integer
 tex4id as integer
 texidmax as integer
 effect$ as string
 usingeffect as integer
 transparency as integer
 strength as integer
 isimmobile as integer
 cantakeweapon as integer
 hasweapon$ as string
 hasweapon as integer
 quantity as integer
 isobjective as integer
 lives as integer
 markerindex as integer
 light as entitylighttype
 trigger as entitytriggertype
 basedecal$ as string
 particleoverride as integer
 particle as decalparticletype
 soundset$ as string
 soundset1$ as string
 spawnatstart as integer
 spawnmax as integer
 spawnupto as integer
 spawnafterdelay as integer
 spawnwhendead as integer
 spawndelay as integer
 spawnqty as integer
 spawndelayrandom as integer
 spawnqtyrandom as integer
 spawnvel as integer
 spawnvelrandom as integer
 spawnangle as integer
 spawnanglerandom as integer
 spawnlife as DWORD
 hurtfall as integer
 castshadow as integer
 reducetexture as integer
 speed as integer
 rateoffire as integer
 damage as integer
 accuracy as integer
 reloadqty as integer
 fireiterations as integer
 lifespan as float
 throwspeed as float
 throwangle as float
 bounceqty as integer
 explodeonhit as integer
 weaponisammo as integer
 spare1 as DWORD
 physics as integer
 phyalways as integer
 phyweight as integer
 phyfriction as integer
 phyforcedamage as integer
 rotatethrow as integer
 explodable as integer
 explodedamage as integer
 phydw1 as DWORD
 phydw2 as DWORD
 phydw3 as DWORD
 phydw4 as DWORD
 phydw5 as DWORD
endtype
rem Entity Elements Data
type entitytype
 enterwater as integer
 isflak as integer
 darkai as darkaitype
 curvcmx as integer
 curvcmy as integer
 curvcmz as integer
 spine as integer
 spiner as float
 spineraim as float
 eyeoffset as integer
 aimoved as integer
 aimovex as float
 aimovez as float
 ttarget as integer
 etimer as integer Rem Hockeykid - 250210 - added entity variable for etimer
 etimerpaused as integer rem V118 - 120810 - knxrb - etimer fix from Scene Commander
 lastdamagetimer as integer
 lastdamagepaused as integer
 editorfixed as integer
 servercontrolled as integer
 fakeplrindex as integer
 active as integer
 dormant as integer
 eleprof as entityeleproftype
 mover as movertype
 ai as aistatustype
 spawn as spawntype
 force as forcetype
 maintype as integer
 bankindex as integer
 profileobj as integer
 staticflag as integer
 obj as integer
 attachmentobj as integer
 attachmentbaseobj as integer
 attachmentweapontype as integer
 attachmentobjfirespotlimb as integer
 attachmentblobobj as integer
 x as float
 y as float
 z as float
 rx as float
 ry as float
 rz as float
 norotate as integer
 nogravity as integer
 dry as float
 floorposy as float
 colr as integer
 colg as integer
 colb as integer
 limbslerp as integer
 logiccount as float
 logiccountburst as integer
 logictimestamp as DWORD
 priorityai as integer
 priorityduration as integer
 raycastcount as integer
 raycastlaststate as integer
 nofloorlogic as integer
 crouchprofile as integer
 plrdist as float
 decalindex as integer
 decalmode as integer
 decalloop as float
 decalslotused as integer
 decalsizex as float
 decalsizey as float
 animset as integer
 animdir as integer
 animdo as integer
 animtime as integer
 animframe as float
 animspeed as float
 animonce as integer
 destanimframe as float
 animframeupdate as integer
 spinrate as integer
 spinvalue as float
 floatrate as integer
 floatvalue as float
 possibletarget as integer
 actualtarget as integer
 realtarget as integer
 targetinway as integer
 losttargetcount as integer
 actualtargetx as float
 actualtargety as float
 actualtargetz as float
 plrtrailindex as integer
 fakeplayerid as integer
 strafemode as integer
 currentweapon as integer
 currentclipammo as integer
 currentammo as integer
 fireweapon as float
 fireweapontimer as integer
 firestrength as integer
 firesoundloop as integer
 firesoundloopremote as integer
 firesoundlooptime as DWORD
 health as integer
 lifecode as integer
 beenkilled as integer
 shotdamage as integer
 shotdamagesource as integer
 shotdamagetype as integer
 rem Scene Commander, changed for timer system
 delaydamagecount as float
 delaydamagetimer as float
 delaydamagesource as integer
 delaydamage as integer
 delayimpact as integer
 delaydamagex# as float
 delaydamagey# as float
 delaydamagez# as float
 delaydir as integer
 collected as integer
 activated as integer
 collisionactive as integer
 invincibleactive as integer
 blockedby as integer
 blockedtox as integer
 blockedtoy as integer
 blockedtoz as integer
 soundset as integer
 soundset1 as integer
 soundlooping as integer
 soundistalking as integer
 alttextureused as integer
 videotexture as integer
 ragdollon as integer
 allowragdoll as integer
 reserve1 as integer
 reserve2 as integer
 reserve3 as integer
 reserve4 as integer
 reserve5 as integer
 rem AirMod - New Entity Info >>
 lastdamagex# as float
 lastdamagey# as float
 lastdamagez# as float
 nobulletcol as boolean
 isaltammo as integer
 Rem Airmod - Done <<<
 hideshadow as integer
 floorpositiony as float
 animatespeed as float rem set animate command speed (markblosser)
 entitydammult# as float rem Scene Commander
 ishidden as integer rem Scene Commander
 cullstate as integer rem Scene Commander
 usefade as boolean rem Scene Commander
 onradar as integer rem Scene Commander
 radardistance as integer
 Rem Scene Commander scaling/both limb and overall.
 LC as integer
 RC as integer
 LF as integer
 RF as integer
 LT as integer
 RT as integer
 LH as integer
 RH as integer
 LFA as integer
 RFA as integer
 LUA as integer
 RUA as integer
 spine2 as integer
 SP3 as integer
 NECK as integer
 shotby as integer
 shotbyammo$ as string
 isimmune as integer
 camuse as integer
 camoffsetx as integer
 camoffsety as integer
 camoffsetz as integer
 offsetanglex as float
 offsetangley as float
 offsetanglez as float
 camrotx as integer
 camroty as integer
 camrotz as integer
 positionchanged as integer
 cullimmobile as integer
 isanobjective as integer
 objectiveradarrange as integer
 objectivecurrentrange as integer
 entityacc as integer
 soundplaying as integer
 frozen as frozen
 distance as integer
 delaydestroy as integer
 delaydestroytimer as integer
 delaytimeactive as integer

endtype
rem Entity Breadcrumbs Data
type entitybreadcrumbstype
 x as float
 y as float
 z as float
endtype
global entityelementlist=0
global entityelementmax=100
grideleprof as entityeleproftype
dim entityelement(entityelementmax) as entitytype
dim entitybreadcrumbs(entityelementmax,50) as entitybreadcrumbstype
dim entitydebug$(entityelementmax)

rem New entity based shader variable array
global globalselectedshadermax as integer : globalselectedshadermax=4
global globalselectedshadervar as integer : globalselectedshadervar=1
dim entityshadervar(entityelementmax,globalselectedshadermax)

rem Segment and EntityProfile/EntityelementList Vars
global preidmaster : preidmaster=0
global segidmaster : segidmaster=0
global entidmaster : entidmaster=0
global entityelementlist : entityelementlist=0
global aiindexmaster : aiindexmaster=0
global waypointmax : waypointmax=0
global wayppointoneonlyflaw : wayppointoneonlyflaw=0
global gheadshotdamage : gheadshotdamage=65500
`
` Artificial Intelegence Data
`

rem AI constants
#constant AICONDNEVER 1
#constant AICONDALWAYS 2
#constant AICONDSTATE 3
#constant AICONDRANDOM 4
#constant AICONDHEALTH 5
#constant AICONDHEALTHLESS 6
#constant AICONDQUANTITY 7
#constant AICONDSPEED 8
#constant AICONDRATEOFFIRE 9
#constant AICONDHEALTHGREATER 10
#constant AICONDVAREQUAL 11
#constant AICONDVARNOTEQUAL 12
#constant AICONDVARGREATER 13
#constant AICONDVARLESS 14
#constant AICONDPLRHEALTHLESS 21
#constant AICONDPLRHEALTHGREATER 22
#constant AICONDLEVELEQUAL 31
#constant AICONDLEVELNOTEQUAL 32
#constant AICONDASSOCIATED 51
#constant AICONDSHADERVARIABLE 71
#constant AICONDSHADERVARIABLELESS 72
#constant AICONDSHADERVARIABLEGREATER 73
#constant AICONDPLRDISTWITHIN 101
#constant AICONDPLRDISTFURTHER 102
#constant AICONDPLRHIGHER 103
#constant AICONDANYWITHIN 104
#constant AICONDANYFURTHER 105
#constant AICONDPLRELEVWITHIN 106
#constant AICONDPLRELEVFURTHER 107
#constant AICONDPLRFACING 108
#constant AICONDPLRNOTFACING 109
#constant AICONDPLRUNDERWATER 110
#constant AICONDPLRALIVE 111
#constant AICONDUNDERWATER 120
#constant AICONDSHOTDAMAGE 121
#constant AICONDIFWEAPON 122
#constant AICONDSHOTDAMAGETYPE 123
#constant AICONDCANTAKE 131
#constant AICONDPLRCANBESEEN 151
#constant AICONDPLRCANNOTBESEEN 152
#constant AICONDPLRHASKEY 153
#constant AICONDPLRUSINGACTION 154
#constant AICONDACTIVATED 155
#constant AICONDPLRWITHINZONE 156
#constant AICONDENTITYWITHINZONE 157
#constant AICONDPLRINGUNSIGHT 158
#constant AICONDNEARACTIVATABLE 159
#constant AICONDNEWWEAPONCANBESEEN 161
#constant AICONDNOISEHEARD 171
#constant AICONDANYWITHINZONE 191
#constant AICONDANYKEYWITHINZONE 192
#constant AICONDRAYCAST 201
#constant AICONDRAYCASTUP 202
#constant AICONDRAYCASTBACK 203
#constant AICONDNORAYCASTUP 204
#constant AICONDFRAMEATEND 301
#constant AICONDFRAMEATSTART 302
#constant AICONDFRAMEWITHIN 303
#constant AICONDFRAMEBEYOND 304
#constant AICONDANIMATIONOVER 305
#constant AICONDREACHTARGET 351
#constant AICONDLOSETARGET 352
Rem Hockeykid - 250210 - Dark AI conditions
#constant AICONDDARKAISTRAFEL 353
#constant AICONDDARKAISTRAFER 354
#constant AICONDDARKAIMOVINGF 355
#constant AICONDDARKAIIDLE 356
#constant AICONDDARKAIMOVINGB 357
#constant AICONDDARKAICANSHOOT 358
#constant AICONDDARKAISTRAFELA 359
#constant AICONDAIDUCKING 360
#constant AICONDAIHEARDSOUND 361
#constant AICONDAIACTION 362
#constant AICONDAIISAI 363
#constant AICONDAITEAM 364
#constant AICONDAIATPOINT 365
#constant AICONDAICALLED 367
#constant AICONDAITARGETDISTWITHIN 368
#constant AICONDAITARGETDISTFURTHER 369
#constant AICONDAIATCOVER 370
#constant AICONDAICALLEDBYPLR 371
#constant AICONDAIHASTARGET 372
#constant AICONDDARKAIRUNNINGF 373
Rem End Dark AI
#constant AICONDHEADANGLEGREATER 401
#constant AICONDHEADANGLELESS 402
#constant AICONDSOUNDFINISHED 451
#constant AICONDALPHAFADEEQUAL 471
#constant AICONDWAYPOINTSTATE 501
#constant AICONDIFMARKER 551
#constant AICONDIFPLRTRAIL 552
#constant AICONDHUDSELECTIONMADE 801
#constant AICONDTIMERGREATER 811
#constant AICONDETIMERGREATER 812
#constant AICONDESCAPEKEYPRESSED 821
#constant AICONDHUDEDITDONE 822
#constant AICONDHUDHAVENAME 823
#constant AICONDSCANCODEKEYPRESSED 824
rem AirMod - New Conditions >>>
#constant AICONDPLRBLOCKING 825
#constant AICONDINVIEW 826
#constant AICONDPICKOBJECT 827
#constant AICONDVELOCITY 828
rem AirMod - Done <<<
#constant AICONDKEYPRESSED 829
#constant AICONDHASWEAPON 830
rem V118 - 110810 - knxrb - Hud Layers
#constant AICONDHUDSELECTED 831
rem V118 - 110810 - knxrb - Setup.ini Variable Conditions
#constant AICONDSETUPSHADER 832
#constant AICONDSETUPTEXQUALITY 833
#constant AICONDSETUPMOUSESENS 834
#constant AICONDSETUPASPECTRATIO 835
#constant AICONDSETUPPOSTPROCESSING 836
#constant AICONDSETUPWIDTH 837
#constant AICONDSETUPHEIGHT 838
#constant AICONDSETUPDEPTH 839
#constant AICONDSETUPANTIALIAS 840
#constant AICONDSETUPSHADOWS 841
rem V118 - 130810 - knxrb - Invert Mouse
#constant AICONDSETUPMOUSEINVERT 842
rem V118 - 120810 - knxrb - 'mousestate=X' command
#constant AICONDMOUSESTATE 843
rem V118 - 140810 - knxrb - Disable Particles
#constant AICONDSETUPPARTICLESUSED 844
rem V118 - 160810 - knxrb - Auto Resolution
#constant AICONDSETUPAUTORES 845
rem GUI-X9 (knxrb) >>>
#constant AICONDHUDMOUSEDOWN 846
#constant AICONDHUDMOUSEUP 847
#constant AICONDHUDMOUSEOVER 848
#constant AICONDLOADVISIBLE 849
#constant AICONDSAVEVISIBLE 850
#constant AICONDSTOPWATCHGREATER 851
#constant AICONDSTOPWATCHLESS 852
#constant AICONDSTOPWATCHRUNNING 853
#constant AICONDSETUPVAREQUAL 854
#constant AICONDCURSORIMAGE 855
#constant AICONDCHOICEVALUEEQUAL 856
#constant AICONDSLIDERVALUEEQUAL 857
rem GUI-X9 (knxrb) <<<

rem v118 - 110511 - cinematic hands - (terry cox) >>>>
`test to see if player is prevented from selecting a gun
#constant AICONDPREVENTEDSELECTINGGUN 858
rem cinematic hands <<<<

Rem Scene commander conditions
#constant AICONDMOUSECONDITION 870
#constant AICONDAIRGREATER 871
#constant AICONDAIRLESSER 872
#constant AICONDAIREQUAL 873
#constant AICONDSAMEFLOORASPLR 874
#constant AICONDPLRFLOOREQUAL 875
#constant AICONDENTFLOOREQUAL 876
#constant AICONDISIMMUNE 877
#constant AICONDWEAPONSGREATER 878
#constant AICONDWEAPONSLESSER 879
#constant AICONDWEAPONSEQUAL 880
#constant AICONDWEAPONINSLOT 881
#constant AICONDCURRENTWEAPON 882
#constant AICONDPLRRUNNING 883
#constant AICONDPLRCROUCHING 884
#constant AICONDZOOMED 885
#constant AICONDPLRUSINGRELOAD 886
#constant AICONDPLRONGROUND 887
#constant AICONDPLRJUMPING 888
#constant AICONDFIREMODE 889
#constant AICONDONRADAR 890
#constant AICONDLASTFIRED 891
#constant AICONDRADARGREATER 892
#constant AICONDRADAREQUAL 893
#constant AICONDENTITYPLRGREATER 894
#constant AICONDENTITYPLRLESSER 895
#constant AICONDFLOORHIGHER 896
#constant AICONDFLOORLOWER 897
#constant AICONDFLASHING 898
#constant AICONDSPAWNSLEFT 899
#constant AICONDSPAWNSGREATER 900
#constant AICONDSHOTBY 901
#constant AICONDNOTZOOMED 902
#constant AICONDPLRNOTRUNNING 903
#constant AICONDPLRNOTCROUCHING 904
#constant AICONDPLRNOTJUMPING 905
#constant AICONDPLRNOTUSINGRELOAD 906
#constant AICONDNOTONRADAR 907
#constant AICONDPLRCARRYING 908
#constant AICONDPLRNOTCARRYING 906
#constant AICONDLASTDAMAGETIME 907
#constant AICONDCURRENTJAMMED 908
#constant AICONDENTITYISIMMUNE 909
#constant AICONDENTITYISNOTIMMUNE 910
#constant AICONDPLRWEAPONIDLE 911
#constant AICONDPLRWEAPONNOTIDLE 912
#constant AICONDOBJECTRANGELESS 913
#constant AICONDOBJECTRANGEGREATER 914
#constant AICONDSOUNDPLAYING 915
#constant AICONDSOUNDNOTPLAYING 916
#constant AICONDWATEREQUAL 917
#constant AICONDWATERLESSER 918
#constant AICONDWATERGREATER 919
#constant AICONDWATERISON 920
#constant AICONDSHOTBYAMMO 921
#constant AICONDPLRFIRED 923
#constant AICONDPLRFIREDGREATER 924
#constant AICONDPLRFIREDLESSER 925
#constant AICONDSTATEGREATER 926
#constant AICONDSTATELESSER 927
#constant AICONDLMBGREATER 928
#constant AICONDLMBLESSER 929
#constant AICONDRMBGREATER 930
#constant AICONDRMBLESSER 931

#constant AICONDLAST 932

#constant AIACTNONE 0
#constant AIACTDESTROY 1
#constant AIACTSUSPEND 2
#constant AIACTFLOORLOGIC 11
#constant AIACTNOGRAVITY 12
#constant AIACTGLOBALVAR 31
#constant AIACTLOCALVAR 32
#constant AIACTSETVAR 33
#constant AIACTINCVAR 34
#constant AIACTDECVAR 35
#constant AIACTDIMVAR 36
#constant AIACTADDVAR 37
#constant AIACTSUBVAR 38
#constant AIACTMULVAR 39
#constant AIACTDIVVAR 40
#constant AIACTMODVAR 41
#constant AIACTWRAPVAR 42
#constant AIACTDIMLOCALVAR 43
#constant AIACTRUNFPIDEFAULT 51
#constant AIACTRUNFPI 52
#constant AIACTWIN 61
#constant AIACTSELECTSHADERVARIABLE 71
#constant AIACTSETSHADERVARIABLE 72
#constant AIACTINCSHADERVARIABLE 73
#constant AIACTDECSHADERVARIABLE 74
#constant AIACTSTATE 101
#constant AIACTINCSTATE 102
#constant AIACTMOVEUP 201
#constant AIACTMOVEFORE 202
#constant AIACTMOVEBACK 203
#constant AIACTFREEZE 204
#constant AIACTRUNFORE 205
#constant AIACTROTATEY 226
#constant AIACTROTATETOPLR 227
#constant AIACTROTATEIY 228
#constant AIACTNOROTATE 229
#constant AIACTRESETHEAD 231
#constant AIACTROTATEHEAD 232
#constant AIACTROTATEHEADRANDOM 233
#constant AIACTFORCEBACK 251
#constant AIACTFORCEFORE 252
#constant AIACTFORCELEFT 253
#constant AIACTFORCERIGHT 254
#constant AIACTFORCEBOUNCE 255
#constant AIACTSPINRATE 281
#constant AIACTFLOATRATE 282
#constant AIACTSETFRAME 301
#constant AIACTINCFRAME 302
#constant AIACTDECFRAME 303
#constant AIACTANIMATE 304
#constant AIACTADVFRAME 305
#constant AIACTANIMATIONNORMAL 306
#constant AIACTANIMATIONREVERSE 307
#constant AIACTSETTARGET 351
#constant AIACTROTATETOTARGET 352
#constant AIACTLOOKATTARGET 353
#constant AIACTMOVETOTARGET 354
#constant AIACTCOLLECTTARGET 355
#constant AIACTCHOOSESTRAFE 356
#constant AIACTSTRAFE 357
#constant AIACTPIVOTRANDOM 358
#constant AIACTLOOKATPLR 359
#constant AIACTSETTARGETNAME 360
#constant AIACTRAGDOLL 370
#constant AIACTCARRYALL 391
#constant AIACTPLRASS 401
#constant AIACTPLRNOASS 402
#constant AIACTPLRMOVEUP 403
#constant AIACTPLRMOVEDOWN 404
#constant AIACTPLRMOVEEAST 405
#constant AIACTPLRMOVEWEST 406
#constant AIACTPLRMOVENORTH 407
#constant AIACTPLRMOVESOUTH 408
#constant AIACTPLRMOVETO 409
#constant AIACTPLRMOVEIFUSED 410
#constant AIACTPLRFREEZE 411
#constant AIACTPLRDISABLE 412
#constant AIACTACTIVATEIFUSED 421
#constant AIACTACTIVATEIFUSEDNEAR 422
#constant AIACTACTIVATETARGET 423
#constant AIACTACTIVATE 424
#constant AIACTACTIVATEALLINZONE 425
#constant AIACTPLRADDHEALTH 431
#constant AIACTPLRSUBHEALTH 432
#constant AIACTPLRSETHEALTH 433
#constant AIACTADDHEALTH 441
#constant AIACTSUBHEALTH 442
#constant AIACTSETHEALTH 443
#constant AIACTSOUND 451
#constant AIACT3DSOUND 452
#constant AIACTLOOPSOUND 453
#constant AIACTSTOPSOUND 454
#constant AIACTTALK 455
#constant AIACTTALKORDERED 456
#constant AIACTTALKRANDOM 457
#constant AIACTALTTEXTURE 461
#constant AIACTSETALPHAFADE 471
#constant AIACTINCALPHAFADE 472
#constant AIACTDECALPHAFADE 473
#constant AIACTRUNDECAL 481
#constant AIACTSHAPEDECAL 482
#constant AIACTTRIGGERFORCE 491
#constant AIACTWAYPOINTSTART 501
#constant AIACTWAYPOINTSTOP 502
#constant AIACTWAYPOINTREVERSE 503
#constant AIACTWAYPOINTNEXT 504
#constant AIACTWAYPOINTPREV 505
#constant AIACTWAYPOINTRANDOM 506
#constant AIACTDROPMARKER 551
#constant AIACTNEXTMARKER 552
#constant AIACTRESETMARKERS 553
#constant AIACTFOLLOWPLR 554
#constant AIACTPLRTAKE 601
#constant AIACTPLRDROP 602
#constant AIACTPLRDROPCURRENT 603
#constant AIACTSHOOTPLR 701
#constant AIACTUSEWEAPON 711
#constant AIACTRELOADWEAPON 712
#constant AIACTCOLOFF 751
#constant AIACTCOLON 752
#constant AIACTETIMERSTART 753
#constant AIACTSPAWNON 761
#constant AIACTSPAWNOFF 762
#constant AIACTHEADSHOT 771
#constant AIACTHEADSHOTDAMAGE 772
#constant AIACTAMBIENCE 821
#constant AIACTAMBIENCERED 822
#constant AIACTAMBIENCEGREEN 823
#constant AIACTAMBIENCEBLUE 824
#constant AIACTFOG 831
#constant AIACTFOGRED 832
#constant AIACTFOGGREEN 833
#constant AIACTFOGBLUE 834
`markblosser - add fogstart,fogend commands
#constant AIACTFOGSTART 835
#constant AIACTFOGEND 836
`markblosser - set post process effect
#constant AIACTSETPOSTEFFECT 837
#constant AIACTSKY 841
#constant AIACTSKYSCROLL 842
#constant AIACTNEWJUMPHEIGHT 901
#constant AIACTBACKDROP 1001
#constant AIACTMUSIC 1011
#constant AIACTMUSICVOLUME 1012
#constant AIACTSOUNDSCALE 1013
#constant AIACTMUSICOVERRIDE 1014
#constant AIACTVIDEO 1021
#constant AIACTAISETVIEWRANGE 1022
#constant AIACTWEBLINK 1031
#constant AIACTEXPLODE 1032
#constant AIACTLIGHTON 1051
#constant AIACTLIGHTOFF 1052
#constant AIACTLIGHTRED 1053
#constant AIACTLIGHTGREEN 1054
#constant AIACTLIGHTBLUE 1055
#constant AIACTLIGHTRANGE 1056
#constant AIACTLIGHTINTENSITY 1057
Rem Hockeykid - 250210 - Dark AI constants
#constant AIACTADDAITEAM 1058
#constant AIACTAIALLYFOLLOW 1059
#constant AIACTAISETTARGET 1061
#constant AIACTAIMOVERANDOM 1062
#constant AIACTAIREMOVE 1063
#constant AIACTAIMOVEMENT 1065
#constant AIACTAIACTIVE 1066
#constant AIACTTOGGLEACTIVE 1067
#constant AIACTAIACTION 1070
#constant AIACTAIFOLLOWPLR 1071
#constant AIACTAIMOVETOSOUND 1072
#constant AIACTAIMOVEAWAYFROMSOUND 1073
#constant AIACTAIADDPOINT 1074
#constant AIACTAIGOTOPOINT 1075
#constant AIACTAICALLTEAM 1076
#constant AIACTAIRESPONDTOCALL 1077
#constant AIACTAIMOVETOCOVER 1078
#constant AIACTAIMOVETOTARGET 1079
#constant AIACTAISTOP 1080
#constant AIACTAIUSEMELEE 1081
#constant AIACTAISETMELEEDAMAGE 1082
#constant AIACTAIROTATETOTARGET 1083
#constant AIACTAIROTATETOSOUND 1084
#constant AIACTAIPLRCALLTEAM 1085
#constant AIACTAISETSPEED 1086
#constant AIACTAIRESPONDTOPLAYER 1087
#constant AIACTAITOGLLEATTACK 1088
#constant AIACTAICLEARTARGET 1089
#constant AIACTAIENABLEFULLAIM 1090
#constant AIACTAIEYELEVEL 1091
#constant AIACTAIADDALLY 1092
#constant AIACTAIADDENEMY 1093
#constant AIACTAIADDNEUTRAL 1094
#constant AIACTAIAUTOFACTIONOFF 1095
#constant AIACTAIROTATEY 1097
#constant AIACTAILOOKAROUND 1098
Rem end Dark AI constants
#constant AIACTNEXTLEVEL 1096
#constant AIACTHUDUSERVAR 1099
#constant AIACTHUDRESET 1100
#constant AIACTHUDX 1101
#constant AIACTHUDY 1102
#constant AIACTHUDZ 1103
#constant AIACTHUDSIZEX 1104
#constant AIACTHUDSIZEY 1105
#constant AIACTHUDSIZEZ 1106
#constant AIACTHUDRED 1107
#constant AIACTHUDGREEN 1108
#constant AIACTHUDBLUE 1109
#constant AIACTHUDIMAGE 1110
#constant AIACTHUDIMAGEFINE 1111
#constant AIACTHUDFONT 1112
#constant AIACTHUDSIZE 1113
#constant AIACTHUDTEXT 1114
#constant AIACTHUDTYPE 1115
#constant AIACTHUDHIDE 1116
#constant AIACTHUDSHOW 1117
#constant AIACTHUDUNSHOW 1118
#constant AIACTHUDNAME 1119
#constant AIACTHUDANIM 1120
#constant AIACTHUDFADEOUT 1121
#constant AIACTHUDMAKE 1199
#constant AIACTNEWGAME 1201
#constant AIACTLOADGAME 1202
#constant AIACTSAVEGAME 1203
#constant AIACTCONTINUEGAME 1204
#constant AIACTQUITGAME 1205
#constant AIACTPAUSEGAME 1206
#constant AIACTRESUMEGAME 1207
#constant AIACTHOSTGAME 1208
#constant AIACTJOINGAME 1209
#constant AIACTREPEATGAME 1210
#constant AIACTTIMERSTART 1211
#constant AIACTQUICKLOADGAME 1212
#constant AIACTQUICKSAVEGAME 1213
Rem AirMod - New Actions >>>
#constant AIACTSETIFUSED 1214
#constant AIACTSETUSEKEY 1215
#constant AIACTRESETPLRWEAPONS 1216
#constant AIACTBACKDROPVID 1217
#constant AIACTBLOODSPURT 1218
#constant AIACTNOBULLETCOL 1219
#constant AIACTALTAMMO 1220
#constant AIACTBLOODSPLASH 1221
#constant AIACTCAMSHAKE 1222
#constant AIACTCAMFOV 1223
#constant AIACTCAMFOVINC 1224
#constant AIACTHIDEWEAPON 1225
#constant AIACTSHOWLASTWEAPON 1227
#constant AIACTCAMPOINTOBJECT 1228
Rem AirMod - Done <<<
#constant AIACTSETUPDYNAMICSHADOWS 1229
#constant AIACTSETUPUSEEFFECTS 1230
#constant AIACTSETUPDIVIDETEXTURESIZE 1231
#constant AIACTSETUPMOUSESENSITIVITY 1232
#constant AIACTSETUPASPECTRATIO 1233
#constant AIACTSETUPPOSTPROCESSING 1234
#constant AIACTSETUPWIDTH 1235
#constant AIACTSETUPHEIGHT 1236
#constant AIACTSETUPDEPTH 1237
#constant AIACTSETUPANTIALIAS 1238
#constant AIACTRESET 1239
#constant AIACTSAVESETUP 1240
#constant AIACTPASSTOSETUP 1241
#constant AIACTFPGCRAWTEXTR 1251
#constant AIACTFPGCRAWTEXTG 1252
#constant AIACTFPGCRAWTEXTB 1253
#constant AIACTFPGCRAWTEXTX 1254
#constant AIACTFPGCRAWTEXTY 1255
#constant AIACTFPGCRAWTEXTSIZE 1256
#constant AIACTFPGCRAWTEXTFONT 1257
#constant AIACTFPGCRAWTEXTOFF 1258
#constant AIACTFPGCRAWTEXT 1259
rem V118 - 110810 - knxrb - Hud Layers
#constant AIACTHUDLAYER 1260
rem V118 - 130810 - knxrb - Mouse Invert (Options Screen)
#constant AIACTSETUPMOUSEINVERT 1261
rem V118 - 140810 - knxrb - Disable Particles (Options Screen)
#constant AIACTSETUPPARTICLESUSED 1262
rem V118 - 160810 - knxrb - Hud - sethudx Command
#constant AIACTSETHUDXPOS 1263
rem V118 - 160810 - knxrb - Auto Resolution
#constant AIACTSETUPAUTORES 1264
rem GUI-X9 (knxrb) >>>
#constant AIACTLOADIMAGE 1265
#constant AIACTMAKEHUD 1266
#constant AIACTSETHUDX 1267
#constant AIACTSETHUDY 1268
#constant AIACTSETHUDW 1269
#constant AIACTSETHUDH 1270
#constant AIACTSETHUDCOLOUR 1271
#constant AIACTSETHUDCOLOR 1272
#constant AIACTSETHUDALPHA 1273
#constant AIACTSETHUDNIMAGE 1274
#constant AIACTSETHUDOIMAGE 1275
#constant AIACTMAKECHECKBOX 1276
#constant AIACTSETCHECKBOXX 1277
#constant AIACTSETCHECKBOXY 1278
#constant AIACTSETCHECKBOXW 1279
#constant AIACTSETCHECKBOXH 1280
#constant AIACTSETCHECKBOXCOLOUR 1281
#constant AIACTSETCHECKBOXCOLOR 1282
#constant AIACTSETCHECKBOXALPHA 1283
#constant AIACTSETCHECKBOXNIMAGE 1284
#constant AIACTSETCHECKBOXCIMAGE 1285
#constant AIACTSETCHECKBOXSTATE 1286
#constant AIACTMAKESLIDER 1287
#constant AIACTSETSLIDERX 1288
#constant AIACTSETSLIDERY 1289
#constant AIACTSETSLIDERW 1290
#constant AIACTSETSLIDERH 1291
#constant AIACTSETSLIDERCOLOUR 1292
#constant AIACTSETSLIDERCOLOR 1293
#constant AIACTSETSLIDERALPHA 1294
#constant AIACTSETSLIDERVALUE 1295
#constant AIACTMAKECHOICE 1296
#constant AIACTSETCHOICEX 1297
#constant AIACTSETCHOICEY 1298
#constant AIACTSETCHOICEW 1299
#constant AIACTSETCHOICEH 1300
#constant AIACTSETCHOICECOLOUR 1301
#constant AIACTSETCHOICECOLOR 1302
#constant AIACTSETCHOICEALPHA 1303
#constant AIACTADDCHOICESTATE 1304
#constant AIACTSETCHOICESTATE 1305
#constant AIACTSETCURSOR 1306
#constant AIACTHIDEALL 1307
#constant AIACTREPLACEIMAGE 1308
#constant AIACTSHOWHUD 1309
#constant AIACTHIDEHUD 1310
#constant AIACTSHOWCURSOR 1311
#constant AIACTHIDECURSOR 1312
#constant AIACTCLEARGUI 1313
#constant AIACTMAKESTOPWATCH 1314
#constant AIACTSTARTSTOPWATCH 1315
#constant AIACTSTOPSTOPWATCH 1316
#constant AIACTMAKESETUPVAR 1317
#constant AIACTSETSETUPVARVALUE 1318
#constant AIACTSETSETUPVARLINE 1319
#constant AIACTREADSETUPVARVALUE 1320
#constant AIACTSAVESETUPVARS 1321
#constant AIACTSETHUDCLICKABLE 1322
#constant AIACTSETSETUPTOCOMP 1323
#constant AIACTSHOWCHOICE 1324
#constant AIACTHIDECHOICE 1325
#constant AIACTSHOWSLIDER 1326
#constant AIACTHIDESLIDER 1327
#constant AIACTSHOWCHECKBOX 1328
#constant AIACTHIDECHECKBOX 1329
#constant AIACTSETHUDNUMERIC 1330
#constant AIACTSETHUDVALUE 1331
rem GUI-X9 (knxrb) <<<
Rem Water commands
#constant AIACTWATERHEIGHT 1332
#constant AIACTWATER 1333
#constant AIACTWATERFOGDIST 1334
#constant AIACTWATERSPEED 1335
#constant AIACTWATERFOGRED 1336
#constant AIACTWATERFOGGREEN 1337
#constant AIACTWATERFOGBLUE 1338
#constant AIACTWATERRED 1339
#constant AIACTWATERGREEN 1340
#constant AIACTWATERBLUE 1341
#constant AIACTWATERHEIGHTOFZONE 1342
Rem Scene Commander water quality
#constant AIACTWATERFLEC 1343
rem GUI-X9 (knxrb) >>>
#constant AIACTEYEHURTTIME 1442
#constant AIACTFADERSPEED 1443
#constant AIACTUSEGUIX9 1444
rem GUI-X9 (knxrb) <<<
#constant AIACTHIDESHADOW 1445
rem LightRay Addition
rem LightRayMod
#constant AIACTLRAYSET 1447
#constant AIACTLRAYACT 1448
#constant AIACTLRBLOOMACT 1449
#constant AIACTLRDEBUGDEACTIVE 1450
rem GUI-X9 (knxrb) >>>
#constant AIACTFORCEGUISUB 1451
rem GUI-X9 (knxrb) <<<
`
rem v118 - 110511 - cinematic hands (terry cox) >>>>
`commands that are needed for cinematic hands
`the first two are optional - the last two are required
#constant AIACTPREVENTPLAYERSELECTINGGUN 1452
#constant AIACTDISABLEFIREBUTTON 1453
#constant AIACTSTARTCINEMATICHANDS 1454
#constant AIACTGETNEWWEAPON 1455
#constant AIACTREMOVECURRENTWEAPON 1456
#constant AIACTDISABLEBLOCKINGBUTTON 1457
rem cinematic hands <<<<
rem set entity speed - (markblosser)
#constant AIACTSETENTITYSPEED 1458
rem set animate command speed - (markblosser)
#constant AIACTSETANIMATESPEED 1459

rem Scene Commander actions
#constant AIACTWOBBLE 1500
#constant AIACTTILTON 1501
#constant AIACTTILTSPEED 1502
#constant AIACTTILTBOUNCE 1503
#constant AIACTUNSKIP 1504
#constant AIACTPLRACTION 1505
#constant AIACTFORCEMOVE 1506
#constant AIACTEMITFORCE 1507
#constant AIACTFORCEDAMAGEON 1508
#constant AIACTCROSSHAIRON 1509
#constant AIACTWEAPONTOSLOT 1510
#constant AIACTARMON 1511
#constant AIACTARMADD 1512
#constant AIACTARMDEC 1513
#constant AIACTARMX 1514
#constant AIACTARMY 1515
#constant AIACTSETARM 1516
#constant AIACTAIRON 1517
#constant AIACTADDAIR 1518
#constant AIACTAIRTIME 1519
#constant AIACTDROWNTIME 1520
#constant AIACTAIRMAX 1521
#constant AIACTSETAIR 1522
#constant AIACTSETAIRX 1523
#constant AIACTSETAIRY 1524
#constant AIACTINSTANTDROWN 1525
#constant AIACTIMMUNE 1526
#constant AIACTARROWON 1527
#constant AIACTJUMPON 1528
#constant AIACTCROUCHON 1529
#constant AIACTPEEKON 1530
#constant AIACTWALKON 1531
#constant AIACTRUNON 1532
#constant AIACTFORCEDAMAGE 1533
#constant AIACTCOMPASSON 1534
#constant AIACTCOMPASSOFF 1535
#constant AIACTCOMPASSX 1536
#constant AIACTCOMPASSY 1537
#constant AIACTCOMPASSSPIN 1538
#constant AIACTNEEDLESPIN 1539
#constant AIACTRADAR 1540
#constant AIACTRADARX 1541
#constant AIACTRADARY 1542
#constant AIACTRADARROTATE 1543
#constant AIACTRADARRANGE 1544
#constant AIACTSPEEDMOD 1545
#constant AIACTADDFPGCRAWTEXT 1546
#constant AIACTSETOBJECTIVE 1547
#constant AIACTSETOBJECTIVEX 1548
#constant AIACTSETOBJECTIVEY 1549
#constant AIACTOBJECTIVEMODE 1550
#constant AIACTSETVARRND 1551
#constant AIACTRANDOMIZE 1552
#constant AIACTMAXSLOTS 1553
#constant AIACTEDAMMULT 1554
#constant AIACTPLRSTRENGTH 1555
#constant AIACTCULLMODE 1556
#constant AIACTCULLRANGE 1557
#constant AIACTHIDEOBJ 1558
#constant AIACTSHOWOBJ 1559
#constant AIACTCULLMODI 1560
#constant AIACTFOOTFALL 1561
#constant AIACTSWAPALT 1562
#constant AIACTROTATEPLRX 1563
#constant AIACTROTATEPLRY 1564
#constant AIACTENTROTX 1565
#constant AIACTENTROTY 1566
#constant AIACTENTROTZ 1567
#constant AIACTMOVEPLRX 1568
#constant AIACTMOVEPLRY 1569
#constant AIACTMOVEPLRZ 1570
#constant AIACTSCALE 1571
#constant AIACTSCALELIMB 1572
#constant AIACTHOLSTER 1573
#constant AIACTNOAIR 1574
#constant AIACTSETDROWNDAMAGE 1575
#constant AIACTPLRPICKON 1576
#constant AIACTPLRPICKRANGE 1577
#constant AIACTFLASH 1578
#constant AIACTFLASHRED 1579
#constant AIACTFLASHGREEN 1580
#constant AIACTFLASHBLUE 1581
#constant AIACTFLASHRANGE 1582
#constant AIACTLOGICBURST 1583
#constant AIACTPLRDAM 1584
#constant AIACTDESTROYIN 1585
#constant AIACTSETLISTKEY 1586
#constant AIACTRAWTEXTVAR 1587
#constant AIACTSIN 1588
#constant AIACTCOS 1589
#constant AIACTSCALEHUDX 1590
#constant AIACTSCALEHUDY 1591
#constant AIACTCHANGEHUDALPHA 1592
#constant AIACTWATERFLOW 1593
#constant AIACTWATERCURRENT 1594
#constant AIACTREMOVEWEAPON 1595
#constant AIACTGIVEWEAPON 1596
#constant AIACTENTITYSETIMMUNE 1597
#constant AIACTRESETONRELOAD 1598
#constant AIACTENTITYCAM 1599
#constant AIACTPLAYERCAM 1600
#constant AIACTLASTCAM 1601
#constant AIACTCUSTGUNANIM 1602
#constant AIACTUSEENTROT 1603
#constant AIACTSETCAMOFFSETX 1604
#constant AIACTSETCAMOFFSETY 1605
#constant AIACTSETCAMOFFSETZ 1606
#constant AIACTSETCAMROTX 1607
#constant AIACTSETCAMROTY 1608
#constant AIACTSETCAMROTZ 1609
#constant AIACTHIDELIMB 1610
#constant AIACTSHOWLIMB 1611
#constant AIACTPLAYPRESET 1612
#constant AIACTLOCKEMPLACEMENT 1613
#constant AIACTFREEEMPLACEMENT 1614
#constant AIACTCULLIMMOBILE 1615
#constant AIACTPLRACC 1616
#constant AIACTENTITYACC 1617
#constant AIACTDEBUGCURSOR 1618
#constant AIACTDEBUGVAR 1619
#constant AIACTDEBUGTEXT 1620
#constant AIACTWIREFRAME 1621
#constant AIACTPLAYEROFFSETON 1622
#constant AIACTPLAYEROFFSETX 1623
#constant AIACTPLAYEROFFSETY 1624
#constant AIACTPLAYEROFFSETZ 1625
#constant AIACTMUTATE 1626
#constant AIACTOBJECTRANGE 1627
#constant AIACTLINKTOPLAYER 1628
#constant AIACTFREEFROMPLAYER 1629
#constant AIACTOBJMET 1630
#constant AIACTALWAYSRUN 1631
#constant AIACTLINKENTITYROTX 1632
#constant AIACTLINKENTITYROTY 1633
#constant AIACTLINKENTITYROTZ 1634
#constant AIACTPLROFFSETANGLEX 1635
#constant AIACTPLROFFSETANGLEY 1636
#constant AIACTPLROFFSETANGLEZ 1637
#constant AIACTENTITYOFFSETANGLEX 1638
#constant AIACTENTITYOFFSETANGLEY 1639
#constant AIACTENTTIYOFFSETANGLEZ 1640
#constant AIACTSHOWWEAPON 1641
#constant AIACTNOSELECT 1642
#constant AIACTDELAYTIMER 1643
#constant AIACTCREATESPLASHSOUND 1644
#constant AIACTTARGETLINK 1645
#constant AIACTSHOWFLAK 1646
#constant AIACTMAKEVIDEOTEXTURE 1647
#constant AIACTUSEVIDEOTEXTURE 1648
#constant AIACTDELETEVIDEOTEXTURE 1649
#constant AIACTPAUSEVIDEOTEXTURE 1650
#constant AIACTRESUMEVIDEOTEXTURE 1651
#constant AIACTVIDEOTEXTURESPEED 1652
#constant AIACTVIDEOTEXTUREVOLUME 1653
#constant AIACTSTOPVIDEOTEXTURE 1654
#constant AIACTSETBULLETCOL 1655
#constant AIACTSYNCRATE 1656
#constant AIACTFLASHLIGHT 1657
#constant AIACTFLASHLIGHTRED 1658
#constant AIACTFLASHLIGHTGREEN 1659
#constant AIACTFLASHLIGHTBLUE 1660
#constant AIACTFLASHLIGHTRANGE 1661
#constant AIACTUSEFADE 1662
#constant AIACTSHOWAIR 1663
#constant AIACTDELAYDESTROY 1664

#constant AIACTLAST 1665

rem V109 BETA3 - 210408 - AI variables
global aivariablemode : aivariablemode=0 : rem 0-global, 1-local
global aivariableindex : aivariableindex=0
dim aiglobals(99)
dim ailocals(1,99) as integer
dim aiuserlocals(1,99) as uservar

rem AI Counters
global actstringmax=0
global conindexcount=0
global aicondseqcount=0
global actindexcount=0
global aiactseqcount=0
global hudmax=0
global hudfadeoutoneatatime=0
global internalloaderhud=0
global internaleyehud=0
global internalfaderhud=0

rem AI BC Sound
global bcsoundstrength#
global bcsoundx#
global bcsoundy#
global bcsoundz#

rem AI actions
type aiactiontype
 type as integer
 value as float
 valueisvar as integer
 rem Variable System - For User Vars we'll need two variables instead of one
 valueb as float
 filename as string
 rem Variable System - For Var to Var operations we'll need two strings
 string1 as string
 string2 as string
endtype
dim aiactionseq(10000) as aiactiontype
type aiactionitemtype
 first last
endtype
dim aiaction(500) as aiactionitemtype
dim actstring$(actstringmax)

rem AI conditions
type aiconditiontype
 type as integer
 valuea as float
 valueb as float
 valuec as float
 rem Variable System - For Var to Var checks we'll need two string
 string1 as string
 string2 as string
endtype
dim aiconditionseq(10000) as aiconditiontype
type aiconditionitemtype
 first last
 action as integer
endtype
dim aicond(500) as aiconditionitemtype

rem AI Library List
type ailiblisttype
 loaded as integer
 file$ as string
 desc$ as string
 conditionfirst as integer
 conditionlast as integer
endtype
dim ailist(200) as ailiblisttype

rem AI Library Count
if leavegamedataalone=0
 dim scriptbank$(100)
 aiindexmaster=0
endif

`
` Waypoint Data Structures
`

rem Waypoint data structure
type waypointtype
 count as integer
 start as integer
 finish as integer
endtype
type waypointcoordtype
 x as float
 y as float
 z as float
 link as integer
 index as integer
endtype
dim waypointcoord(1000) as waypointcoordtype
dim waypoint(10) as waypointtype
global waypointeditheight#=0
global waypointcoordmax=0
global waypointmax=0
`
` Global Particle and Debris Data Structures
`
rem FPGC - 080701 - never a good idea, removed perminantly
`dim debris(32)

`
` Gun Data Structures
`
rem AirMod - Gun Lag
global gunlagX# as float
global gunlagY# as float

rem AirMod - Simple Zoom Offset
global gunOffsetX# as float
global gunOffsetY# as float

rem AirMod - Gun Recoil
global gunRecoilX# as float
global gunRecoilAngleX# as float
global gunRecoilY# as float
global gunRecoilAngleY# as float

global gunRecoilCorrectX# as float
global gunRecoilCorrectAngleY# as float
global gunRecoilCorrectX# as float
global gunRecoilCorrectAngleY# as float

rem AirMod - Cam Fov
global airmod_camfov_d# as float
global airmod_camfov# as float
global airmod_plr_frozen as integer
global airmod_last_weapon as integer

rem Gun Sounds Data Structure
type gunsoundbanktype
 name$ as string
 soundid as integer
 altname$ as string
 altsoundid as integer
endtype
type gunsoundbankcompaniontype
 soundid as integer
endtype
type gunsounditemtype
 keyframe as integer
 playsound as integer
 lastplay as integer
endtype
type gunsoundstype
 soundframes as integer
 fireloopend as integer
 altfireloopend as integer
endtype

rem Gun Settings Data Structure
type gunsettingstype
Rem Scene Commander
emptyreloadonly as integer
gravitygun as integer
gravitystrength as integer
magnet as integer
magnetstrength as integer
jamchance as float
jammed as integer
shotsbeforejam as integer
shotsfired as integer
cooldown as integer
cooltimer as integer
nosubmergedfire as integer
addtimer as integer
mintimer as integer

rem scene commnader end
 modessharemags as integer
 bulletamount as integer
 currentbullet as integer
 bulletlimbsmax as integer
 bulletlimbstart as integer
 bulletlimbend as integer
 bulletreset as integer
 bulletmod as integer
 altswapkey1 as integer
 altswapkey2 as integer
 meleekey as integer
 meleedamage as integer
 meleerange as integer
 meleenoscorch as integer
 `altmeleekey as integer
 altmeleedamage as integer
 altmeleerange as integer
 altmeleenoscorch as integer
 ismelee as integer
 disablerunandshoot as integer
 altpoolindex as integer
 poolindex as integer
 isempty as integer
 muzzleflash as integer
 muzzlex# as float
 muzzley# as float
 muzzlez# as float
 muzzlesize# as float
 muzzlecolorr as integer
 muzzlecolorg as integer
 muzzlecolorb as integer
 brass as integer
 smoke as integer
 flashlimb as integer
 brasslimb as integer
 smokelimb as integer
 flashlimb2 as integer
 brasslimb2 as integer
 smokelimb2 as integer
 handlimb as integer
 flashimg as integer
 brassobjmaster as integer
 smokeimg as integer
 crosshairimg as integer
 flakname$ as string
 flakindex as integer
 seconduse as integer
 damage as integer
 damagetype as integer
 scorchtype as integer
 reloadqty as integer
 weaponisammo as integer
 iterate as integer
 accuracy as integer
 zoommode as integer
 zoomaccuracy as integer
 range as integer
 smokespeed as integer
 smokedecal$ as string
 firerate as integer
 altfirerate as integer
 shotgun as integer
 emptyshotgun as integer
 rotx# as float
 roty# as float
 rotz# as float
 equipment as integer
 equipmententityelementindex as integer
 lockcamera as integer
 rem AirMod - Added Following Lines for Weapon Addition Awesomness
 burst as integer
 gunlagSpeed as float
 gunlagXmax as float
 gunlagYmax as float
 noscorch as boolean
 soundstrength as integer
 simplezoom as integer
 simplezoommod as integer
 simplezoomacc as integer
 simplezoomx# as float
 simplezoomy# as float
 simplezoomspeed as integer
 simplezoomanim as integer
 simplezoomflash as integer
 zoommuzzlex# as float
 zoommuzzley# as float
 zoommuzzlez# as float
 alternateisflak as integer
 alternateisray as integer
 altreloadqty as integer
 altiterate as integer
 altaccuracy as integer
 altdamage as integer
 altrange as integer
 altmuzzlex# as float
 altmuzzley# as float
 altmuzzlez# as float
 altmuzzleflash as integer
 altflashimg as integer
 alternate as integer
 recoily# as float
 recoilx# as float
 recoilycorrect# as float
 recoilxcorrect# as float
 zoomrecoily# as float
 zoomrecoilx# as float
 zoomrecoilycorrect# as float
 zoomrecoilxcorrect# as float
 altrecoily# as float
 altrecoilx# as float
 altrecoilycorrect# as float
 altrecoilxcorrect# as float
 forcezoomout as integer
 ammomax as integer
 runy# as float
 runx# as float
 runaccuracy as integer
 noautoreload as boolean
 nofullreload as boolean
 chamberedround as boolean
 altchamberedround as boolean
 movespeedmod as boolean
 zoomgunlagSpeed as float
 zoomgunlagXmax as float
 zoomgunlagYmax as float
 zoomwalkspeed as float
 zoomturnspeed as float
 rem AirMod - Done
 hasempty as integer
 canaddtospare as integer
 addtospare as integer
endtype

type gunparticletype
 rem gun particles
 id as integer
 velocity as float
 decal$ as string
endtype

rem Gun Actions Data Structure
type gunanimtype
 s as integer
 e as integer
endtype
type gunactionstype
 show as gunanimtype
 idle as gunanimtype
 move as gunanimtype
 start as gunanimtype
 automatic as gunanimtype
 finish as gunanimtype
 startreload as gunanimtype
 reloadloop as gunanimtype
 endreload as gunanimtype
 cock as gunanimtype
 hide as gunanimtype
 rem AirMod - Melee Block Animation
 block as gunanimtype
 rem AirMod - 2 Alternate Fire Animations
 start2 as gunanimtype
 finish2 as gunanimtype
 start3 as gunanimtype
 finish3 as gunanimtype
 to as gunanimtype
 from as gunanimtype
 Rem Hockeykid - Support for running animations
 run as gunanimtype
endtype

type gunanimextras

rem Scene commander
 clearjam as gunanimtype
 handpush as gunanimtype
 handdead as gunanimtype
 jammed as gunanimtype
 handdoor as gunanimtype
 swaptoalt as gunanimtype
 handbutton as gunanimtype
 handtake as gunanimtype
 pullup as gunanimtype
 pulldown as gunanimtype
 pullleft as gunanimtype
 pullright as gunanimtype

endtype

rem Gun Data Structure (is 10 our maximum for the entire game, ie weapon slots max?)
type guntype
 particle as gunparticletype
 firemode as integer
 activeingame as integer
 obj as integer
 secondobj as integer
 name$ as string
 weapontype as integer
 texd$ as string
 effect$ as string
 zoomscope$ as string
 zoomscope as integer
 decal$ as string
 decalid as integer
 effectidused as integer
 transparency as integer
 settings as gunsettingstype
 sound as gunsoundstype
 action as gunactionstype
 action2 as gunanimextras
 hudimage as integer
 horiz# as float
 vert# as float
 forward# as float
 zoomaction as gunactionstype
 altaction as gunactionstype
 emptyaction as gunactionstype
 meleeaction as gunactionstype
 altmeleeaction as gunactionstype
endtype


dim gun(100) as guntype

dim firemode(100,1) as guntype
Global firemode : firemode=0
Global bulletlimbsmax : bulletlimbsmax=0
`dim bulletlimbs(100,25)
`dim gunsound(100,5) as gunsoundbanktype
`dim gunsoundcompanion(100,5,2) as gunsoundbankcompaniontype
Rem AirMod - Extended to 15 Sounds
dim gunsound(100,15) as gunsoundbanktype
rem AirMod - Update for 15 sounds
dim gunsoundcompanion(100,15,2) as gunsoundbankcompaniontype
dim gunsounditem(100,50) as gunsounditemtype
dim brassfallcount(30)
global autoloadgun=0
global gunslotmax=0
global gunmax

type ammopooltype
 name$ as string
 ammo as integer
 used as integer
endtype
dim ammopool(100) as ammopooltype

rem Flak Elements Data Structure
type flakelementtype
 flakid as integer
 profile as flakprofiletype
 active as integer
 range as integer
 obj as integer
 rem scene commnder fix for 'hovering' flak
 lastx as float
 lasty as float
 lastz as float
 lasttime as integer
 xpos as float
 ypos as float
 zpos as float
 colx as float
 coly as float
 colz as float
 owner as integer
 isentity as integer
 Rem Scene Commander fix for flagging air explosion for changed particles.
 preexplode as integer
endtype
global flakelementmax=100
dim flakelement(flakelementmax) as flakelementtype

type flaksticktype
 flakid as integer
 x as float
 y as float
 z as float
 colx as float
 coly as float
 colz as float
 obj as integer
 life as integer
 rx as float
 ry as float
 rz as float
 used as integer
endtype
dim flakstick(flakelementmax) as flaksticktype
for i=1 to flakelementmax
 flakstick(i).obj=flakstickbankoffset+100+(i-1)
next i

rem Decal Structure (explosions, lightdlare, smoke, steam, plasma)
type decaltype
 active as integer
 imageid as integer
 name$ as string
 across as integer
 down as integer
 framemax as integer
 particle as decalparticletype
endtype
global decalmax=10
dim decal(decalmax) as decaltype
decal(1).name$=""

rem Decal Element Structure (reusable instances)
type decalelementtype
 decalid as integer
 active as integer
 obj as integer
 xpos as float
 ypos as float
 zpos as float
 frame as float
 framedelay as float
 orient as integer
 originator as integer
 scalemodx as float
 scalemody as float
 particle as decalparticletype
 particleix as float
 particleiy as float
 particleiz as float
 particlemirror as integer
endtype
global decalelementmax=499
dim decalelement(decalelementmax) as decalelementtype

`
` Players Data
`

rem Input Command Structure
type inputcommandtype
 take drop newweapon
endtype
type playerstatetype
 moving firingmode
 rem AirMod - Melee Block Move
 blockingaction as integer
 empty as integer
endtype

rem Weapon Data Structure
type weaponslottype
 pref got invpos
 noselect
endtype
if leavegamedataalone=0
 dim weaponslot(10) as weaponslottype
 `dim weaponammo(10) as integer
 `dim weaponclipammo(10) as integer
 rem AirMod - Next 2 lines modified, 20 now, to allow for alternate fire ammo count
 dim weaponammo(20) as integer
 dim weaponclipammo(20) as integer
 for ws=1 to 10 : weaponslot(ws).pref=0 : next ws
endif
dim weaponhud(10) as integer

rem Inventory Data Structure
type inventorytype
 new as integer
 drop as integer
 index as integer
endtype

rem Players Data Structure
type playertype
 serverplayer as integer
 command as inputcommandtype
 state as playerstatetype
 x as float
 y as float
 z as float
 envstate as integer
 envassociatedentity as integer
 recovershield as integer
 health as integer
 lives as integer
 inventorymax as integer
 usingaction as integer
endtype
type playertrailtype
 time as DWORD
 x as float
 y as float
 z as float
endtype
global playermax=1
global playertrailmax=0
dim player(playermax) as playertype
dim playersound(playermax,520) as integer
dim playersoundtimeused(playermax,520) as DWORD
dim playersoundset$(playermax) as string
dim playermovementstep(playermax) as float
dim playerinventory(playermax,100) as inventorytype
dim playertrial(100) as playertrailtype
playersoundset$(1)=""

rem FPGC - 020909 - new sound management (smaller memory footprint)
dim playersoundsetindex(playermax) as integer
global soundsetlistmax : soundsetlistmax=0
dim soundsetlist$(soundsetlistmax)
dim soundsetlist(soundsetlistmax)
dim soundvolumes(2) as integer

rem Player Mission
global missiongoaltotal as integer
dim playerobjective(99) as integer

rem Player+Multiplayer Related Data
global multiplayeridlinkmax : multiplayeridlinkmax=0
dim multiplayeridlink(16) as DWORD
dim multiplayername$(16) as string
dim multiplayerisnew(16) as integer
dim multiplayerplrindex(16) as integer
dim multiplayeri(16) as integer

rem Infini-Light Data Structure
type colrgbtype
 r g b
endtype
type infinilighttype
 used as integer
 type as integer
 x as float
 y as float
 z as float
 range as float
 id as integer
 dist as float
 colrgb as colrgbtype
 islit as integer
 e as integer
endtype
dim infinilight(0) as infinilighttype
empty array infinilight(0)
dim infinilightshortlist(0)
empty array infinilightshortlist(0)

rem Shadow Lights Data Structure
type shadowlighttype
 x# y# z# range#
endtype
dim shadowlight(0) as shadowlighttype

rem Data structure for Bit-Fragments
type bitdetailstype
 max as integer
 file$ as string
 collisionmode as integer
 fragmentobjstart as integer
 choice as integer
 sizex as float
 sizey as float
 sizez as float
endtype
type bitoffsettype
 x# y# z#
endtype
dim bitdetails(10) as bitdetailstype
dim bitoffset(10,8) as bitoffsettype

rem Explosion Data Structure
type explodetype
 obj as integer
 explode as integer
 explodesound as integer
 dist# as float
 smoke# as float
 fade# as float
 x as float
 y as float
 z as float
endtype
global explodermax=4
dim exploder(explodermax) as explodetype

rem GUI Visual Settings
type guivisualsettingstype
 updateflag as integer
 ambience as integer
 ambienceoverride as integer
 shadows as integer
 shadowstrength as integer
 shadowshades as integer
 dynamiclightcount as integer
 ambiencescripted as integer
endtype
guivisualsettings as guivisualsettingstype
guivisualsettings.ambienceoverride=-1

rem HUD structure
type hudtype
 uservarislocal as integer
 uservar as integer
 name$ as string
 maintype as integer
 typemode as integer
 posx as float
 posy as float
 posz as float
 sizex as integer
 sizey as integer
 sizez as integer
 red as integer
 green as integer
 blue as integer
 fadeout as integer
 baseanim as integer
 image as integer
 font$ as string
 fontsize as integer
 text$ as string
 hide as integer
 hidedelay as float
 highlighted as integer
 width as integer
 height as integer
 imagefile$ as string
 rem scene commander scale hud
 scalex as integer
 scaley as integer
 update as integer
 rem Scene Commander
 alpha as integer
 rem V118 - 110810 - knxrb - Hud Layers
 layer as integer
endtype
dim hud(10) as hudtype
global saveloadgamehudmax : saveloadgamehudmax=0
dim saveloadgamehud(10) as hudtype

rem Setup work floats (for HUD decimal detail)
value1 as float
value2 as float
value3 as float
workhudx as float
workhudy as float
workhudz as float

rem FPSCV104 Fog globals
Global hudfogon as integer
Global hudfogison as integer
Global hudfoglaston as integer
Global hudfognear as float : hudfognear=-2000.0
Global hudfogfar as float : hudfogfar=-10000.0
Global hudfogred as float
Global hudfoggreen as float
Global hudfogblue as float

rem Water Fog globals
Global waterfogon as integer
Global waterfogison as integer
Global waterfoglaston as integer
Global waterfognear as float
Global waterfogfar as float : waterfogfar=2000.0
Global waterfogred as float : waterfogred=55
Global waterfoggreen as float : waterfoggreen=65
Global waterfogblue as float : waterfogblue=75

rem LightRay Addition
rem LRMod globals
global rotvar# : rotvar#=0.0
global lrsamples : lrsamples=1
global lroldsamples : lroldsamples=lrsamples
global lrswitchsamples : lrswitchsamples=1
global lrbloomactive : lrbloomactive=1
global lrswitchbloomactive : lrswitchbloomactive=1
global lroldbloomactive : lroldbloomactive=lrbloomactive
global lrdebugdeactive : lrdebugdeactive=0

rem LightRay Types
type FrameTargetData
 Object
 Effect
 Teq$
endtype

type RenderTargetData
 Camera
 Image
 Object
 Effect
 Teq$
endtype

rem World Physics Settings
global physicson=1
global physicsdebug=0 : rem gdebugphysicsstate will set this to one!
global physicsgravx#=0.0
global physicsgravy#=0 : physicsgravy#=-40.0
global physicsgravz#=0.0
global physicsplayerweight# : physicsplayerweight#=500.0
global grav# as float : grav#=0
global camerapositionx as float : camerapositionx=0
global camerapositiony as float : camerapositiony=0
global camerapositionz as float : camerapositionz=0
global cameraspeed as float : cameraspeed=0
global camerapickup as integer : camerapickup=1
global cameraholding as integer : cameraholding=0
global camerapickupkeyrelease : camerapickupkeyrelease=0
global camerareach# as float : camerareach#=0
global camerareachatrun# as float : camerareachatrun#=0
global camerareachmax# as float : camerareachmax#=75
global camerapickedangle# as float : camerapickedangle#=0
global camerapicked as integer : camerapicked=0
global camerapickede as integer : camerapickede=0
global camerapickeddrop as integer : camerapickeddrop=0
global camerapickedthrown as integer : camerapickedthrown=0
global camerathrow# as float : camerathrow#=100.0
global camerathrowelev# as float : camerathrowelev#=0.0
global cameradampen# : cameradampen#=1.0
global cameradampenactive : cameradampenactive=0
global cameracarryweight# : cameracarryweight#=4000
dim phyobjvelocity#(1)
dim phylasttravelled#(1)
dim phylastfloorstop#(1)
dim phyobjsounding(1)
dim phyobjremove(1)
dim phyobjele(1)
dim shadowobj(1)

rem Respawn array for arena game
type respawntype
 e as integer
 x as float
 y as float
 z as float
 ry as float
endtype
dim respawn(16) as respawntype
global respawnmax : respawnmax=0

rem Multiplayer globals and structures
global hudiplistmax : hudiplistmax=-1
dim hudiplist$(20,1)
global repeatsamelevel : repeatsamelevel=0
global winnersname$ as string : winnersname$=""
global servername$ : servername$="FPSC Creator Portal"
global ipaddress$
global multiplayerinitialised as integer
global createorjoin as integer
global lagmon# as float
global startofrecording as DWORD
global dwBurstTime as DWORD
global dwStartTime as DWORD
global dwStartJoinTime as DWORD
global dwPlayerID as DWORD
global timestampforlagtest as DWORD
global locallagtime as DWORD
global dwMessageCode as DWORD
global dwCode as DWORD
global dwLocalPlayerID as DWORD
global iLocalEL as integer
global PlayerCanStart as integer
global Servergameisfull as integer
global gterminationcountdown as integer
global tenminutetimer as DWORD
global cameratimeslice as DWORD
rem talktoaster arrays
dim talkscript$(10)
dim talkscriptcount(10)
dim talkscriptwho(10)
global talkindex as integer
global gtalkytoaster as integer
global talkpingsound as integer
rem Characters (chosen is indexed by iLocalEL, list is flaglist of used identities)
global multiplayermax : multiplayermax=16
dim characterchosen(multiplayermax)
dim characterchoiceentityindex(multiplayermax)
dim characterlist$(multiplayermax) as string
dim characterlist(multiplayermax)
dim characterlistentity(multiplayermax)
rem Dead reckoning temp arrays
dim cpx#(4)
dim cpy#(4)
dim cpz#(4)
dim stategetready(multiplayermax)
dim statex(multiplayermax)
dim statey(multiplayermax)
dim statez(multiplayermax)
dim statea(multiplayermax)
dim stateanim(multiplayermax)
dim stateanimdir(multiplayermax)
dim statecolmaterialtype(multiplayermax)
dim stateanimwait(multiplayermax)
dim statewhodidit(multiplayermax)
dim stateplayagain(multiplayermax)
dim stateviewy(multiplayermax) as float
dim statesviewdy(multiplayermax) as float
dim stateweapon(multiplayermax)
dim stateannounce(multiplayermax)
dim statesx(multiplayermax)
dim statesy(multiplayermax)
dim statesz(multiplayermax)
dim statesa(multiplayermax)
dim statesvel(multiplayermax) as float
dim statetx(multiplayermax)
dim statety(multiplayermax)
dim statetz(multiplayermax)
dim statedx(multiplayermax)
dim statedy(multiplayermax)
dim statedz(multiplayermax)
dim statemove(multiplayermax)
dim statelag(multiplayermax) as float
dim statemsgap(multiplayermax) as float
dim statemytimer(multiplayermax) as DWORD
dim statecodeupdate(multiplayermax,4)
dim stateraycastpace(multiplayermax)

rem Server Scores
dim frags(multiplayermax) as integer

rem End of FULL-DATA-INIT Subroutine
return


`
` Initialise using SETUP.INI
`

_FPSC_Setup:

rem Very first task is find and load BUILD.INI (if flagged)
global gcompilestandaloneexe : gcompilestandaloneexe=0
global gbuildpath$ as string
global gbuildname$ as string

rem Find and load SETUP.INI settings as global states
global grealgameviewstate : grealgameviewstate=0
global gmultiplayergame : gmultiplayergame=0
global gdebugreportmodestate : gdebugreportmodestate=0
global gexitpromptreportmodestate : gexitpromptreportmodestate=0
global gdebugphysicsstate : gdebugphysicsstate=0
global gdebugreportstepthroughstate : gdebugreportstepthroughstate=0
global gshowentitygameinfostate : gshowentitygameinfostate=0
global gshowdebugtextingamestate : gshowdebugtextingamestate=0
global gincludeonlyvideo : gincludeonlyvideo=0
global gincludeonlyname$ : gincludeonlyname$=""
global gignorefastbone : gignorefastbone=0
global glightmappingstate : glightmappingstate=0
`global glightmapsize : glightmapsize=8 `preV104RC8
`global glightmapquality : glightmapquality=100
global glightmappingold : glightmappingold=0
global glightshadowsstate : glightshadowsstate=0
global glightambientr : glightambientr=0
global glightambientg : glightambientg=0
global glightambientb : glightambientb=0
global glightsunx : glightsunx=0
global glightsuny : glightsuny=-1
global glightsunz : glightsunz=0
global glightsunr : glightsunr=0
global glightsung : glightsung=0
global glightsunb : glightsunb=0
global glightzerorange : glightzerorange=2000
global glightatten : glightatten=16000
global glightmaxsize : glightmaxsize=-1
global glightboost : glightboost=4
global glighttexsize : glighttexsize=512
global glightquality : glightquality=5
global glightblurmode : glightblurmode=1
global glightthreadmax : glightthreadmax=4
global gdynamiclightingstate : gdynamiclightingstate=0
global gdynamicshadowsstate : gdynamicshadowsstate=1
global guseeffectstate : guseeffectstate=0
global guseeffectongunsstate : guseeffectongunsstate=0
global guseeffectonscenesstate : guseeffectonscenesstate=0
global guseeffectonentitiesstate : guseeffectonentitiesstate=0
global gdividetexturesize : gdividetexturesize=0
global goptimizemode : goptimizemode=0
global ghsrmode : ghsrmode=0
global guseskystate : guseskystate=0
global gusefloorstate : gusefloorstate=0
global guseenvsoundsstate : guseenvsoundsstate=0
global guseweaponsstate : guseweaponsstate=0
global gindieditorstate : gindieditorstate=0
global gdisplaywidth : gdisplaywidth=ScreenW rem typo error fixed - overwritten in test game SETUP.INI (width)
global gdisplayheight : gdisplayheight=ScreenH rem typo error fixed - overwritten in test game SETUP.INI (height)
global gdisplaydepth : gdisplaydepth=32
global gfullscreen : gfullscreen=0
global gcontrollerhint : gcontrollerhint=0
global gcontrollerhinthudid : gcontrollerhinthudid=0
global gcontrollerhintbase : gcontrollerhintbase=0
global gvrmode : gvrmode=0
global gvrmodemag : gvrmodemag=100
global gmousesensitivity : gmousesensitivity=100
global guniquesignature as DWORD : guniquesignature=0
global ggameobjectivetype : ggameobjectivetype=0
global ggameobjectivevalue : ggameobjectivevalue=0
global goneshotkills : goneshotkills=0
global numberofplayers : numberofplayers=16
global gspawnrandom : gspawnrandom=0
global guniquegamecode$ : guniquegamecode$=""
global guseuniquelynamedentities : guseuniquelynamedentities=0
global gexportassets : gexportassets=0
global gproducelogfiles : gproducelogfiles=0
global ggodmodestate : ggodmodestate=0
global glevelmax : glevelmax=1
global level : level=1
global glocalserveroverride$ : glocalserveroverride$=""
global gbloodonfloor : gbloodonfloor=0
global gimageblockmode : gimageblockmode=0
global shroudsize : shroudsize=10 : rem now taken from SETUP.INI so lower end machines can restore shroud to 5
global shroudsizedefaultsize : shroudsizedefaultsize=shroudsize
global gxbox : gxbox=0
global gxboxinvert : gxboxinvert=0
global gxboxcontrollertype : gxboxcontrollertype=0
global gxboxmag as float : gxboxmag=1.0
global gshowalluniquetextures : gshowalluniquetextures=0
global gaspectratio : gaspectratio=0
global gnewblossershaders : gnewblossershaders=1
global gpostprocessing : gpostprocessing=0
global gpostprocessingnotransparency : gpostprocessingnotransparency=0
global gfinalrendercameraid : gfinalrendercameraid=0
global gdepthcameraid : gdepthcameraid=0
global gshowaioutlines : gshowaioutlines=0
global gairadius : gairadius=20
global gdisablepeeking : gdisablepeeking=0
global gsystemmemorycapoff : gsystemmemorycapoff=0
global gentitytogglingoff : gentitytogglingoff=0
global gextracollisionbuilddisabled : gextracollisionbuilddisabled=1
global galwaysconfirmsave : galwaysconfirmsave=0
global gsimplifiedcharacterediting : gsimplifiedcharacterediting=0
global gantialias : gantialias=0 rem reverted
rem V118 - 130810 - knxrb - Invert Mouse
global gminvert : gminvert=0
rem V118 - 140810 - knxrb - Disable Particles
global gparticlesnotused : gparticlesnotused=0
rem V118 - 160810 - knxrb - Auto Resolution
global gautores : gautores=0
global guseoggoff:guseoggoff=0
global gcapfpson: gcapfpson=0
global createsplashsound : createsplashsound=1

rem Version Control - TEST GAME Mode
global gtestgamemodefromeditor : gtestgamemodefromeditor=0
global gtestgamemodefromeditorokaypressed : gtestgamemodefromeditorokaypressed=0
gosub _version_commandlineprompt

rem V110 - 160508 - get version information from version file
global gversion : gversion=10000
if file exist("version.ini")=1
 dim data$(99)
 load array "version.ini",data$()
 version$=""
 for n=1 to len(data$(0))
  c$=mid$(data$(0),n)
  if c$<>"." then version$=version$+c$
 next n
 gversion=val(version$)
 undim data$()
endif

rem Default, unless overridden by BUILD -B
global setupfilename$
setupfilename$="setup.ini"

rem V118 - 060211 - defeat 'cumilative virtual memory limit of 1.8GB' by terminating
rem FPSC-Game.exe each complete level, and re-launching to start new heap each time
global startbuildinglevelfromdir$ : startbuildinglevelfromdir$=get dir$()
global startbuildingleveloverride : startbuildingleveloverride=1
tcommandline$=cl$()
if lower$(left$(tcommandline$,3))="-bl"
 startbuildingleveloverride=val(right$(tcommandline$,len(tcommandline$)-3))
 tcommandline$="-b"
endif

rem COMMANDLINE Info
if lower$(tcommandline$)="-b"
 `
 rem BUILD settings
 gcompilestandaloneexe=1
 setupfilename$="buildsetup.ini"
 tfile$="build.ini"
 if file exist(tfile$)=1
  dim data$(99)
  load array tfile$,data$()
  for l=0 to 99
   line$=data$(l)
   if len(line$)>0
    if lower$(left$(line$,4))=";end" then exit
    if left$(line$,1)<>";"
     `
     rem take fieldname and values
     for c=0 to len(line$)
      if mid$(line$,c)="=" then mid=c : exit
     next c
     field$=lower$(removeedgespaces(left$(line$,mid-1)))
     value$=removeedgespaces(right$(line$,len(line$)-mid))
     for c=0 to len(value$)
      if mid$(value$,c)="," then mid=c : exit
     next c
     value1=val(removeedgespaces(left$(value$,mid-1)))
     value2$=removeedgespaces(right$(value$,len(value$)-mid))
     if len(value2$)>0 then value2=val(value2$) else value2=-1
     `
     rem collect data from fields in setup file
     Rem TDM - Plystire
      tryfield$="matchtype" : if field$=tryfield$ then multi_match_type=value1
      tryfield$="serverhostname" : if field$=tryfield$ then serverhostname=value$
      rem all multiplayer taunts
      for num=1 to 30
     tryfield$="taunt"+str$(num)
     if field$=tryfield$ then taunt$(num)=value$
    next num
     tryfield$="path" : if field$=tryfield$ then gbuildpath$=value$
     tryfield$="name" : if field$=tryfield$ then gbuildname$=value$
     tryfield$="multiradar":if field$=tryfield$ then darkradar=value1
     tryfield$="multicompass":if field$=tryfield$ then compasson=value1
     tryfield$="multicompassx":if field$=tryfield$ then compassx=value1
     tryfield$="multicompassy":if field$=tryfield$ then compassy=value1
     tryfield$="multiradarx":if field$=tryfield$ then radarx=value1
     tryfield$="multiradary":if field$=tryfield$ then radary=value1
     `
    endif
   endif
  next l
  undim data$()
 endif
 `
endif

rem RESTORE MAP Mode
global grestoreeditorsettings : grestoreeditorsettings=0
if lower$(cl$())="-r"
 grestoreeditorsettings=1
endif

rem SETUP Info`
tfile$=setupfilename$
if file exist(tfile$)=1
 `
 rem Load Data from file
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem collect data from fields in setup file
    tryfield$="version" : if field$=tryfield$ then gversion=value1
    tryfield$="realgameview" : if field$=tryfield$ then grealgameviewstate=value1
    tryfield$="multiplayergame" : if field$=tryfield$ then gmultiplayergame=value1
    tryfield$="debugreport" : if field$=tryfield$ then gdebugreportmodestate=value1
    tryfield$="exitpromptreport" : if field$=tryfield$ then gexitpromptreportmodestate=value1
    tryfield$="debugphysics" : if field$=tryfield$ then gdebugphysicsstate=value1
    tryfield$="debugreportstepthrough" : if field$=tryfield$ then gdebugreportstepthroughstate=value1
    tryfield$="showentitygameinfo" : if field$=tryfield$ then gshowentitygameinfostate=value1
    tryfield$="showdebugtextingame" : if field$=tryfield$ then gshowdebugtextingamestate=value1
    tryfield$="includeonlyvideo" : if field$=tryfield$ then gincludeonlyvideo=value1
    tryfield$="includeonlyname" : if field$=tryfield$ then gincludeonlyname$=value$
    tryfield$="ignorefastbone" : if field$=tryfield$ then gignorefastbone=value1
    tryfield$="loadreport" : if field$=tryfield$ then gloadreportstate=value1
    `
    tryfield$="optimizemode" : if field$=tryfield$ then goptimizemode=value1
    tryfield$="lightmapping" : if field$=tryfield$ then glightmappingstate=value1
    tryfield$="lightmapsize" : if field$=tryfield$ then glightmapsize=value1
    tryfield$="lightmapquality" : if field$=tryfield$ then glightmapquality=value1
    tryfield$="lightmapold" : if field$=tryfield$ then glightmappingold=value1
    tryfield$="lightmapshadows" : if field$=tryfield$ then glightshadowsstate=value1
    tryfield$="lightmapambientr" : if field$=tryfield$ then glightambientr=value1
    tryfield$="lightmapambientg" : if field$=tryfield$ then glightambientg=value1
    tryfield$="lightmapambientb" : if field$=tryfield$ then glightambientb=value1
    tryfield$="lightmapsunx" : if field$=tryfield$ then glightsunx=value1
    tryfield$="lightmapsuny" : if field$=tryfield$ then glightsuny=value1
    tryfield$="lightmapsunz" : if field$=tryfield$ then glightsunz=value1
    tryfield$="lightmapsunr" : if field$=tryfield$ then glightsunr=value1
    tryfield$="lightmapsung" : if field$=tryfield$ then glightsung=value1
    tryfield$="lightmapsunb" : if field$=tryfield$ then glightsunb=value1
    tryfield$="lightmapzerorange" : if field$=tryfield$ then glightzerorange=value1
    tryfield$="lightmapatten" : if field$=tryfield$ then glightatten=value1
    tryfield$="lightmapmaxsize" : if field$=tryfield$ then glightmaxsize=value1
    tryfield$="lightmapboost" : if field$=tryfield$ then glightboost=value1
    tryfield$="lightmaptexsize" : if field$=tryfield$ then glighttexsize=value1
    tryfield$="lightmapquality" : if field$=tryfield$ then glightquality=value1
    tryfield$="lightmapblurmode" : if field$=tryfield$ then glightblurmode=value1
    tryfield$="lightmapthreadmax" : if field$=tryfield$ then glightthreadmax=value1
    tryfield$="bloodonfloor" : if field$=tryfield$ then gbloodonfloor=value1
    tryfield$="imageblockmode" : if field$=tryfield$ then gimageblockmode=value1
    tryfield$="shroudsize" : if field$=tryfield$ then shroudsize=value1
    tryfield$="showalluniquetextures" : if field$=tryfield$ then gshowalluniquetextures=value1
    tryfield$="systemmemorycapoff" : if field$=tryfield$ then gsystemmemorycapoff=value1
    tryfield$="entitytogglingoff" : if field$=tryfield$ then gentitytogglingoff=value1
    tryfield$="extracollisionbuilddisabled" : if field$=tryfield$ then gextracollisionbuilddisabled=value1
    tryfield$="alwaysconfirmsave" : if field$=tryfield$ then galwaysconfirmsave=value1
    tryfield$="simplifiedcharacterediting" : if field$=tryfield$ then gsimplifiedcharacterediting=value1
    tryfield$="useoggoff" : if field$=tryfield$ then guseoggoff=value1
    tryfield$="cullmode" : if field$=tryfield$ then cullmode=value1
    tryfield$="capfpson" : if field$=tryfield$ then gcapfpson=value1
    `
    tryfield$="xbox"
    if field$=tryfield$
     rem FPGC - 010410 - only set if 'any' controller exists
     if joystick information(0)>0
      if value1=0 then gxbox=0 : gxboxinvert=0 : gxboxcontrollertype=0
      if value1=1 then gxbox=1 : gxboxinvert=0 : gxboxcontrollertype=0
      if value1=2 then gxbox=1 : gxboxinvert=1 : gxboxcontrollertype=0
      if value1=3 then gxbox=1 : gxboxinvert=0 : gxboxcontrollertype=1
      if value1=4 then gxbox=1 : gxboxinvert=1 : gxboxcontrollertype=1
     endif
    endif
    tryfield$="xboxmag" : if field$=tryfield$ then gxboxmag=(0.0+value1)/100.0
    `
    tryfield$="dynamiclighting" : if field$=tryfield$ then gdynamiclightingstate=value1
    tryfield$="dynamicshadows" : if field$=tryfield$ then gdynamicshadowsstate=value1 : newdynamicshadows=value1
    tryfield$="useeffects" : if field$=tryfield$ then guseeffectstate=value1 : newuseeffects=value1
    tryfield$="useeffectsonguns" : if field$=tryfield$ then guseeffectongunsstate=value1
    tryfield$="useeffectsonscene" : if field$=tryfield$ then guseeffectonscenesstate=value1
    tryfield$="useeffectsonentities" : if field$=tryfield$ then guseeffectonentitiesstate=value1
    tryfield$="dividetexturesize" : if field$=tryfield$ then gdividetexturesize=value1 : newdividetexturesize=value1
    tryfield$="controllerhint" : if field$=tryfield$ then gcontrollerhint=value1
    tryfield$="vrmode" : if field$=tryfield$ then gvrmode=value1
    tryfield$="vrmodemag" : if field$=tryfield$ then gvrmodemag=value1
    tryfield$="mousesensitivity" : if field$=tryfield$ then gmousesensitivity=value1 : newmousesensitivity=value1
    tryfield$="producelogfiles" : if field$=tryfield$ then gproducelogfiles=value1
    tryfield$="hsrmode" : if field$=tryfield$ then ghsrmode=value1
    tryfield$="newblossershaders" : if field$=tryfield$ then gnewblossershaders=value1
    tryfield$="postprocessing" : if field$=tryfield$ then gpostprocessing=value1 : newpostprocessing=value1
    tryfield$="showaioutlines" : if field$=tryfield$ then gshowaioutlines=value1
    tryfield$="airadius" : if field$=tryfield$ then gairadius=value1
    tryfield$="disablepeeking" : if field$=tryfield$ then gdisablepeeking=value1
    tryfield$="antialias" : if field$=tryfield$ then gantialias=value1 : newantialias=value1
    rem V118 - 130810 - knxrb - Invert Mouse
    tryfield$="invmouse" : if field$=tryfield$ then gminvert=value1 : newmouseinvert=value1
    rem V118 - 140810 - knxrb - Disable Particles
    tryfield$="disableparticles" : if field$=tryfield$ then gparticlesnotused=value1 : newparticlesused=value1
    rem V118 - 160810 - knxrb - Auto Resolution
    tryfield$="autores" : if field$=tryfield$ then gautores=value1 : newautores=value1
    `
    tryfield$="usesky" : if field$=tryfield$ then guseskystate=value1
    tryfield$="usefloor" : if field$=tryfield$ then gusefloorstate=value1
    tryfield$="useenvsounds" : if field$=tryfield$ then guseenvsoundsstate=value1
    tryfield$="useweapons" : if field$=tryfield$ then guseweaponsstate=value1
    `
    tryfield$="indieditor" : if field$=tryfield$ then gindieditorstate=value1
    rem V119 - 060611 - Hockeykid - Removed, should only be allowed in test game
    tryfield$="godmode" : if field$=tryfield$ then ggodmodestate=0`value1
    `
    tryfield$="width" : if field$=tryfield$ then gdisplaywidth=value1 : newwidth=value1
    tryfield$="height" : if field$=tryfield$ then gdisplayheight=value1 : newheight=value1
    tryfield$="depth" : if field$=tryfield$ then gdisplaydepth=value1 : newdepth=value1
    tryfield$="fullscreen" : if field$=tryfield$ then gfullscreen=value1
    tryfield$="aspectratio" : if field$=tryfield$ then gaspectratio=value1 : newaspectratio=value1
    `
    tryfield$="uniquesignature" : if field$=tryfield$ then guniquesignature=value1
    tryfield$="gameobjectivetype" : if field$=tryfield$ then ggameobjectivetype=value1
    tryfield$="gameobjectivevalue" : if field$=tryfield$ then ggameobjectivevalue=value1
    tryfield$="oneshotkills" : if field$=tryfield$ then goneshotkills=value1
    tryfield$="maxplayers" : if field$=tryfield$ then numberofplayers=value1
    tryfield$="spawnrandom" : if field$=tryfield$ then gspawnrandom=value1
    tryfield$="uniquegamecode" : if field$=tryfield$ then guniquegamecode$=value$
    `
    tryfield$="useuniquelynamedentities" : if field$=tryfield$ then guseuniquelynamedentities=value1
    tryfield$="exportassets" : if field$=tryfield$ then gexportassets=value1
    tryfield$="localserver" : if field$=tryfield$ then glocalserveroverride$=value$
    `
    rem all FPI screens
    tryfield$="title" : if field$=tryfield$ then titlefpi$=value$
    tryfield$="global" : if field$=tryfield$ then setupfpi$=value$
    tryfield$="gamewon" : if field$=tryfield$ then gamewonfpi$=value$
    tryfield$="gameover" : if field$=tryfield$ then gameoverfpi$=value$
    tryfield$="levelfpi1" : if field$=tryfield$ then loadingfpi$=value$ : levelfpiinsetup=l
    ` rem TDM - Plystire
      tryfield$="hudr" : if field$=tryfield$ then r#=value1
      tryfield$="hudg" : if field$=tryfield$ then g#=value1
      tryfield$="hudb" : if field$=tryfield$ then b#=value1
      tryfield$="autoswaptrue" : if field$=tryfield$ then autoswap=value1
      tryfield$="messagetime" : if field$=tryfield$ then messagetime=value1
      tryfield$="allowscope" : if field$=tryfield$ then allowscope$=value1
      tryfield$="serverhostname" : if field$=tryfield$ then serverhostname=value$
      tryfield$="alwaysrun" : if field$=tryfield$ then alwaysrun=value1
      tryfield$="matchtype" : if field$=tryfield$ then multi_match_type=value1
      tryfield$="multiradar":if field$=tryfield$ then darkradar=value1
      tryfield$="multicompass"::if field$=tryfield$ then compasson=value1
      tryfield$="multicompassx":if field$=tryfield$ then compassx=value1
      tryfield$="multicompassy":if field$=tryfield$ then compassy=value1
      tryfield$="multiradarx":if field$=tryfield$ then radarx=value1
      tryfield$="multiradary":if field$=tryfield$ then radary=value1
    rem Levels
    if field$="levelmax" then glevelmax=value1
    if glevelmax>0
     for v=1 to glevelmax
      tryfield$="levelfpm"+str$(v)
      if field$=tryfield$ then levelfpm$=value$
      tryfield$="levelfpi"+str$(v)
      if field$=tryfield$
       levelfpi$=value$
       dim level$(v) as leveltype
       level$(v).fpm$=levelfpm$
       level$(v).fpi$=levelfpi$
      endif
     next l
    endif
    `
    rem all key actions
    for num=1 to 11
     tryfield$="key"+str$(num)
     if field$=tryfield$ then listkey(num)=value1
    next num
    `
    rem all gun slots
    for num=1 to 9
     tryfield$="slot"+str$(num)
     if field$=tryfield$ then gunslots$(num)=value$
    next num
    `rem all multiplayer taunts - TDM - Plystire
    for num=1 to 30
     tryfield$="taunt"+str$(num)
     if field$=tryfield$ then taunt$(num)=value$
    next num
    rem localization data
    tryfield$="language" : if field$=tryfield$ then language$=value$
    `
   endif
  endif
 next l
 undim data$()
 `
 rem V118 - 160810 - knxrb - Auto Resolution
 if gautores=1
  gdisplaywidth = desktop width()
  gdisplayheight = desktop height()
 endif
 `
else
 `
 rem No SETUP.INI, default is a standalone game
 grealgameviewstate=1
 gdynamiclightingstate=1
 guseeffectstate=0
 guseeffectongunsstate=0
 guseeffectonscenesstate=0
 guseeffectonentitiesstate=0
 guseskystate=1
 gusefloorstate=0
 guseenvsoundsstate=1
 guseweaponsstate=1
 `
endif

rem Indicate a time stamp for app start time
timestampactivity(0,"Flag to produce log files set in SETUP.INI (producelogfiles=1)")

rem FPGC - 020810 - sub-PS2.0 cards CANNOT have post processing
if gpostprocessing>0
 tpsv#=get maximum pixel shader version()
 if tpsv#<2.0 then gpostprocessing=0
endif

rem USERDETAILS Info`
global language$ : language$=""
tfile$="userdetails.ini"
if file exist(tfile$)=1
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem localization data
    tryfield$="language" : if field$=tryfield$ then language$=value$
    `
   endif
  endif
 next l
 undim data$()
endif

rem One flag that controls many
if guseeffectstate=0
 guseeffectongunsstate=0
 guseeffectonscenesstate=0
 guseeffectonentitiesstate=0
endif

rem Physics debug mode 9to see all collision shapes)
if gdebugphysicsstate=1 then physicsdebug=1

rem Forced switches
if gcompilestandaloneexe=1
 rem Cannot be real game, must optimize
 grealgameviewstate=0
 goptimizemode=1
 rem Wipe any imported unique code (generate when build EXE)
 guniquegamecode$=""
endif
if gtestgamemodefromeditor=1
 grealgameviewstate=0
endif

rem The MyGames folder precedes Files\
global exedir$ : exedir$=get dir$()+"\MyGames\"
rem Vista Alert!
`global usersdocumentsfolder$ : usersdocumentsfolder$="?"
`global exedirmaster$ : exedir$=usersdocumentsfolder$+"\MyGames\"
`global exedir$ : exedir$=exedirmaster$

rem First task for any program is to enter the Files Folder
tnopathprotomode=0
if path exist("Files")=1
 set dir "Files"
else
 tnopathprotomode=1
` distinquish between runtime final exe and proto
` print "No Files!"
` wait key
` end
endif

rem Basic globals for all programs
global gmapeditmode : gmapeditmode=0

rem Establish global files and folders
global imgext$ : imgext$="tga"
global rootdir$ : rootdir$=get dir$()+"\"
global browserexe$ : browserexe$="FPSC-Browser.exe"
global browsername$ : browsername$="FPSC TEST Browser"
global segeditexe$ : segeditexe$="FPSC-Segments.exe"
global segeditname$ : segeditname$="FPSC TEST Segment Editor"
global gameexe$ : gameexe$="FPSC-Game.exe"
global gamename$ : gamename$="FPSC Game"

rem Default directories
global currentmeshdir$ : currentmeshdir$=rootdir$+"meshbank\"
global currententitydir$ : currententitydir$=rootdir$+"entitybank\"
global currenttexdir$ : currenttexdir$=rootdir$+"texturebank\"
global currentfxdir$ : currentfxdir$=rootdir$+"effectbank\"
global currentpredir$ : currentpredir$=rootdir$+"prefabs\"
global currentsegdir$ : currentsegdir$=rootdir$+"segments\"
global currentvideodir$ : currentvideodir$=rootdir$+"videobank\"

rem Determine if GAME or MAPEDITOR here, so can set display mode accordingly
global trueappname$ : trueappname$="FPSC-Game"
if lower$(right$(appname$(),18))="fpsc-mapeditor.exe"
 trueappname$="FPSC-MapEditor"
endif

rem Right away set LEGACY CONVERT MODE (LOAD OBJECT should not load extra UV layers)
set legacy convert mode 1

rem And finally switch the resolution if different from default
if runengineinframe=1
 rem FPGC - 260210 - display size from SETUP.INI, else 640x480
 vsyncflag=1 : thevrmodeflag=0 : if gvrmode<>0 then thevrmodeflag=1
 if check display mode(gdisplaywidth,gdisplayheight,gdisplaydepth)=1
  set display mode gdisplaywidth,gdisplayheight,gdisplaydepth,vsync,0,0,0,0,thevrmodeflag
 else
  set display mode 640,480,gdisplaydepth,vsync
 endif
else
 if trueappname$="FPSC-MapEditor"
  rem set resolution for map editor (backbuffer size of renderable area ratio to desktop)
  bkwidth=desktop width()-(800-652) : bkheight=desktop height()-(600-480)
  set display mode desktop width(),desktop height(),screen depth(),0,0,0,bkwidth,bkheight
 else
  `
  rem Set FULLSCREEN MODE (or keep windowed mode) (game only)
  if gtestgamemodefromeditor=0 and gcompilestandaloneexe=0
   if gfullscreen=1 then set window off
  endif
  `
  rem set resolution for game
  if tnopathprotomode=0 or gvrmode<>0
   rem FPGC - 121009 - changed EXE from 1024x768 to 640x480 (for NetBook + odd PCs)
   rem and also detect -1,-1 in which case use desktop width and height
   if gdisplaywidth=-1 or gdisplayheight=-1 then gdisplaywidth=desktop width() : gdisplayheight=desktop height()
   `if gdisplaywidth<>1024 or gdisplayheight<>768 or gdisplaydepth<>32 or gvrmode<>0
   if gdisplaywidth<>640 or gdisplayheight<>480 or gdisplaydepth<>32 or gvrmode<>0
    rem V115 - activate VSYNC mode for U74
    vsyncflag=1
    `vsyncflag=0 : rem to test machine independence
    thevrmodeflag=0 : if gvrmode<>0 then thevrmodeflag=1
    if check display mode(gdisplaywidth,gdisplayheight,gdisplaydepth)=1
     set display mode gdisplaywidth,gdisplayheight,gdisplaydepth,vsync,0,0,0,0,thevrmodeflag
    else
     set display mode desktop width(),desktop height(),gdisplaydepth,vsync
     gdisplaywidth=desktop width()
     gdisplayheight=desktop height()
    endif
   endif
  endif
  `
  rem FPGC - 131009 - option use use correct aspect ratio?
  if gaspectratio=1
   aspect#=desktop width() : aspect#=aspect#/desktop height()
   realaspect#=aspect#
  endif
  `
 endif
endif
newwidth=gdisplaywidth : newheight=gdisplayheight : newdepth=gdisplaydepth
global gratiox# : gratiox#=gdisplaywidth : gratiox#=gratiox#/1024.0
global gratioy# : gratioy#=gdisplayheight : gratioy#=gratioy#/768.0
set camera aspect realaspect#

rem FPGC - 150310 - special case, VRMODE=5 detects VR920 (switches OFF if not found)
if gvrmode=5
 vr920exist=reset left eye()
 if vr920exist=1
  gvrmode=4
 else
  gvrmode=0
 endif
endif

rem FPGC - 130411 - special case, VRMODE=6 assumes new device
global vrsidebysidestereo : vrsidebysidestereo=0
if gvrmode=6
 vrsidebysidestereo=1
 set sprite resize 0,0,0.5
 gvrmode=4
endif

rem V119 - reposition default radar,compass and objective based on new screen resolution
radarx =(gdisplaywidth/100.0)*90
radary = (gdisplayheight/100.0)*90
compassX =(gdisplaywidth/100.0)*10
compassY = (gdisplayheight/100.0)*90
rem Scene Commander, bring objective, armour and air in line with Lee changes
objectivex= compassx
objectivey= compassy
armx = (gdisplaywidth/100.0)
army = (gdisplayheight/100.0)
airx = (gdisplaywidth/100.0)
airy = (gdisplayheight/100.0)

rem FPGC - 230211 - must be done AFTER a resolution change, as 3d math gets wiped out (matrix4=15)
gosub _main_initcalceyes

rem FPGC - 121009 - moved to after resolution change to get correct save load dialog position
gosub _saveload_savebox_init

rem Indicate a time stamp for app start time
timestampactivity(0,"Time Stamp Activity Started")

rem Translation Component (load strarr data)
if tnopathprotomode=0
 stdir$=get dir$()
 if language$="" then language$="english"
 set dir "languagebank\"+language$+"\textfiles\"
 global wordlibmax
 if file exist("fpsc-050.ini")=1
  open to read 1,"fpsc-050.ini"
  read string 1,wordlibmax$ : wordlibmax=val(wordlibmax$)
  close file 1
  strarrmax=1
  dim strarr$(wordlibmax)
  dim wordlib$(wordlibmax)
  load array "fpsc-050.txt",wordlib$()
  for n=0 to wordlibmax
   for c=1 to len(wordlib$(n))
    if mid$(wordlib$(n),c)="="
     strarri=val(left$(wordlib$(n),c-1))
     strarr$(strarri)=right$(wordlib$(n),len(wordlib$(n))-c)
     if strarri>strarrmax then strarrmax=strarri
     exit
    endif
   next c
  next n
  undim wordlib$()
  rem FPGC - 280809 - overwrite 'violent' references with kid friendly
  if file exist("fpsc-120.txt")=1
   dim wordlib$(wordlibmax)
   load array "fpsc-120.txt",wordlib$()
   for n=0 to wordlibmax
    for c=1 to len(wordlib$(n))
     if mid$(wordlib$(n),c)="="
      strarri=val(left$(wordlib$(n),c-1))
      if strarri<=strarrmax
       strarr$(strarri)=right$(wordlib$(n),len(wordlib$(n))-c)
      endif
      exit
     endif
    next c
   next n
   undim wordlib$()
  endif
 else
  rem language file missing
  exit prompt "FAIL","CANNOT FIND LANGUAGE FILE!"
  end
 endif
 set dir stdir$
endif

rem Version control on EXE Building
gosub _version_endofinit

rem
rem
rem LEAP POINT (detect if running as FPSC-Game.exe or FPSC-MapEditor.exe)
rem
rem
if trueappname$="FPSC-MapEditor"
 `
 rem FPGC - 100710 - if we cannot write to Program Files, we shoud find out NOW and report it
 open to write 1,"testwrite.dat"
 write string 1,"we can write to the FPSC folder! Good."
 close file 1
 if file exist("testwrite.dat")=1
  delete file "testwrite.dat"
 else
  exit prompt "FPSC-MapEditor cannot write files to the Program Files area. Ensure you have UAC switched off and that you are running as an administrator user", "Init Error" : end
 endif
 `
 rem gather list of behaviours at start (if exists)
 global behaviourlistmax : behaviourlistmax=0
 behaviourlistmax=fillgloballistwithbehaviours_init()
 `
 rem Enter Map Editor specific code
 goto _mapeditorexecutable
 `
endif

rem
rem GAME MAIN
rem

rem FPGC - 020810 - Game uses AI
gosub _darkai_start

rem Create controls for debug view
global gamedebugrefresh : gamedebugrefresh=0
global gamedebugviewtime : gamedebugviewtime=0
global gamedebugviewmem : gamedebugviewmem=GET MEMORY AVAILABLE(0)
global gamedebugviewlastmem : gamedebugviewlastmem=0
global gamedebugview$ : debugviewactivate(1)
global testgametabtoggle : testgametabtoggle=0
global debugviewmode
global debugviewtog

rem Global used to track memory usage
global gamememstamp : gamememstamp=GET MEMORY AVAILABLE(0)

rem For status text if any
set text font "Verdana"

rem Init app (lee - 140310 - sync rate was 38)
`sync on : sync rate 0 : autocam off : disable systemkeys
rem scene commander performance

sync on : syncrate = 80 : autocam off : disable systemkeys `alpha v1.6 cap for jerky animations

hide mouse : backdrop off : disable escapekey

rem If Game is NOT IN TEST MODE, default is full screen shown
if gtestgamemodefromeditor=0 and gcompilestandaloneexe=0
 `
 rem Show window
 timestampactivity(0,"Start Fullscreen")
 gosub _main_game_showwindownow
 `
 rem optional splash or blank screen at Very Start of Execution
 cls 0 : sync : cls 0 : sync
 Rem Scene Commander changes to allow splash to be bmp,png or jpg
 splashloaded=0:splashfix$=""
 for variousfiles=1 to 3
   select variousfiles
   case 1
   splashfix$="bmp"
   endcase
   case 2
   splashfix$="png"
   endcase
   case 3
   splashfix$="jpg"
   endcase
   endselect

   splashpath$="..\splash."+splashfix$

 if file exist(splashpath$)=1 and splashloaded=0
  rem perhaps publisher splash optional here (finds a specific file name)
  load image splashpath$,1
  if image exist(1)=1
   set sprite 1,0,1
   set sprite alpha 1,0
   logoimagewidth#=image width(1)
   logoimageheight#=image height(1)
   logoimageaspectratio#=logoimagewidth#/logoimageheight#
   logowidth#=screen height()*logoimageaspectratio#
   logowidth#=logowidth#/desktop width()
   logowidth#=logowidth#*screen width()
   size sprite 1,logowidth#,screen height()
   sprite 1,(screen width()-logowidth#)/2,0,1
   for f=0 to 255 step 10
    cls 0 : set sprite alpha 1,f : sync
   next f
   set sprite alpha 1,255
   cls 0 : sync : cls 0 : sync
   splashloaded=1
  endif
 endif

next variousfiles

rem Scene Commander optional splash video file.
    videofilename$="..\splash.avi"

      if videofilename$<>""
       if file exist(videofilename$)=1
        splashvideoplayed=1
        load animation videofilename$,splashvideoplayed
        play animation splashvideoplayed,0,0,screen width(),screen height()
        while animation playing(splashvideoplayed)=1

            if control_escapekey()=1 then exit
            if spacekey()=1 then exit
            if control_mouseclick()<>0 then exit

         sync
        endwhile
        while control_escapekey()=1 or spacekey()=1 or control_mouseclick()<>0 : sync : endwhile

        delete animation splashvideoplayed
        splashvideoplayed=0

       endif
      endif

 rem get the actual server IP for information purposes
 if gmultiplayergame=1
  `
  rem connection check and IP gathering
  show mouse
  `
  rem FPSCV105 - 090307 - check FIREWALL
  rem FPSCV105RC2 - 100307 - AND puts the actual HOSTable IP address in serveripaddress$
  gosub _ai_gamelist_checkforfirewall
  `
  rem FPSCV105RC3 - 140307 - also gather the local IP (in case they want a LAN game) ;localipaddress$;
  MULTIPLAYER CREATE TCP SERVER servername$
  localipaddress$=MULTIPLAYER GET IP ADDRESS()
  if left$(localipaddress$,8)<>"192.168." then localipaddress$=""
  for c=1 to len(serveripaddress$)
   if mid$(localipaddress$,c)=":" then localipaddress$=left$(localipaddress$,c-1) : exit
  next c
  MULTIPLAYER DISCONNECT
  `
  rem done with network stuff for now
  hide mouse
  `
 endif
 if image exist(1)=1
  for f=255 to 0 step -20
   cls 0 : set sprite alpha 1,f : sync
  next f
  set sprite alpha 1,0
  cls 0 : sync : cls 0 : sync
  delete sprite 1
  delete image 1
 endif
 `
endif

rem Reset file collector
resetfilecollection()

rem FPGC - 200310 - initialise FULL SCREEN EFFECTS (camera one) (moved from above to allow file capture)
gosub _postprocess_init

addfiletocollection("databank\compass.png")
addfiletocollection("databank\needle.png")
addfiletocollection("databank\radarback.png")
addfiletocollection("databank\objective.png")

if file exist("videobank\storyvideo.avi")=1
   addfiletocollection("videobank\storyvideo.avi")
endif
for f=1 to 20
a$="databank\blip"+str$(f)+".png"
if file exist(a$)
addfiletocollection(a$)
endif
next f


rem FPGC - 010410 - add controller graphics if flagged
if gcontrollerhint<>0
 addfiletocollection("gamecore\huds\controller\base.png")
 addfiletocollection("gamecore\huds\controller\duck.png")
 addfiletocollection("gamecore\huds\controller\jump.png")
 addfiletocollection("gamecore\huds\controller\look1.png")
 addfiletocollection("gamecore\huds\controller\look2.png")
 addfiletocollection("gamecore\huds\controller\look3.png")
 addfiletocollection("gamecore\huds\controller\look4.png")
 addfiletocollection("gamecore\huds\controller\run.png")
 addfiletocollection("gamecore\huds\controller\use.png")
 addfiletocollection("gamecore\huds\controller\walk1.png")
 addfiletocollection("gamecore\huds\controller\walk2.png")
 addfiletocollection("gamecore\huds\controller\walk3.png")
 addfiletocollection("gamecore\huds\controller\walk4.png")
endif

rem FPGC - 100610 - include gun or equipment folder to specify genre
addfiletocollection("gamecore\"+fpgchuds$+"\"+fpgchuds$+".txt")

rem Add localisation text to final game
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.ini")
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.txt")
 rem FPGC - 010909 - extra files for enhanced versions
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-120.txt")
endif

rem Add ODE licenses text files to final game
if gcompilestandaloneexe=1
 addfiletocollection("License\LICENSE-BSD.TXT")
endif

rem Add SAVELOAD mandatory media
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\saveload-base.tga")
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\areyousure.tga")
endif

rem V118 - 300111 - mandatory files if game uses water
if gcompilestandaloneexe=1
 addfiletocollection("effectbank\common\water_N.dds")
 addfiletocollection("audiobank\water\Drown.wav")
 addfiletocollection("audiobank\water\GaspForAir.wav")
 addfiletocollection("audiobank\water\WaterIn.wav")
 addfiletocollection("audiobank\water\WaterOut.wav")
 addfiletocollection("audiobank\materials\17WadingA1.wav")
 addfiletocollection("audiobank\materials\17WadingA2.wav")
 addfiletocollection("audiobank\materials\17WadingA3.wav")
 addfiletocollection("audiobank\materials\17WadingA4.wav")
 addfiletocollection("audiobank\materials\17WadingD.wav")
 addfiletocollection("audiobank\materials\17WadingI.wav")
 addfiletocollection("audiobank\materials\17WadingS.wav")
 addfiletocollection("audiobank\materials\18UnderwaterA1.wav")
 addfiletocollection("audiobank\materials\18UnderwaterA2.wav")
 addfiletocollection("audiobank\materials\18UnderwaterA3.wav")
 addfiletocollection("audiobank\materials\18UnderwaterA4.wav")
 addfiletocollection("audiobank\materials\18UnderwaterD.wav")
 addfiletocollection("audiobank\materials\18UnderwaterI.wav")
 addfiletocollection("audiobank\materials\18UnderwaterS.wav")
endif

rem Forced 'Shader Compatibility Warning' PROMPT
if gcompilestandaloneexe=1 or grealgameviewstate=1
 filename$="languagebank\"+language$+"\gamecore\huds\noshader.tga"
 img=loadinternalimagecompressquality(filename$,5,1)
endif
if grealgameviewstate=1
 tneed#=0.0
 if guseeffectstate=1
  tneed#=1.0
  if guseeffectonscenesstate=1
   tneed#=2.0
  endif
 endif
 tpsv#=get maximum pixel shader version()
 timestampactivity(0,"Shaders - Need:"+str$(tneed#)+" Got:"+str$(tpsv#))
 if tneed#>tpsv#
  screenprompt(img,strarr$(123))
 endif
endif
`
rem V109 BETA3 - 220408 - build image block OPEN
if gcompilestandaloneexe=1 and gimageblockmode=1
 rem V118 - 060211 - only delete if LEVEL=1 (as we now re-launch build exe and need to retain imageblock from last build)
 if startbuildingleveloverride=1
  if file exist("imageblock.bin")=1 then delete file "imageblock.bin"
 endif
 open imageblock "imageblock.bin",0
 exclude from imageblock "levelbank"
endif
if grealgameviewstate=1
 if file exist("imageblock.bin")=1
  open imageblock "imageblock.bin",1
 endif
endif
`
rem V109BETA5 - 250408 - reset material usage flags before entity/segment load
rem V109BETA10 - 1204508 - flak loads data only (to keep flak indexing same as gun usage)
gosub _flak_init
gosub _ode_loadmateriallist_init
gosub _player_resetmaterialsused
if grealgameviewstate=1 then gosub _player_loadmaterialsused
gosub _ode_loadmateriallist_core
`
rem FPGC - 231109 - initialise DarkVOICES
gosub _lipsync_init
rem GUI-X9 (knxrb)
gosub _gui_init
rem if gcompilestandaloneexe=1 and gimageblockmode=1 then GUI_ATIB()

`
rem Run gameflow default screen path
timestampactivity(0,"Game Flow Started..")
gosub _gameflow_default
`
rem V109BETA5 - 250408 - save materials that have been used in this game
if gcompilestandaloneexe=1
 rem call list_core again so we can add only used files ot build
 gosub _ode_loadmateriallist_core
 gosub _player_savematerialsused
endif
`
rem Export game as standalone if -B used
if gcompilestandaloneexe=1
 rem Generate unique code
 guniquegamecode$=genuniqueservercode(gbuildname$)
 rem Build Executable Game Mode
 gosub _main_game_buildexe
 rem V118 - 060211 - new system terminates build exe after one level, and re-launches if more levels
 inc level
 if level<=glevelmax
  rem NEXT level needs to be build
  timestampactivity(0,"Terminate build executable to start building level "+str$(level))
  set dir startbuildinglevelfromdir$
  execute file "FPSC-Game.exe","-bl"+str$(level),"",0
  end
 else
  rem NOW can return to map editor
  rem close dialog (cannot reload data into it when RELOAD MAPEDITOR)
  open file map 1, "FPSBUILDGAME"
  set file map dword 1, 24, 1
  wait for file map event 1
  close file map 1
  rem call map editor back
  open file map 1, "FPSEXCHANGE"
  set file map string$ 1, 1000, "FPSC-MapEditor.exe"
  set file map string$ 1, 1256, "-r"
  set file map dword 1, 994, 0
  set file map dword 1, 924, 1
  wait for file map event 1
  close file map 1
 endif
endif
`
rem V109 BETA3 - 220408 - close read imageblock (write imageblock closed inside buildexe)
if grealgameviewstate=1
 if file exist("imageblock.bin")=1
  close imageblock
 endif
endif
`
rem End executable
if gexitpromptreportmodestate<>0 then exit prompt "Terminated Game Exe","FPSCV10X Debug Report"
timestampactivity(0,strarr$(125))
end

`
` EXE Building Subroutines
`

_main_game_buildexe:
 `
 rem Version control on EXE Building
 gosub _version_main_game_buildexe
 `
return

`
` MAIN GAME SUBROUTINES
`

_main_game_loadgamedata:
 `
 rem Display game loading/creating-game backdrop
 if gdebugreportmodestate=1
  if gtestgamemodefromeditor=0
   for s=0 to 1
    cls rgb(255,255,0)
    ink rgb(0,0,255),0 : center text screen width()/2,screen height()/2,"DEBUG REPORT MODE ACTIVE"
    ink rgb(255,255,255),0
    sync
   next s
  endif
 endif
 debugviewprogressmax(330)
 `
 rem Place camera faw away (effectively hide all 3D)
 set camera range 2.0,realrange#
 position camera -50000,50000,50000
 point camera -50000,50010,50000
 `
 rem Load segment banks
 segobjusedforfinalgame=1 : segnoeffects=gsegnoeffectstate
 `
 rem Load AI Scripts (can be done in elements process-only load as needed)
 debugviewtext(30,strarr$(126)) : gosub _ai_loadessentialentityscripts
 debugviewtext(60,strarr$(127)) : gosub _decal_init
 `if gmultiplayergame=0 then debugviewtext(70,strarr$(128)) : gosub _flak_initonlyused `moved after GUN LOADS to know what we are using!
 debugviewtext(70,strarr$(129)) : gosub _gun_init
 debugviewtext(75,strarr$(130)) : gosub _gun_setup
 `
return

_main_game_freeleveldata:
 `
 rem only for final game run ( not test game ) - uses leavegamedataalone in last part
 if grealgameviewstate=1 or gcompilestandaloneexe=1
  `
  rem free AI resouces
  gosub _darkai_free
  `
  rem Free multiplayer resources
  gosub _multi_free
  `
  rem Free fragments
  if gmultiplayergame=0 then gosub _part_free
  `
  rem Free the old gun
  gosub _gun_freeafterlevel
  `
  rem Place camera faw away (effectively hide all 3D)
  position camera -50000,50000,50000
  point camera -50000,50010,50000
  `
  rem Remove universe (so camera can reset to no-3D-view)
  gosub _universe_destruct
  `
  rem Physics cleanup
  gosub _ode_cleanup
  `
  rem Remove all images
  deleteallinternalimages()
  `
  rem FREE REST OF GAME RESOURCES
  for p=1 to 65535 : if particles exist(p)=1 : delete particles p : endif : next p
  for e=1 to 65532 : if effect exist(e)=1 : delete effect e : endif : next e
  for s=1 to 65535
   if sound exist(s)=1
    rem V109 BETA5 - leave core materials alone
    if s>=materialsoundoffset and s<=materialsoundoffset+materialsoundmax
     rem do not delete core material sounds loaded prior to level-loading
    else
     delete sound s
    endif
   endif
  next s
  `
  rem Free all objects
  rem V115 - BETA3 - 180309 - leave any FLAK objects in tact
  `delete objects 1,endofallobjectsoffset
  delete objects 1,flakbankoffset-1
  rem FPGC - 050410 - skip camera one screen aligned quad
  delete objects flakelementoffset,65535
  delete objects 65537,endofallobjectsoffset
  `
  rem FPGC - 250310 - ensure objecteffect array is cleared after any object delete
  for o=1 to 65535
   if object exist(o)=0 then objecteffect(o)=0
  next o
  `
  Rem Hockeykid - 250210 - RESET DARKAI
  rem FPGC - 300710 - DarkAI only in single player
  if gmultiplayergame=0
   ai reset : darkaiplayer=0
  endif
  `
  rem FPGC - 090411 - reset fast bone effectid list
  gfastboneeffectshaderidmax=0
  `
  rem FREE ANY DATA
  Rem AI Undim
  undim ischaracter()
  undim aifaction()
  undim aisafezone()
  undim points()
  undim aisound()
  Rem undimming ammopool was breaking ammo transfer.
 ` undim ammopool()
  undim undoredolist()
  undim meshbank$()
  undim texturebank$()
  undim effectbank$()
  undim soundbank$()
  undim prefabbank$()
  undim selectionbank$()
  undim entitybank$()
  undim gunbank$()
  undim muzzlebank$()
  undim brassbank$()
  undim smokebank$()
  undim decalbank$()
  undim imagebank$()
  undim segmentprofileheader()
  undim segmentprofile()
  undim map()
  undim viscolmap()
  undim refmap()
  undim mapolay()
  undim olaylist()
  undim mapentries()
  undim mastermesh()
  undim entitybodypart()
  rem AirMod - Advanced Blood
  undim entityblood()
  undim entityanim()
  undim entityfootfall()
  undim entityprofileheader()
  undim entityprofile()
  undim entityelement()
  undim entityshadervar()
  undim entitydebug$()
  undim aiactionseq()
  undim aiaction()
  undim aiconditionseq()
  undim aicond()
  undim ailist()
  undim waypointcoord()
  undim waypoint()
  `undim debris()
  undim gun()
  undim firemode()
  undim bulletlimbs()
  undim gunsound()
  undim gunsoundcompanion()
  undim gunsounditem()
  undim flakelement()
  undim flakstick()
  undim decal()
  undim decalelement()
  undim player()
  undim playersound()
  undim playersoundsetindex() : rem FPGC - 020909 - improved sound management
  undim playerinventory()
  undim infinilight()
  undim infinilightshortlist()
  undim shadowlight()
  undim hud()
  `
  rem Ensure loader HUD is not used if resources removed
  internalloaderhud=0
  gcontrollerhinthudid=0
  gcontrollerhintbase=0
  guivisualsettings.ambiencescripted=0
  `
  rem Special exception as only arrays that need carrying to new levels
  if leavegamedataalone=0
   undim scriptbank$()
   undim weaponslot()
   undim weaponammo()
   undim weaponclipammo()
  endif
  undim weaponhud()

rem Compass - Scene commander- original code used with permission knxrb
compassOn = 0
madeCompass =0
if sprite exist(compassobject)=1
hide sprite compassobject
endif
if sprite exist(needleobject)=1
hide sprite needleobject
endif
  `
  rem Recreate all data for new level (uses leavegamedataalone)
  gosub _FPSC_Full_Data_Init
  `
 endif
 `
return

_main_game_core:

 rem Transition
 if gamewarmupcount=0
  if gametransitionscreen=1
   dec gametransitionscreencount,30
   if gametransitionscreencount<=0
    set camera view 0,0,screen width(),screen height()
    gametransitionscreen=0 : gametransitionscreencount=0
    rem Handle Hosting/Joining (multiplayer) when 3D starts
    if gmultiplayergame=1 and multiplayerinitialised=0 then gosub _multi_start
   else
    if gametransitionscreencount<(screen height()/2)-30
      rem Scene Commander - changes for player cam offsets.
     position camera lastcamx#+plrcamoffsetx#,lastcamy#+plrcamoffsety#,lastcamz#+plrcamoffsetz#
     color backdrop rgb(0,0,64)
    endif
    set camera view 0,gametransitionscreencount,screen width(),gametransitionscreencount+(screen height()-(gametransitionscreencount*2))
   endif
  endif
 else
  rem the warmup allows decals to form, player start gravity to settle, etc
  cls 0 : dec gamewarmupcount,timeelapsed#
  rem FPGC - 110610 - stabalize start of physics simulation for text and standalone games
  gosub _ode_beginphysics
  if gamewarmupcount<0 then gamewarmupcount=0
  if gamewarmupcount=0
   cleardelta=mousemovex() : cleardelta=mousemovey()
   rem switch gravity on after warm up (maybe?)
   `ode set world gravity physicsgravx#,physicsgravy#,physicsgravz#
   rem FPGC - 110610 - little nudge to ensure floating entities tied to physics fall to floor when game has warmed up
   gosub _ode_giveentitiesalittlenudgejustbeforelevelbegins
  endif
 endif
 `
 rem Sky stays with camera
 if object exist(65123)=1
  position object 65123,camera position x(0),camera position y(0),camera position z(0)
 endif
 if object exist(65124)=1
  position object 65124,camera position x(0),camera position y(0)+1000,camera position z(0)
  scroll object texture 65124,0.0004,0.0005
 endif
 `
 rem Control main game
 gosub _main_game_corecontrol
 `
 rem Get time from last sample to SYNC command (rest)
 inc gameperfresttosync, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem Update physics
 gosub _ode_update
 `
 rem Count physics time
 inc gameperfphysics, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  `
  rem V118 - 240111 - must set player height for correct DarkAI running (and use CAMERA not OBJECT)
  tcamx#=camera position x()
  tcamy#=camera position y()
  tcamz#=camera position z()
  AI Set Player Position tcamx#,tcamy#,tcamz#
  `
  Rem Hockeykid - 250210 - Dark AI Tell AI system if player crouching
  if crouchmode<>0
   ai set player ducking 1
  else
   ai set player ducking 0
  endif
  `
  Rem Hockeykid - 050410 - Update AI Safe zones
  Gosub _SafeZone_Update
  `
  Rem Hockeykid - 300310 - Update AI sound
  AIUpdateSounds()
  `
  Rem Hockeykid - 250210 - Update AI
  AI Update
  `
  rem FPGC - 060710 - hide any debug text behind the AI debug flag so final games do not get
  rem extra debug text in their test game and standalone game sessions
  if gshowaioutlines=1
   for x=1 to 20
    for y=1 to 20
     if aifaction(x,y).enemy<>0 then print "Team:"+str$(aifaction(x,1).team)+" Enemy:"+str$(aifaction(x,y).enemy)
     if aifaction(x,y).ally<>0 then print "Team:"+str$(aifaction(x,1).team)+" Ally:"+str$(aifaction(x,y).ally)
     if aifaction(x,y).neutral<>0 then print "Team:"+str$(aifaction(x,1).team)+" Neutral:"+str$(aifaction(x,y).neutral)
    next y
   next x
  endif
  `
 endif
 `
 rem Record AI usage
 inc gameperfai, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()
 `
 rem Measure overall performance counts
 inc gameperftotalcount, perftimer()-gameperftotalcountTOP
 gameperftotalcountTOP=perftimer()

 if wateron=1
  Gosub _water_control
 endif
 `
 rem Update screen
 if keystate(28) then gotintodes=0

rem scene commander jump underwater fix
if playerunderwater=1
jumpaction=0
endif

rem scene commander new air commands

if airon=2 and playerunderwater=0 and noairon=0 then airleft=airmax

if playerunderwater<>0 or noairon<>0

   if airon<>0 or noairon<>0

      if timer()-airtimer>airtime and airleft>0
      airleft=airleft-1
      airtimer=timer()
      endif

   if airleft<=0
      if instantdrown=0
         if timer()-drowntimer>drowntime and player(1).health>0
         drowned=1
      tdamage=drowndamage:gosub _player_takedamage
      drowntimer=timer()
      drowned=0
         endif

      endif

   endif

      if airleft<=0
       if instantdrown=1
       drowned=1
     tdamage=1000000:gosub _player_takedamage
     airleft=airmax
     rem play drown sound alpha v1.2
     tsnd=19
      if playersound(tplrid,tsnd)>0
      broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0,-1)
      play sound playersound(tplrid,tsnd)

       endif
      endif

   endif
  endif
endif

Rem Scene Commander tilt on player death.

if tilton<>0
   if tiltondeath<>0
      if tiltontemp=0 then tiltontemp=tilton
      if tiltontemp=5 then tiltontemp=rnd(3)+1

      select tiltontemp
case 1
   dec tiltondeath,tiltspeed#
   rotate camera 0,camera angle x(0),camera angle y(0),tiltondeath
   if tiltondeath<270
      tiltondeath=270
      if thud=0 then thud=1:camshake#=rnd(tiltbounce)+tiltbounce
   endif
endcase

case 2
   inc tiltondeath,tiltspeed#
   if tiltondeath>360 then tiltondeath=1
   rotate camera 0,camera angle x(0),camera angle y(0),tiltondeath
   if tiltondeath>90
      tiltondeath=90
      if thud=0 then thud=1:camshake#=rnd(tiltbounce)+tiltbounce
   endif
endcase

case 3
   inc tiltondeath,tiltspeed#
   if tiltondeath>360 then tiltondeath=1
   rotate camera 0,tiltondeath,camera angle y(0),camera angle z(0)
   if tiltondeath>90
      tiltondeath=90
      if thud=0 then thud=1:camshake#=rnd(tiltbounce)+tiltbounce
      endif
endcase

case 4
     dec tiltondeath,tiltspeed#
   rotate camera 0,tiltondeath,camera angle y(0),camera angle z(0)
   if tiltondeath<270
      tiltondeath=270
      if thud=0 then thud=1:camshake#=rnd(tiltbounce)+tiltbounce
    endif
endcase

endselect
endif
endif

if player(1).health>0 and justdone=0 then tiltondeath=0:rotate camera 0,0,camera angle y(0),0:temptilt=0:thud=0:justdone=1

Rem Scene commander
Rem Show / Hide crosshair
if object exist(hudbankoffset+31)
   if gunid>0 and crosshairon=0
      if gun(gunid).settings.crosshairimg>0 then hide object hudbankoffset+31
   endif

   if gunid>0 and crosshairon=1
    if gun(gunid).settings.crosshairimg>0 then show object hudbankoffset+31
   endif
endif

 gosub _main_sync
 `
 rem FPGC - 190310 - quick exit keys (for standalone game only)
 if grealgameviewstate=1
  if keystate(56)=1 or keystate(184)=1
   if keystate(18)=1 then continueokay=1 : loopapp=0 : levelwon=2 : rem quit game
  endif
 endif
 rem code added for new syncrate
if syncrate <> 0
      ` while timer()-gametimer < 1000 / syncrate
   ` endwhile
    `gametimer= timer()
global tm_current_value,syncrate#
global dim syncrate(15)

   syncrate(tm_current_value) = timer()
   inc tm_current_value
   if tm_current_value = 10 then tm_current_value = 1
   syncrate# = ( timer() - syncrate(tm_current_value) ) / 1000.0

 endif


 rem Can intercept to grab screen - Scene Commander fix, no longer freezes if PlrkeyF12 is held
 if keystate(plrkeyF12)=1 and (timer()-screengrabtimer>1000)
 screengrabtimer=timer()
  tnum=1
  repeat
   snapshotfile$="..\snapshot"+str$(tnum)+".bmp"
   inc tnum
  until file exist(snapshotfile$)=0
  get image 21000000,0,0,screen width(),screen height(),1
  if image exist(21000000)=1
   save image snapshotfile$,21000000,1
   delete image 21000000
  endif
  `while keystate(plrkeyF12)=1
  `endwhile
 endif
 `
 rem Sync Performance check
 gameperfsync=gameperfsync+(perftimer()-gameperftimestamp)
 gameperftimestamp=perftimer()
 gamedebugviewtime=timer()
 `
 rem Exit Conditions for test game
 if grealgameviewstate=0
  Rem Hockeykid - 260210 - Added ai reset to avoid Dark AI from creating a silent crash
  if control_escapekey()=1
   if gmultiplayergame=0 then ai reset
   continueokay=1 : levelwon=2 : rem QUIT
  endif
 endif
 `
return

_main_sync:

if ecam=0

rem scene commander, final adjustments to camera if rotation offsets for player

  if plroffsetanglex#<>0 or plroffsetangley#<>0 or plroffsetanglez#<>0
  rotate camera 0,camera angle x(0)+plroffsetanglex#,camera angle y(0)+plroffsetangley#,camera angle z(0)+plroffsetanglez#
  endif
rem scene commander, player camera offsets
   if plrcamoffseton<>0 and showgamemenu=0
   position camera camera position x(0)+plrcamoffsetx#,camera position y(0)+plrcamoffsety#,camera position z(0)+plrcamoffsetz#
   endif
endif
rem attach entity to camera using entity offsets

if eplayercam<>0

rem Scene commander, does entity use player rotation values?

trotx=0
troty=0
trotz=0

if linkx<>0
xrotate object entityelement(eplayercam).obj,wrapvalue(camera angle x(0)+entityelement(eplayercam).offsetanglex)
endif

if linky<>0
yrotate object entityelement(eplayercam).obj,wrapvalue(camera angle y(0)+entityelement(eplayercam).offsetangley)
endif

if linkz<>0
zrotate object entityelement(eplayercam).obj,wrapvalue(camera angle z(0)+entityelement(eplayercam).offsetanglez)
endif

rem reposition entity

 x1#=object position x(physicsplayerborble)
 y1#=object position y(physicsplayerborble)
 z1#=object position z(physicsplayerborble)

entityelement(eplayercam).x=x1#+entityelement(eplayercam).camoffsetx
entityelement(eplayercam).y=y1#+entityelement(eplayercam).camoffsety
entityelement(eplayercam).z=z1#+entityelement(eplayercam).camoffsetz

position object entityelement(eplayercam).obj,entityelement(eplayercam).x,entityelement(eplayercam).y,entityelement(eplayercam).z

if entityelement(eplayercam).attachmentobj>0
      if object exist(entityelement(eplayercam).attachmentobj)=1

       SET OBJECT TO OBJECT ORIENTATION entityelement(eplayercam).attachmentobj,entityelement(eplayercam).obj,1
      endif
   endif

endif

rem using entity cam

if ecam<>0

position camera entityelement(ecam).x+entityelement(ecam).camoffsetx,entityelement(ecam).y+entityelement(ecam).camoffsety,entityelement(ecam).z+entityelement(ecam).camoffsetz
   if entityelement(ecam).camuse=0
   rotate camera wrapvalue(entityelement(ecam).rx+entityelement(ecam).offsetanglex),wrapvalue(entityelement(ecam).ry+entityelement(ecam).offsetangley),wrapvalue(entityelement(ecam).rz+entityelement(ecam).offsetanglez)


   else
   rotate camera wrapvalue(entityelement(ecam).camrotx+entityelement(ecam).offsetanglex),wrapvalue(entityelement(ecam).camroty+entityelement(ecam).offsetanglex),wrapvalue(entityelement(ecam).camrotz+entityelement(ecam).offsetanglex)
   endif
endif


 rem FPGC - 280610 - moved entire SYNC sequence to subroutine so PAUSE mode can call it too
 if gvrmode<>0
  rem VR920
  set current camera 0
  set camera rotation xyz
  if gvrmode=4
   rem VRMODE 4 - player has no mouselook control of looking up/down (use tracker)
   rotate camera 0,camangy#,0
  else
   rotate camera camangx#,camangy#,0
  endif
  if gvrmode>=2
   if gvrmode=4
    rem FPGC - 260410 - mode 4 diminishes X if Y large
    rem Harder to look up if looking left/right too
    tdiminishfactor#=abs(vrmodetrackery#)
    if tdiminishfactor#>90.0 then tdiminishfactor#=90.0
    tdiminishfactor#=1.0-(tdiminishfactor#/90.0)
    vrmodetrackerxdiminished#=vrmodetrackerx#*tdiminishfactor#
    pitch camera up vrmodetrackerxdiminished#
   else
    pitch camera up vrmodetrackerx#
   endif
   if gvrmode=2 or gvrmode=3
    rem VRMODE 2 - head turn causes player to turn
    cappedvrmodetrackery#=vrmodetrackery#
    if cappedvrmodetrackery#>10 then cappedvrmodetrackery#=10
    if cappedvrmodetrackery#<-10 then cappedvrmodetrackery#=-10
    tsubtletracking#=curvevalue(cappedvrmodetrackery#,tsubtletracking#,5.0)
    turn camera left tsubtletracking#
    precama#=camangy#+(vrmodetrackery#*-1)
   endif
   if gvrmode=4
    rem VRMODE 4 - head turn, player angle stays put
    rem FPGC - 260410 - mode 4 diminishes Y if X large
    rem Harder to look left/right if looking up/down too
    tdiminishfactor#=abs(vrmodetrackerx#)
    if tdiminishfactor#>90.0 then tdiminishfactor#=90.0
    tdiminishfactor#=1.0-(tdiminishfactor#/90.0)
    vrmodetrackerydiminished#=vrmodetrackery#*tdiminishfactor#
    turn camera left vrmodetrackerydiminished#
   endif
   if gvrmode<>4
    rem FPGC - 260410 - mode 4 (mode 5 autoswtch) uses only X and Y
    roll camera right vrmodetrackerz#
   endif
  else
   precama#=camangy#
  endif


  rem FPGC - 250210 - new stereo eye positioning (correct this time)
  rem position left eye camera and do main render
  gosub _main_calceyes
  precamx#=camera position x()
  precamy#=camera position y()
  precamz#=camera position z()

  position camera camera position x()+x vector4(13),camera position y()+y vector4(13),camera position z()+z vector4(13)
  if vrsidebysidestereo=1
   set camera view 0,0,screen width()/2,screen height()
   set sprite resize 0,0,0.5
  endif
  sync
  rem then relocate camera to right eye and render quickly
  position camera camera position x()+x vector4(14),camera position y()+y vector4(14),camera position z()+z vector4(14)
  rem re-paint all HUD graphics as they are rendered over regular 3D
  gosub _ai_hud_view
  if vrsidebysidestereo=1
   set camera view screen width()/2,0,screen width(),screen height()
   set sprite resize 0,512,0.5
  endif
  fastsync
  rem restore camera position and rotation for engine flow
  position camera precamx#,precamy#,precamz#
  rotate camera camangx#,camangy#,0

 else
  Rem Exclude water from postprocess render
  if wateron=1 then hide object waterobj
  gosub _postprocess_renderdepthcamera
  if wateron=1 then show object waterobj
  `
  if wateron=1
   Rem Hide crosshair from camera renders
   if gunid>0
    if gun(gunid).settings.crosshairimg>0 then hide object hudbankoffset+31
   endif
   if currentgunobj>0
    if object visible(currentgunobj)
     Hide Object currentgunobj : tguncurrenthidden=1
    endif
   endif
   `
   Rem ensure skybox is rendered
   if object exist(65123)
    if object visible(65123)=0 then show object 65123 : wasinvisible=1
   endif
   UpdateWater()
   if object exist(65123)
    if wasinvisible=1 then hide object 65123 : wasinvisible=0
   endif
   `
   if gunid>0
    if gun(gunid).settings.crosshairimg>0 then show object hudbankoffset+31
   endif
   if currentgunobj>0 and tguncurrenthidden=1 then show object currentgunobj : tguncurrenthidden=0
  else
   if object visible(waterobj) then Hide Object waterobj
  endif
  `
  Rem Handle fog
  if hudfogon=1 and waterfogon=0
   hudfogison=1
   if fogison=0 then fog on : fogison=1
   fog distance hudfognear,hudfogfar
   fog color hudfogred,hudfoggreen,hudfogblue
   `
   rem FPGC - 090411 - also set fog colour in fast bone shaders (if any)
   r=make vector4(1)
   set vector4 1,(hudfogred/255.0),(hudfoggreen/255.0),(hudfogblue/255.0),1.0/hudfogfar
   for fbei=1 to gfastboneeffectshaderidmax
    tfsbeffectid=gfastboneeffectshaderid(fbei)
    set effect constant vector tfsbeffectid,"FogColor",1
   next fbei
   r=delete vector4(1)
   `
  else
   if hudfogon=0 and waterfogon=0
    if fogison=1 then fog off : fogison=0
    hudfogison=0
   endif
  endif
  if waterfogon>0 and hudfogon=1 then hudfogison=0
  if waterfogon>0
   if fogison=0 then fog on : fogison=1
   fog color rgb(waterfogred,waterfoggreen,waterfogblue)
   if waterfogon=2
    fog distance 250+(camera position y(0)-waterheight#)*10
   else
    fog distance waterfogfar
   endif
   `
   rem FPGC - 090411 - also set fog colour in fast bone shaders (if any)
   r=make vector4(1)
   set vector4 1,(waterfogred/255.0),(waterfoggreen/255.0),(waterfogblue/255.0),1.0/waterfogfar
   for fbei=1 to gfastboneeffectshaderidmax
    tfsbeffectid=gfastboneeffectshaderid(fbei)
    set effect constant vector tfsbeffectid,"FogColor",1
   next fbei
   r=delete vector4(1)
   `
  endif
  `
  Rem When water is off exclude the render of cameras 1 and 2
  if wateron=0 or excludewatercams=1 then sync mask %11111001


 rem LightRay Addition
  rem LRMODUPDATE

      Rem Scene Commander flashlight
      gosub _flashlight_control
  SyncAll()
  if gpostprocessing=0 or gpostprocessing=1 or gpostprocessing=2 then set current camera 0
  if gpostprocessing=0 or gpostprocessing=1 or gpostprocessing=2 then sync

 ` sync
 ` if gcapfpson=0 then sync rate 80
  endif
 `if gcapfpson=0 then syncrate = 140

return

_main_initcalceyes:
 rem FPGC - 250210 - set-up distance between left and right eyes
 r=make vector4(11) : r=make vector4(12)
 r=make vector4(13) : r=make vector4(14)
 set vector4 11,-2.5,0,0,0 : set vector4 12,2.5,0,0,0
 r=make matrix4(15)
return

_main_calceyes:
 rem FPGC - 250210 - use view matrix (inverted) to make eyes align to camera 'head'
 view matrix4 15
 r=inverse matrix4(15,15)
 transform vector4 13,11,15
 transform vector4 14,12,15
return



rem
rem LEES Game Runner Code
rem

_load_game_scene:

rem GUI-X9 (knxrb)
GUILoad=0 : GUISave=0 : gosub _gui_run : rem (Clears screen of unnecessary GUI parts)

rem Loading Screen
if gdebugreportmodestate=0 then set camera view 0,0,1,1

rem Direct to realgame or testgame
if grealgameviewstate=1
 `
 rem Set realgame level path
 levelmapptah$="levelbank\testlevel\"
 `
 rem load the FPL file which populates testlevel for current level to play (level var)
 gosub _mapfile_load_fpl
 `
else
 `
 rem During test map this path can be used (map edit files)
 levelmapptah$="mapbank\testmap\"
 `
 rem Load the FPM data to mapbank\testmap (level var)
 if gcompilestandaloneexe=1
  gosub _mapfile_loadgamemap_fpm
  elementsfilename$=""
 endif
 `
endif

rem TestGameFromEditor Mode
if gtestgamemodefromeditor=1
 `
 rem FPGC - 050909 - load resources collected so far (from previous test games)
 loadresource()
 `
 rem FPGC - 130710 - if in test mode, load ambient setting override
 guivisualsettings.ambienceoverride=-1
 if gtestgamemodefromeditor=1
  if file exist("editors\gridedit\testambience.txt")=1
   open to read 1,"editors\gridedit\testambience.txt"
   read string 1,a$ : guivisualsettings.ambienceoverride=val(a$)
   close file 1
  endif
 endif
 `
endif

rem Free any old player resources
debugviewtext(120,strarr$(131)) : gosub _player_free

rem Flush video for new graphics usages
debugviewtext(130,strarr$(132)) : flush video memory

rem Free old resources first
debugviewtext(140,strarr$(133)) : gosub _entity_deleteelements

rem Load waypoints
if gshowdebugtextingamestate=0 then gdontcreatewaypointobjects=1
debugviewtext(150,strarr$(134)) : gosub _waypoint_loaddata
if gshowdebugtextingamestate=1 then gosub _waypoint_createallobjs

rem Ensure segments are loaded (not for final game though - universe dbo does this)
if grealgameviewstate=0 then debugviewtext(160,strarr$(135)) : gosub _segment_loadbank

rem Ensure segments and entities are up to date
debugviewtext(170,strarr$(136)) : gosub _entity_loadbank

rem Load individual-elements
debugviewtext(180,strarr$(137)) : gosub _entity_loadelementsdata
debugviewtext(185,strarr$(137)) : gosub _entity_switchtostaticformultiplayer

rem DarkAI called before each level starts (and before static entities created)
debugviewtext(190,"Initialise AI...") : gosub _darkai_init

rem Load map (with any segment entitiy-elements)
debugviewtext(200,strarr$(138)) : gosub _game_loadmap

rem Finally create and attach elements to map
if gmultiplayergame=0 then debugviewtext(299,strarr$(626)) : gosub _part_init
debugviewtext(300,strarr$(139)) : gosub _entity_createelements
debugviewtext(310,strarr$(140)) : gosub _entity_attachelementstogame
debugviewtext(311,strarr$(141)) : gosub _ai_createentityreferences

rem Load material list and sounds
debugviewtext(312,strarr$(142)) : gosub _ode_loadmateriallist

rem Entities can intropduce fake players, init all
debugviewtext(312,strarr$(142)) : gosub _player_startgun
debugviewtext(313,strarr$(143)) : gosub _gun_loadonlypresent
rem V109 BETA10 - 120508 - moved here to load FLAK after GUNLOADS (usedinlevel flag)
if gmultiplayergame=0 then debugviewtext(313,strarr$(128)) : gosub _flak_initonlyused
debugviewtext(314,strarr$(144)) : gosub _decal_loadonlyactivedecals
Gosub _gun_decaldetails
`
Rem load flak scripts
if gmultiplayergame=0 then debugviewtext(315,"Loading Flak Scripts...") :   gosub _flak_load_script
`
rem Entities can intropduce fake players, init all
debugviewtext(318,strarr$(145)) : gosub _player_init : gosub _player_resetobjectives
debugviewtext(320,strarr$(146)) : gosub _entity_startentitiesoff
`
debugviewtext(321,"Creating Water...") : MakeWater()
rem LightRay Addition
debugviewtext(322,"Creating Light Rays...") : CreateLGMod()

rem Okay for start of game, can skip for exe construction
if gcompilestandaloneexe=0
 `
 rem FPGC - 290410 - create obstacles per level (but not when building exe - done earlier)
 debugviewtext(324,"Generating Obstacles...") : gosub _darkai_createlevel
 `
 rem Physics init of universe and entities (321,322,323)
 debugviewtext(325,strarr$(627)) : gosub _ode_init
 `
 rem Setup camera (player)
 debugviewtext(326,strarr$(628)) : gosub _player_setup
 `
 rem Reset multiplayer state (multiplayer)
 if gmultiplayergame=1
  gosub _multi_restartprepare
  multiplayerinitialised=0
 endif
 `
 Rem Hockeykid - 260210 - Added subroutine for debugging Dark AI
 debugviewtext(327,"Preparing AI Data...") : gosub _darkai_debug
 Rem Hockeykid - 040410 - Added subroutine to add all .ischaracter's E to ischaracter() array
 debugviewtext(327,"Preparing AI Arrays...") : gosub _Character_Array
 `
 rem FPGC - 050510 - at end of generation phase, load sounds in (if room)
 debugviewtext(328,strarr$(105)) : gosub _entity_createelements_loadsoundlast
 `
 rem Starting main loop
 debugviewtext(329,strarr$(629))
 `
else
 `
 rem need to at least add script referenced files to collection (during build)
 gosub _entity_createelements_loadsoundlast_fileref
 `
endif

rem TestGameFromEditor Mode
if gtestgamemodefromeditor=1
 `
 rem FPGC - 050909 - save resources collected from this test game
 saveresource()
 `
 rem Activate OK button
 open file map 1, "FPSTESTGAMEDIALOG"
 set file map dword 1, 12, 1
 rem FPGC - 050510 - report size of the test game (useful)
 `set file map string$ 1, 1000, strarr$(147)
 vmsize=(system smem available(2)/1024)
 set file map string$ 1, 1000, strarr$(147)+". This level uses "+str$(vmsize)+"MB."
 set file map dword 1, 8, 100
 wait for file map event 1
 close file map 1
 while 1
  open file map 1, "FPSEXCHANGE"
  wait for file map event 1
  rem Wait for Test Game Dialog OK button pressed
  if get file map dword( 1, 974 ) = 1 then exit
  if get file map dword( 1, 994 ) = 1
   rem terminate test game mid-build
   set file map string$ 1, 1000, "FPSC-MapEditor.exe"
   set file map string$ 1, 1256, "-r"
   set file map dword 1, 994, 2
   set file map dword 1, 924, 1
   wait for file map event 1
   close file map 1
   rem Terminate
   end
  else
   close file map 1
  endif
  sync
 endwhile
 close file map 1
 `
 rem make sure the cancel code is not detected for anymore in debug function
 gtestgamemodefromeditorokaypressed=1
 `
 rem Version Control - possible logo use
 gosub _version_onscreenlogos
 `
 rem Show Test Game Window
 gosub _main_game_showwindownow
 `
endif

rem Sample transition IN
gametransitionscreen=1 : gametransitionscreencount=600/2

Rem AirMod - Make Sure Backdrop Vid Isn't Active
if animation exist(1) then stop animation 1 : delete animation 1


return

_main_game_showwindownow:
 if runengineinframe=0
  set window layout 0,0,0
  maximize window
  show window
  if grealgameviewstate=1
   rem run direct from EXE
  else
   rem test game to front
   rem FPGC - 010909 - TEST GAME needs this to keep window to the very front always (though not when debuggin)
   if gloadreportstate=1
    window to front "FPSC Game"
   else
    window to front "__topmost__"+"FPSC Game"
    sleep 100
    window to front "__topmost__"+"FPSC Game"
   endif
  endif
 endif
return

_main_game_corecontrol:


rem Stamp time for performance meter
if showgamemenu=0 then inputpositionmouse(screen width()/2,screen height()/2)

rem STATUS AND HUD GRAPHICS
if gamewarmupcount=0
 gosub _screen_control
endif

rem Scene Commander - calculate more accurate time based movement

timebasepercycle#=(1.0/50.0)*(timer()-timebasepercyclestamp) : timebasepercyclestamp=timer()

rem FPSCV104RC4 - i want to see this
`if grealgameviewstate=0
if gdebugreportmodestate=1 or grealgameviewstate=0
 `
 rem Debug info
 debuggameoverlaysystem(0)
 inc gameperfdebug, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
else
 `
 rem Ingame debug FPS
 if keystate(15)=0 then keystate15pressed=0
 if keystate(15)=1 and keystate15pressed=0
  inc showfpsinrealgame
  if ggodmodestate=0
   if showfpsinrealgame>1 then showfpsinrealgame=0
  else
   if showfpsinrealgame>2 then showfpsinrealgame=0
  endif
  keystate15pressed=1
 endif
 if showfpsinrealgame=1 then set cursor 0,0 : print screen fps()
 `
 rem suicide key
 if gmultiplayergame=1
  if lower$(inkey$())="i" and gtalkytoaster=0
   tdamage=10 : e=characterchoiceentityindex(iLocalEL)
   if entityelement(e).health>0
    gosub _multi_dealentityedamage
   endif
  endif
 endif
 `
 rem Talk system
 if gmultiplayergame=1
  tylinevalue=screen height()-20
  if lower$(inkey$())="t" and gtalkytoaster=0
   gtalkytoaster=1 : clear entry buffer
  endif
  if gtalkytoaster=1
   rem TDM - Plystire
      set cursor 0,tylinevalue
      print "ENTER 1 - 30 TO USE TAUNTS"
      set cursor 0,tylinevalue - 1
   rem V118 - 090810 - knxrb - Edited below line to allow for backspace to remove characters from talk messages before sending.
   `print "TALK>";entry$();
   print "TALK>";entry$(1);
  endif
  if returnkey()=1 and gtalkytoaster=1
   rem send message to all
   gtalkytoaster=0
   rem V118 - 090810 - knxrb - Edited below line to allow for backspace to remove characters from talk messages before sending.
   `tmessage$=entry$()
   tmessage$=entry$(1)
   Rem TDM - Plystire.
   ttaunt = val(tmessage$)
   if ttaunt > 0 and ttaunt <= 30 then tmessage$ = taunt$(ttaunt)
   MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
   MULTIPLAYER SEND MESSAGE STRING ">>"+tmessage$,0x0080
   clear entry buffer
   rem see own message (only if server)
   if createorjoin=1
    talkscript$(talkindex)=">>"+tmessage$
    talkscriptcount(talkindex)=200
    talkscriptwho(talkindex)=iLocalEL
    inc talkindex : if talkindex>10 then talkindex=0
   endif
   rem V118 - 090810 - knxrb - Added below line ' jumpaction=0' to stop jumping action when 'T' is pressed to talk.
   rem This is to fix the 'super jump' bug where the player can jump endlessly high if they press the 'T' key to talk, hold
   rem the space key down to enter lots of spaces into the chat and then press the 'Enter' key (in built arena game).
   jumpaction=0
  endif
 endif
 `
 rem Ingame debug SPEEDTESTS
 if showfpsinrealgame=2
  rem multiplayer data
  if gmultiplayergame=1
   if timer()-totalbytestime>1000
    totalbytestime=timer()
    totalguarenteedbytes=guarenteedbytes
    totalunreliablebytes=unreliablebytes
    guarenteedbytes=0
    unreliablebytes=0
   endif
   tt$="GD="+str$(totalguarenteedbytes)
   text (screen width()/2)-75,screen height()-80,tt$
   tt$="UD="+str$(totalunreliablebytes)
   text (screen width()/2)+00,screen height()-80,tt$
   tt$="QUEUE="+str$(multiplayer get queue size(0))+","+str$(multiplayer get queue size(1))
   text (screen width()/2)+75,screen height()-80,tt$
  endif
  rem regular stats
  debugviewmode=0
  debuggameoverlaysystem(0)
  inc gameperfdebug, perftimer()-gameperftimestamp
  gameperftimestamp=perftimer()
 endif
 `
endif

rem Dynamic lighting control
gosub _lighting_ambientcontrol
if (gdynamiclightingstate=1 and lightingsystemdisabled=0) or forceambientlightsetting>0
 gosub _lighting_control
 gosub _lighting_managedynamiclights
 gosub _lighting_managegloballighting
 gosub _lighting_applyplayerlighting
 gosub _lighting_applytoscene
endif
gosub _lighting_controlupdate
inc gameperflighting, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Game Active
if gamewarmupcount=0
 `
 rem Skip input (if not multiplayer ready or talkmode on)
 tokay=1
 if gmultiplayergame=1 and PlayerCanStart=0 then tokay=0
 if gtalkytoaster=1 then tokay=0
 if tokay=1
  `
  rem Player management
  gosub _player_input
  gosub _player_manager
  gosub _player_itemmanager
  gosub _player_mission
  `
  rem The Player Camera
  gosub _player_camera
  gosub _gun_update_hud
  `
 endif
 `
endif

rem Measure plr calcs time
inc gameperfplayer, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Entity Control Handling Here
gosub _entity_controlelements
inc gameperfentities, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Control multiplayer communicaions (multiplayer)
if gmultiplayergame=1 and multiplayerinitialised=1 and multiplayersystemdisabled=0
 gosub _multi_control
endif

rem Game Active
if gamewarmupcount=0
 `
 rem After AutoCol (after plr move and entity push-back, use autocol so stay in walls)
 gosub _ode_playeraftermove
 gosub _ode_playerpickup
 `
 rem The Gun Manager after new camera pos/rot
 gosub _gun_manager
 inc gameperfgun, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
endif

rem Flak in-game handling
gosub _particles_control
if gmultiplayergame=0 then gosub _flakelement_control
if supportsystemdisabled=0
 gosub _decalelement_control
endif
gosub _part_controlexploders
gosub _gun_update_overlay
inc gameperfmisc, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

return

function screenprompt(img,desc$)
 backdrop off : position camera -50000,-50000,-50000 : point camera -550000,-550000,-550000
 ink rgb(255,255,255),0 : set text font "Verdana" : set text size 24
 cls 0 : sync : cls 0 : sync
 for s=1 to 20
  center text screen width()/2,(screen height()/2)-16,desc$
  if img>0
   if image exist(img)=1
    paste image img,(screen width()-512)/2,(screen height()-384)/2
   endif
  endif
  sync : sleep 200
 next s
endfunction

rem Function to use anywhere
function genuniqueservercode(name$)
 date$=get date$()
 time$=get time$()
 code$=""
 for index=0 to 10
  ci1=index mod len(name$) : c1$=mid$(name$,1+ci1) : if c1$="," then c1$="."
  ci2=index mod len(date$) : c2$=mid$(date$,1+ci2) : if c2$="," then c2$="."
  ci3=index mod len(time$) : c3$=mid$(time$,1+ci3) : if c3$="," then c3$="."
  code$=code$+c1$+c2$+c3$
 next index
 code$=right$(code$,32)
endfunction code$

rem
rem GAME
rem

`
` Game Core Functions
`
_game_loadmap:

rem Load map data (in real mode, we ignore what the header gmultiplayergame flag is)
storegmultiplayergame=gmultiplayergame : gosub _mapfile_loadmap
if grealgameviewstate=1 then gmultiplayergame=storegmultiplayergame

rem Setup lighting
gosub _lighting_init

rem V106 Can skip universe construction if flagged
rem do not call skip code if real game or build game
rem compare MAP arrays with last saved copy
rem compare static lights to last saved copy
rem compare static entities to last saved copy
if gcompilestandaloneexe=1 or grealgameviewstate=1
 if grealgameviewstate=1 then tperformuniverseconstruction=0
 if gcompilestandaloneexe=1 then tperformuniverseconstruction=1
else
 rem only in test game scenario should this check be made
 tperformuniverseconstruction=1
 gosub _universe_construct_skip : rem sets universeconstructskip flag
 if universeconstructskip=1 then tperformuniverseconstruction=0
 `270111 - never worked, need to store full effects flag and re-build when toggled..
 `rem FPGC - 051109 - quick universe rebuild not designed with shaded static geometry in mind!
 `if guseeffectonscenesstate=1 then tperformuniverseconstruction=1
endif

rem If universe.dbo not present, construct it
universefile$="levelbank\testlevel\universe.dbo"
if tperformuniverseconstruction=0
 `
 rem sneak automatic floor texture into data!
 thorizonplanes$=""
 `
 rem Load effects (as some scene geometry needs setting changes)
 debugviewtext(195,strarr$(115))
 filename$="levelbank\testlevel\universe.eff"
 open to read 1,filename$
  read file 1,teffectbankmax
  for eff=1 to teffectbankmax
   read string 1,tfile$
   teffectid=loadinternaleffect(tfile$)
  next eff
  read string 1,thorizonplanes$
 close file 1
 `
 rem load pre-created universe for level
 debugviewtext(200,strarr$(116))
 load static objects universefile$,gdividetexturesize
 `
 rem Load elements list (that includes scene dynamic entities)
 if grealgameviewstate=1 or gcompilestandaloneexe=1
  `
  rem V106 RC4 only for final game loading and construction
  debugviewtext(201,strarr$(117))
  elementsfilename$="levelbank\testlevel\universe.ele" : gosub _entity_loadelementsdata
  `
  rem Load infinity lights data
  debugviewtext(202,strarr$(118))
  filename$="levelbank\testlevel\universe.lgt"
  open to read 1,filename$
   read file 1,tinfinimax
   dim infinilight(tinfinimax) as infinilighttype
   for i=0 to tinfinimax
    read file 1,infinilight(i).used
    read file 1,infinilight(i).type
    read float 1,infinilight(i).x
    read float 1,infinilight(i).y
    read float 1,infinilight(i).z
    read float 1,infinilight(i).range
    read file 1,infinilight(i).id
    read float 1,infinilight(i).dist
    read file 1,infinilight(i).colrgb.r
    read file 1,infinilight(i).colrgb.g
    read file 1,infinilight(i).colrgb.b
    read file 1,infinilight(i).islit
    infinilight(i).e=-1
   next i
  close file 1
  `
 else
  `
  rem V109 BETA3 - 210408 - TEST GAME recreates LGT data as it is not consistent with quick rebuild which has different entities!
  gosub _universe_recreateinfinilights
  tinfinimax=infinilightindex
  `
 endif
 `
 rem count dynamic lights for the counter that controls this activity
 activatedynamiclightscount=0
 if array count(infinilight())<>-1 : rem U74 - V115 - fix thanks to S4REAL
  if gdynamiclightingstate=1
   for i=0 to tinfinimax
    if infinilight(i).type=1
     inc activatedynamiclightscount
    endif
   next i
  endif
 endif
 `
 rem create horizon planes
 segobjstart=universebuildobjstartoffset
 segobj=segobjstart
 if gusefloorstate=1
  rem load in the texture used by the horizon polys (from filename got from above)
  mapselection=1 : dim segmentprofile(mapselection,64) as segmentprofiletype
  if thorizonplanes$="" then thorizonplanes$="texturebank\common\ground_D2.tga"
  segmentprofile(mapselection,0).texdid=loadinternalimage(thorizonplanes$)
  rem create the edge of universe polys
  gosub _universe_createhorizonplanes
 endif
 lastsegobj=segobj
 `
else
 `
 rem construct universe for level
 segobjstart=universebuildobjstartoffset
 gosub _universe_construct
 `
endif

rem V111BETA4 - 240608 - new mode which asks portal clipper NOT to skip empty nodes that have already been traversed
rem (default is designed for speed, this mode restores older system which recurses through more portals (large indoor scene))
if ghsrmode=2
 set static culling 1
else
 set static culling 0
endif

rem Opportunity for ambience to be adjusted based on number of lights
gosub _lighting_postdefaults

rem Use mapdata to build viscolmap data
gosub _entity_fillviscolmap

rem setup scorch texture
if guseweaponsstate=1
 debugviewtext(280,strarr$(119))
 tbullethole=loadinternalimage("gamecore\Bulletholes\bulletholes.tga")
 debugviewtext(290,strarr$(120))
 set static scorch tbullethole,4,4
endif
rem Compass - has game started flag.
gameStarted = 1
rem FPGC - now universe constructed, can remove all STATIC ENTITY resources
debugviewtext(291,"Removing static entities...")
eleobj=entityobjectoffset
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entid>0 and entityelement(e).staticflag=1 and entityprofile(entid).ismarker=0
  tokay=1
  for te=1 to entityelementlist
   if e<>te
    if entid=entityelement(te).bankindex and entityelement(te).staticflag=0 then tokay=0
   endif
  next te
  if tokay=1
   obj=entityelement(e).profileobj
   if obj>0
    if object exist(obj)=1
     delete object obj
    endif
    entityelement(e).profileobj=0
   endif
  endif
 endif
next e

return

`
` SUPPORT SUBROUTINES FOR GRIDEDIT CODE
`

_gridedit_getmapvalues:
 `
 rem mapid in
 mapselection    = ( mapid && %11111111111100000000000000000000 ) >> 20
 mapscaler       = ( mapid && %00000000000011110000000000000000 ) >> 16
 mapground       = ( mapid && %00000000000000001100000000000000 ) >> 14
 maprotate       = ( mapid && %00000000000000000011000000000000 ) >> 12
 maporient       = ( mapid && %00000000000000000000110000000000 ) >> 10
 mapsymbol       = ( mapid && %00000000000000000000001111110000 ) >> 4
 maptile         = ( mapid && %00000000000000000000000000001111 )
 `
return

_gridedit_makemapvalues:
 `
 mapid = 0
 mapid = mapid + ( ( mapselection && %111111111111 ) << 20 )
 mapid = mapid + ( ( mapscaler && %1111 ) << 16 )
 mapid = mapid + ( ( mapground && %11 ) << 14 )
 mapid = mapid + ( ( maprotate && %11 ) << 12 )
 mapid = mapid + ( ( maporient && %11 ) << 10 )
 mapid = mapid + ( ( mapsymbol && %111111 ) << 4 )
 mapid = mapid + ( ( maptile && %1111 ) )
 rem mapid out
 `
return

rem
rem SEGMENTS
rem

_segment_validatearraysize:
 `
 rem ensure enough space in arrays
 if segidmaster+32>segidmastermax
  segidmastermax=segidmaster+32
  dim selectionbank$(segidmastermax)
  dim selectionbanklocal$(segidmastermax)
  dim segmentprofileheader(segidmastermax) as segmentprofileheadertype
  dim segmentprofile(segidmastermax,64) as segmentprofiletype
 endif
 `
return

_segment_shufflebank:

rem FPSCV104RC6 - scan entire map data, delete all segment entries not used
if segidmaster>0
 dim segmentbankused(segidmaster)
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 rem segs in map
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0 then segmentbankused(tttsegid)=1
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0 then segmentbankused(tttsegid)=1
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 for tttsegid=1 to segidmaster
  if segmentbankused(tttsegid)=0
   selectionbank$(tttsegid)=""
  endif
 next tttsegid
 rem shuffle to remove empties
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 treadsegid=1 : tlargest=0
 for tttsegid=1 to segidmaster
  if treadsegid<=segidmaster
   while selectionbank$(treadsegid)=""
    inc treadsegid : if treadsegid>segidmaster then exit
   endwhile
   if treadsegid<=segidmaster
    selectionbank$(tttsegid)=selectionbank$(treadsegid)
    selectionbanklocal$(tttsegid)=selectionbanklocal$(treadsegid)
    segmentprofileheader(tttsegid)=segmentprofileheader(treadsegid)
    for tt=0 to 64 : segmentprofile(tttsegid,tt)=segmentprofile(treadsegid,tt) : next tt
    segmentbankused(treadsegid)=tttsegid
    tlargest=tttsegid
   else
    selectionbank$(tttsegid)=""
   endif
  else
   selectionbank$(tttsegid)=""
  endif
  inc treadsegid
 next tttsegid
 rem new list size
 if segidmaster<>tlargest
  segidmaster=tlargest
  entityorsegmententrieschanged=1
 endif
 rem update bank index numbers in mapdata
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0
      rem new segment entry place index
      newtttsegid = segmentbankused(tttsegid)
      tttmapid = tttmapid && %00000000000011111111111111111111
      tttmapid = tttmapid || ( newtttsegid << 20 )
      map(tttl,tttx,ttty)=tttmapid
     endif
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0
        newtttsegid = segmentbankused(tttsegid)
        tttmapid = tttmapid && %00000000000011111111111111111111
        tttmapid = tttmapid || ( newtttsegid << 20 )
        olaylist(ttto,tt)=tttmapid
       endif
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 undim segmentbankused()
endif

return

_segment_savebank:

rem Save segment bank
if file exist("mapbank\testmap\map.seg")=1 then delete file "mapbank\testmap\map.seg"
open to write 1,"mapbank\testmap\map.seg"
 write file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   write string 1,selectionbank$(segid)
  next segid
 endif
close file 1

return

_segment_deletebank:

rem Destroy old segments
if segidmastermax>0
 rem changed from segidmaster
 for segid=1 to segidmastermax
  segobj=selectionbankoffset+segid
  if object exist(segobj)=1 then delete object segobj
  selectionbank$(segid)=""
 next segid
endif
segidmaster=0

return

_segment_loadbank:

rem If seg file exists
if file exist("mapbank\testmap\map.seg")=1

rem Destroy old segments
gosub _segment_deletebank

rem Load segment bank
open to read 1,"mapbank\testmap\map.seg"
 read file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 1,selectionbank$(segid)
  next segid
 endif
close file 1

rem Load segments specified by bank
segdir$="segments\"
if segidmaster>0
 for segid=1 to segidmaster
  seg$=selectionbank$(segid)
  if seg$<>""
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   gosub _segment_load
   if segmentprofileheader(segid).partmax=-1
    selectionbank$(segid)=""
   endif
  else
   segmentprofileheader(segid).partmax=-1
  endif
 next segid
endif

rem No file
endif

return

_segment_updatebank:

rem If seg file exists
if file exist("mapbank\testmap\map.seg")=1

rem Clear non-present entries
for segid=segidmaster+1 to segidmastermax
 selectionbank$(segid)=""
next segid

rem Update segment bank
segdir$="segments\"
open to read 2,"mapbank\testmap\map.seg"
 read file 2,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 2,tseg$
   if tseg$<>selectionbank$(segid)
    selectionbank$(segid)=tseg$
    seg$=selectionbank$(segid)
    segcategory$=getfirstdir(seg$)
    segpath$=getseconddir(seg$)
    gosub _segment_load
   endif
  next segid
 endif
close file 2

rem No file
endif

return

_segment_preloadtextures:

rem Load textures for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 `
 rem RADICAL change - D2 only required texture - rest generated here D.I.N.S
 `
 rem Can use multi-texture
 if segobjusedforfinalgame=1
  if segmentprofile(segid,p).multimeshmode=1
   extralimbp=segmentprofile(segid,p).multimeshstart
   if extralimbp>0
    rem points to two new meshes which may have _02 and _03 textures associated
    ttfile$=segmentprofile(segid,p).tex$
    tfilecheck$=left$(ttfile$,len(ttfile$)-4)
    if lower$(right$(tfilecheck$,6))="_01_d2"
     rem generate _02 and _03 textures in correct part of segment (mesh)
     tfile$=ttfile$ : tfile$=left$(tfile$,len(tfile$)-len("_NN_D2.TGA"))
     segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_D2.TGA"
     if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
      segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_D2.DDS"
      if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
       segmentprofile(segid,extralimbp+0).tex$=ttfile$
      endif
     endif
     segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_D2.TGA"
     if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
      segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_D2.DDS"
      if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
       segmentprofile(segid,extralimbp+1).tex$=ttfile$
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem Load actual textures based on effect requirements
 segmentprofile(segid,p).texid=0
 segmentprofile(segid,p).texdid=0
 segmentprofile(segid,p).texnid=0
 segmentprofile(segid,p).texsid=0
 texdir$=segmentprofile(segid,p).tex$
 if texdir$<>""
  `
  rem Effect or No
  tfile$=segmentprofile(segid,p).effect$
  `
  rem V118 - 300111 - rather than correct old segment files, if full effects on
  rem but no effect specified (FF), then assume BUMP.FX (handled later by 'better' shader system)
  rem REVERT - 130411 - this FIXES the invisible segment issue (works on some PC's
  rem but not all PC's - need to find solution for shading older segments?
`  quix=0
`  if guseeffectonscenesstate=1
`   if segmentprofile(segid,p).effect$=""
`    segmentprofile(segid,p).effect$="effectbank\bump\bump.fx"
`    tfile$=segmentprofile(segid,p).effect$
`    quix=1
`   endif
`  endif
  `
  teffectuseslightmapstage=1 : gosub _common_makeeffecttextureset
  if tfile$<>"" and guseeffectonscenesstate=1
   `
   rem Load and apply MAIN texture directly
   tstage=0
   for tlayer=0 to 4
    if tlayer=0 then texfiletouse$=texdir1$
    if tlayer=1 then texfiletouse$=texdir2$
    if tlayer=2 then texfiletouse$=texdir3$
    if tlayer=3 then texfiletouse$=texdir4$
    if tlayer=4 then texfiletouse$=texdir5$
    texuseid=loadinternaltexture(texfiletouse$)
    if texuseid=0
     rem some effects need a blank texture if no file available
     if tlayer<=ensureclearlayermax
      if lower$(mid$(right$(texfiletouse$,5),1))="n"
       rem normal texture if intended
       texuseid=loadinternalimagecompressquality("texturebank\common\normal.dds",1,0)
      else
       rem black texture if no texture
       texuseid=loadinternalimagecompressquality("texturebank\common\black.dds",1,0)
      endif
     endif
    endif
    if texuseid>0
     if tstage=0 then segmentprofile(segid,p).texdid=texuseid : segmentprofile(segid,p).texid=texuseid
     if tstage=1 then segmentprofile(segid,p).texiid=texuseid
     if tstage=2 then segmentprofile(segid,p).texnid=texuseid
     if tstage=3 then segmentprofile(segid,p).texsid=texuseid
     if tstage=4 then segmentprofile(segid,p).texsid=texuseid
     inc tstage
    endif
   next tlayer
   `
  else
   rem Basic Texture (D2)
   tfile$=segmentprofile(segid,p).tex$
   segmentprofile(segid,p).texid=loadinternaltexture(tfile$)
   if segmentprofile(segid,p).multimeshmode=1
    textralimbp=segmentprofile(segid,p).multimeshstart
    if textralimbp>0
     segmentprofile(segid,textralimbp+0).texid=loadinternaltexture(segmentprofile(segid,textralimbp+0).tex$)
     segmentprofile(segid,textralimbp+1).texid=loadinternaltexture(segmentprofile(segid,textralimbp+1).tex$)
    endif
   endif
  endif
 endif
 `
next p

return

_segment_preloadeffects:

rem Load effect for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 if segmentprofile(segid,p).effect$<>"" and segnoeffects=0 and guseeffectonscenesstate=1
  tfile$=segmentprofile(segid,p).effect$
  gosub _common_wipeeffectifnotexist
  if tfile$<>""
   debugfilename(tfile$,"effect:"+seg$)
   segmentprofile(segid,p).effectid=loadinternaleffect(tfile$)
  else
   segmentprofile(segid,p).effectid=0
  endif
 else
  segmentprofile(segid,p).effectid=0
 endif
next p

return

_segment_load:

rem Segment Object Index
segobj=selectionbankoffset+segid

rem debug info
mytimer=timer()

rem Load segment profile data
segmentprofileheader(segid).partmax=-1
gosub _segment_loaddata
segpartmax=segmentprofileheader(segid).partmax

rem Only if profile exists
if segpartmax<>-1
 `
 rem Check if DBO version of segment obj exists
 tsegobjpreloaded=0
 if segobjusedforfinalgame=0
  tsegobjfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".dbo"
  if file exist(tsegobjfile$)=1 and segobjusedformapeditor=0
   load object tsegobjfile$,segobj
   set object filter segobj,2
   tsegobjpreloaded=1
  endif
 endif
 `
 rem segment mesh max
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 `
 rem Load meshes for segment
 if tsegobjpreloaded=0
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    tmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).csgmesh$<>"" then tmeshname$=segmentprofile(segid,p).csgmesh$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,p).meshid=loadinternalmesh(tfile$)
    endif
   endif
  next p
 endif
 `
 rem Load multi-meshes for segment
 originalsegmeshpartmax=-1
 if segobjusedforfinalgame=1
  dim tempsegmentprofile(64) as segmentprofiletype
  tempp=0
  rem place where new limbs will be located (extralimbp) - we will move things like entitys/csgs to end
  extralimbp=segmeshpartmax+1
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    ttmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).multimeshmode=1
     if segmentprofile(segid,p).csgmesh$="" and ttmeshname$<>""
      if lower$(right$(ttmeshname$,3))="a.x"
       for ttwo=0 to 1
        tmeshname$=ttmeshname$
        tmeshname$=left$(tmeshname$,len(tmeshname$)-3)
        if ttwo=0 then tmeshname$=tmeshname$+"b.x"
        if ttwo=1 then tmeshname$=tmeshname$+"c.x"
        tfile$=tmeshname$
        debugfilename(tfile$,"mesh:"+seg$)
        tempsegmentprofile(tempp)=segmentprofile(segid,p)
        if ttwo=0 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        if ttwo=1 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        inc tempp
       next ttwo
      else
       rem not a.x, but can still habe multi-texture so use base mesh instead
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
      endif
      segmentprofile(segid,p).multimeshstart=extralimbp
      inc extralimbp,2
     endif
    endif
   endif
  next p
  rem multimesh entries made
  if tempp>0
   rem first copy non-mesh parts (entity/csg) to new end
   for p=segpartmax to segmeshpartmax+1 step -1
    segmentprofile(segid,p+tempp)=segmentprofile(segid,p)
   next p
   rem now copy accumilated multi-meshes to updated segment profile
   temppmax=tempp : tempp=0
   for p=segmeshpartmax+1 to segmeshpartmax+temppmax
    segmentprofile(segid,p)=tempsegmentprofile(tempp) : inc tempp
   next p
   rem update max values
   segmentprofileheader(segid).partmax=segpartmax+temppmax
   segpartmax=segmentprofileheader(segid).partmax
   originalsegmeshpartmax=segmeshpartmax
   segmentprofileheader(segid).lastmeshmax=segmeshpartmax+temppmax
   segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  endif
 endif
 `
 rem Load textures for segment
 gosub _segment_preloadtextures
 `
 rem Load effect for segment
 gosub _segment_preloadeffects
 `
 rem Build segment in object from segment profile
 if tsegobjpreloaded=0
  segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  tpstart=0 : tpend=segmeshpartmax
  for p=tpstart to tpend
   ttthemeshtouse=segmentprofile(segid,p).meshid
   if ttthemeshtouse=0
    if object exist(temporarymeshobject)=0 then make object sphere temporarymeshobject,0 : make mesh from object temporarymeshobject,temporarymeshobject
    ttthemeshtouse=temporarymeshobject
   endif
   if object exist(segobj)=0
    make object segobj,ttthemeshtouse,0
   else
    add limb segobj,p,ttthemeshtouse
   endif
   offset limb segobj,p,segmentprofile(segid,p).offx,segmentprofile(segid,p).offy,segmentprofile(segid,p).offz
   rotate limb segobj,p,0,segmentprofile(segid,p).roty,0
  next p
 endif
 `
 rem load csg meshes for scene building
 if tsegobjpreloaded=0
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,tp).meshid=loadinternalmesh(tfile$)
     ttthemeshtouse=segmentprofile(segid,tp).meshid
     if ttthemeshtouse=0
      if object exist(temporarymeshobject)=0 then make object sphere temporarymeshobject,0 : make mesh from object temporarymeshobject,temporarymeshobject
      ttthemeshtouse=temporarymeshobject
     endif
     add limb segobj,p,ttthemeshtouse
     offset limb segobj,p,segmentprofile(segid,tp).offx,segmentprofile(segid,tp).offy,segmentprofile(segid,tp).offz
     rotate limb segobj,p,0,segmentprofile(segid,tp).roty,0
     color limb segobj,p,rgb(0,255,0)
     segmentprofile(segid,tp).actuallimb=p
     inc p
    endif
   endif
  next tp
 else
  rem still need actuallimb data for CSG meshes
  p=segmeshpartmax+1
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>"" then segmentprofile(segid,tp).actuallimb=p : inc p
   endif
  next tp
 endif
 `
 rem Save DBO of segment if not exist
 if segobjusedforfinalgame=0
  if file exist(tsegobjfile$)=0
   save object tsegobjfile$,segobj
  endif
 endif
 `
 rem Texture segment in object from segment profile
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 for p=0 to segmeshpartmax
  if segmentprofile(segid,p).effectid=0
   texture limb segobj,p,segmentprofile(segid,p).texid
  else
   if segmentprofile(segid,p).texdid=0
    texture limb segobj,p,segmentprofile(segid,p).texid
   else
    texture limb segobj,p,0,segmentprofile(segid,p).texdid
    if segmentprofile(segid,p).texiid<>0 then texture limb segobj,p,1,segmentprofile(segid,p).texiid
    if segmentprofile(segid,p).texnid<>0 then texture limb segobj,p,2,segmentprofile(segid,p).texnid
    if segmentprofile(segid,p).texsid<>0 then texture limb segobj,p,3,segmentprofile(segid,p).texsid
   endif
   set limb effect segobj,p,segmentprofile(segid,p).effectid
  endif
 next p
 `
 rem Set any segment transparenct (always uses transparency TGA=alpha)
 set object transparency segobj,1
 `
 rem Hide object away
 position object segobj,100000,100000,100000
 `
 rem Ensure multimeshes are hidden from segment handling (only used in node tree creation)
 if segobjusedforfinalgame=1 and originalsegmeshpartmax<>-1
  segmentprofileheader(segid).lastmeshmax=originalsegmeshpartmax
  segmeshpartmax=originalsegmeshpartmax
 endif
 `
rem no profile exists endif
endif

rem debug info and timestamp (if logged)
debugviewtext(-1,"Built "+seg$+" in "+str$(timer()-mytimer)+"ms")
if segobj>0
 if object exist(segobj)=1
  timestampactivity(0,"Loaded "+str$(segid)+":"+seg$)
 endif
endif

return

_segment_cleardata:

rem Default mesh settings
segpartmax=64
for q=0 to segpartmax
 segmentprofile(segid,q).partmode=0
 segmentprofile(segid,q).tex$=""
 segmentprofile(segid,q).texid=0
 segmentprofile(segid,q).texdid=0
 segmentprofile(segid,q).texiid=0
 segmentprofile(segid,q).texnid=0
 segmentprofile(segid,q).texsid=0
` segmentprofile(segid,q).texd$=""
` segmentprofile(segid,q).texn$=""
` segmentprofile(segid,q).texs$=""
 segmentprofile(segid,q).effect$=""
 segmentprofile(segid,q).effectid=0
 segmentprofile(segid,q).csgmesh$=""
 segmentprofile(segid,q).csgmode=0
 segmentprofile(segid,q).csgimmune=0
 segmentprofile(segid,q).transparency=0
next q

rem Default hidden parts
segmentprofile(segid).vis.overlay=0
segmentprofile(segid).vis.f=-1
segmentprofile(segid).vis.r=-1
segmentprofile(segid).vis.wb=-1
segmentprofile(segid).vis.wr=-1
segmentprofile(segid).vis.wf=-1
segmentprofile(segid).vis.wl=-1
segmentprofile(segid).vis.owb=-1
segmentprofile(segid).vis.owr=-1
segmentprofile(segid).vis.owf=-1
segmentprofile(segid).vis.owl=-1
segmentprofile(segid).vis.ctl=-1
segmentprofile(segid).vis.ctr=-1
segmentprofile(segid).vis.cbr=-1
segmentprofile(segid).vis.cbl=-1
segmentprofile(segid).vis.octl=-1
segmentprofile(segid).vis.octr=-1
segmentprofile(segid).vis.ocbr=-1
segmentprofile(segid).vis.ocbl=-1

rem Default blueprint data
segmentprofile(segid).blueprint.mode=0
segmentprofile(segid).blueprint.symbol=0
segmentprofile(segid).blueprint.floorsizey=-1
segmentprofile(segid).blueprint.sidesizex=100
segmentprofile(segid).blueprint.sidesizey=100
segmentprofile(segid).blueprint.sidesizez=100

rem Default properties data
segmentprofile(segid).properties.groundmode=0
segmentprofile(segid).properties.kindof=0

return

_segment_loaddata:

rem Default Segment Data
gosub _segment_cleardata

rem Fill this last if not in filedata
segmentprofileheader(segid).lastmeshmax=-1

rem Ensure segment profile still exists
if file exist(segdir$+seg$)=1

rem Export entity FPE file if flagged
if gexportassets=1
 tthumbbmpfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bmp"
 addfiletocollection(segdir$+seg$) : addfiletocollection(tthumbbmpfile$)
endif

rem Check if binary version of segment profile exists
tprofile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bin"
if isbinaryfileolderthantxtfileforseg(tprofile$,segdir$+seg$)=1 then delete file tprofile$
if file exist(tprofile$)=0

 rem Load Segment Data from file
 dim data$(999)
 load array segdir$+seg$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem HEADER
    if field$="partmax" then segmentprofileheader(segid).partmax=value1
    if field$="lastmeshmax" then segmentprofileheader(segid).lastmeshmax=value1
    `
    rem SEGMENT PARTS
    segpartmax=segmentprofileheader(segid).partmax
    for p=0 to segpartmax
     tryfield$="partmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).partmode=value1
     tryfield$="meshname"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).meshname$=value$
     tryfield$="offx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offx=value1
     tryfield$="offy"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offy=value1
     tryfield$="offz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offz=value1
     tryfield$="rotx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotx=value1
     tryfield$="roty"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).roty=value1
     tryfield$="rotz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotz=value1
     tryfield$="texture"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).tex$=value$
     tryfield$="transparency"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).transparency=value1
     tryfield$="effect"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).effect$=value$
     tryfield$="colmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).colmode=value1
     tryfield$="csgmesh"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmesh$=value$
     tryfield$="csgmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmode=value1
     tryfield$="csgimmune"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgimmune=value1
     tryfield$="lightmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).lightmode=value1
     tryfield$="multimeshmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).multimeshmode=value1
     tryfield$="materialindex"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).material.index=value1
     `
     rem V109 BETA5 - 250408 - flag material is being used
     if segmentprofile(segid,p).material.index>0
      mi=segmentprofile(segid,p).material.index-1
      material(mi).usedinlevel=1
     endif
     `
    next p
    `
    rem SEGMENT VISIBILITY
    if field$="visoverlay" then segmentprofile(segid).vis.overlay=value1
    if field$="visfloor" then segmentprofile(segid).vis.f=value1
    if field$="visroof" then segmentprofile(segid).vis.r=value1
    if field$="viswallb" then segmentprofile(segid).vis.wb=value1 : segmentprofile(segid).vis.owb=value2
    if field$="viswallr" then segmentprofile(segid).vis.wr=value1 : segmentprofile(segid).vis.owr=value2
    if field$="viswallf" then segmentprofile(segid).vis.wf=value1 : segmentprofile(segid).vis.owf=value2
    if field$="viswalll" then segmentprofile(segid).vis.wl=value1 : segmentprofile(segid).vis.owl=value2
    if field$="viscornertl" then segmentprofile(segid).vis.ctl=value1 : segmentprofile(segid).vis.octl=value2
    if field$="viscornertr" then segmentprofile(segid).vis.ctr=value1 : segmentprofile(segid).vis.octr=value2
    if field$="viscornerbr" then segmentprofile(segid).vis.cbr=value1 : segmentprofile(segid).vis.ocbr=value2
    if field$="viscornerbl" then segmentprofile(segid).vis.cbl=value1 : segmentprofile(segid).vis.ocbl=value2
    if field$="visportalmode" then segmentprofile(segid).vis.portalmode=value1
    `
    rem SEGMENT BLUEPRINT
    if field$="mode" then segmentprofile(segid).blueprint.mode=value1
    if field$="symbol" then segmentprofile(segid).blueprint.symbol=value1
    if field$="floorsizey" then segmentprofile(segid).blueprint.floorsizey=value1
    if field$="sidesizex" then segmentprofile(segid).blueprint.sidesizex=value1
    if field$="sidesizey" then segmentprofile(segid).blueprint.sidesizey=value1
    if field$="sidesizez" then segmentprofile(segid).blueprint.sidesizez=value1
    `
    rem SEGMENT PROPERTIES
    if field$="groundmode" then segmentprofile(segid).properties.groundmode=value1
    if field$="kindof" then segmentprofile(segid).properties.kindof=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Save segment profile as binary (and strings tagged to end)
 dim temp(64) as segmentprofiletype
 open to write 1,tprofile$
 rem V110 - 160508 - added extra code to hold new version number in segment BIN file
 write file 1,-1 : write file 1,gversion
 write file 1,segmentprofileheader(segid).partmax
 write file 1,segmentprofileheader(segid).lastmeshmax
 segpartmax=segmentprofileheader(segid).partmax
 for p=0 to segpartmax : temp(p)=segmentprofile(segid,p) : next p
 if memblock exist(1)=1 then delete memblock 1
 for p=0 to segpartmax
  temp(p).meshname$=free string()
  temp(p).tex$=free string()
  temp(p).effect$=free string()
  temp(p).csgmesh$=free string()
 next p
 make memblock from array 1,temp(0)
 write memblock 1,1
 for p=0 to segpartmax
  write string 1,segmentprofile(segid,p).meshname$
  write string 1,segmentprofile(segid,p).tex$
  write string 1,segmentprofile(segid,p).effect$
  write string 1,segmentprofile(segid,p).csgmesh$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
else
 `
 rem load binary version of segment profile file
 dim temp(64) as segmentprofiletype
 open to read 1,tprofile$
 read file 1,tval
 read file 1,tversion
 read file 1,tval : segmentprofileheader(segid).partmax=tval
 read file 1,tval : segmentprofileheader(segid).lastmeshmax=tval
 segpartmax=segmentprofileheader(segid).partmax
 read memblock 1,1
 make array from memblock temp(0),1
 for p=0 to segpartmax : segmentprofile(segid,p)=temp(p) : next p
 for p=0 to segpartmax
  read string 1,tstr$ : segmentprofile(segid,p).meshname$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).tex$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).effect$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).csgmesh$=tstr$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
endif

rem V109 BETA10 - 120508 - flag material usage here (after possiblw BIN load)
segpartmax=segmentprofileheader(segid).partmax
for p=0 to segpartmax
 if segmentprofile(segid,p).material.index>0
  mi=segmentprofile(segid,p).material.index-1
  material(mi).usedinlevel=1
 endif
next p

rem If lastmesh not there, use partmax
if segmentprofileheader(segid).lastmeshmax=-1
 segmentprofileheader(segid).lastmeshmax=segmentprofileheader(segid).partmax
endif

rem File not exist endif
else
 rem File not exist, provide debug information
 debugfilename(segdir$+seg$,"")
endif

return

_segment_savedata:

rem Create seg file in string array (segid to savesegfile$)
dim data$(999) : l=-1

rem SEGMENT HEADER
inc l : data$(l)=";Segment Spec"
inc l : data$(l)=""
inc l : data$(l)=";Header"
inc l : data$(l)=""
inc l : data$(l)="partmax = "+str$(segmentprofileheader(segid).partmax)
inc l : data$(l)="lastmeshmax = "+str$(segmentprofileheader(segid).lastmeshmax)

rem SEGMENT PARTS
inc l : data$(l)=""
inc l : data$(l)=";Segment Parts"
inc l : data$(l)=""
for p=0 to segmentprofileheader(segid).partmax
 tryfield$=minstring("partmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).partmode)
 tryfield$=minstring("meshname"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).meshname$
 tryfield$=minstring("offx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offx)
 tryfield$=minstring("offy"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offy)
 tryfield$=minstring("offz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offz)
 tryfield$=minstring("rotx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotx)
 tryfield$=minstring("roty"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).roty)
 tryfield$=minstring("rotz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotz)
 tryfield$=minstring("texture"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).tex$
` tryfield$=minstring("textured"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texd$
` tryfield$=minstring("texturen"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texn$
` tryfield$=minstring("textures"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texs$
 tryfield$=minstring("transparency"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).transparency)
 tryfield$=minstring("effect"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).effect$
 tryfield$=minstring("colmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).colmode)
 tryfield$=minstring("csgmesh"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).csgmesh$
 tryfield$=minstring("csgmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgmode)
 tryfield$=minstring("csgimmune"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgimmune)
 tryfield$=minstring("lightmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).lightmode)
 tryfield$=minstring("multimeshmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).multimeshmode)
 tryfield$=minstring("materialindex"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).material.index)
 inc l : data$(l)=""
 `
 rem Ensure we never run out of array space
 if l>100 then array insert at bottom data$(),11
 `
next p

rem SEGMENT VISIBILITY
inc l : data$(l)=";Segment Visibility"
inc l : data$(l)=""
inc l : data$(l)=minstring("visoverlay",15)+" = "+str$(segmentprofile(segid).vis.overlay)
inc l : data$(l)=minstring("visfloor",15)+" = "+str$(segmentprofile(segid).vis.f)
inc l : data$(l)=minstring("visroof",15)+" = "+str$(segmentprofile(segid).vis.r)
try=segmentprofile(segid).vis.owb : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallb",15)+" = "+str$(segmentprofile(segid).vis.wb)+extra$
try=segmentprofile(segid).vis.owr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallr",15)+" = "+str$(segmentprofile(segid).vis.wr)+extra$
try=segmentprofile(segid).vis.owf : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallf",15)+" = "+str$(segmentprofile(segid).vis.wf)+extra$
try=segmentprofile(segid).vis.owl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswalll",15)+" = "+str$(segmentprofile(segid).vis.wl)+extra$
try=segmentprofile(segid).vis.octl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertl",15)+" = "+str$(segmentprofile(segid).vis.ctl)+extra$
try=segmentprofile(segid).vis.octr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertr",15)+" = "+str$(segmentprofile(segid).vis.ctr)+extra$
try=segmentprofile(segid).vis.ocbr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbr",15)+" = "+str$(segmentprofile(segid).vis.cbr)+extra$
try=segmentprofile(segid).vis.ocbl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbl",15)+" = "+str$(segmentprofile(segid).vis.cbl)+extra$
`
rem V110 - 160508 - added new flag to segment profile
try=segmentprofile(segid).vis.portalmode : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("visportalmode",15)+" = "+str$(segmentprofile(segid).vis.portalmode)+extra$

rem SEGMENT BLUEPRINT
inc l : data$(l)=""
inc l : data$(l)=";Segment Blueprint"
inc l : data$(l)=""
inc l : data$(l)=minstring("mode",15)+" = "+str$(segmentprofile(segid).blueprint.mode)
inc l : data$(l)=minstring("symbol",15)+" = "+str$(segmentprofile(segid).blueprint.symbol)
inc l : data$(l)=minstring("floorsizey",15)+" = "+str$(segmentprofile(segid).blueprint.floorsizey)
inc l : data$(l)=minstring("sidesizex",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizex)
inc l : data$(l)=minstring("sidesizey",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizey)
inc l : data$(l)=minstring("sidesizez",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizez)

rem SEGMENT PROPERTIES
inc l : data$(l)=minstring("groundmode",15)+" = "+str$(segmentprofile(segid).properties.groundmode)
inc l : data$(l)=minstring("kindof",15)+" = "+str$(segmentprofile(segid).properties.kindof)

rem END MARKER
inc l : data$(l)=""
inc l : data$(l)=";end"

rem Shorten array based on L
dim newdata$(l+1) : for t=0 to l : newdata$(t)=data$(t) : next t

rem Delet the short-load BIN and DBO files
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".bin"
if file exist(tprofile$)=1 then delete file tprofile$
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".dbo"
if file exist(tprofile$)=1 then delete file tprofile$

rem Save Segment Data to file
if file exist(savesegfile$)=1 then delete file savesegfile$
save array savesegfile$,newdata$()

rem Free usages
undim newdata$()
undim data$()

return

_segment_showallsegmentlimbs:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem force show all limbs for overlay
for tl=1 to 99
 if limb exist(obj,tl)=1
  show limb obj,tl
 endif
next tl

rem rotate object ro rotation
yrotate object obj,maporient*90

`rem Set any segment transparenct - many transparency values - use profileobj
`set object transparency obj,segmentprofile(seg).transparency

return

_segment_customisesinglesegment:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem scale any walls to scaler value (if any)
if segmentprofile(seg).blueprint.sidesizex>100
 if segmentprofile(seg).vis.wb<>-1
  if (mapscaler && %0001)
   show limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
  else
   hide limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then hide limb obj,segmentprofile(seg).vis.owb
  endif
 endif
 if segmentprofile(seg).vis.wr<>-1
  if (mapscaler && %0010)
   show limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
  else
   hide limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then hide limb obj,segmentprofile(seg).vis.owr
  endif
 endif
 if segmentprofile(seg).vis.wf<>-1
  if (mapscaler && %0100)
   show limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
  else
   hide limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then hide limb obj,segmentprofile(seg).vis.owf
  endif
 endif
 if segmentprofile(seg).vis.wl<>-1
  if (mapscaler && %1000)
   show limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
  else
   hide limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then hide limb obj,segmentprofile(seg).vis.owl
  endif
 endif
else
 if segmentprofile(seg).vis.wb<>-1
  show limb obj,segmentprofile(seg).vis.wb
  if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
 endif
 if segmentprofile(seg).vis.wr<>-1
  show limb obj,segmentprofile(seg).vis.wr
  if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
 endif
 if segmentprofile(seg).vis.wf<>-1
  show limb obj,segmentprofile(seg).vis.wf
  if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
 endif
 if segmentprofile(seg).vis.wl<>-1
  show limb obj,segmentprofile(seg).vis.wl
  if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
 endif
endif

rem default limbs states
if segmentprofile(seg).vis.f<>-1 then show limb obj,segmentprofile(seg).vis.f
if segmentprofile(seg).vis.r<>-1 then show limb obj,segmentprofile(seg).vis.r
if segmentprofile(seg).vis.ctl<>-1 then hide limb obj,segmentprofile(seg).vis.ctl
if segmentprofile(seg).vis.ctr<>-1 then hide limb obj,segmentprofile(seg).vis.ctr
if segmentprofile(seg).vis.cbr<>-1 then hide limb obj,segmentprofile(seg).vis.cbr
if segmentprofile(seg).vis.cbl<>-1 then hide limb obj,segmentprofile(seg).vis.cbl
if segmentprofile(seg).vis.octl<>-1 then hide limb obj,segmentprofile(seg).vis.octl
if segmentprofile(seg).vis.octr<>-1 then hide limb obj,segmentprofile(seg).vis.octr
if segmentprofile(seg).vis.ocbr<>-1 then hide limb obj,segmentprofile(seg).vis.ocbr
if segmentprofile(seg).vis.ocbl<>-1 then hide limb obj,segmentprofile(seg).vis.ocbl

rem apply side-maprotation for walls
twb=segmentprofile(seg).vis.wb : twr=segmentprofile(seg).vis.wr
twf=segmentprofile(seg).vis.wf : twl=segmentprofile(seg).vis.wl
towb=segmentprofile(seg).vis.owb : towr=segmentprofile(seg).vis.owr
towf=segmentprofile(seg).vis.owf : towl=segmentprofile(seg).vis.owl
if segmaprot=1
 twb=segmentprofile(seg).vis.wl :  twr=segmentprofile(seg).vis.wb
 twf=segmentprofile(seg).vis.wr :  twl=segmentprofile(seg).vis.wf
 towb=segmentprofile(seg).vis.owl :  towr=segmentprofile(seg).vis.owb
 towf=segmentprofile(seg).vis.owr :  towl=segmentprofile(seg).vis.owf
endif
if segmaprot=2
 twb=segmentprofile(seg).vis.wf :  twr=segmentprofile(seg).vis.wl
 twf=segmentprofile(seg).vis.wb :  twl=segmentprofile(seg).vis.wr
 towb=segmentprofile(seg).vis.owf :  towr=segmentprofile(seg).vis.owl
 towf=segmentprofile(seg).vis.owb :  towl=segmentprofile(seg).vis.owr
endif
if segmaprot=3
 twb=segmentprofile(seg).vis.wr :  twr=segmentprofile(seg).vis.wf
 twf=segmentprofile(seg).vis.wl :  twl=segmentprofile(seg).vis.wb
 towb=segmentprofile(seg).vis.owr :  towr=segmentprofile(seg).vis.owf
 towf=segmentprofile(seg).vis.owl :  towl=segmentprofile(seg).vis.owb
endif

rem eliminate external walls if blocked
if maprotate=0
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=1
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towr
endif
if maprotate=2
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=3
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towr
endif

rem inner wall to hide
if twr<>-1
 if maptile>=2 then hide limb obj,twr
endif
if twb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,twb
endif
if twl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,twl
endif
if twf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,twf
endif

rem outer wall to hide
if towr<>-1
 if maptile>=2 then hide limb obj,towr
endif
if towb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,towb
endif
if towl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,towl
endif
if towf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,towf
endif

rem symbol no floor hides floor/roof
if mapsymbol=1
 if segmentprofile(seg).vis.f<>-1 then hide limb obj,segmentprofile(seg).vis.f
 if segmentprofile(seg).vis.r<>-1 then hide limb obj,segmentprofile(seg).vis.r
endif

rem calculate actual corner before whole seg is rotated
ttoctl=segmentprofile(seg).vis.octl
ttoctr=segmentprofile(seg).vis.octr
ttocbr=segmentprofile(seg).vis.ocbr
ttocbl=segmentprofile(seg).vis.ocbl
toctl=-1 : toctr=-1 : tocbr=-1 : tocbl=-1
if segmaprot=0
 tctl=segmentprofile(seg).vis.ctl
 tctr=segmentprofile(seg).vis.ctr
 tcbr=segmentprofile(seg).vis.cbr
 tcbl=segmentprofile(seg).vis.cbl
 toctl=ttoctl
 toctr=ttoctr
 tocbr=ttocbr
 tocbl=ttocbl
endif
if segmaprot=1
 tctl=segmentprofile(seg).vis.ctr
 tctr=segmentprofile(seg).vis.cbr
 tcbr=segmentprofile(seg).vis.cbl
 tcbl=segmentprofile(seg).vis.ctl
 toctl=ttoctr
 toctr=ttocbr
 tocbr=ttocbl
 tocbl=ttoctl
endif
if segmaprot=2
 tctl=segmentprofile(seg).vis.cbr
 tctr=segmentprofile(seg).vis.cbl
 tcbr=segmentprofile(seg).vis.ctl
 tcbl=segmentprofile(seg).vis.ctr
 toctl=ttocbr
 toctr=ttocbl
 tocbr=ttoctl
 tocbl=ttoctr
endif
if segmaprot=3
 tctl=segmentprofile(seg).vis.cbl
 tctr=segmentprofile(seg).vis.ctl
 tcbr=segmentprofile(seg).vis.ctr
 tcbl=segmentprofile(seg).vis.cbr
 toctl=ttocbl
 toctr=ttoctl
 tocbr=ttoctr
 tocbl=ttocbr
endif

rem remove external corners if not needed
ttoctl=-1 : ttoctr=-1 : ttocbr=-1 : ttocbl=-1
if maprotate=0
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbl=tocbl
endif
if maprotate=1
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=2
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=3
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbl=tocbl
endif

rem inner corner limbs to show
if tctl<>-1
 if maptile>=7 and maptile<=11 then show limb obj,tctl
endif
if tctr<>-1
 if maptile=8 or maptile=10 or maptile=11 then show limb obj,tctr
endif
if tcbr<>-1
 if maptile=9 or maptile=10 or maptile=11 or maptile>=13 then show limb obj,tcbr
endif
if tcbl<>-1
 if maptile=11 or maptile=12 or maptile=14 then show limb obj,tcbl
endif

rem outer corner limbs to show
if ttoctl<>-1
 if maptile=1 then show limb obj,ttoctl
 if maptile=2 then show limb obj,ttoctl
 if maptile=3 then show limb obj,ttoctl
 if maptile=15 then show limb obj,ttoctl
endif
if ttoctr<>-1
 if maptile=1 then show limb obj,ttoctr
endif
if ttocbr<>-1
 if maptile=1 then show limb obj,ttocbr
endif
if ttocbl<>-1
 if maptile=1 then show limb obj,ttocbl
 if maptile=2 then show limb obj,ttocbl
endif

rem rotate object ro rotation
yrotate object obj,maporient*90

return

`
` Special Function for finding GROUNDMODE from NEIGHBOR MAP TILE (external wall removal)
`

function getgroundmodefrommap(mapatl,mapatx,mapaty)
 mapground=3
 if mapatx>=0
  if mapaty>=0
   if mapatx<=49
    if mapaty<=49
     mapid=map(mapatl,mapatx,mapaty)
     if mapid<>0
      mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
     else
      mapground = 3
     endif
    endif
   endif
  endif
 endif
endfunction mapground

_segment_scanfornewsegments:

rem Scan for segments
segdir$="segments\"
empty array filelist$()
buildfilelist(segdir$,"")

rem If segments exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem Segment name from folder
  seg$=filelist$(chkfile)
  if right$(seg$,4)=".fps"
  `
  rem Check segment exists in bank
  tokay=1
  if segidmaster>0
   for segid=1 to segidmaster
    if selectionbank$(segid)=seg$ then tokay=0
   next segid
  endif
  if tokay=1
   `
   rem Find Free Segment Index
   freesegid=-1
   if segidmaster>0
    for segid=1 to segidmaster
     if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
    next segid
   endif
   `
   rem New Segment or Free One
   if freesegid=-1
    inc segidmaster : gosub _segment_validatearraysize
    segid=segidmaster
   else
    segid=freesegid
   endif
   `
   rem Extract firstdir and path from seg$
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   `
   rem Load Segment
   selectionbank$(segid)=seg$
   gosub _segment_load
   `
  endif
  `
  endif
 next chkfile
endif

return

_segment_addtoworkspace:

rem If type valid
segnewloaded=0
if right$(seg$,4)=".fps"
 `
 rem Check segment exists in bank
 tokay=1
 if segidmaster>0
  for segid=1 to segidmaster
   if selectionbank$(segid)=seg$ then tokay=0 : tfoundid=segid : exit
  next segid
 endif
 if tokay=1
  `
  rem Find Free Segment Index
  freesegid=-1
  if segidmaster>0
   for segid=1 to segidmaster
    if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
   next segid
  endif
  `
  rem New Segment or Free One
  if freesegid=-1
   inc segidmaster : gosub _segment_validatearraysize
   segid=segidmaster
   segnewloaded=1
  else
   segid=freesegid
  endif
  `
  rem Extract firstdir and path from seg$
  segcategory$=getfirstdir(seg$)
  segpath$=getseconddir(seg$)
  `
  rem Load Segment
  selectionbank$(segid)=seg$
  gosub _segment_load
  `
  rem Localization Extra
  if localdesc$<>""
   selectionbanklocal$(segid)=localdesc$
  endif
  `
 else
  `
  rem already got, assign ID from existing
  segid=tfoundid
  `
 endif
 `
endif

return

_segment_addtoselection:

rem Load segment from file requester
set dir currentsegdir$
seg$=browseropen$(6)
segdir$="segments\"
seg$=right$(seg$,len(seg$)-len(rootdir$+segdir$))
currentsegdir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _segment_addtoworkspace

return

_segment_createnewselection:

rem Create new segment using SEGEDIT (indi-tool)
set dir currentsegdir$
segedit$(1)
set dir rootdir$

return

rem Add selected to workspace selection
_prefab_addtoworkspace:

rem If type valid
prenewloaded=0
if lower$(right$(prefab$,4))=".fpp"
 `
 rem Check prefab exists in bank
 tokay=1
 if preidmaster>0
  for preid=1 to preidmaster
   if prefabbank$(preid)=prefab$ then tokay=0 : exit
  next preid
 endif
 if tokay=1
  `
  rem Find Free prefab Index
  freepreid=-1
  if preidmaster>0
   for preid=1 to preidmaster
    if prefabbank$(preid)="" then freepreid=preid : exit
   next preid
  endif
  `
  rem New prefab or Free One
  if freepreid=-1
   inc preidmaster
   if preidmaster>=100
    dim prefabbank$(preidmaster)
    dim prefabbanklocal$(preidmaster)
   endif
   preid=preidmaster
  else
   preid=freepreid
  endif
  `
  rem Extract firstdir and path from prefab$
  preategory$=getfirstdir(prefab$)
  prepath$=getseconddir(prefab$)
  `
  rem Load Prefab
  prefabbank$(preid)=prefab$
  prenewloaded=1
  `
  rem Localization Extra
  if localdesc$<>""
   prefabbanklocal$(preid)=localdesc$
  endif
  `
 endif
 `
endif

return

_prefab_addtoselection:

rem Load segment from file requester
set dir currentpredir$
prefab$=browseropen$(7)
predir$="prefabs\"
prefab$=right$(prefab$,len(prefab$)-len(rootdir$+predir$))
currentpredir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _prefab_addtoworkspace

return

rem
rem SUBROUTINES AND FUNCTIONS FOR DEBUG ONLY
rem

rem FUNCTIONS

function hide3d()
 backdrop off : sync off
 set current bitmap 0
 for o=1 to 50000
  if object exist(o)=1
   hide object o
  endif
 next o
endfunction

function show3d()
 backdrop on : sync on
 for o=1 to 50000
  if object exist(o)=1
   show object o
  endif
 next o
endfunction

function debugfilename(tfile$,desc$)
 texit=0
 tryfile$=tfile$
 if lower$(right$(tfile$,3))="tga" then tryfile$=left$(tryfile$,len(tryfile$)-3)+imgext$
 if file exist(tfile$)=0 and file exist(tryfile$)=0
  timestampactivity(0,strarr$(53)+tfile$+") info:"+desc$)
  timestampactivityflagged=1
  rem FPGC - 090909 - add this to missingmedia report
  inc missingmediacounter
  dim missingmedia$(missingmediacounter)
  missingmedia$(missingmediacounter)=tfile$
 endif
endfunction

function debugstring(tfile$,desc$)
 timestampactivity(0,strarr$(54)+tfile$+" - "+desc$+")")
endfunction

function debugseevar(var)
 timestampactivity(0,strarr$(55)+str$(var)+")")
endfunction

function debugpeek(desc$)
 set text opaque
 ink rgb(255,255,255),0
 while spacekey()=0
  set cursor 100,150
  print desc$
  sync
 endwhile
 while spacekey()=1 : sync : endwhile
 set text transparent
endfunction

`
` Progress Report Debug Function
`

function debugviewactivate(mode)
 `
 if gdebugreportmodestate=1
  if mode=1
   if bitmap exist(1)=0 then create bitmap 1,screen width(),150
  else
   if bitmap exist(1)=1 then delete bitmap 1
  endif
  set current bitmap 0
 endif
 `
endfunction

function debugviewprogressmax(progressmax)
 dim mshot(progressmax)
 lastmshotmem=0
 gprogressmax=progressmax
 gprogresscounter=0
endfunction

function debugviewtext(progress,gamedebugviewtext$)
 `
 rem leave immediately if mapeditor
 if gmapeditmode=1 then exitfunction
 `
 rem FPSCV104RC9 - loading time readout to file
 if gloadreportstate=1
  if loadreportarraydimmed=0 then dim loadreport$(100000) : loadreportarraydimmed=1
  rem get time, distance from last time, description, etc..
  if gloadreporttime=0 then gloadreporttime=timer()
  thetime=timer()-gloadreporttime
  thetime$=right$(str$(1000000+thetime),6)
  thediff=timer()-gloadreportlasttime
  thediff$=right$(str$(1000000+thediff),6)
  gloadreportlasttime=timer()
  loadreport$(gloadreportindex)=thetime$+" : "+thediff$+" : "+gamedebugviewtext$
  inc gloadreportindex : if gloadreportindex>10000 then gloadreportindex=10000
  if progress>gprogressmax-10
   rem only save in last 10 counts before end of progress bar
   save array rootdir$+"\loadreport.txt",loadreport$()
   rem Hockeykid - 011110 - engine is done using the load report array, lets get rid of it!
   `undim loadreport$(100000) : loadreportarraydimmed=0
  endif
 endif
 `
 rem progress bar based on progress/gprogressmax (some white and black)
 if progress<>-1
  rem Memory counters
  mshoti=progress
  rem FPGC - 111209 - more info to indicate potential reason for a sudden crash (too much memory?)
  `gamedebugviewtext$="["+right$(str$(1000+mshoti),3)+"] "+gamedebugviewtext$
  gamedebugviewtext$="["+right$(str$(1000+mshoti),3)+"] "+gamedebugviewtext$+"  ("+str$(system smem available(2)/1024)+"MB used)"
  mshotmem=GET MEMORY AVAILABLE(0)
  if lastmshotmem=0 then lastmshotmem=mshotmem : mshotfirst=GET MEMORY AVAILABLE(0)
  mshot(mshoti)=lastmshotmem-mshotmem
  if mshot(mshoti)>mshotmemlargest then mshotmemlargest=mshot(mshoti)
  if mshoti>lastmshoti
   rem deposit memory use result to report
   timestampactivity(0,strarr$(56)+str$(mshot(mshoti))+"K  "+gamedebugviewtext$)
   lastmshoti=mshoti
   lastmshotmem=mshotmem
  endif
  rem Game GUI Readout
  if progress>gprogressmax then progress=gprogressmax
  progress#=progress
  progress#=progress#/(gprogressmax+0.0001)
  rem FPGC - 121009 - adjust progress# to account for screen width different from 1024
  tscrwiddiff#=screen width()
  tscrwiddiff#=tscrwiddiff#/1024.0 : progress#=progress#*tscrwiddiff#
  tscrhighdiff#=screen height()
  tscrhighdiff#=tscrhighdiff#/800.0
  if guiUsed = 0
       if internalloaderhud>0 and internalloaderhud<=array count(hud())
           rem Image Expand Bar Progress
           t1=hud(internalloaderhud).width*progress#
           size sprite internalloaderhud,t1,hud(internalloaderhud).height*tscrhighdiff#
           paste sprite internalloaderhud,hud(internalloaderhud).posx,hud(internalloaderhud).posy
       else
           rem Default Bar Progress
           if gdebugreportmodestate=1
                progressx=54 : progressy=392 : progressh=18
                progressw=screen width()-100.0001
                if screen width()=800 then progressw=693
                t1=progressw*progress# : t2=progressx+t1
                ty=(screen height()-150)-(screen height()/10)
                if screen height()=600 then ty=progressy
                if t2>progressx then ink rgb(255,255,255),0 : box progressx,ty,t2,ty+(progressh*tscrhighdiff#)
                if t2<progressx+progressw then ink rgb(0,0,0),0 : box t2,ty,progressx+progressw,ty+(progressh*tscrhighdiff#)
           endif
       endif
  else
      if guiloaderhud > -1
       rem GUI-X9 (knxrb)
       if sprite exist(65534)
        size sprite 65534,screen width(),screen height()
        paste sprite 65534,0,0
       endif
       guiloadprogress = progress# : gosub _gui_run
      endif
   endif
    if gdebugreportmodestate=0 then sync mask 0x1 : sync `S4real fix reflection problem with water.
 endif
 `if gdebugreportmodestate=0 then sync
 `
 rem Report On Progress Percentage
 if progress<>-1
  if progress>gprogressmax then progress=gprogressmax
  progress#=progress : progress#=progress#/(gprogressmax+0.0001)
  progress#=progress#*100.0
 endif
 `
 rem TestGameFromEditor Mode
 if gtestgamemodefromeditor=1
  rem detect if CANCEL early (while building)
  if gtestgamemodefromeditorokaypressed=0
   open file map 2, "FPSEXCHANGE"
   wait for file map event 2
   if get file map dword( 2, 994 ) = 1
    `
    rem As can take time, tell user can take time
    open file map 3, "FPSTESTGAMEDIALOG"
    set file map dword 3, 12, 1
    set file map string$ 3, 1000, strarr$(630)
    wait for file map event 3
    while get file map dword ( 3, 12 ) = 1
     wait for file map event 3
    endwhile
    close file map 3
    `
    rem terminate test game mid-build
    set file map string$ 2, 1000, "FPSC-MapEditor.exe"
    set file map string$ 2, 1256, "-r"
    set file map dword 2, 994, 2
    set file map dword 2, 924, 1
    wait for file map event 2
    close file map 2
    rem Terminate
    if 1 then timestampactivity(0,strarr$(57))
    end
   else
    rem Update Test Game Dialog progress and status text
    open file map 1, "FPSTESTGAMEDIALOG"
    if progress<>-1
     set file map dword 1, 8, int(progress#)
    endif
    rem Display Status Text
    set file map string$ 1, 1000, gamedebugviewtext$
    set file map dword 1, 12, 1
    wait for file map event 1
    close file map 1
   endif
   close file map 2
  endif
 endif
 rem Build Executable Game Mode
 if gcompilestandaloneexe=1
  rem check if build cancelled
  tokay=0
  open file map 2, "FPSEXCHANGE"
  wait for file map event 2
  if get file map dword( 2, 994 ) = 1 then tokay=1
  close file map 2
  if tokay=1
   rem terminate build early
   open file map 1, "FPSBUILDGAME"
   set file map dword 1, 108, 1
   set file map dword 1, 112, 0
   rem close dialog (cannot reload data into it when RELOAD MAPEDITOR)
   set file map dword 1, 24, 1
   wait for file map event 1
   close file map 1
   rem call map editor back
   open file map 2, "FPSEXCHANGE"
   set file map string$ 2, 1000, "FPSC-MapEditor.exe"
   set file map string$ 2, 1256, "-r"
   set file map dword 2, 994, 0
   set file map dword 2, 924, 1
   wait for file map event 2
   close file map 2
   rem terminate
   if 1 then timestampactivity(0,strarr$(58))
   end
  else
   rem game build progress bar and text
   open file map 1, "FPSBUILDGAME"
   if progress<>-1
    set file map dword 1, 108, 1
    set file map dword 1, 112, int(progress#)
   endif
   set file map dword 1, 40, 12
   set file map dword 1, 44, 1
   if level>0 and level<=glevelmax
    set file map string$ 1, 1000, strarr$(59)+str$(level)+"\"+str$(glevelmax)+" : "+gamedebugviewtext$
   else
    set file map string$ 1, 1000, gamedebugviewtext$
   endif
   wait for file map event 1
   close file map 1
  endif
 endif
 `
 rem debug view text
 if gdebugreportmodestate=1 and gmapeditmode=0
  thetime=timer()-gamedebugviewtime
  thetime$=right$(str$(1000000+thetime),6)
  themem=gamedebugviewmem-GET MEMORY AVAILABLE(0)
  themem$=right$(str$(10000000+themem),7)
  themem$=" [ "+themem$+" ] ("
  if (themem-gamedebugviewlastmem)>0 then themem$=themem$+"+"
  themem$=themem$+str$(themem-gamedebugviewlastmem)+")  :  "
  gamedebugview$=thetime$+themem$+gamedebugviewtext$+chr$(13)+chr$(10)+gamedebugview$
  gamedebugviewlastmem=themem
  `
  rem gamemain_writetexttodebugview:
  if gdebugreportmodestate=1
   if bitmap exist(1)=1
    set current bitmap 1
    cls rgb(0,48,0)
    ink rgb(255,255,255),0
    print gamedebugview$
    ink rgb(0,255,0),0
    `
    rem gamemain_updatedebugviewstats
    for stat=1 to 9
     if stat=1 then stat$=strarr$(60)
     if stat=2 then stat$=strarr$(61) : stat2=segidmaster
     if stat=3 then stat$=strarr$(62) : stat2=entidmaster
     if stat=4 then stat$=strarr$(63) : stat2=entityelementlist
     if stat=5 then stat$=strarr$(64) : stat2=aiindexmaster
     if stat=6 then stat$=strarr$(65) : stat2=texturebankmax
     if stat=7 then stat$=strarr$(66) : stat2=imagebankmax
     if stat=8 then stat$=strarr$(67) : stat2=effectbankmax
     if stat=9 then stat$=strarr$(68) : stat2=waypointmax
     if stat>1
      stat2$=str$(stat2) : stat3$="" : for st=1 to stat2 step 2 : stat3$=stat3$+"|" : next st
      stat1$=stat$ : stat2$=stat2$+space$(3-len(stat2$))+stat3$
     else
      stat1$=stat$ : stat2$=""
     endif
     text screen width()-(screen width()/4),(stat-1)*14,stat1$
     text screen width()-(screen width()/8),(stat-1)*14,stat2$
    next stat
    `
    set current bitmap 0
   endif
   gamedebugrefresh=1
  endif
  `
  debugviewupdate(1)
  if gdebugreportstepthroughstate=1
   rem step through debugging
   wait key
  endif
 endif
 `
 rem FPGC - 110210 - some systems having issues with builds exceeding 1.5GB, so provide a graceful cap
 rem FPGC - 050510 - turns out virtual memory address fragmentation crashes apps exceeding 2GB
 if gsystemmemorycapoff=0
  vmsize=(system smem available(2)/1024)
  if vmsize>1850
   if thisisaonetimeglobalbeforethisbuildends=0
    do
     rem use a global to ensure this function does not call itself (recursively)
     thisisaonetimeglobalbeforethisbuildends=1
     debugviewtext(-1,"Build process has exceed 1.85GB of virtual memory, using "+str$(vmsize)+"MB. Press CANCEL to abort this build!")
     sleep 10
    loop
    end
   endif
  endif
 endif
 `
endfunction

function debugviewupdate(doisync)
 `
 if gdebugreportmodestate=1 and gmapeditmode=0
  if gamedebugrefresh=1
   gamedebugrefresh=0
   if bitmap exist(1)=1
    set current bitmap 1
    get image editorimagesoffset+1,0,0,screen width(),150,1
   endif
  endif
  set current bitmap 0
  if doisync=0 and image exist(editorimagesoffset+1)=1 then paste image editorimagesoffset+1,0,screen height()-150
  if doisync=1 and image exist(editorimagesoffset+1)=1 then paste image editorimagesoffset+1,0,screen height()-150
  if doisync=1 then sync
 endif
 `
endfunction

function debuggameoverlaysystem(clearscr)
`
rem collect perf data
perf(1) = statistic(1)
perf(2) = screen fps()
if scancode()<>15
 inc wshoti : if wshoti>400 then wshoti=0
endif
wshot(wshoti,0)=perf(1) : if wshot(wshoti,0)>wshotmax(0) then wshotmax(0)=wshot(wshoti,0)
wshot(wshoti,1)=perf(2) : if wshot(wshoti,1)>wshotmax(1) then wshotmax(1)=wshot(wshoti,1)
wshot(wshoti,2)=statistic(8) : if wshot(wshoti,2)>wshotmax(2) then wshotmax(2)=wshot(wshoti,2)
wshot(wshoti,3)=perf(6) : if wshot(wshoti,3)>wshotmax(3) then wshotmax(3)=wshot(wshoti,3)
wshot(wshoti,4)=perf(7) : if wshot(wshoti,4)>wshotmax(4) then wshotmax(4)=wshot(wshoti,4)
`
rem uses perftimer now for cycle accuracy (once a second so I can read changes)
av#=20.0
inc gameperftimetracker
if gameperftimetracker>av#
 gameperftimetracker=0
 i=3 : perf(i) = gameperftotalcount/av# : gameperftotalcount=0
 i=4 : perf(i) = gameperflighting/av# : gameperflighting=0
 i=5 : perf(i) = gameperfplayer/av# : gameperfplayer=0
 i=6 : perf(i) = gameperfentities/av# : gameperfentities=0
 i=7 : perf(i) = gameperfgun/av# : gameperfgun=0
 i=8 : perf(i) = gameperfmisc/av# : gameperfmisc=0
 i=9 : perf(i) = gameperfdebug/av# : gameperfdebug=0
 i=10 : perf(i) = gameperfphysics/av# : gameperfphysics=0
 i=11 : perf(i) = gameperfsync/av# : gameperfsync=0
 i=12 : perf(i) = gameperfentities1/av# : gameperfentities1=0
 i=13 : perf(i) = gameperfentities2/av# : gameperfentities2=0
 i=14 : perf(i) = gameperfentities3/av# : gameperfentities3=0
 i=15 : perf(i) = gameperfentities4/av# : gameperfentities4=0
 i=16 : perf(i) = gameperfentities5/av# : gameperfentities5=0
 i=17 : perf(i) = gameperfai/av# : gameperfai=0
endif

rem Optional additional statistics
rem FPGC - 060710 - removed old debug text in favour of graphical readout (below)
rem FPGC - 140710 - some users want the old debug info back, so add under LOADREPORT flag
if debugviewmode=0 and gloadreportstate=1
 `
 rem Appreviated for game scene (temp)
 t$=""
 overalltotal as double integer
 overalltotal=perf(3)
 for i=1 to 11
  if i=1 then t$=t$+"P"
  if i=2 then t$=t$+"F"
  if i=3 then t$=t$+"#"
  if i=4 then t$=t$+"L"
  if i=5 then t$=t$+"P"
  if i=6 then t$=t$+"E"
  if i=7 then t$=t$+"G"
  if i=8 then t$=t$+"M"
  if i=9 then t$=t$+"D"
  if i=10 then t$=t$+"P"
  if i=11 then t$=t$+"S"
  if i<=2
   thevalueB=perf(i)
  else
   thevalueA#=1000.0/overalltotal
   thevalueB=perf(i)*thevalueA#
  endif
  t$=t$+":"+str$(thevalueB)
  if i=6
   rem extra entity display
   rem V109 BETA11 - 130508 -= more readable performace values based on 1000.0 representing overall total
   thevalueB12=perf(12)*thevalueA#
   thevalueB13=perf(13)*thevalueA#
   thevalueB14=perf(14)*thevalueA#
   thevalueB15=perf(15)*thevalueA#
   thevalueB16=perf(16)*thevalueA#
   t$=t$+" [SH:"+str$(logicprioritycount)+"/"+str$(int(logicprioritymax#))+"][1:"+str$(thevalueB12)+" 2:"+str$(thevalueB13)+" 3:"+str$(thevalueB14)+" 4:"+str$(thevalueB15)+" 5:"+str$(thevalueB16)+"]"
  endif
  t$=t$+"   "
 next i
 ink rgb(255,255,0),0
 `
 rem FPGC - 150709 - do not display debug text when rawtext is in action
 if grawtext$=""
  set text size 12 : grawtextsizelast=-1
  rem debug statistics
  center text screen width()/2,screen height()-16,t$
  rem V110 - 160508 - added version number in bottom right corner (better transparency for debugging with shots)
  center text screen width()-32,screen height()-16,"V"+str$(gversion)
 endif
 `
endif

rem place statistics in resource meter values
resourcemeterdest#(0)=((perf(11)+0.0)/300000.0)*192.0 : rem syncs
resourcemeterdest#(1)=((perf(10)+0.0)/50000.0)*192.0 : rem physics
resourcemeterdest#(2)=((perf(17)+0.0)/75000.0)*192.0 : rem ai
resourcemeterdest#(3)=((perf(6)+0.0)/20000.0)*192.0 : rem entitylogic
memoryused#=system smem available(2)-(600*1024)
if memoryused#<0 then memoryused#=0
memoryused#=memoryused#/1024/12
resourcemeterdest#(4)=(memoryused#/100.0)*192.0 : rem memory
for rmi=0 to 4
 resourcemeter#(rmi)=curvevalue(resourcemeterdest#(rmi),resourcemeter#(rmi),10.0)
 if resourcemeter#(rmi)<0 then resourcemeter#(rmi)=0
 if resourcemeter#(rmi)>192 then resourcemeter#(rmi)=192
 resourcemeter(rmi)=resourcemeter#(rmi)
next rmi

rem Resource Meter Panel (FPGC - 300710 - ensured multiplayer does not show resource panels)
if gmultiplayergame=0
if testgametabtoggle=1
 `
 rem draw resource meter
 img=effectmenuimagestart+33 : rmposx=0 : rmposy=screen height()-335
 paste sprite img+1,rmposx,rmposy
 for rmi=0 to 4
  paste sprite img+3+(rmi*4)+0,rmposx+19,rmposy+60+(rmi*53) : rem label
  paste sprite img+3+(rmi*4)+1,rmposx+17,rmposy+80+(rmi*53) : rem start
  t=resourcemeter(rmi) : if t<10 : t=10 : endif : size sprite img+3+(rmi*4)+2,t,10
  paste sprite img+3+(rmi*4)+2,rmposx+22,rmposy+80+(rmi*53) : rem filler
  paste sprite img+3+(rmi*4)+3,rmposx+22+t,rmposy+80+(rmi*53) : rem end
  size sprite img+2,207,14
  paste sprite img+2,rmposx+15,rmposy+78+(rmi*53) : rem glass
 next rmi
 `
 rem FPS reading in resource meter panel
 printvalue(rmposx+199,rmposy+19,screen fps())
 `
 rem FPGC - 280710 - print polygon count over polygon bar
 printvalue(rmposx+190,rmposy+60+(0*53),perf(1))
 `
else
 `
 rem FPGC - 060710 - replace text based debug info with more graphics (cooler and more relevent)
 if debugviewmode=0 and gloadreportstate=0
  `
  rem draw resource meter
  img=effectmenuimagestart+33 : rmposx=(screen width()-548)/2 : rmposy=screen height()-20
  for rmi=0 to 4
   paste sprite img+3+(rmi*4)+1,rmposx+17+(rmi*112),rmposy : rem start
   t=resourcemeter(rmi)/2 : if t<10 : t=10 : endif : size sprite img+3+(rmi*4)+2,t,10
   paste sprite img+3+(rmi*4)+2,rmposx+22+(rmi*112),rmposy : rem filler
   paste sprite img+3+(rmi*4)+3,rmposx+22+t+(rmi*112),rmposy : rem end
   size sprite img+2,108,14
   paste sprite img+2,rmposx+15+(rmi*112),rmposy-2 : rem glass
  next rmi
  printvalue(rmposx,rmposy,screen fps())
  printvalue(screen width()-32,rmposy+6,gversion)
  `
 endif
 `
endif
endif

rem Current keypress
if gtalkytoaster=0
 k$=inkey$()
else
 k$=""
endif

if tupdatewater=1
 rem when water level changes, rejig entities so they trigger floating
 gosub _entity_rejigifwaterlevelchanges
 `tupdatewater=0
endif

rem Portal Control
if k$="[" then g_iPortal = 1 : set static portals on : set static objects wireframe on
if k$="]" then g_iPortal = 0 : set static portals off : set static objects wireframe off

rem V118 - BETA10 - commented out all debug keys (confuses users)

rem Restoration key (now the cap, X key means normal)
`if k$="t" then sync rate 38 : entitysystemdisabled=0 : lightingsystemdisabled=0

rem Disable parts of engin
`if k$="-" then entitysystemdisabled=1
`if k$="=" then lightingsystemdisabled=1

rem Sync control
`if k$="x" then sync rate 0
`if k$="u" then sync rate 5

rem Collision control
`if k$="m" then deactivatecollision=0
`if k$="n" then deactivatecollision=1

rem glide for floating
`if player(1).health>0 or playerstartstrength=0
` if k$="z" then grav#=-2.0 : jumpaction=0
`endif

rem Mouse control/pointer (press TAB to toggle menu view)
if (scancode()<>15) and debugviewtog=1 then debugviewtog=0
if (scancode()=15 or triggerdebugview>0) and debugviewtog=0
 if triggerdebugview>0
  debugviewmode=triggerdebugview-1
  triggerdebugview=0
 else
  testgametabtoggle=testgametabtoggle+1
  if testgametabtoggle=2 then testgametabtoggle=0
  if testgametabtoggle=0 then debugviewmode=0
  if testgametabtoggle=1 then debugviewmode=1
  `if testgametabtoggle=2 then debugviewmode=0
  debugviewtog=1
 endif
endif

endfunction

function printvalue(x,y,value)
 `
 rem prepare sprite for text printing
 sid=effectmenuimagestart+4
 sprite sid,-10000,-10000,effectmenuimagestart+31
 set sprite diffuse sid,255,255,255
 set sprite alpha sid,255
 size sprite sid,10,10
 `
 rem print value
 text$=str$(value)
 tactualtextwidth=10
 tcenterx#=(len(text$)*tactualtextwidth)/2
 for tt=1 to len(text$)
  ttnum=-1
  if mid$(text$,tt)="." then ttnum=10
  if mid$(text$,tt)="\" then ttnum=11
  if ttnum=-1 then ttnum=asc(mid$(text$,tt))-asc("0")
  if ttnum<>-1
   ttnumy=ttnum/4 : ttnum=ttnum-(ttnumy*4)
   ttbitx#=(1.0/64.0)*16 : ttbity#=(1.0/64.0)*16
   set sprite texture coord sid,0,(ttbitx#*ttnum),(ttbity#*ttnumy)
   set sprite texture coord sid,1,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)
   set sprite texture coord sid,2,(ttbitx#*ttnum),(ttbity#*ttnumy)+ttbity#
   set sprite texture coord sid,3,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)+ttbity#
   paste sprite sid,(x-tcenterx#)+((tt-1)*tactualtextwidth),y
  endif
 next tt
 `
 rem restore sprite image
 sprite sid,-10000,-10000,sid
 `
endfunction



rem
rem ENTITY (Control)
rem

_entity_startentitiesoff:
 `
 rem V118 - 070211 - reset level globals (to avoid accessing an entity index that may not exist)
 lastlogicpriorityfurtheste=0
 `
 rem Prepare entities for logical usage
 for e=1 to entityelementlist
  if entityelement(e).active=1 and entityelement(e).spawn.leader=0
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
   rem check if entity starts inside geometry
   entid=entityelement(e).bankindex
   if entityprofile(entid).ischaracter=1 and entityelement(e).y>20
    tettry=0 : tskip=0
    ttryy#=entityelement(e).y
    ellipseheight#=1.0
    if entityelement(e).obj
     if object exist(entityelement(e).obj)=1
      if object size y(entityelement(e).obj)<50
       tskip=1
      endif
     endif
    endif
    if tskip=0
     while tettry<25
      if static volume(entityelement(e).x,ttryy#+33,entityelement(e).z,entityelement(e).x,ttryy#+32,entityelement(e).z,ellipseheight#)=0 then exit
      ttryy#=ttryy#+1.0
      inc tettry
     endwhile
     if tettry>=25
      rem entity stuck - so make it immobile to shut down struggle!
      entityelement(e).eleprof.isimmobile=1
     else
      rem entities can find floor initially (not playerstart,trigger,light,emission)
      entityelement(e).y=ttryy#
      entityelement(e).mover.inmotion=1
      entityelement(e).mover.grav=0.0
     endif
    endif
   endif
  endif
 next e
 timestamp=timer()
 `
 rem Overwrite any GUN or FLAK settings with mods-from-entity-weapons
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  tgunid$=entityprofile(entid).isweapon$
  gosub _entity_getgunidandflakid
  if tgunid>0
   firemode(tgunid,0).settings.accuracy=entityelement(e).eleprof.accuracy
   firemode(tgunid,0).settings.reloadqty=entityelement(e).eleprof.reloadqty
   firemode(tgunid,0).settings.iterate=entityelement(e).eleprof.fireiterations
   if tflakid=0
    firemode(tgunid,0).settings.damage=entityelement(e).eleprof.damage
   else
    flak(tflakid).profile.damage=entityelement(e).eleprof.damage
    flak(tflakid).profile.lifespan=entityelement(e).eleprof.lifespan
    flak(tflakid).profile.bounceonhit=entityelement(e).eleprof.bounceqty
    flak(tflakid).profile.explodeonhit=entityelement(e).eleprof.explodeonhit
    `
    rem some assumptions over how FLAK settings affect flak itself
    flak(tflakid).profile.zinc=entityelement(e).eleprof.throwspeed
    flak(tflakid).profile.yinc=entityelement(e).eleprof.throwangle/10.0
    flak(tflakid).profile.yspeed=1+((entityelement(e).eleprof.throwangle/2.0)/1000.0)
    flak(tflakid).throwangle=entityelement(e).eleprof.throwangle
    if entityelement(e).eleprof.throwangle>0
     flak(tflakid).profile.weight=0.5
    else
     flak(tflakid).profile.weight=0.0
    endif
    `
   endif
  endif
 next e
 `
 rem also ensure entity characters have switched to their weapon (gundata not avail at createelements)
 for e=1 to entityelementlist
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  if obj>0 and entid>0
   if entityprofile(entid).ischaracter=1
    if object exist(obj)=1
     if entityprofile(entid).firespotlimb>-1
      rem spawn leaders do not require attached weapon
      if entityelement(e).spawn.leader=0
       tobj=obj : gosub _entity_switchattachment

      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_resetentitiestorestartstates:
 `
 rem uses tcopyorrestart (1-resttart)
 rem copy start-data-entity-backup to real entityelements
 if tcopyorrestart=0
  dim copyofentityelement(entityelementmax) as entitytype
  for e=1 to entityelementmax
   copyofentityelement(e)=entityelement(e)
  next e
 else
  for e=1 to entityelementmax
   entityelement(e)=copyofentityelement(e)
  next e
 endif
 `
return

_entity_resetentitiesifplrleaps:
 `
 rem Reset logic if player leaps from one location to another
 for e=1 to entityelementlist
  if entityelement(e).active=1
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
  endif
 next e
 `
return

_entity_rejigifwaterlevelchanges:
 `
 rem Prepare entities for logical usage
 for e=1 to entityelementlist
  if entityelement(e).active=1 and entityelement(e).spawn.leader=0
   entid=entityelement(e).bankindex
   if entityelement(e).obj
    if object exist(entityelement(e).obj)=1
     if object position y(entityelement(e).obj)<waterheight#
      if entityelement(e).eleprof.physics=1
       rem regular physics objects only (not pseudo static entities like windows)
       ttx#=0 : tty#=2.5 : ttz#=0
       ttobj=entityelement(e).obj : gosub _physics_setvelocity
      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_addetoprioritylist:
 `
 rem add entity to prority status
 if entityelement(e).priorityai=0
  entityelement(e).priorityai=1
  inc logicprioritycount
 endif
 `
return

_entity_removeefromprioritylist:
 `
 rem remove entity from prority status
 if entityelement(e).priorityai=1
  if entityelement(e).priorityduration=0
   entityelement(e).losttargetcount=99999
   entityelement(e).priorityai=0
   if logicprioritycount>0
    dec logicprioritycount
   endif
   `
   rem V110 - 290508 - stop loop sound if entity pulled from priority action
   entityelement(e).fireweapon=0
   if entityelement(e).firesoundloop>0
    stop sound entityelement(e).firesoundloop
    entityelement(e).firesoundloop=0
   endif
   `
  endif
 endif
 `
return

_entity_stealpriorityandgivetoe:
 `
 rem Steal from furthest, give to this one (E)
 if lastlogicpriorityfurtheste>0
  if entityelement(e).priorityai=0
   if entityelement(lastlogicpriorityfurtheste).priorityai=1
    if entityelement(lastlogicpriorityfurtheste).priorityduration=0
     tste=e : e=lastlogicpriorityfurtheste
     gosub _entity_removeefromprioritylist
     rem FPGC - 290310 - when priority stolen from entity character, they could be MID animation, so switch back to idle
     tttentid=entityelement(e).bankindex
     if entityprofile(tttentid).ischaracter=1
      entityelement(e).animset=1+1
      entityelement(e).destanimframe=0
      entityelement(e).animframe=0
      entityelement(e).animtime=0
     endif
     e=tste : entityelement(e).logiccount=0
     gosub _entity_addetoprioritylist
    endif
   endif
  endif
 endif
 `
return

_entity_blastinitentities:
 `
 rem give entities a 10 cycle blast of logic (to set up things like decals and floating collectables)
 for tencycles=1 to 10
  for e=1 to entityelementlist
   if entityelement(e).active=1 and entityelement(e).spawn.leader=0
    entid=entityelement(e).bankindex
    if entid>0
     obj=entityelement(e).obj
     entityelement(e).logictimestamp=timer()
     gosub _entity_controlsingleai
     tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez# : tdy#=entityelement(e).y-mey#
     entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     `X9 - 050208 - s4real speedup if entityelement(e).plrdist<1000.0
     if entityelement(e).plrdist<600.0
      entityelement(e).logiccount=0
      entityelement(e).dormant=0
     else
      entityelement(e).logiccount=0
      entityelement(e).dormant=1
     endif
    endif
   endif
  next e
 next tencycles
 `
 rem Bring all entities alive quickly
 allentsfulllogicatstartcount=100
 `
 rem 030805 - and once call to entity control to start off visuals/decals/etc
 gosub _entity_controlelements
 `
return

_entity_showdebugstringinfo:
 `
 if e>0 and obj>0
  if entityelement(e).priorityai<>0 then ink rgb(255,255,255),0
  if entityelement(e).plrdist<500
   rem V117 - 171209 - ensure no entity debug text when raw text in operation (font size changes)
   if object in screen(obj)=1 and grawtext$=""
    `
    rem Entity Name and Debug string
    if entityelement(e).priorityai=1 then tpri$=" (priority)" else tpri$=""
    center text object screen x(obj),object screen y(obj)-60,entityelement(e).eleprof.name$+tpri$
    center text object screen x(obj),object screen y(obj)-40,entitydebug$(e)
    `
    rem V109 BETA3 - variable readout
    center text object screen x(obj),object screen y(obj)+20,"G:"+str$(aiglobals(0))+","+str$(aiglobals(1))+","+str$(aiglobals(2))+" L:"+str$(ailocals(e,0))+","+str$(ailocals(e,1))+","+str$(ailocals(e,2))
    `
    rem Entity Status Info
    toffsetspawnlabel=0
    if entityelement(e).spawn.leader=1 then toffsetspawnlabel=20
    tentid=entityelement(e).bankindex
    rem PFGC - 191009 - brought out form inside character check, need AI script name for weapon debug info
    if entityelement(e).ai.libindex>=1 and entityelement(e).ai.libindex<=array count(scriptbank$(0))
     tainame$=scriptbank$(entityelement(e).ai.libindex)
    else
     tainame$=str$(entityelement(e).ai.libindex)
    endif
    if entityprofile(tentid).ischaracter<>0
     rem GUI-X9 (String States)
     center text object screen x(obj),object screen y(obj)+toffsetspawnlabel-20,"A:"+tainame$+" S:"+entityelement(e).ai.state$+" WS:"+str$(entityelement(e).ai.waypoint.state)+" L:"+str$(entityelement(e).eleprof.lives)+" H:"+str$(entityelement(e).health)+" LT:"+str$(entityelement(e).losttargetcount)+"("+str$(int(entityelement(e).actualtargetx))+","+str$(int(entityelement(e).actualtargety))+","+str$(int(entityelement(e).actualtargetz))+") RCC:"+str$(entityelement(e).raycastcount)+" FRAME:"+str$(entityelement(e).animframe)+"\"+str$(entityelement(e).destanimframe)+"  ry="+str$(entityelement(e).ry)
     if entityelement(e).currentweapon>0
      center text object screen x(obj),object screen y(obj)+toffsetspawnlabel,"WA:"+str$(entityelement(e).currentammo)+"\"+str$(entityelement(e).currentclipammo)
     endif
    else
     if entityprofile(tentid).isweapon<>0
      tgunid=entityprofile(tentid).isweapon
      rem GUI-X9 (String States)
      center text object screen x(obj),object screen y(obj)+toffsetspawnlabel-20," AI:"+tainame$+" S:"+entityelement(e).ai.state$+strarr$(99)+str$(gun(tgunid).settings.damage)+" H:"+str$(entityelement(e).health)
     else
      rem GUI-X9 (String States)
      center text object screen x(obj),object screen y(obj)+toffsetspawnlabel-20," AI:"+tainame$+" S:"+entityelement(e).ai.state$+" A:"+str$(entityelement(e).activated)+" H:"+str$(entityelement(e).health)+" FRAME:"+str$(entityelement(e).animframe)+"\"+str$(entityelement(e).destanimframe)
      center text object screen x(obj),object screen y(obj)+toffsetspawnlabel,"WP:"+str$(entityelement(e).ai.waypoint.current)+" TRK:"+str$(entityelement(e).ai.waypoint.tracker)+" DIR:"+str$(entityelement(e).ai.waypoint.direction)+" S:"+str$(entityelement(e).ai.waypoint.state)
     endif
    endif
    `
   endif
  endif
  if entityelement(e).priorityai<>0 then ink rgb(255,255,0),0
 endif
 `
return

_entity_controlelements:

rem FPSCV10X - solve slow life for entities at distance
if allentsfulllogicatstartcount>0
 dec allentsfulllogicatstartcount
endif

rem Entity Performance
gameperftimestamplocal=perftimer()

rem FPGC - 150310 - control controller hint if required
if gcontrollerhint=1 and gxbox<>0
 if gcontrollerhinthudid>0
  hud(gcontrollerhinthudid).image=gcontrollerhintbase
  if gplayercanpressenterhere=1
   hud(gcontrollerhinthudid).image=gcontrollerhintbuttonuse
  else
   if crouchmode<>0
    hud(gcontrollerhinthudid).image=gcontrollerhintbuttonduck
   else
    if jumpaction<>0
     hud(gcontrollerhinthudid).image=gcontrollerhintbuttonjump
    else
     if (plrkeySHIFT)=1 or (plrkeySHIFT2)=1
      hud(gcontrollerhinthudid).image=gcontrollerhintbuttonrun
     else
      if movement<>0
       if (plrkeyA)=1 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonwalk4
       if (plrkeyD)=1 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonwalk3
       if (plrkeyS)=1 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonwalk2
       if (plrkeyW)=1 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonwalk1
      else
       tjtx2#=0 : tjty2#=0
       if gxboxcontrollertype=0
        tjtx2#=(joystick twist x()-32767.0)/(327.67*0.5)
        tjty2#=(joystick twist y()-32767.0)/327.67
       endif
       if gxboxcontrollertype=1
        tjtx2#=(joystick z()/10.0)
        tjty2#=(joystick twist z()-32767.0)/327.67
       endif
       if tjtx2#>20 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonlook3
       if tjtx2#<-20 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonlook4
       if tjty2#>20 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonlook2
       if tjty2#<-20 then hud(gcontrollerhinthudid).image=gcontrollerhintbuttonlook1
      endif
     endif
    endif
   endif
  endif
  if sprite exist(gcontrollerhinthudid)=1
   if hud(gcontrollerhinthudid).image>0
    sprite gcontrollerhinthudid,-10000,-10000,hud(gcontrollerhinthudid).image
   endif
  endif
 endif
endif

rem FPGC - 150310 - reset 'awareness' flags
gplayercanpressenterhere=0 : rem detect if player can press USE via entity scripts

rem General data for control management
mex#=camerapositionx : mey#=camerapositiony : mez#=camerapositionz
meheight#=(ellipsevolumesize#-0.25)*30.0

rem handle AI sound
managebroadcastsound()

rem maintain constant game speed -timer based - Scene Commander rewrite for smoother movement
remstart
timeelapsed#=timebasepercycle#
fpsstore(nextave)=timeelapsed#
temptime#=0
for ave=1 to 80
temptime#=temptime#+fpsstore(ave)
next ave
timeelasped#=temptime#/80
timeelasped#=(timeelasped#/100)*(timer()-timestamp): timestamp=timer()
inc nextave,1:if nextave>80 then nextave=1
rem maintain constant game speed
`timeelapsed#=(1.0/50.0)*(timer()-timestamp) : timestamp=timer()
remend
rem changed for speed
`timeelapsed#=(1.0/50.0)*(timer()-timestamp) : timestamp=timer()
`fpsstore(nextave)=timebasepercycle# ` alpha v1.5 speed up
`temptime#=0
`for ave=1 to 80
`temptime#=temptime#+fpsstore(ave)
`next ave
`timeelasped#=temptime#/80
`inc nextave,1:if nextave>80 then nextave=1

timeelapsed#=(1.0/50.0)*(timer()-timestamp) : timestamp=timer()

rem maintain couner for any animspeed changes
inc timeelapsedrefreshentityanimspeeds
if timeelapsedrefreshentityanimspeeds>5
 timeelapsedrefreshentityanimspeeds=0
endif

rem Debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  set cursor 0,100
  ink rgb(128,255,128),0
  print strarr$(98)
  print
 endif
endif

rem Entity Performance
inc gameperfentities1, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Go through all entities for LOGIC
superstealpriority=0
tonestealperaiphase=0
tonestealperaiphasedist#=99999
logicpriorityfurthest#=0
Rem Scene Commander - track nearest character
nearestcharacterdist=100000
nearestold=nearestcharacterdist
rem scene commander, reset flag for sudden cullmode changes
cullmodechange=0
for e=1 to entityelementlist
 `
 Rem Scene commander - increase player weight if character near to prevent playing being pushed from universe or trapping player behind allies.
 entid=entityelement(e).bankindex
 obj=entityelement(e).obj
 if obj>0
  if object size(obj)>42 and entityprofile(entid).custombiped=0
   if entityprofile(entid).ischaracter=1 and entityelement(e).beenkilled=0 and (entityelement(e).active<>0 and entityelement(e).spawn.leader=0)
    edistance(e)
    howfar2=plrdistance#
    if howfar2<(object size z(obj)*4)*deactivatecollision=1
     ode set body mass physicsplayerborble,physicsplayerweight#+entityelement(e).eleprof.phyweight
     ode set body mass obj,entityelement(e).eleprof.phyweight/4
     thx#=newxvalue(entityelement(e).rx,camera angle y(),10.0)
     thy#=ode get body linear velocity y(obj)
     thz#=newzvalue(entityelement(e).rz,camera angle y(),10.0)
     ode set linear velocity obj,thx#,thy#,thz#
    else
     ode set body mass physicsplayerborble,physicsplayerweight#
     ode set body mass obj,entityelement(e).eleprof.phyweight
    endif
   endif
  endif
 endif
 `
 Rem Scene Commander, handle video textures
 `cullmodelast=cullmode
 if obj>0
          If entityelement(e).videotexture<>0
          if animation playing(entityelement(e).videotexture)=0 then play animation to image entityelement(e).videotexture,animations(entityelement(e).videotexture-9).img,0,0,512,512
          texture object obj,0,animations(entityelement(e).videotexture-9).img
            if entityelement(e).eleprof.usingeffect>0
            if entityelement(e).eleprof.tex1id<>0 then texture object obj,1,entityelement(e).eleprof.tex1id
            if entityelement(e).eleprof.tex2id<>0 then texture object obj,2,entityelement(e).eleprof.tex2id
            if entityelement(e).eleprof.tex3id<>0 then texture object obj,3,entityelement(e).eleprof.tex3id
            rem FPSC - 210111 - force CPU animation for entities with specific limb identities
            set object effect obj,entityelement(e).eleprof.usingeffect,1
            else
            set object effect obj,entityelement(e).eleprof.usingeffect,0
            endif
            objecteffect(obj)=entityelement(e).eleprof.usingeffect
            else
            rem FPGC - 100610 - fix issue which wipes 'material mode' when re-apply texture
            set object diffuse obj,rgb(128,128,128)
            endif
    endif


         if cullmode<>cullmodelast and cullmodechange=0
         cullmodechange=1
         endif

         Rem scene commander, handle sudden changes in cullmode.

         if cullmodechange=1
            for change=1 to entityelementlist
            tobj=entityelement(change).obj
            if entityelement(change).ishidden<2
               if tobj>0
                  if object exist(tobj)=1
                  set alpha mapping on tobj,100
                  show object tobj
                  endif
               endif
            endif
            next change
         cullmodechange=2
         cullmodelast=cullmode
         endif

Rem Scene Commander, calling culling per entity for performance increase.
culling(e,entid,obj)
`cullmode=cullmodelast
rem Scene Commander - Ensure ismmobile entites are restored
if entityelement(e).eleprof.physics=99 then entityelement(e).eleprof.physics=3


   rem scene commander, apply entity angle offsets

   if obj>0
   tempx#=entityelement(e).rx+entityelement(e).offsetanglex
   tempy#=entityelement(e).ry+entityelement(e).offsetangley
   tempz#=entityelement(e).rz+entityelement(e).offsetanglez
   rotate object obj,tempx#,tempy#,tempz#

endif

rem Move entity if underwater

if obj>0
   if watercurrent<>0 and entityelement(e).eleprof.isimmobile<>1
      tempwaterpos=object position y(obj)+(object size y(obj)/2.0)
      if tempwaterpos<(waterheight#+(object size y(obj)/2.0))
      oldvelx#=sin(watercurrent)*(waterflow*2)
      oldvely#=ode get body linear velocity y(obj)
      oldvelz#=cos(watercurrent)*(waterflow*2)
      ode set linear velocity obj,oldvelx#,oldvely#,oldvelz#
      endif
   endif
endif

 rem AirMod - Added for Advanced Blood
 gosub _entity_controlblood
 obje=e
 if entityelement(e).isflak>0

  `Print "Obj Exist: "+str$(Object Exist(entityelement(e).obj))
  `Print "Profile Obj Exist: "+str$(Object Exist(entityelement(e).profileobj))
  `Print "Obj Visible: "+str$(Object Visible(entityelement(e).obj))
 endif
 if entityelement(e).active=1 and entityelement(e).dormant=0
  `
  rem only non-spawn-masters with valid profile indexes
  if entid>0 and entityelement(e).spawn.leader=0
   `
   rem reset kill flag
   tkillentitynow=0
   `
   rem always fade entity to lifespan no matter logic slice
   if entityelement(e).spawn.life>0
    if timer()>entityelement(e).spawn.life
     entityelement(e).spawn.life=0
     entityelement(e).shotby=998
     entityelement(e).shotbyammo$=""
     tkillentitynow=1
    endif
   endif
   `
   rem always kill an entity falling out of universe
   if entityelement(e).y<-100
    tkillentitynow=1
    entityelement(e).shotby=999
    entityelement(e).shotbyammo$=""
   endif
   `
   rem kill now
   if tkillentitynow=1
    tdamage=entityelement(e).health
    tdamagesource=0 : timpacttype=1
    tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
    ttodestroyevenifimmune=entityelement(e).eleprof.strength : rem store for later return
    if entityelement(e).eleprof.strength=0 then entityelement(e).eleprof.strength=1
    gosub _entity_deducthealth : entityelement(e).eleprof.strength=ttodestroyevenifimmune
    tkillentitynow=0
   endif

   Rem Hockeykid - 250210 - Dark AI main control subroutine call
`   inc gameperfentities2, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()
   gosub _darkai_control
`   inc gameperfentities3, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()
   `
   rem logic timeslice
   tlogic#=entityelement(e).logiccount-timeelapsed#
   entityelement(e).logiccount=tlogic#
   if entityelement(e).eleprof.phyalways<>0 then entityelement(e).logiccount=0
   if entityelement(e).logiccountburst>0 then entityelement(e).logiccountburst=entityelement(e).logiccountburst-1 : entityelement(e).logiccount=0
   if entityelement(e).logiccount>0.0
    `
    rem if player runs at entity quickly, entity AI should be ready with AI
    tdx#=entityelement(e).x-mex# : tdy#=entityelement(e).y-mey# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    if entityprofile(entid).ischaracter=0
     rem for doors and proximity AI
     if entityelement(e).plrdist<100
      entityelement(e).logiccount=0
     endif
     rem FPGC - 280610 - for looping decals, always active
     if entityelement(e).decalmode=2 or entityelement(e).decalmode=3 or entityelement(e).decalmode=5
      entityelement(e).logiccount=0
     endif
    else
     rem characters can have a priority logic monopoly
     if logicprioritycount<int(logicprioritymax#)
      gosub _entity_addetoprioritylist
     else
      rem if this entity character is substantially closer that furthest priority entity, switch
      if entityelement(e).plrdist<lastlogicpriorityfurthest#+125.0
       rem switch priroity to this entity (priority entity characters are always the closest)
       if entityelement(e).plrdist<tonestealperaiphasedist#
        tonestealperaiphasedist#=entityelement(e).plrdist
        tonestealperaiphase=e
       endif
      endif
      rem hold character logic at bay - until logicpriority allows
      entityelement(e).logiccount=100
     endif
     if entityelement(e).priorityai=1
      entityelement(e).logiccount=0
     endif
     `
     rem FPGC - 100610 - characters can also force their targets to assume high priority (like remote doors)
     tcharactertarget=entityelement(e).actualtarget
     if tcharactertarget>1
      entityelement(tcharactertarget-1).logiccount=0
     endif
     `
    endif
    if entityelement(e).ai.libindex=entityelement(e).ai.libdestroy or entityelement(e).ai.libindex=entityelement(e).ai.libinit
     entityelement(e).logiccount=0
    endif
    rem FPGC - 300310 - constant dynamic lighting and flame (decal mode 7)
    if entityprofile(entid).ismarker<>0 or entityprofile(entid).islightmarker=1
     rem checkpoint, lights, triggers and emissions
     entityelement(e).logiccount=0
    endif
    `
   endif
   if entityelement(e).logiccount<=0
    `
    rem time slice of logic (...since entity last thought...)
    timeslice#=(1.0/50.0)*(timer()-entityelement(e).logictimestamp)
    entityelement(e).logictimestamp=timer()
    `
    rem logic control
    gosub _entity_controlsingleai
    `
    rem when move, sounds might also need moving
    if entityelement(e).eleprof.physics<=2
     for tsnd=0 to 2
      if tsnd=0 then ttsnd=entityelement(e).soundset
      if tsnd=1 then ttsnd=entityelement(e).soundset1
      if tsnd=2 then ttsnd=entityelement(e).soundlooping
      if ttsnd>0
       if sound exist(ttsnd)=1
        if sound looping(ttsnd)=1
         posinternal3dsound(ttsnd,entityelement(e).x,entityelement(e).y,entityelement(e).z)
        endif
       endif
      endif
     next tsnd
    endif
    `
    rem free up a counter for a new AI character to be selected
    if entityelement(e).priorityai=1
     tokay=0
     if entityelement(e).active=0 or entityelement(e).plrdist>500
      entityelement(e).priorityduration=0
      tokay=1
     endif
     if tokay=1
      gosub _entity_removeefromprioritylist
     else
      rem work out which E is the furthest back
      tpridist#=entityelement(e).plrdist
      if tpridist#>logicpriorityfurthest#
       logicpriorityfurthest#=tpridist#
       logicpriorityfurtheste=e
      endif
     endif
     rem priority duration protects from being lost or stolen for a while (running away)
     if entityelement(e).priorityduration>0
      entityelement(e).priorityduration=entityelement(e).priorityduration-1
     else
      entityelement(e).priorityduration=0
     endif
    endif
    `
    rem calculate player activity distance
    tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
    `
    rem can I see checkpoints here
    if entityprofile(entid).ismarker=1 and entityprofile(entid).lives=-1
     if entityelement(e).plrdist<120.0
      if checkpointentity<>e
       playinternal3dsound(entityelement(e).soundset,mex#,mey#,mez#)
       checkpointentity=e
      endif
     endif
    endif
    `
    rem logic count based on distance (cancelled for important AI above)
    if allentsfulllogicatstartcount>0
     rem FPSCV10X - all entities should have immediate burst of logic to get started
     entityelement(e).logiccount=0
    else
     entityelement(e).logiccount=entityelement(e).plrdist/5.0
    endif
    `
   endif
   `
  endif
  `
 else
  `
  rem only if not dormant
  if entityelement(e).dormant=0
   `
   rem Inactive entity, however characters have logic even when dead
   if entityprofile(entid).ischaracter=1
    `
    rem remove attached weapon physics if out of bounds
    tobj=entityelement(e).attachmentobj
    if tobj>0
     if object position y(tobj)<-50 and object position y(tobj)<>-5000
      gosub _ode_deleteentity
      hide object tobj
      position object tobj,-5000,-5000,-5000
     endif
    endif
    `
    rem FPGC - 100710 - on occasion, character can be killed off screen (no anim performed)
    rem so need to adjust position of any carried weapon to floor (other it floats)
    rem V119 - 020711 - Hockeykid - new system (x10 method) isn't animation specific
    remstart
    if obj>0
     tvweapobj=entityelement(e).attachmentobj
     if object exist(obj)=1
      if object in screen(obj)=0 `and entityelement(e).ragdollon=0
       if tvweapobj>0
        if object exist(tvweapobj)=1
         unglue object tvweapobj
         if object position y(tvweapobj)>entityelement(e).y+5
          position object tvweapobj,object position x(tvweapobj),entityelement(e).y,object position z(tvweapobj)
         endif
        endif
       endif
      endif
     endif
    endif
    remend
    `
    if entityelement(e).eleprof.cantakeweapon=1
     tgunid=entityelement(e).currentweapon
     if tgunid>0
      rem calculate player activity distance (of the attached weapon point)
      rem FPGC - 100710 - if ragdollified, use entity last location for gun pickup (real OBJ at 0,0,0)
      tdropobj=entityelement(e).attachmentobj
      if tdropobj>0
       x1#=object position x(tdropobj) `limb position x(obj,entityprofile(entid).firespotlimb)
       y1#=object position y(tdropobj)`limb position y(obj,entityprofile(entid).firespotlimb)
       z1#=object position z(tdropobj)`limb position z(obj,entityprofile(entid).firespotlimb)
      else
       x1#=limb position x(obj,entityprofile(entid).firespotlimb)`entityelement(e).x
       y1#=limb position y(obj,entityprofile(entid).firespotlimb)`entityelement(e).y
       z1#=limb position z(obj,entityprofile(entid).firespotlimb)`entityelement(e).z
      endif
      tdx#=x1#-mex# : tdy#=y1#-mey# : tdz#=z1#-mez#
      entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
      if entityelement(e).plrdist<80
       rem player collects weapon from enemy (stores takeweaponammo in Quantity)
       weaponindex=tgunid
       weaponinvposition=pint : tgunid=weaponindex
       tqty=rnd(firemode(tgunid,0).settings.reloadqty)
       autoentityusedtoholdweapon=e
       gosub _player_addweapon
       rem for weapnisammo collections, add required ammo
       if gotweapon>0
        if gun(tgunid).settings.weaponisammo=0
         tqty=firemode(tgunid,0).settings.reloadqty*entityelement(e).eleprof.quantity
         `weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
         tpool=firemode(tgunid,0).settings.poolindex
         if tpool=0 then weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty else ammopool(tpool).ammo=ammopool(tpool).ammo+tqty
        else
         if tqty=0 then tqty=1
         if weaponammo(gotweapon)=0
          weaponammo(gotweapon)=tqty
         else
          weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
         endif
        endif
       endif
       rem and play a reload sound from the gun (collection sound=reload)
       if gunsound(tgunid,2).soundid>0
        if sound exist(gunsound(tgunid,2).soundid)=1
         if sound playing(gunsound(tgunid,2).soundid)=0
          playinternalBC3dsound(gunsound(tgunid,2).soundid,camera position x(),camera position y(),camera position z(),1)
         endif
        endif
       endif
       rem and remove weapon from dead entity
       entityelement(e).currentweapon=0
       rem remove attached weapon from entity also
       tobj=entityelement(e).attachmentobj


       if tobj>0
       gosub _ode_deleteentity
       hide object tobj
       position object tobj,-5000,-5000,-5000
       endif

      endif
     endif
    endif
   endif
  else
   `
   rem Entity is completely dormant (brand new or frozen by distance)
   if obj>0
    if object exist(obj)=1
     if object visible(obj)=1
      rem no longer dormant if revealed by areabox render
      entityelement(e).dormant=0
     endif
    endif
   else
    rem not dormant if close enough to be useful (trigger areas, emissions, non-objs)
    tdx#=entityelement(e).x-mex# : tdy#=entityelement(e).y-mey# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    if entityelement(e).plrdist<1000.0
     entityelement(e).dormant=0
    endif
   endif
   `
   rem Not dormant if always active
   if entityelement(e).eleprof.phyalways<>0 then entityelement(e).dormant=0
   `
  endif
  `
 endif
next e

rem end of debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  ink rgb(255,255,0),0
 endif
endif

rem Steal priority if new entity closer
if tonestealperaiphase>0
 e=tonestealperaiphase : gosub _entity_stealpriorityandgivetoe
endif

rem Drop a priority entity if need to get some AI speed back
if logicpriorityfurtheste>0
 lastlogicpriorityfurthest#=logicpriorityfurthest#
 lastlogicpriorityfurtheste=logicpriorityfurtheste
 if logicprioritycount>int(logicprioritymax#)
  e=logicpriorityfurtheste
  gosub _entity_removeefromprioritylist
 endif
endif

rem Entity Performance
inc gameperfentities4, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Go through all entities for MOVEMENT
for e=1 to entityelementlist
 if entityelement(e).dormant=0
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  gosub _entity_controlspawn
  if entityelement(e).spawn.leader=0
   if entityelement(e).active=1
    gosub _entity_controlwaypoints
    gosub _entity_controlforce
    gosub _entity_controlcollision
    gosub _entity_controlmovements
    gosub _entity_controldelayeddamage
   endif
  endif
 endif
next e

rem Calculate any logic drop increments/decrements
rem V110 - 290508 - give more MS to entity logic (it is a drainer in X9)
`if screen fps()>=30
`if screen fps()>=25
Rem Scene Commander, changed to reduce increasing entity usage hogging.

if screen fps()>=25
currentmax#=screen fps()/10:if currentmax#>6.0 then currentmax#=6.0
 `X9 - 060208 - if logicprioritymax#<10.0
 `if logicprioritymax#<5.0
 if logicprioritymax#<currentmax#
  rem better consistent frame rate if only five entities have close logic (for raycasting, etc)
  logicprioritymax#=logicprioritymax#+0.02
 endif
else
 rem V110 - 290508 - step down slowly to stop all AI just halting instantly
 `logicprioritymax#=2.0
 if logicprioritymax#>2.0
  dec logicprioritymax#,0.04
 endif
endif
if logicprioritymax#<2.0 then logicprioritymax#=2.0
rem speed work
incspeed#=(1.0/40.0)*(timer()-lastincrementspeedtime) : lastincrementspeedtime=timer()
rem Go through all entities for VISUAL
for e=1 to entityelementlist
 obj=entityelement(e).obj
 entid=entityelement(e).bankindex
 `
 if obj>0 then gosub _entity_controlattachments
 `
 if entityelement(e).active=1 and entityelement(e).dormant=0
  if obj>0
   `
   if object exist(obj)=1 and entityelement(e).plrdist<1000
    `
    rem Operate spin and float system
    tspin#=0.0 : thover#=0.0
    if entityelement(e).spinrate<>0
     entityelement(e).spinvalue=entityelement(e).spinvalue+(timeelapsed#*entityelement(e).spinrate)
     tspin#=wrapvalue(entityelement(e).spinvalue)
    endif
    if entityelement(e).floatrate<>0
     entityelement(e).floatvalue=entityelement(e).floatvalue+(timeelapsed#*4)
     thover#=entityelement(e).floatrate+(cos(wrapvalue(entityelement(e).floatvalue))*entityelement(e).floatrate)
    endif
    `
    rem update entity object position (keep position for univese vis-culling)
    if entityelement(e).eleprof.physics=1
     rem V118 - when underwater, can apply extra force to underwater entity
     if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
      tdx#=object position x(obj)-camera position x()
      tdy#=object position y(obj)-camera position y()
      tdz#=object position z(obj)-camera position z()
      tdplrdist#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
      tminradius#=object size(obj)*1.5
      if tdplrdist#<tminradius#
       rem push force to move entity away from player
       tpushforce#=(tminradius#-tdplrdist#)*0.5
       tpushangle#=atanfull(tdx#,tdz#)
       tdx#=newxvalue(0.0,tpushangle#,tpushforce#)
       if tdy#>0.0 then tdy#=tpushforce#
       if tdy#<0.0 then tdy#=tpushforce#*-1.0
       tdz#=newzvalue(0.0,tpushangle#,tpushforce#)
       oldvelx#=ODE GET BODY LINEAR VELOCITY X(obj)+tdx#
       oldvely#=ODE GET BODY LINEAR VELOCITY Y(obj)+tdy#
       oldvelz#=ODE GET BODY LINEAR VELOCITY Z(obj)+tdz#
       ode set linear velocity obj,oldvelx#,oldvely#,oldvelz#
      endif
     endif
     rem regular physics driven
     entityelement(e).x=object position x(obj)
     entityelement(e).y=object position y(obj)
     entityelement(e).z=object position z(obj)
     entityelement(e).ry=object angle y(obj)
    else
     if entityelement(e).eleprof.physics=2
      rem entity driven physics (character)
      todee=e : gosub _ode_entitydrivenphysics
     else
      if entityelement(e).eleprof.physics=3
       rem entity is typically immobile (door/window)
       todee=e : gosub _ode_entitydrivenstaticphysics
      else
       rem no physics influences
       position object obj,entityelement(e).x,entityelement(e).y+thover#,entityelement(e).z
      endif
     endif
    endif
    `
    rem Animations need consistency when suddenly obj is visible
    gosub _entity_controlanim
    `
    rem if actually visible to camera
    if object visible(obj)=1
     `
     rem Only need decal creation if an existing obj is visible
     gosub _entity_controldecals
     `
     rem handle object rotation
     if entityelement(e).norotate=0
      yrotate object obj,entityelement(e).ry+tspin#
     endif
     `
     rem update animation frame of entity
     if entityelement(e).animframeupdate=1
       stop object obj : set object interpolation obj,100
       set object frame obj,entityelement(e).animframe
       entityelement(e).animframeupdate=0
     endif
     `
     rem Update head if available
     if entityprofile(entid).headlimb<>-1
      if limb exist(obj,entityprofile(entid).headlimb)=1
       `
       rem handle regular head rotation to obey headangle
       rem FPGC - 110111 - include headdownangle in final head rotation (head down depressed script)
       `rotate limb obj,entityprofile(entid).headlimb,curveangle(entityelement(e).ai.headangle,limb angle x(obj,entityprofile(entid).headlimb),3.0),limb angle y(obj,entityprofile(entid).headlimb),limb angle z(obj,entityprofile(entid).headlimb)
       rotate limb obj,entityprofile(entid).headlimb,curveangle(entityelement(e).ai.headangle,limb angle x(obj,entityprofile(entid).headlimb),3.0),curveangle(entityelement(e).ai.headdownangle,limb angle y(obj,entityprofile(entid).headlimb),3.0),limb angle z(obj,entityprofile(entid).headlimb)
       `
       rem FPGC - DARKVOICES - 070910 - quick hack to move mouth and arm of the NEW character type
       if nextgenbranch=1
        if entityprofile(entid).ischaracter=1
         if entityelement(e).soundistalking=1
          rem only if talking a sound
          tsnd=entityelement(e).soundlooping
          if tsnd>0
           if sound playing(tsnd)=0 then tsnd=0
          endif
          if tsnd>0
           rem animate mouth
           perform checklist for object limbs obj
           if checklist quantity()>=entityprofile(entid).headframefinish and entityprofile(entid).headframefinish>0
            gosub _lipsync_control
            `for limb=58 to 80 : rem mark (not sensible to use frame nums, should opt for limb names)
            `for limb=59 to 139 : rem jon
            for limb=entityprofile(entid).headframestart to entityprofile(entid).headframefinish
             set object frame obj,limb,pose,1
            next limb
            `
            rem FPGC - 230310 - commented this out as it seemed to be a hack to solve something..
            `rotate limb obj,77,-40,45+(cos(entityelement(e).ai.headangle)-30.0),(sin(entityelement(e).ai.headangle)-30.0)
            `
            rem experimental arm gestures
            `armgesture#=armgesture#+0.1
            `if armgesture#<10
            ` armgestureon=1
            `else
            ` armgestureon=0
            `endif
            `for limb=29 to 33
            ` set object frame obj,limb,armgesture#,armgestureon
            `next limb
            `for limb=41 to 47
            ` set object frame obj,limb,armgesture#,armgestureon
            `next limb
            `
           endif
          endif
         endif
        endif
       endif
       `
      endif
     endif
     `
     Rem spine update
     entid=entityelement(e).bankindex

    if entityelement(e).actualtarget=0
      entityelement(e).spineraim=0
     `if entityelement(e).spiner>0 then dec entityelement(e).spiner,2
    `if entityelement(e).spiner<0 then entityelement(e).spiner=0
     endif
     if entityprofile(entid).spine>-1 and entityprofile(entid).ischaracter=1 and entityprofile(entid).spine2>-1
      `rotation#=(entityelement(e).spiner/2.0)
      if int(entityelement(e).spiner)<>int(entityelement(e).spineraim)
      if int(entityelement(e).spiner)>int(entityelement(e).spineraim)
      entityelement(e).spiner=int(entityelement(e).spiner)-1
      else
      entityelement(e).spiner=int(entityelement(e).spiner)+1
      endif
      endif

      rotation#=int(entityelement(e).spiner)
      Rem Handle Spine 1 Rotation
     ` text object screen x(entityelement(e).obj),object screen y(entityelement(e).obj),str$(entityelement(e).spiner)
         if entityprofile(entid).spine>0
            if limb exist(entityelement(e).obj,entityprofile(entid).spine)=1
            Rotate Limb entityelement(e).obj,entityprofile(entid).spine,Limb Angle X(entityelement(e).obj,entityprofile(entid).spine),rotation#,Limb Angle Z(entityelement(e).obj,entityprofile(entid).spine)
            endif
         endif
      Rem Handle Spine 2 Rotation
         if entityprofile(entid).spine2>0
            if limb exist(entityelement(e).obj,entityprofile(entid).spine2)=1
            Rotate Limb entityelement(e).obj,entityprofile(entid).spine2,Limb Angle X(entityelement(e).obj,entityprofile(entid).spine2),rotation#,Limb Angle Z(entityelement(e).obj,entityprofile(entid).spine2)
            endif
         endif
     endif
     `
     rem any visual overlay info
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
     rem update alpha fade value
     if gmultiplayergame=1
      rem multiplayer - bug in 5.8, characters cannot control alpha (seem to be influenced by other objects)
      set alpha mapping on obj,100
      if entityprofile(entid).ischaracter<>0
       if entityelement(e).invincibleactive<>0
        ghost object on obj
       else
        ghost object off obj
       endif
      endif
     else
      rem keep for single player
      if entityelement(e).invincibleactive<>0
       set alpha mapping on obj,50+rnd(25)
      else
       if entityelement(e).ai.alphafadeupdate=1
        set alpha mapping on obj,entityelement(e).ai.alphafade
        entityelement(e).ai.alphafadeupdate=0
       endif
      endif
     endif
     `
     rem control lighting of entities (and free at start also - get start lighting)
     if gdynamiclightingstate=1 or forceambientlightsetting>0
      if object in screen(obj)=1
       gosub _entity_controllighting
      endif
     endif
     `
     rem show attachment obj
     tobj=entityelement(e).attachmentobj
     if tobj>0
      if object exist(tobj)=1
       show object tobj
      endif
     endif
     `
     rem blob shadow control (all other non local plrs)
     if entityprofile(entid).ischaracter=1
      if (gmultiplayergame=0 and entityelement(e).health>0) or (gmultiplayergame=1 and entityelement(e).collisionactive<>0)
       dst#=static raycast(entityelement(e).x,entityelement(e).y+5,entityelement(e).z,entityelement(e).x,entityelement(e).y-50,entityelement(e).z)
      else
       dst#=0.0
      endif
     else
      dst#=0.0
     endif
     if dst#>0
      dst#=dst#-5.0
      tmvszy#=object size y(obj)/2
      tmvszyforobj#=tmvszy#-(tmvszy#*(entityprofile(entid).scale/100.0))
      if gmultiplayergame=1
       rem FPGC - 020810 - arena game does not use ODE characters, so place shadow at obj y base
       tmvy#=0
      else
       tmvy#=0-tmvszy#
      endif
      entityelement(e).floorpositiony=(tmvy#-dst#-entityprofile(entid).raisefactor)+0.5
     else
      entityelement(e).floorpositiony=50000.0
     endif
     if entityelement(e).attachmentblobobj>0
      if object exist(entityelement(e).attachmentblobobj)=1


       `if entityelement(e).floorpositiony<50000.0
        `position object entityelement(e).attachmentblobobj,object position x(obj),object position y(obj)+tmvszyforobj#+entityelement(e).floorpositiony,object position z(obj)
if (gmultiplayergame=0 and entityelement(e).health>0) or (gmultiplayergame=1 and entityelement(e).collisionactive<>0)
        dst#=static raycast(entityelement(e).x,entityelement(e).y+5,entityelement(e).z,entityelement(e).x,entityelement(e).y-50,entityelement(e).z)
       else
        dst#=0.0
       endif
       if dst#>0
        dst#=dst#-5.0
        tmvszy#=(object size y(obj)/2)*(entityprofile(entid).scale/100.0)
        if gmultiplayergame=1
         rem FPGC - 020810 - arena game does not use ODE characters, so place shadow at obj y base
         tmvy#=object position y(obj)
        else
         tmvy#=object position y(obj)-tmvszy#
        endif
        rem X9 V109 - 14030 - Account for RAISEFACTOR when setting shadow position
        `position object entityelement(e).attachmentblobobj,object position x(obj),(tmvy#-dst#)+0.5,object position z(obj)
        position object entityelement(e).attachmentblobobj,object position x(obj),(tmvy#-dst#-entityprofile(entid).raisefactor)+0.5,object position z(obj)
        show object entityelement(e).attachmentblobobj
        tsc#=(100.0-dst#) : scale object entityelement(e).attachmentblobobj,tsc#,tsc#,tsc#
       else
        hide object entityelement(e).attachmentblobobj
       endif
       if entityelement(e).hideshadow=1 then hide object entityelement(e).attachmentblobobj
      endif
     endif
     `
    else
     `
     rem Limited debug info view of entities not visible (for spawn debugging)
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
     rem entity not visible by camera ny more
     tobj=entityelement(e).attachmentobj
     if tobj>0
      if object exist(tobj)=1
       hide object tobj
      endif
     endif
     `
    endif
    `
   endif
   `
  else
   `
   rem entity has no OBJ
   if entityprofile(entid).ismarker=4
    rem emission markers can emit decals of course
    gosub _entity_controldecals
   endif
   `
  endif
 endif
 `
 rem monitor entity for splash (dead or alive, or not facing at the time)
 if entityelement(e).dormant=0
  if obj>0
   if object exist(obj)=1
    gosub _entity_monitorforsplash
   endif
  endif
 endif
 `
next e

rem Display vis col map (as radar test)
if entitysystemdisabled=0 and gshowentitygameinfostate=1 and 0 : rem FPGC - 070909 - do not show radar - slow & inaccurate!
 lock pixels
 thorizpos=(screen width()-40)-40-10
 tvertpos=(screen height()-40)-511-10-20
 metx=camerapositionx/25 : mety=camerapositiony/100 : metz=camerapositionz/-25
 line thorizpos,470+tvertpos,thorizpos+82,470+tvertpos : line thorizpos,553+tvertpos,thorizpos+82,553+tvertpos
 line thorizpos,470+tvertpos,thorizpos,553+tvertpos : line thorizpos+82,470+tvertpos,thorizpos+82,553+tvertpos
 for tx=metx-20 to metx+20
  for ty=mety to mety
   for tz=metz-20 to metz+20
    tdot=0
    if tx>=0 and tx<=160 and ty>=0 and ty<=5 and tz>=0 and tz<=160
     if viscolmap(tx,ty,tz)<>0
      tdot=1
     endif
    else
     if (tx=-1 or tx=161) and tz>=0 and tz<=160
      tdot=1
     endif
     if (tz=-1 or tz=161) and tx>=0 and tx<=160
      tdot=1
     endif
    endif
    if tdot=1
     dot thorizpos+41+((tx-metx)*2),511+((tz-metz)*2)+tvertpos
     dot thorizpos+41+((tx-metx)*2),512+((tz-metz)*2)+tvertpos
     dot thorizpos+42+((tx-metx)*2),511+((tz-metz)*2)+tvertpos
     dot thorizpos+42+((tx-metx)*2),512+((tz-metz)*2)+tvertpos
    endif
   next tz
  next ty
 next tx
 unlock pixels
endif

rem Entity Performance
inc gameperfentities5, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

return

_entity_monitorforsplash:
 `
 if wateron=0 then return
 rem entity can have a splash if they enter the water at force
 if (entityelement(e).eleprof.physics=1 or entityelement(e).eleprof.physics=2) and splashdecalid>0
  rem if regular physics obj or character obj
  rem ensure this does not happen if entity drops 'near' water line (deduct a margin)
  waterlevelforsplash#=waterheight#-10.0
  if entityelement(e).eleprof.physics=2
   rem character/ragdoll center
   tactualbaseofobject#=object position y(entityelement(e).obj)
  else
   tactualbaseofobject#=object position y(entityelement(e).obj)-(object size y(entityelement(e).obj)/2.0)
  endif
  if tactualbaseofobject#<waterlevelforsplash#
   if entityelement(e).decalloop=0
    rem measure velocity on impact with water
    velocity#=0.0
    if entityelement(e).obj>0 and entityelement(e).obj<=array count(phyobjele())
     ttobj=entityelement(e).obj
     velocity#=abs(ODE GET BODY LINEAR VELOCITY Y(ttobj))
    endif
    if entityelement(e).eleprof.physics=2
     velocity#=velocity#*10.0
    endif
    if velocity#>7.0
     rem regular underwater handling
     oldvelx#=ODE GET BODY LINEAR VELOCITY X(entityelement(e).obj)*0.97
     oldvely#=ODE GET BODY LINEAR VELOCITY Y(entityelement(e).obj)*0.97
     oldvelz#=ODE GET BODY LINEAR VELOCITY Z(entityelement(e).obj)*0.97
     ode set linear velocity entityelement(e).obj,oldvelx#,oldvely#,oldvelz#
     rem set so only do one splash per entry into water
     if waterdecalripple<>0
      rem and only if water does ripple
      rem ripple
      decalid=waterdecalripple
      decalorient=0
      decalx=object position x(entityelement(e).obj)
      decaly=waterheight#+1.0
      decalz=object position z(entityelement(e).obj)
      decalorient=2
      decalscalemodx=20+(abs(entityelement(e).eleprof.phyweight)/50.0) : decalscalemody=decalscalemodx
      decalalpha=15
      originatore=0 : gosub _decalelement_create
      rem splash
      entityelement(e).decalloop=1
      decalx=object position x(entityelement(e).obj)
      decalz=object position z(entityelement(e).obj)
      rem V118 - 060211 - splash needs to be on surface at all times (submerged splash decal looks odd)
      rem V118 - 060211 - modify scale based on velocity and size of object
      tscaleofobject#=object size(entityelement(e).obj)/80.0
      decalscalemodx=(decalscalemodx/20.0)*(velocity#-5.0)*tscaleofobject#
      if decalscalemodx<0 then decalscalemodx=0
      if decalscalemodx>100 then decalscalemodx=100
      decalscalemody=decalscalemodx
      decaly=waterheight#-((100-decalscalemodx)/2)
      gosub _entity_makeasplash
     endif
    endif
    rem ensure we don't splash when exit water
    entityelement(e).decalloop=1
   else
    rem entity in IN water
    rem if entity disturbing surface, fire off random rippe now and then
    if rnd(150)=0 and waterdecalripple<>0 and entityelement(e).active=1
     rem and only if water does ripple
     if abs(object position y(entityelement(e).obj)-waterheight#)<25.0
      decalid=waterdecalripple
      decalorient=0
      decalx=object position x(entityelement(e).obj)
      decaly=waterheight#+1.0
      decalz=object position z(entityelement(e).obj)
      decalorient=2
      decalscalemodx=20+(abs(entityelement(e).eleprof.phyweight)/50.0) : decalscalemody=decalscalemodx
      decalalpha=15
      originatore=0 : gosub _decalelement_create
     endif
    endif
   endif
  else
   rem if entity leaves water, reset splash flag
   if entityelement(e).decalloop=1
    if tactualbaseofobject#>waterlevelforsplash#
     rem completely out of water, gravity back on
     entityelement(e).decalloop=0
    endif
   endif
  endif
 endif
 `
return

_entity_makeasplash:
 `
 rem takes DECAL X Y Z, velocity#
 if waterdecalripple<>0
  `
  rem show splash
  decalid=splashdecalid
  decalorient=0
  `decalscalemodx=100 `specified by calling code (adjusted for velocity and object size)
  `decalscalemody=decalscalemodx
  decalalpha=velocity# : if decalalpha>50 then decalalpha=50
  originatore=0 : gosub _decalelement_create
  `
  rem play splash sound - toggle spalsh sound on/off - Flatlander
  if createsplashsound=1
   tmatindex=17 : tsoundtrigger=material(tmatindex).impactid
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=decalx : tsy#=decaly : tsz#=decalz
   tvol#=velocity#/2.0 : if tvol#>100 then tvol#=100
   gosub _ode_triggermaterialsound
  endif
  `
 endif
 `
return

_entity_fillviscolmap:
 `
 rem Fill empty map tiles with no-walk id
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 4
    for tx=0 to 3
     for tz=0 to 3
      viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=0
     next tz
    next tx
   next tml
  next tmz
 next tmx
 `
 rem FPSCV104RC5 use map data to determine where layer holes are (so characters cannot fall off ledges)
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 19
    fillviscolmapnow=0
    if map(tml,tmx,tmz)=0
     rem no base segment means hole in universe
     fillviscolmapnow=1
     rem FPGC - 110610 - check if overlays have a floor to ensure no hole is added
     tolaymax=0 : olayindex=mapolay(tml,tmx,tmz)
     while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
     dec tolaymax
     if tolaymax>=0
      for olayti=0 to tolaymax
       mapid=olaylist(olayindex,olayti)
       if mapid<>0
        gosub _gridedit_getmapvalues
        if object exist(selectionbankoffset+mapselection)=1
         rem does this overlay segment have a floor we can stand on?
         if segmentprofile(mapselection).blueprint.mode>0
          fillviscolmapnow=0
         endif
        endif
       endif
      next olayti
     endif
    endif
    if fillviscolmapnow=1
     for tx=0 to 3
      for tz=0 to 3
       viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=-2
      next tz
     next tx
    endif
   next tml
  next tmz
 next tmx
 `
return

_entity_controlsingleai:

rem get functional overview
gosub _entity_controlrecalcdist

rem before any point of logic, if no health in main AI, die
if entityelement(e).ai.libindex=entityelement(e).ai.libmain
 if entityelement(e).health<=0
  entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.headangle=0
  entityelement(e).ai.state$="0" rem GUI-X9 (String States)
 endif
endif

rem New AI Script flag
trundefaultscript=0
taddforcesphere=0

rem Get AI Script for Entity Element
aiindex=entityelement(e).ai.libindex
if entityelement(e).active=1
 gosub _ai_control
endif
`
rem Apply force if actioned
if taddforcesphere>0
 spherex#=entityelement(e).x
 spherey#=entityelement(e).y
 spherez#=entityelement(e).z
 sphereforce#=taddforcesphere/100.0
 gosub _entity_addforcesphere
endif
`
rem Stop weapon firing if AI no longer in control of entity
if entityelement(e).active=0 then entityelement(e).fireweapon=0
`
rem Weapon Control for entities
if entityelement(e).fireweapon=1
 tgunid=entityelement(e).currentweapon
 if tgunid>0
  `
  rem start of shot pos
  if entityprofile(entid).firespotlimb>-1
   rem V118 - 210211 - end of gun for purpose of casting a shot ray does not work round CCW corners
   rem so use the centre of the character instead, only using the Y coordinate from the weapon limb
   `x1#=limb position x(obj,entityprofile(entid).firespotlimb)
   `y1#=limb position y(obj,entityprofile(entid).firespotlimb)
   `z1#=limb position z(obj,entityprofile(entid).firespotlimb)
   x1#=entityelement(e).x
   y1#=limb position y(obj,entityprofile(entid).firespotlimb)
   z1#=entityelement(e).z
  else
   x1#=entityelement(e).x
   y1#=entityelement(e).y+45.0
   z1#=entityelement(e).z
  endif
  `
  rem weapon type
  flakid=firemode(tgunid,0).settings.flakindex
  `if gun(tgunid).settings.alternateisflak = 1 then flakid = 0
  if flakid=0
   `
   rem BULLET
   rem initial shot creates light flash
   spotflash=100 : tx#=x1# : ty#=y1# : tz#=z1#
   tcolr=firemode(tgunid,0).settings.muzzlecolorr
   tcolg=firemode(tgunid,0).settings.muzzlecolorg
   tcolb=firemode(tgunid,0).settings.muzzlecolorb
   gosub _lighting_spotflash
   `
   rem discharge sound (single fire, or automatic loop sound)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   if tsndid>0
    if firemode(tgunid,0).action.automatic.s>0
     if entityelement(e).firesoundloop=0
      play sound tsndid,firemode(tgunid,0).sound.fireloopend : rem some sound bug
      loop sound tsndid,0,firemode(tgunid,0).sound.fireloopend
      entityelement(e).firesoundloop=tsndid
     endif
    else
     play sound tsndid
    endif
    posinternal3dsound(tsndid,x1#,y1#,z1#)
    broadcast3dsound(x1#,y1#,z1#,25.0,entityelement(e).obj)
   endif
   `
   rem gun data for accuracy
   Rem Hockeykid - 010410 - Swapped to a float to work better with Plystire's accuracy system
   `trayaccuracy=gun(tgunid).settings.accuracy
   Rem Scene Commander - force accuracy if set to 0
   if entityelement(e).entityacc=0 then entityelement(e).entityacc=1
   trayaccuracy#=firemode(tgunid,0).settings.accuracy*entityelement(e).entityacc
   Rem Hockeykid - 10410 - Added iteratations for AI
   trayiter=1+firemode(tgunid,0).settings.iterate
   `
   for iterate=1 to trayiter
    Rem Hockeykid - 010410 - Replaced old accuracy sytem with Plystire's
    rem project gun-line-for-shot (from raw-calc or target)
    if entityelement(e).actualtarget<>0
     tte=entityelement(e).actualtarget-1
     rem 140411 - extra check to ensure entity target exists
     tttokay=0
     if tte>0
      if tte<=array count(entityelement())
       tttokay=1
      endif
     endif
     rem scene commander fix, prevents occasional crash.
     if tttokay=1
      testobj=entityelement(tte).obj
      if testobj>0
        if object exist(testobj)
         y2#=object position y(testobj)
         x2#=object position x(testobj)
         z2#=object position z(testobj)
        endif
      endif
     else
      y2#=object position y(physicsplayerborble)
      x2#=object position x(physicsplayerborble)
      z2#=object position z(physicsplayerborble)
     endif
     tdx#=abs(x2#-x1#)
     tdy#=abs(y2#-y1#)
     tdz#=abs(z2#-z1#)
     tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
     range=tdd#+15
    else
     range=firemode(tgunid,0).settings.range
    endif
    position object hudbankoffset+3,x1#,y1#,z1#
    tca#=rnd(360000.0)/1000.0
    tcx#=cos(tca#) : tcy#=sin(tca#)
    tcm#=rnd(trayaccuracy#*1000.0)/1000.0 : tcx#=tcx#*tcm# : tcy#=tcy#*tcm#
    rem V118 - BETA11 - this only projects forward ray (does not account for offset height between shooter and target!)
    `rotate object hudbankoffset+3,tcy#,entityelement(e).mover.da+tcx#,0
    point object hudbankoffset+3,x2#,y2#,z2#
    rotate object hudbankoffset+3,object angle x(hudbankoffset+3)+tcy#,object angle y(hudbankoffset+3)+tcx#,object angle z(hudbankoffset+3)
    move object hudbankoffset+3,range`gun(tgunid).settings.range
    disable object zdepth hudbankoffset+3
    x2#=object position x(hudbankoffset+3)`+trayaccuracy-rnd(trayaccuracy*2)
    y2#=object position y(hudbankoffset+3)`+trayaccuracy-rnd(trayaccuracy*2)
    z2#=object position z(hudbankoffset+3)`+trayaccuracy-rnd(trayaccuracy*2)
    `
    rem had bulletray hit anything solid
    tbullethit=0 : tbullethitstatic=0
    tbullethitmaterial=0 : tbullethitflesh=0
    entityelement(e).raycastcount=0
    dst#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
    if dst#<>0
     x#=checklist fvalue a(6) : x2#=x#
     y#=checklist fvalue b(6) : y2#=y#
     z#=checklist fvalue c(6) : z2#=z#
     tbullethitstatic=1 : tbullethit=1
     tcolmaterial=get static collision value()-1
     `if tcolmaterial>=0 and tcolmaterial<=8 then tbullethitmaterial=tcolmaterial : rem FPSCV101 - fix
     if tcolmaterial>=0 and tcolmaterial<=99 then tbullethitmaterial=tcolmaterial
    endif
    `
    rem if it hits player before wall, hurt player
    if entityelement(e).actualtarget=1
     dst#=intersect object(hudbankoffset+2,x1#,y1#,z1#,x2#,y2#,z2#)
     if dst#<>0 or tdd#<125.0
      tbullethitstatic=0
     endif
    endif
    `
    if tbullethitstatic>0
     tsoundtrigger=0 : tsoundmaterial=0
     if tbullethitmaterial>=0
      tmatindex=tbullethitmaterial
      if tmatindex>=0 and tmatindex<=gmaterialmax
       tsoundmaterial=1+tmatindex
       tsoundtrigger=material(tmatindex).impactid
       tsx#=x# : tsy#=y# : tsz#=z#
       tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
       rem if material sound triggered
       gosub _ode_triggermaterialsound
       gosub _decal_triggermaterialdebris
      endif
     endif
    endif
    `
    rem where wall not hit, must be a hit
    if tbullethitstatic=0
     trange#=firemode(tgunid,0).settings.range
     tperc#=(trange#-dst#)/trange#
     if dst#<200 then tperc#=1.0
     bulletdamage#=firemode(tgunid,0).settings.damage : dec bulletdamage#,rnd(bulletdamage#/5)
     if firemode(tgunid,0).settings.damage>5
      rem enemy fire always one half the players effectiveness after first few points
      tperc#=tperc#*0.5
     endif
     rem scene commander entity damage muliplier
     if entityelement(e).entitydammult#=0 then entityelement(e).entitydammult#=1.0
     tdamage#=bulletdamage#*tperc#*entityelement(e).entitydammult#: tdamage=tdamage#
     if entityelement(e).actualtarget=1
      rem player was the target
      if tdamage>0 then gosub _player_takedamage
      if player(1).health<=0 and playerstartstrength>0
       rem Scene Commander, reset culled items on death to prevent 'transparent` entities on restart
       for change=1 to entityelementlist
        tobj=entityelement(change).obj
        if entityelement(change).ishidden<2
         if tobj>0
          if object exist(tobj)=1
           set alpha mapping on tobj,100
           show object tobj
          endif
         endif
        endif
       next change
       rem hear the full sound of what killed you
       if tsndid>0
        rem Scene commander tilt on death
        if tiltondeath=0
         tiltondeath=360:justdone=0
         if gunid>0 then gunmode=31
        endif
        playinternal3dsound(tsndid,camera position x(),camera position y(),camera position z())
       endif
      endif
     else
      rem entity was the target (store E while leap to other entity for damage control)
      if entityelement(e).actualtarget>1 and tdamage>0
       tdamagesource=0 : timpacttype=1
       tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
       stte=e : e=entityelement(e).actualtarget-1 : tte=entityelement(e).actualtarget-1
       entityelement(e).darkai.ambushed=1
       entityelement(e).darkai.ambushx#=tdamagex#
       entityelement(e).darkai.ambushz#=tdamagez#
       entityelement(e).darkai.ehit=e
       Rem Hockeykid - 020410 - Create blood splat if hit
       Rem Hockeykid - 020410 - Ensure that the target is alive
       if entityelement(e).beenkilled=0
        decalid=entitydecal(entityelement(e).bankindex,1)
        if decalid>0
         distx#=tdamagex#-entityelement(e).x
         disty#=tdamagey#-entityelement(e).y
         distz#=tdamagez#-entityelement(e).z
         dmgdist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
         rem direction from player to entity
         tix#=entityelement(e).x-tdamagex# : tiy#=entityelement(e).y-tdamagey# : tiz#=entityelement(e).z-tdamagez#
         tdd#=sqrt(abs(tix#*tix#)+abs(tiy#*tiy#)+abs(tiz#*tiz#))
         tix#=tix#/tdd# : tiy#=tiy#/tdd# : tiz#=tiz#/tdd#
         rem find point of impact
         tix#=tix#*(dmgdist#-10.0)
         rem Scene Commander blood fix
         tiy#=rnd(12)
         tiz#=tiz#*(dmgdist#-10.0)
         rem create a splat decal
         decalscalemodx=0 : rem FPSCV101 - fix
         decalorient=0 : decalx=tdamagex#+tix# : decaly=((entityelement(e).y+(object size y(entityelement(e).obj)/2))-rnd(6))+tiy# : decalz=tdamagez#+tiz#
         originatore=-1 : gosub _decalelement_create
        endif
        rem blood splat
        tscorchtype3=8+rnd(3)
        tscorchsize3#=10.0+((abs(dst#-dist#)/100.0)*(20.0+rnd(20)))
        if gbloodonfloor=1
        rem FPSC - X9 - V109 - 310308 - if flagged, blood is redirected to floor
         tempx#=entityelement(e).x
         tempy#=entityelement(e).y
         tempz#=entityelement(e).z
         tempraytofloor#=static raycast(tempx#,tempy#+25,tempz#,tempx#,tempy#-125,tempz#)
        endif
        add static scorch tscorchsize3#,tscorchtype3
       endif
       gosub _entity_deducthealth : e=stte
       tentid=entityelement(e).bankindex
       entid=entityelement(e).bankindex
      endif
     endif
     tbullethitstatic=0 : tbullethit=1
     tbullethitflesh=1
    endif
    `
    rem bullet result
    if tbullethit=1
     rem debris where the bullet struck
     remstart FPGC - 080701 - never a good idea, removed perminantly
     for p=1 to 32
      if debris(p)=0
       rem debris where the bullet struck
       position particles p,x#,0,z#
       position particle emissions p,0,y#/20.0,0
       set particle emissions p,10
       debris(p)=40
       exit
      endif
     next p
     remend
     rem add scorch if hit universe static polygons
     if tbullethitstatic=1
      tscorchtype=firemode(tgunid,0).settings.scorchtype
      gosub _entity_doscorch
     endif
    endif
   next iterate
   `
  else
   `
   rem FLAK (grenames, rockets)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   playinternal3dsound(tsndid,x1#,y1#,z1#)
   broadcast3dsound(x1#,y1#,z1#,15.0,entityelement(e).obj)
   `
   rem determine if need to pitch the launch based on direction and distance
   flakpitch=0
   if flak(flakid).throwangle=0
    rem LAUNCH
    if entityelement(e).actualtarget>1
     tte=entityelement(e).actualtarget-1
     tdx#=object position x(entityelement(tte).obj)-x1#`entityelement(e).x
     tdz#=object position z(entityelement(tte).obj)-z1#`entityelement(e).z
     tdy#=object position y(entityelement(tte).obj)-y1#`entityelement(e).y
    else
     tdx#=mex#-x1#`entityelement(e).x
     tdz#=mez#-z1#`entityelement(e).z
     tdy#=(mey#-phyeyeheight#)-y1#`entityelement(e).y
    endif
    flakpitch=atanfull(tdy#,sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)))*-1
   else
    rem LOB
    if entityelement(e).actualtarget<>0
     tte=entityelement(e).actualtarget-1
     if tte=0 then y2#=mey# else y2#=object position y(entityelement(tte).obj)
     if y2#>entityelement(e).y-100.0
      if tte=0 then x2#=mex# else x2#=object position x(entityelement(tte).obj)
      if tte=0 then z2#=mez# else z2#=object position z(entityelement(tte).obj)
      tdx#=abs(x2#-x1#)
      tdy#=abs(y2#-y1#)
      tdz#=abs(z2#-z1#)
      tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
      flakpitch=22.0+((45.0/500.0)*tdd#)
      if flakpitch>80 then flakpitch=80
      if flakpitch<22.0 then flakpitch=22.0
      rem FPSCV105RC2 - so can throw closer to plr (through door)
      firestr#=entityelement(e).firestrength/100.0
      flakpitch=flakpitch*firestr#*-1.0
     endif
    endif
   endif
   `
   rem launch the flak
   flakangle=entityelement(e).mover.da : flakowner=e
   flakx=x1#+newxvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flaky=y1#+flak(flakid).throwheight
   flakz=z1#+newzvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flakspeed#=2.0
   gosub _flakelement_create
   `
  endif
  rem a pause while guns cools down (fingers of shooter release trigger and repress)
  entityelement(e).fireweapon=2
 else
  rem no wepon so deflag fire
  entityelement(e).fireweapon=0
 endif
else
 if entityelement(e).fireweapon>0
  tgunid=entityelement(e).currentweapon
  Rem to slow
  `entityelement(e).fireweapon=entityelement(e).fireweapon+timeelapsed#
 ` entityelement(e).fireweapon=entityelement(e).fireweapon+1
  if firemode(tgunid,0).action.automatic.s>0
   if entityelement(e).currentammo<=0 and entityelement(e).firesoundloop>0
    stop sound entityelement(e).firesoundloop
    entityelement(e).firesoundloop=0
   endif
   if timer()-entityelement(e).fireweapontimer>100
    entityelement(e).fireweapon=0
    entityelement(e).fireweapontimer=0
   endif
  else
   Rem FPS is no longer 30!
   `if entityelement(e).fireweapon>30 then entityelement(e).fireweapon=0
   `if entityelement(e).fireweapon>screen fps() then entityelement(e).fireweapon=0
   Rem Why not just use a timer
   if timer()-entityelement(e).fireweapontimer>=500 then entityelement(e).fireweapon=0 : entityelement(e).fireweapontimer=0
  endif
 else
  if entityelement(e).firesoundloop>0
   stop sound entityelement(e).firesoundloop
   entityelement(e).firesoundloop=0
  endif
 endif
endif
`
rem Switch to FPI AI Scripts
if trundefaultscript>0
 `
 rem About to leave main?
 tleavingmain=0
 if entityelement(e).ai.libindex=entityelement(e).ai.libmain then tleavingmain=1
 `
 rem Switch to specified AI scripts
 entityelement(e).ai.libindex=trundefaultscript-1
 trundefaultscript=0
 `
 rem If returning from internal AI switch
 if entityelement(e).ai.usinginternalai=1
  rem restore old state values
  entityelement(e).ai.waypoint.state=entityelement(e).ai.oldwaypointstate
  entityelement(e).ai.alphafade=entityelement(e).ai.oldalphafade
  entityelement(e).ai.state$=entityelement(e).ai.oldstate$ rem GUI-X9 (String States)
  entityelement(e).ai.usinginternalai=0
  `
  rem V109 - 210308 - prevents death anim from throw going back to middle of main anim which might be 2600-2650! goes through all anims
  if entityelement(e).health>0
   rem but only restore if entity not dead and going to get back up, etc
   entityelement(e).animframe=entityelement(e).ai.oldanimframe
   entityelement(e).destanimframe=entityelement(e).ai.olddestanimframe
  endif
  `
 else
  if trundefaultscriptinternal=1 and tleavingmain=1
   gosub _entity_storemainai
  endif
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.state$="0" rem GUI-X9 (String States)
 endif
 `
 rem Always reset these after AI script switch
 entityelement(e).ai.headdestangle=0
 entityelement(e).ai.headangle=0
 `
endif

return

_entity_doscorch:
 rem material damage
 rem AirMod - Line Modified for no scorch mode
 if tbullethitmaterial>0
  if firemode(gunid,firemode).settings.noscorch = 0 and gun(gunid).settings.ismelee<>2 or firemode(gunid,firemode).settings.meleenoscorch=0 and gun(gunid).settings.ismelee=2
   tscorchsize2#=4.0+(rnd(10)/10.0) : tscorchtype2=11+tbullethitmaterial
   if tscorchtype2>15 then tscorchtype2=12 : rem FPSCV101 - fix
   add static scorch tscorchsize2#,tscorchtype2
  endif
 endif
 if tbullethitflesh>0
  rem blood splat
  tscorchtype3=8+rnd(3)
  tscorchsize3#=10.0+((tbullethitflesh/100.0)*(20.0+rnd(20)))
  if gbloodonfloor=1
   rem FPSC - X9 - V109 - 310308 - if flagged, blood is redirected to floor
   if bulletrayhit>0
    tempx#=entityelement(bulletrayhit).x
    tempy#=entityelement(bulletrayhit).y
    tempz#=entityelement(bulletrayhit).z
    tempraytofloor#=static raycast(tempx#,tempy#+25,tempz#,tempx#,tempy#-125,tempz#)
   endif
  endif
  add static scorch tscorchsize3#,tscorchtype3
 else
  rem AirMod - Line added for no scorch weapon
  if firemode(gunid,firemode).settings.noscorch = 0 and gun(gunid).settings.ismelee<>2 or firemode(gunid,firemode).settings.meleenoscorch=0 and gun(gunid).settings.ismelee=2
   rem bullethole
   tscorchsize#=2.0+(rnd(10)/10.0)
   if tscorchtype>=2 then tscorchsize#=3.0+(rnd(10)/10.0)
   add static scorch tscorchsize#,tscorchtype
  endif
 endif
return

rem AirMod - Added for Blood >>>
_entity_doblood:
 if (array count(entityblood())/BLOODMAX)-1 < e or entityprofile(entid).bloodscorch=0
  return
 endif
 entid=entityelement(e).bankindex
 obj = entityelement(e).obj
 Rem Hockeykid - 080710 - avoid bug of entity spurting out muzzle flash decal instead of blood
 decal$="blood"
 Gosub _decal_find
 blood=decalid
 ax# = wrapvalue(-rnd(90))
 ay# = rnd(360)
 for n = 1 to 2
  for k = 1 to BLOODMAX-1
   if entityblood(e,k).active = 0
    entityblood(e,k).active = 1
    entityblood(e,k).mode = 0
    select tbloodspurtmode
    case 1:
     if entityprofile(entid).headlimb<>-1
      entityblood(e,k).x# = limb position x(obj,entityprofile(entid).headlimb)+entityelement(e).lastdamagex#
      entityblood(e,k).y# = limb position y(obj,entityprofile(entid).headlimb)+entityelement(e).lastdamagey#
      entityblood(e,k).z# = limb position z(obj,entityprofile(entid).headlimb)+entityelement(e).lastdamagez#
     else
      entityblood(e,k).x# = entityelement(e).x+entityelement(e).lastdamagex#
      entityblood(e,k).y# = entityelement(e).y+entityelement(e).lastdamagey#
      entityblood(e,k).z# = entityelement(e).z+entityelement(e).lastdamagez#
     endif
    endcase
    case 2:
     if entityprofile(entid).headlimb<>-1
      entityblood(e,k).x# = limb position x(obj,entityprofile(entid).headlimb)
      entityblood(e,k).y# = limb position y(obj,entityprofile(entid).headlimb)
      entityblood(e,k).z# = limb position z(obj,entityprofile(entid).headlimb)
     else
      entityblood(e,k).x# = entityelement(e).x
      entityblood(e,k).y# = entityelement(e).y
      entityblood(e,k).z# = entityelement(e).z
     endif
    endcase
    case 3:
     entityblood(e,k).x# = entityelement(e).x
     entityblood(e,k).y# = entityelement(e).y
     entityblood(e,k).z# = entityelement(e).z
     `ax# = 90
     entityblood(e,k).mode = 1
    endcase
    case default:
     entityblood(e,k).x# = entityelement(e).x
     entityblood(e,k).y# = entityelement(e).y
     entityblood(e,k).z# = entityelement(e).z
    endcase
    endselect
    entityblood(e,k).oldx# = entityblood(e,k).x#
    entityblood(e,k).oldy# = entityblood(e,k).y#
    entityblood(e,k).oldz# = entityblood(e,k).z#
    entityblood(e,k).anglex# = wrapvalue(ax# + rnd((n*5)))
    entityblood(e,k).angley# = wrapvalue(ay# + rnd((n*2)))
    entityblood(e,k).spawndelay = n*3
    entityblood(e,k).delay = 2
    if n = 1
     decalid=blood`entitydecal(entid,1)
     decalscalemodx=0 : rem FPSCV101 - fix
     decalorient=0 : decalx=entityblood(e,k).x# : decaly=entityblood(e,k).y# : decalz=entityblood(e,k).z#
     originatore=-1 : gosub _decalelement_create
    endif
    k = BLOODMAX
   endif
 next k
next n

return

_entity_controlblood:
 if (array count(entityblood())/BLOODMAX)-1 < e or entityprofile(entid).bloodscorch=0
  return
 endif
 Rem Hockeykid - 080710 - avoid bug of entity spurting out muzzle flash decal instead of blood
 decal$="blood"
 Gosub _decal_find
 blood=decalid
 `text 0,14,"BLOOD UPDATE!"
 for k = 1 to BLOODMAX-1
  if entityblood(e,k).active = 1
   if entityblood(e,k).spawndelay > 0 then dec entityblood(e,k).spawndelay,1
   if entityblood(e,k).spawndelay < 1
    `text 0,28+(14*k),"BLOOD SPAWNED: "+str$(k)
    dec entityblood(e,k).delay,1
    if entityblood(e,k).mode = 0
     entityblood(e,k).x# = newxvalue(entityblood(e,k).x#,entityblood(e,k).angley#,3)
     entityblood(e,k).z# = newzvalue(entityblood(e,k).z#,entityblood(e,k).angley#,3)
     entityblood(e,k).y# = newyvalue(entityblood(e,k).y#,entityblood(e,k).anglex#,6)
     entityblood(e,k).anglex# = curveangle(90,entityblood(e,k).anglex#,10-rnd(5))
    else
     entityblood(e,k).y# = entityblood(e,k).y#-6
    endif
    if entityblood(e,k).delay < 1 or entityblood(e,k).delay/2 = int(entityblood(e,k).delay/2)
     ecalid=blood`entitydecal(entid,1)
     decalscalemodx=0 : rem FPSCV101 - fix
     tdecalairmodsize = 1 : tdecalairmodsizex# = 0.5 : tdecalairmodsizey# = 0.8
     decalorient=0 : decalx=entityblood(e,k).x# : decaly=entityblood(e,k).y# : decalz=entityblood(e,k).z#
     originatore=-1 : gosub _decalelement_create
    endif
    if entityblood(e,k).delay < 1
     entityblood(e,k).delay = 10
     bdstwallhit#=static raycast(entityblood(e,k).oldx#,entityblood(e,k).oldy#,entityblood(e,k).oldz#,entityblood(e,k).x#,entityblood(e,k).y#,entityblood(e,k).z#)
     if bdstwallhit#>0
      bwallhitx#=checklist fvalue a(6)
      bwallhity#=checklist fvalue b(6)
      bwallhitz#=checklist fvalue c(6)
      `   wallhitmaterial=get static collision value()-1
      tscorchtype3=8+rnd(3)
      tscorchsize3#=10.0 + rnd(20)`+((tbullethitflesh/100.0)*(20.0+rnd(20)))
      if entityprofile(entid).bloodscorch > 0
       add static scorch tscorchsize3#,tscorchtype3
      endif
      entityblood(e,k).active = 0
      decalid=blood`entitydecal(entid,1)
      decalscalemodx=0 : rem FPSCV101 - fix
      tdecalairmodsize = 1 : tdecalairmodsizex# = 2.5 : tdecalairmodsizey# = 2.5
      decalorient=0 : decalx=bwallhitx# : decaly=bwallhity# : decalz=bwallhitz#
      originatore=-1 : gosub _decalelement_create
     endif
     entityblood(e,k).oldx# = entityblood(e,k).x#
     entityblood(e,k).oldy# = entityblood(e,k).y#
     entityblood(e,k).oldz# = entityblood(e,k).z#
     if entityblood(e,k).y# < -1000 then entityblood(e,k).active = 0
    endif
   endif
  endif
 next k
return
rem AirMod - Done <<<

_entity_controlspawn:

rem Only leaders control spawn events (activated is automatic for spawn switch on)
if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=0 and entityelement(e).activated=1 then entityelement(e).spawn.atstart=1

if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=1

 rem Count down to next spawn
 if entityelement(e).spawn.afterdelay=1
  entityelement(e).spawn.leadercount=entityelement(e).spawn.leadercount-(1*timeelapsed#)
 endif
 rem If count goes to zero (and have some left 'upto')
 tpermitaspawn=0
 if entityelement(e).spawn.upto>0
  if entityelement(e).spawn.leadercount<=0 then tpermitaspawn=1
  if entityelement(e).spawn.whendead=1
   for te=1+e to e+entityelement(e).spawn.max
    tobj=entityelement(te).obj
    if tobj>0
     if object exist(tobj)=1 and entityelement(te).active=0
      if entityelement(te).beenkilled=1
       entityelement(te).beenkilled=0
       entityelement(te).ishidden=0
       tpermitaspawn=1 : exit
      endif
     endif
    endif
   next te
  endif
 endif
 if tpermitaspawn=1
  rem Restart spawn cycle
  `entid=entityelement(e).bankindex
  entityelement(e).spawn.leadercount=entityelement(e).spawn.delay+rnd(entityelement(e).spawn.delayrandom)
  rem Hockeykid - 080611 - Won't work, throw-ragdoll scripts do not allow for the character to get back up!
  `if entityelement(e).ragdollon=1 then ode destroy ragdoll entityelement(e).obj : entityelement(e).ragdollon=0
  rem Find child of this leader to spawn
  tproduceqty=0
  tnumbertospawn=entityelement(e).spawn.qty+rnd(entityelement(e).spawn.qtyrandom)
  for te=e+1 to e+entityelement(e).spawn.max
   tobj=entityelement(te).obj
   if tobj>0
    if object exist(tobj)=1 and entityelement(te).active=0
     `
     rem find place not occupied if entity driven object
     rem V111 - 140608 - and only if NOT only one in spawn chain (first and only object is ALWAYS placed where you put it)
     `if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
     if entityelement(e).spawn.max>1 and (entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2)
      tokay=0
      ttriesrange=0
      while tokay=0
       for ttriesx=ttriesrange*-1 to ttriesrange
        for ttriesz=ttriesrange*-1 to ttriesrange
         tryx#=entityelement(e).spawn.x+(ttriesx*25)
         tryz#=entityelement(e).spawn.z+(ttriesz*25)
         ty=entityelement(te).y/100
         tx=tryx#/25 : tz=tryz#/-25
         if tx>=0 and ty>=0 and tz>=0
          if tx<=viscolx and ty<=viscoly and tz<=viscolz
           if viscolmap(tx,ty,tz)=0
            entityelement(te).y=entityelement(e).spawn.y
            entityelement(te).x=tryx#
            entityelement(te).z=tryz#
            tokay=1 : exit
           endif
          endif
         endif
        next ttriesz
       next ttriesx
       inc ttriesrange
       if ttriesrange>8 then tokay=2
      endwhile
     else
      entityelement(te).x=entityelement(e).spawn.x
      entityelement(te).y=entityelement(e).spawn.y
      entityelement(te).z=entityelement(e).spawn.z
      tokay=1
     endif
     `
     rem if space, init entity with AIINIT
     if tokay=1
      `
      entityelement(te).active=1
      entityelement(te).dormant=1
      entityelement(te).ai.libindex=entityelement(te).ai.libinit
      entityelement(te).ai.waypoint.state=0
      entityelement(te).ai.waypoint.tracker=0
      entityelement(te).ai.waypoint.current=0
      entityelement(te).ai.state$="0" rem GUI-X9 (String States)
      entityelement(te).ai.headangle=0
      entityelement(te).ai.headdestangle=0
      entityelement(te).ai.usinginternalai=0
      entityelement(te).ai.oldstate$="0" rem GUI-X9 (String States)
      entityelement(te).ai.alphafade=0
      entityelement(te).ai.oldalphafade=0
      entityelement(te).ai.destalphafade=100
      entityelement(te).ai.oldwaypointstate=0
      entityelement(te).ai.headshot=0
      entityelement(te).actualtarget=0
      entityelement(te).losttargetcount=0
      `
      entityelement(te).rx=entityelement(e).rx
      entityelement(te).ry=entityelement(e).ry
      entityelement(te).rz=entityelement(e).rz
      entityelement(te).mover.da=entityelement(e).ry
      `
      entitybreadcrumbs(te,0).x=0
      entityelement(te).mover.grav=1.0
      entityelement(te).mover.moved=0
      entityelement(te).mover.inmotion=0
      entityelement(te).mover.ix=0
      entityelement(te).force.ix=0
      entityelement(te).mover.iy=0
      entityelement(te).force.iy=0
      entityelement(te).mover.iz=0
      entityelement(te).force.iz=0
      entityelement(te).force.active=0
      entityelement(te).logiccount=0
      entityelement(te).blockedby=0
      `
      rem rest ragdoll
      rem Hockeykid - 080611 - Won't work, throw-ragdoll scripts do not allow for the character to get back up!
      `if entityelement(te).ragdollon=1 then ode destroy ragdoll entityelement(te).obj : entityelement(te).ragdollon=0
      `
      rem reset entity that reappears in game
      if entityelement(te).eleprof.strength>0
       entityelement(te).health=entityelement(e).eleprof.strength
      else
       entityelement(te).health=1
      endif
      entityelement(te).eleprof.lives=entityelement(e).eleprof.lives
      entityelement(te).shotdamage=0
      entityelement(te).shotdamagesource=0
      entityelement(te).shotdamagetype=0
      `
      rem clear out dake player info
      tplrid=entityelement(e).fakeplayerid
      player(tplrid).inventorymax=0
      `
      rem put weapon back in character hands
      entityelement(te).currentweapon=entityelement(e).eleprof.hasweapon
      entityelement(te).currentclipammo=9999
      entityelement(te).firesoundloop=0
      entityelement(te).currentammo=0
      entityelement(te).fireweapon=0
      `
      rem give entity infinite or finite life
      if entityelement(e).spawn.life>0
       entityelement(te).spawn.life=timer()+(entityelement(e).spawn.life*1000)
      else
       entityelement(te).spawn.life=0
      endif
      `
      tdropobj=entityelement(te).attachmentobj
      if tdropobj>0 then storetobj=tobj : tobj=tdropobj : gosub _ode_deleteentity :  tobj=storetobj
      `
      rem object setting
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       ste=e : e=te : gosub _ode_switchoffe : e=ste
      endif
      position object tobj,entityelement(te).x,entityelement(te).y,entityelement(te).z
      rem V109 BETA10 - 120508 - fix disppearing spawned characters using full effects
      Rem Scene Commander fix, now start at full alpha for respawns.
      entityelement(te).ai.alphafade=96
      entityelement(te).ai.destalphafade=100
      entityelement(te).ai.oldalphafade=0
      entityelement(te).ai.alphafadeupdate=1
      set alpha mapping on tobj,entityelement(te).ai.alphafade
      rem V106 RC3 set rotation of spawned to rotation values too
`      rotate object tobj,0,0,0
      rotate object tobj,entityelement(te).rx,entityelement(te).ry,entityelement(te).rz
      show object tobj
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       rem lee - 300113 - small nudge up so does not get stuck in floor (subtle contact but causes radical response)
       if entityprofile(entid).ischaracter=0
        rem lee - 310113 - but not character spawners
        tttprofileobj=entityelement(te).profileobj
        tttadj#=object collision center y(tttprofileobj)
        tttentid=entityelement(te).bankindex
        if entityprofile(tttentid).scale<>0
         tttapplyscalefactor#=(entityprofile(tttentid).scale/100.0)
         tttadj#=tttadj#*tttapplyscalefactor#
        endif
        entityelement(te).y=entityelement(te).y+tttadj#
        position object tobj,entityelement(te).x,entityelement(te).y,entityelement(te).z
       endif
       rem continue to create and propel physics object
       ste=e : e=te : gosub _ode_setupewithphysics
       tvel=entityelement(e).spawn.vel+rnd(entityelement(e).spawn.velrandom)
       tangle=entityelement(e).spawn.angle+rnd(entityelement(e).spawn.anglerandom)
       gosub _ode_pushusingtvelandangle
       e=ste
      endif
      `
      rem reset visuals
      entid=entityelement(te).bankindex
      tobj=entityelement(te).obj
      if total object frames(tobj)>0
       set object frame tobj,0
       if entityprofile(entid).ischaracter=1
        if entityprofile(entid).animmax>=1
         teai=0 : if entityanim(entid,1).start>0 then teai=1
         tbaseframe=teai : gosub _entity_getactualframestart : tfstart=tactualframe
         tbaseframe=teai : gosub _entity_getactualframefinish : tffinish=tactualframe
         loop object tobj,tfstart,tffinish
        else
         loop object tobj : stop object tobj
        endif
       endif
      endif
      `
      rem set spawned entity collision
      if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
       entityelement(te).collisionactive=0
       set object collision off tobj
      else
       entityelement(te).collisionactive=1
       set object collision on tobj
      endif
      `
      rem write entity to viscolmap if space available, else find new place
      if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
       tx=entityelement(te).x/25
       ty=entityelement(te).y/100
       tz=entityelement(te).z/-25
       if tx>=0 and ty>=0 and tz>=0
        if tx<=viscolx and ty<=viscoly and tz<=viscolz
         viscolmap(tx,ty,tz)=te
        endif
       endif
      endif
      `      `
      rem reduce overall UPTO count
      entityelement(e).spawn.upto=entityelement(e).spawn.upto-1
      if entityelement(e).spawn.upto<=0
       entityelement(e).spawn.upto=0
       exit
      endif
      `
      rem go to end if no more to produce
      inc tproduceqty
      if tproduceqty>=tnumbertospawn
       te=e+entityelement(e).spawn.max
       exit
      endif
      `
     endif
     `
    endif
   endif
  next te
 endif
endif

return

_entity_controlwaypoints:

rem waypoint behaviour substatesystem
if entityelement(e).ai.waypoint.state>0
 w=entityelement(e).ai.waypoint.current
 if entityelement(e).ai.waypoint.state=1
  `
  rem before set-off make sure can see destination
  tokay=0
  telex#=entityelement(e).x
  teley#=entityelement(e).y+35.0
  telez#=entityelement(e).z
  tdistx#=telex#-waypointcoord(w).x
  tdisty#=teley#-waypointcoord(w).y+35.0
  tdistz#=telez#-waypointcoord(w).z
  tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
  if tdist#<1000.0
   tmpx#=waypointcoord(w).x
   tmpy#=waypointcoord(w).y+35.0
   tmpz#=waypointcoord(w).z
   entityelement(e).raycastcount=0
   if static raycast(telex#,teley#,telez#,tmpx#,tmpy#,tmpz#)=0
    tokay=1
   endif
  endif
  `
  rem setup walk to get to next waypoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  `entityelement(e).mover.run=0 : rem FPGC - 110111 - must not interfere with RUN state (RUNFORE=2)
  entityelement(e).ai.waypoint.state=2
  `
  rem characters animate when waypoint is followed, if alive
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1 and entityelement(e).health>0 and ai entity exist(entityelement(e).obj)=0
   if entityelement(e).animdo<>entityelement(e).animset-1
    entityelement(e).animset=3
   endif
  endif
  `
 endif
 if entityelement(e).ai.waypoint.state=2
  rem walking along wayppoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  `entityelement(e).mover.run=0 : rem FPGC - 110111 - must not interfere with RUN state (RUNFORE=2)
  tdx#=entityelement(e).mover.dx-entityelement(e).x
  tdz#=entityelement(e).mover.dz-entityelement(e).z
  entityelement(e).mover.da=atanfull(tdx#,tdz#)
  if ai entity exist(entityelement(e).obj)=1
   rem FPGC - 110111 - ensure any DAI calls are protected with existence check!
   ai set entity angle y entityelement(e).obj,entityelement(e).mover.da
   ai entity look at position entityelement(e).obj,tdx#,tdz#
  endif
  distx#=waypointcoord(w).x-entityelement(e).x
  distz#=waypointcoord(w).z-entityelement(e).z
  wpdist#=sqrt(abs(distx#*distx#)+abs(distz#*distz#))
  if wpdist#<7.0*(entityelement(e).eleprof.speed/100.0)
   rem decision on direction
   if entityelement(e).ai.waypoint.direction=1
    rem forward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w>=waypoint(entityelement(e).ai.waypoint.tracker).finish
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   else
    rem backward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w<=waypoint(entityelement(e).ai.waypoint.tracker).start
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   endif
   `
   rem ensure action taken immediately
   entityelement(e).logiccount=0
   `
   rem FPGC - 100610 - characters animate when waypoint is followed, if alive (copied from state one to solve sliding character bug afgter opening door)
   entid=entityelement(e).bankindex
   if entityprofile(entid).ischaracter=1 and ai entity exist(entityelement(e).obj)=0
    if entityelement(e).animdo<>entityelement(e).animset-1
     entityelement(e).animset=3
    endif
   endif
   `
  endif
 endif
 if entityelement(e).ai.waypoint.state=999
  rem internal state - wait for force to end in main AI
  if entityelement(e).ai.libindex=entityelement(e).ai.libmain
   if entityelement(e).force.active=0 and entityelement(e).ai.waypoint.tracker>0
    rem resume waypoint logic (only if alive and have waypoints)
    if entityelement(e).health>0
     entityelement(e).ai.waypoint.state=1
     entityelement(e).logiccount=0
    endif
   endif
  endif
 endif
endif

return

_entity_controlforce:

rem control force events via inertia values
if entityelement(e).force.active=1
 rem no force if entity immobile
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).force.active=0
 else
  rem degrade inertia values
  forceineffect=0
  if entityelement(e).force.ix<>0.0 then forceineffect=1 : entityelement(e).force.ix=entityelement(e).force.ix/1.1
  if entityelement(e).force.iz<>0.0 then forceineffect=1 : entityelement(e).force.iz=entityelement(e).force.iz/1.1
  rem apply gravity constant only when above ground
  entityelement(e).force.iy=entityelement(e).force.iy-1.0
  rem update entity position with inertia values if in effect
  if forceineffect=1
   rem restrict by active raycast collision
   tmpx1#=entityelement(e).x
   tmpz1#=entityelement(e).z
   tmpheight#=entityelement(e).y+40
   tnorm#=abs(entityelement(e).force.ix)+abs(entityelement(e).force.iz)
   tmpx2#=tmpx1#+entityelement(e).force.ix+((entityelement(e).force.ix/tnorm#)*20.0)
   tmpz2#=tmpz1#+entityelement(e).force.iz+((entityelement(e).force.iz/tnorm#)*20.0)
   entityelement(e).raycastcount=0
   if static raycast(tmpx1#,tmpheight#,tmpz1#,tmpx2#,tmpheight#,tmpz2#)=0
    rem move the element if no collision or collision too far away
    entityelement(e).mover.stepcount=1
    entityelement(e).mover.ix=entityelement(e).force.ix
    entityelement(e).mover.iy=entityelement(e).force.iy
    entityelement(e).mover.iz=entityelement(e).force.iz
    entityelement(e).ai.waypoint.state=999
    entityelement(e).mover.inmotion=1
   endif
   rem so small we can make them zero
   if entityprofile(entid).ischaracter=1
    rem characters regain themselves quicker
    `if abs(entityelement(e).force.ix)<2 then entityelement(e).force.ix=0.0
    `if abs(entityelement(e).force.iz)<2 then entityelement(e).force.iz=0.0
    rem FPGC - 230210 - makes no sense for characters to slide back, so keep them put
    entityelement(e).force.ix=0.0 : entityelement(e).force.iz=0.0
   else
    rem inanimate objects slide to a stop
    if abs(entityelement(e).force.ix)<0.1 then entityelement(e).force.ix=0.0
    if abs(entityelement(e).force.iz)<0.1 then entityelement(e).force.iz=0.0
   endif
  else
   entityelement(e).force.active=0
  endif
 endif
endif

return

_entity_controlanim:

rem entity with an object
if obj>0
 `
 rem animation and slerp handling
 if entityelement(e).animset>0
  entityelement(e).animdo=entityelement(e).animset-1
  entityelement(e).animtime=12
  entityelement(e).animset=0
  rem FPGC - 100710 - to defeat anim staggering (jittering between two constantly called animation calls)
  rem we only start to interpolate at ANIMTIME=3 then 2 and then 1 so the first ANIMTIME=4 does not affect visual
  rem see animtime code below
 endif
 if entityelement(e).animdo>=0
  rem handle transition into loop anim
  if entityelement(e).animtime=11
   rem FPGC - 100710 - defeats anim stagger
   if object playing(obj)=1 then stop object obj
   set object interpolation obj,10
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart
   set object frame obj,tactualframe
  else
   if entityelement(e).animtime=1
    set object interpolation obj,100
    tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart : tfstart=tactualframe
    tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
    rem hack as we know the anims (die anims) (multiplayer)
    if gmultiplayergame=1
     if entityelement(e).animdo=11 then entityelement(e).animonce=1
     if entityelement(e).animdo=14 then entityelement(e).animonce=1
     if entityelement(e).animdo=17 then entityelement(e).animonce=1
     if entityelement(e).animdo=20 then entityelement(e).animonce=1
    endif
    if entityelement(e).animonce=1
     loop object obj,tffinish-0.001,tffinish
     set object frame obj,tfstart
     entityelement(e).animonce=0
     set object speed obj,100*entityelement(e).animatespeed rem animatespeed multiplier (markblosser)
    else
     loop object obj,tfstart,tffinish
     if entityelement(e).animdir=1
      set object speed obj,-110*timeelapsed#*entityelement(e).animatespeed rem animatespeed multiplier (markblosser)
     else
      set object speed obj,110*timeelapsed#*entityelement(e).animatespeed rem animatespeed multiplier (markblosser)
     endif
    endif
   endif
  endif
  if entityelement(e).animtime>0 then entityelement(e).animtime=entityelement(e).animtime-1
  `
  rem monitor any animation (periodically)
  if timeelapsedrefreshentityanimspeeds=0
   if entityelement(e).animdir=1
    set object speed obj,-110*timeelapsed#*entityelement(e).animatespeed rem animatespeed multiplier (markblosser)
   else
    set object speed obj,110*timeelapsed#*entityelement(e).animatespeed rem animatespeed multiplier (markblosser)
   endif
  endif
  `
 endif
 `
 rem slerp limbs back into place
 if entityelement(e).limbslerp>0
  tlcount=0
  for tl=0 to entityelement(e).limbslerp-1
   if tl>0
    if limb exist(entityelement(e).obj,tl)=1
     tlx#=limb angle x(entityelement(e).obj,tl)/1.1
     tly#=limb angle y(entityelement(e).obj,tl)/1.1
     tlz#=limb angle z(entityelement(e).obj,tl)/1.1
     rotate limb entityelement(e).obj,tl,tlx#,tly#,tlz#
     if tlx#=0 and tly#=0 and tlz#=0 then inc tlcount
    endif
   else
    inc tlcount
   endif
  next tl
  if tlcount>=entityelement(e).limbslerp
   entityelement(e).limbslerp=0
  endif
 endif
 `
endif

return

_entity_controldecals:

rem decal effects from entity element
tindex=entityelement(e).decalindex
if tindex<>0
 if tindex<0
  decalid=abs(tindex)
 else
  decalid=entitydecal(entid,tindex-1)
 endif
 if decalid>0
  rem entityelement(e).decalmode
  rem 0-once face player
  rem 1-once keep angle
  rem 2-loop face player
  rem 3-loop keep angle
  rem 4-once face up
  rem 5-loop face up
  rem 6-character-spot-decal (at end of entity characters gun if available)
  rem 7-spawn decal based particle (flame or fire)
  decalorient=0
  decalx=entityelement(e).x : decalz=entityelement(e).z
  if entityelement(e).decalmode>=4 and entityelement(e).decalmode<=5
   decaly=entityelement(e).y+0.5
  else
   decaly=entityelement(e).y
  endif
  rem FPGC - 170610 - can apply a Y-rotated offset for entity
  if entityprofile(entid).decaloffsetdist<>0 or entityprofile(entid).decaloffsety<>0
   trotatedoffsetx=newxvalue(0,entityelement(e).ry+entityprofile(entid).decaloffsetangle,entityprofile(entid).decaloffsetdist)
   trotatedoffsetz=newzvalue(0,entityelement(e).ry+entityprofile(entid).decaloffsetangle,entityprofile(entid).decaloffsetdist)
   toffsety=entityprofile(entid).decaloffsety
   decalx=decalx+trotatedoffsetx
   decalz=decalz+trotatedoffsetz
   decaly=decaly+toffsety
  endif
  if entityelement(e).decalmode=1
   rem used for windows, where glass smash decal must exactly match
   if entityelement(e).obj>0
    decalx=decalx+object collision center x(entityelement(e).obj)
    decaly=decaly+object collision center y(entityelement(e).obj)
    decalz=decalz+object collision center z(entityelement(e).obj)
   endif
  endif
  if entityelement(e).decalmode=1 or entityelement(e).decalmode=3
   decalorient=1 : decalorientx#=entityelement(e).rx : decalorienty#=entityelement(e).ry : decalorientz#=entityelement(e).rz
  endif
  if entityelement(e).decalmode=4 or entityelement(e).decalmode=5
   decalorient=2
  endif
  decalscalemodx=entityelement(e).decalsizex
  decalscalemody=entityelement(e).decalsizey
  if entityelement(e).decalmode=6
   if entityprofile(entid).ischaracter=1
    tobj=entityelement(e).attachmentobj
    if tobj>0
     tobjlimb=entityelement(e).attachmentobjfirespotlimb
     decalx=limb position x(tobj,tobjlimb)
     decaly=limb position y(tobj,tobjlimb)
     decalz=limb position z(tobj,tobjlimb)
     if tobjlimb=0
      rem V118 - 070211 - only use 25 unit offset IF VWEAP does not have firespot limb set-up
      rem V118 - 050210 - decal fire spot 'inside' gun, needs to be at end
      tslidex#=newxvalue(0.0,entityelement(e).ry,25.0)
      tslidez#=newzvalue(0.0,entityelement(e).ry,25.0)
      decalx=decalx+tslidex#
      decalz=decalz+tslidez#
     endif
    endif
   endif
   decalorient=3
  endif
  if entityelement(e).decalmode=0 or entityelement(e).decalmode=1 or entityelement(e).decalmode=4 or entityelement(e).decalmode=6
   rem play decal once
   entityelement(e).decalindex=0
   originatore=e : gosub _decalelement_create
  endif
  if entityelement(e).decalmode=2 or entityelement(e).decalmode=3 or entityelement(e).decalmode=5
   rem loop decal continually recreating it
   entityelement(e).decalloop=entityelement(e).decalloop+(timeelapsed#*2)
   if entityelement(e).decalloop>=15
    entityelement(e).decalloop=0
    currentdecald=entityelement(e).decalslotused
    originatore=e : gosub _decalelement_continue
    entityelement(e).decalslotused=currentdecald
   endif
  endif
  if entityelement(e).decalmode=7
   rem FPGC - 300310 - spawn a decal based particle fragment (for new flame and fire) (once)
   decalorient=7
   entityelement(e).decalindex=0
   originatore=e : gosub _decalelement_create
  endif
 endif
endif

return

_entity_controlcollision:

rem no movement if entity immobile
if entityelement(e).mover.moved=1
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).mover.moved=0
 endif
endif

rem entity has moved, collision a consideration
if entityelement(e).mover.moved=1 and entityelement(e).force.active=0
 `
 rem tragectory of entity movement
 tdx#=entityelement(e).mover.dx-entityelement(e).x
 tdy#=entityelement(e).mover.dy-entityelement(e).y
 tdz#=entityelement(e).mover.dz-entityelement(e).z
 tdist#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))+30
 `
 rem ensure projected movement is free of large entity obstacles
 dstbest#=99999.9 : dstbestfound=0
 tblockedtox=entityelement(e).mover.dx
 tblockedtoy=entityelement(e).mover.dy
 tblockedtoz=entityelement(e).mover.dz
 `
 rem if blocked, a quicker check to see if collision disabled on it
 tusethisasweneeddoorstoblock=1
 if tusethisasweneeddoorstoblock=1
  if entityelement(e).blockedby>0
   if entityelement(e).blockedtox=tblockedtox and entityelement(e).blockedtoy=tblockedtoy and entityelement(e).blockedtoz=tblockedtoz
    te=entityelement(e).blockedby
    if entityelement(te).active=0 or entityelement(te).collisionactive=0
     entityelement(e).blockedby=0
    else
     dstbestfound=te
    endif
   else
    entityelement(e).blockedby=0
   endif
  endif
  rem obstacle detection removed for V1 (speed issue)
  if entityelement(e).blockedby=0 and entitysystemdisabled=0
   rem intensive scan for solid entity obstacles
   for te=1 to entityelementlist
    if te<>e
     if entityelement(te).active=1
      if entityelement(te).obj>0 and entityelement(te).collisionactive=1
       tentid=entityelement(te).bankindex
       if entityprofile(tentid).ischaracter=0
        rem ensure only entity with DOOR characteristics are rayscanned
        if entityelement(te).editorfixed<>0
         dst#=intersect object(entityelement(te).obj,entityelement(e).x,entityelement(e).y+40.0,entityelement(e).z,entityelement(e).mover.dx,entityelement(e).mover.dy+40.0,entityelement(e).mover.dz)
         if dst#>0 and dst#<tdist#-30
          if dst#<dstbest# then dstbest#=dst# : dstbestfound=te
         endif
        endif
       endif
      endif
     endif
    endif
   next te
   if dstbestfound>0
    rem if collide with close entity, recalc distance to move so we just touch it
    entityelement(e).blockedby=dstbestfound
    entityelement(e).blockedtox=tblockedtox
    entityelement(e).blockedtoy=tblockedtoy
    entityelement(e).blockedtoz=tblockedtoz
    tdist#=dstbest#-1.0 : dstbestfound=0
   endif
  endif
 endif
 `
 rem go ahead - can move or not move
 if dstbestfound=0
  `
  rem get angle from tragectory
  tda#=atanfull(tdx#,tdz#)
  tstepup#=0.0
  `
  rem strafe adjusts mover angle
  if entityelement(e).mover.strafe<>0
   tda#=tda#+entityelement(e).mover.strafe
   tdistold#=tdist#
   tdist#=50.0
  endif
  `
  rem When need to slide past other things
  if entityelement(e).mover.slidevel<>0
   tda#=tda#+entityelement(e).mover.slidevel
  endif
  `
  rem strafe dist over-shot so character not in wall, reduce back to real dist
  tdist#=tdist#-30.0
  `
  rem speed calc using timestamp
  tspeed#=tdist# : if tspeed#>3.0 then tspeed#=3.0
  `
  rem calculate mover inertias for per-cycle movement
  entityelement(e).mover.ix=newxvalue(0,tda#,tspeed#)
  entityelement(e).mover.iz=newzvalue(0,tda#,tspeed#)
  if entityelement(e).nogravity=1
   entityelement(e).mover.iy=tdy#/(tdist#/tspeed#)
  else
   entityelement(e).mover.iy=0.0
  endif
  if tdist#<1.0
   entityelement(e).mover.stepcount=0
  else
   entityelement(e).mover.stepcount=tdist#/tspeed#
  endif
  entityelement(e).mover.inmotion=1
  `
 else
  `
  rem if blocked, losing target
  entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
  `
 endif
 `
 rem checks over
 entityelement(e).mover.moved=0
 `
endif

return

_entity_move_removeref:
 tx=entityelement(e).x/25 : ttryx=tx
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25 : ttryz=tz
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=0
  endif
 endif
return

_entity_move_avoidentities:
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if ty>=0 and ty<=viscoly
  tnearest=0 : tnearestds#=9999
  for lsx=tx-2 to tx+2
   for lsz=tz-2 to tz+2
    if lsx>=0 and lsz>=0
     if lsx<=viscolx and lsz<=viscolz
      localscan=viscolmap(lsx,ty,lsz)
      if localscan>0
       rem touching entity
       tentid=entityelement(localscan).bankindex
       if entityprofile(tentid).ischaracter=1
        if entityelement(localscan).mover.inmotion=0 or e>localscan
         rem ensure this E does not enter cylinder of locally scanned E
         tldx#=entityelement(e).x-entityelement(localscan).x
         tldz#=entityelement(e).z-entityelement(localscan).z
         tlds#=sqrt(abs(tldx#*tldx#)+abs(tldz#*tldz#))
         if tlds#<36.0
          if tnearestds#>tlds# then tnearestds#=tlds# : tnearest=localscan
         endif
        endif
       endif
      endif
     endif
    endif
   next lsz
  next lsx
  if tnearest>0
   tldx#=entityelement(e).x-entityelement(tnearest).x
   tldz#=entityelement(e).z-entityelement(tnearest).z
   tlan#=atanfull(tldx#,tldz#)
   if (int(e/2.0)*2.0)=int((e/2.0)*2.0)
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel+1
    tlan#=tlan#+3
   else
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel-1
    tlan#=tlan#-3
   endif
   entityelement(e).x=newxvalue(entityelement(tnearest).x,tlan#,36.0)
   entityelement(e).z=newzvalue(entityelement(tnearest).z,tlan#,36.0)
   tavoidedentity=1
  endif
 endif
return

_entity_move_restoreref:
 rem get tile coord
 tputback=0
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if tx>=0 and tx<=viscolx and ty>=0 and ty<=viscoly and tz>=0 and tz<=viscolz
  rem or an obstacle (entity, not player) either above or below
  if viscolmap(tx,ty,tz)>0 then tputback=1
  rem FPSCV105RC2 - added all voids as obstacles in VISCOLMAP (so characters canont run off ledges)
  if viscolmap(tx,ty,tz)=-2
   rem if blocked, instantly lose target
   entityelement(e).losttargetcount=100
   tputback=1
  endif
  tryy = (entityelement(e).y+35)/100 : if tryy<=viscoly and viscolmap(tx,tryy,tz)>0 then tputback=1
  tryy = (entityelement(e).y-35)/100 : if tryy>=0 and viscolmap(tx,tryy,tz)>0 then tputback=1
 else
  tputback=1
 endif
 if tputback=1
  tkillfallingentity=0
  if entityelement(e).y<0
   rem entity left by falling off the universe, restore but remove all health and lives
   tkillfallingentity=1
  else
   rem restore by bouncing tragectory back
   if entityelement(e).mover.grav>1
    entityelement(e).mover.grav=entityelement(e).mover.grav*-1
   endif
  endif
  entityelement(e).x=toldx#
  entityelement(e).y=toldy#
  entityelement(e).z=toldz#
  entityelement(e).mover.stepcount=tstep#
  if tkillfallingentity=1 and entityelement(e).health>0
   entityelement(e).eleprof.lives=1
   entityelement(e).eleprof.strength=1
   tdamage=entityelement(e).health
   entityelement(e).health=1
   tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
   entityelement(e).shotby=999
   entityelement(e).shotbyammo$=""
   gosub _entity_deducthealth
  endif
 endif
 rem place back in viscolmap
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=e
  endif
 endif
return

_entity_controlmovements:
 `
 rem uses MOVER IX IY IZ and STEPCOUNT to move entity around the scene
 tstep#=entityelement(e).mover.stepcount
 if entityelement(e).eleprof.isimmobile=0
  `
  rem server controlled entities never have motion
  if entityelement(e).servercontrolled=1
   entityelement(e).mover.inmotion=0
  endif
  `
  rem clear viscolmap data if going to move
  rem V117 - 171209 - ensures antigrav platforms using nofloorlogic are not stopped by thin air
  if entityelement(e).mover.inmotion=1 and entityelement(e).nofloorlogic=0
   gosub _entity_move_removeref
  endif
  `
  rem control position movement
  toldx#=entityelement(e).x
  toldy#=entityelement(e).y
  toldz#=entityelement(e).z
  if tstep#>0.0
   `
   rem machine-independent inertia
   tbit#=(1.0*timeelapsed#)
   if tstep#>tbit#
    rem standard paced inertia movememt
    tix#=entityelement(e).mover.ix*timeelapsed#
    tiy#=entityelement(e).mover.iy*timeelapsed#
    tiz#=entityelement(e).mover.iz*timeelapsed#
    if entityelement(e).mover.run=1 then tix#=tix#*2.0 : tiy#=tiy#*2.0 : tiz#=tiz#*2.0
    if entityelement(e).eleprof.speed<>100
     tss#=entityelement(e).eleprof.speed/100.0
     tix#=tix#*tss# : tiy#=tiy#*tss# : tiz#=tiz#*tss#
    endif
   else
    rem ensure steps are taken to the last decimal bit
    tbit#=tstep#
    tix#=entityelement(e).mover.ix*tbit#
    tiy#=entityelement(e).mover.iy*tbit#
    tiz#=entityelement(e).mover.iz*tbit#
   endif
   rem movement
   entityelement(e).x=entityelement(e).x+tix#
   entityelement(e).y=entityelement(e).y+tiy#
   entityelement(e).z=entityelement(e).z+tiz#
   entityelement(e).mover.stepcount=tstep#-tbit#
   `
   rem FPGC - 300710 - DarkAI only in single player
   if gmultiplayergame=0
    if ai entity exist(entityelement(e).obj)
     if ai get entity x(entityelement(e).obj)<>entityelement(e).x or ai get entity z(entityelement(e).obj)<>entityelement(e).z or entityelement(e).darkai.aiy<>entityelement(e).y
      rem lee - 240111 - place virtual DAI entity position X units before 'floor' to avoid ray cast collision with geometry!
      ai set entity position entityelement(e).obj,entityelement(e).x,entityelement(e).y+5,entityelement(e).z
      entityelement(e).aimovex=entityelement(e).x : entityelement(e).aimovez=entityelement(e).z : entityelement(e).aimoved=1
     endif
    endif
   endif
   `
  endif
  `
  rem ensure entity characters do not croud each other
  Rem Hockeykid - 250210 - Dark AI added flag/if to allow ai system to take control
  tavoidedentity=0
  if entityelement(e).mover.inmotion=1
   if entityprofile(entid).ischaracter=1 and ai entity exist(entityelement(e).obj)=0
    gosub _entity_move_avoidentities
   endif
  endif
  `
  Rem Hockeykid - 250210 - Dark AI added flag/if to allow ai system to take control
  if tavoidedentity=0 and ai entity exist(entityelement(e).obj)=0
   if entityelement(e).mover.slidevel<>0
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel/1.1
    if abs(entityelement(e).mover.slidevel)<1.0
     entityelement(e).mover.slidevel=0
    endif
   endif
  endif
  `
  rem simple volume check for free-moving entities
  if entityelement(e).mover.inmotion=1
   tokay=0 : tgravitydefeated=0
   if entityelement(e).nogravity=0
    if entityelement(e).nofloorlogic=0
     rem full gravity and volume handling of entities in motion
     if entitysystemdisabled=0

      rem 051112 - do not allow gravity's downward pull to effect flak (handled in flak system incy and grav!)
      if entityelement(e).isflak=0
       tmaxfall#=entityelement(e).mover.grav*timeelapsed# : if tmaxfall#>10.0 then tmaxfall#=10.0
       entityelement(e).y=entityelement(e).y-tmaxfall#
      endif
      if static volume(toldx#,toldy#+30,toldz#,entityelement(e).x,entityelement(e).y+30,entityelement(e).z,1.0)=1
       entityelement(e).x=toldx#+get static collision x()
       entityelement(e).y=toldy#+get static collision y()
       entityelement(e).z=toldz#+get static collision z()
       colmaterialtype=-1
       if get static collision floor()=1
        tgravitydefeated=1 : colmaterialtype=get static collision value()-1
       endif
       tokay=1
      endif
     endif
    else
     rem quick no-vertical-no-gravity handling (always floor)
     tmaxfall#=entityelement(e).mover.grav*timeelapsed# : if tmaxfall#>10.0 then tmaxfall#=10.0
     entityelement(e).y=entityelement(e).y-tmaxfall#
     if entityelement(e).y<entityelement(e).nofloorlogic-1
      entityelement(e).y=entityelement(e).nofloorlogic-1
      tgravitydefeated=1 : colmaterialtype=-1
      tokay=1
     endif
     rem allow physics to do this - no static geom detection for v1 (speed issue)
     rem V109 - BETA11 - reactivated this as it helps nofloorlogic characters keep out of walls!
     Rem Hockeykid - 250210 - Dark AI added flag/if to allow ai system to take control
     if ai entity exist(entityelement(e).obj)=0
      tdx2#=entityelement(e).x-toldx#
      tdz2#=entityelement(e).z-toldz#
      tda2#=atanfull(tdx2#,tdz2#)
      tdforex#=newxvalue(0,tda2#,30.0)
      tdforez#=newzvalue(0,tda2#,30.0)
      if static raycast(toldx#,toldy#+30,toldz#,entityelement(e).x+tdforex#,entityelement(e).y+30,entityelement(e).z+tdforez#)<>0
       entityelement(e).x=toldx#
       entityelement(e).z=toldz#
       tokay=1
      else
       rem V109 BETA11 - 130508 - check change in floor height, if so do not go there (stairs and holes)
       ttddist#=static raycast(entityelement(e).x+tdforex#,entityelement(e).y+30,entityelement(e).z+tdforez#,entityelement(e).x+tdforex#,entityelement(e).y-30,entityelement(e).z+tdforez#)
       if abs(ttddist#-30.0)>2.0
        entityelement(e).x=toldx#
        entityelement(e).z=toldz#
        tokay=1
       endif
      endif
     endif
    endif
   endif
   if tokay=1
    plrid=entityelement(e).fakeplayerid
    if entityprofile(entid).footfallmax>0 and plrid>1
     rem V110 BETA5 - 080608 - manually controlled footfalls (from FPE data)
     manuallycontrolledfootfallframe=1
     if obj>0
      tcurrentkeyframe=object frame(obj)
      for q=0 to entityprofile(entid).footfallmax-1
       if entityfootfall(entid,q).keyframe=tcurrentkeyframe then manuallycontrolledfootfallframe=1+tcurrentkeyframe : exit
      next q
      `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)
      if manuallycontrolledfootfallframe>1
       rem make a footfall sound for the entity
       movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
       gosub _player_playfootfall
       `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)+"   PING!"
      endif
     endif
     manuallycontrolledfootfallframe=0
    else
     rem default - timer based footfalls
     if tstep#>0.0
      if entityelement(e).mover.run=1
       basespeed#=55
      else
       basespeed#=35
      endif
      if entityelement(e).eleprof.speed<>100
       tss#=entityelement(e).eleprof.speed/100.0
       basespeed#=basespeed#*tss#
      endif
      movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
      if plrid>1 then gosub _player_playfootfall
     endif
    endif
    if entityelement(e).force.active=1
     if tgravitydefeated=1
      entityelement(e).force.iy=0
     else
      entityelement(e).force.ix=0 : entityelement(e).force.iz=0
     endif
    endif
   endif
   if tgravitydefeated=1
    rem determine if fall hurt character
    if entityelement(e).y<entityelement(e).mover.gravlasty-entityelement(e).eleprof.hurtfall
     rem level substantial different from last stood on ground
     tdamage=1+((abs(entityelement(e).y-entityelement(e).mover.gravlasty)-entityelement(e).eleprof.hurtfall)/5.0)
     tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
     tdamagesource=0 : timpacttype=1
     entityelement(e).shotby=997
     entityelement(e).shotbyammo$=""
     gosub _entity_deducthealth
    endif
    rem record last ground player stood on
    entityelement(e).mover.gravlasty=entityelement(e).y
    rem restore gravity
    entityelement(e).mover.grav=1
   else
    tmaxfall#=1*timeelapsed# : if tmaxfall#>2.0 then tmaxfall#=2.0
    entityelement(e).mover.grav=entityelement(e).mover.grav+tmaxfall#
   endif
  endif
  `
  rem if not moving (colliding), increment losttarget counter
  if entityelement(e).mover.inmotion=1
   if abs(entityelement(e).x-toldx#)+abs(entityelement(e).z-toldz#)<(1.0*timeelapsed#)
    entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
   else
    entityelement(e).losttargetcount=0
   endif
  endif
  `
  rem restore entity viscolmap data
  rem V117 - 171209 - ensures antigrav platforms using nofloorlogic are not stopped by thin air
  if entityelement(e).mover.inmotion=1 and entityelement(e).nofloorlogic=0
   gosub _entity_move_restoreref
  endif
  `
  rem if gravity stops entity, and was in motion, and no-more-moving, deactivate motion
  if entityelement(e).mover.inmotion=1
   if tgravitydefeated=1 and tstep#=0
    rem FPGC - 100610 - only stop if NOT currently on a waypoint path (briefly stops for door that gets opened)
    if entityelement(e).ai.waypoint.state<>2
     rem entity stops moving
     entityelement(e).mover.inmotion=0
     rem stop animation too if logic count far from resolution
     if entityprofile(entid).animmax>=1
      if entityelement(e).animdo>=1 and entityelement(e).animdo<=5
       entityelement(e).animset=1+1
      endif
     endif
    endif
   endif
  endif
  `
 endif
 `
 rem control rotation movement
 entityelement(e).ry=curveangle(entityelement(e).mover.da,entityelement(e).ry,2.0/timeelapsed#)
 `
 rem control alpha level movement
 if entityelement(e).ai.destalphafade<>entityelement(e).ai.alphafade
  if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade+(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade>entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  else
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade-(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  endif
  entityelement(e).ai.alphafadeupdate=1
 endif
 `
 rem update animation frame of entity
 if entityelement(e).animframe<>entityelement(e).destanimframe
  tss#=1.0 : if entityelement(e).eleprof.speed<>100 then tss#=entityelement(e).eleprof.speed/100.0
  if entityelement(e).animframe<entityelement(e).destanimframe
   entityelement(e).animframe=entityelement(e).animframe+(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe>entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  else
   entityelement(e).animframe=entityelement(e).animframe-(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe<entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  endif
  entityelement(e).animframeupdate=1
 endif
 `
 rem make sure head rotates and can restore itself (in proportion)
 if entityelement(e).ai.headangle<>entityelement(e).ai.headdestangle
  if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
   entityelement(e).ai.headangle=entityelement(e).ai.headangle+(10*timeelapsed#)
   if entityelement(e).ai.headangle>entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  else
   entityelement(e).ai.headangle=entityelement(e).ai.headangle-(10*timeelapsed#)
   if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  endif
 else
  rem add subtle movements in headangle
  entityelement(e).ai.headangle=curvevalue(entityelement(e).ai.headdestangle-5.0+(rnd(100)/10.0),entityelement(e).ai.headangle,3.0)
 endif
 `
return

_entity_controlattachments:

rem ensure attachments are updated and visible
tobj=entityelement(e).attachmentobj
if tobj>0
 tentid=entityelement(e).bankindex
 if object exist(tobj)=1

  if entityelement(e).beenkilled=0 and entityelement(e).active<>0
   rem manual position of gun attachment
   limbpx#=object position x(entityelement(e).obj)
   limbpy#=object position y(entityelement(e).obj)
   limbpz#=object position z(entityelement(e).obj)
   if entityelement(e).obj>0
    if object exist(entityelement(e).obj)=1
     tentid=entityelement(e).bankindex
     if entityprofile(tentid).firespotlimb>=0
      rem position of entity hand where gun rests
      limbpx#=limb position x(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbpy#=limb position y(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbpz#=limb position z(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      `
      limbax#=limb direction x(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbay#=limb direction y(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbaz#=limb direction z(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      `set object to object orientation tobj,entityelement(e).obj,entityprofile(tentid).firespotlimb,0


      rotate object tobj,limbax#,limbay#,limbaz#
      Rem Fix to occasionally random scaling of weapon attachments.
      scale object tobj,85,85,85
     endif
    endif
   endif
   position object tobj,limbpx#,limbpy#,limbpz#


  else

   rem attachment free of entity, using physics to settle in scene
  endif
  `
  rem hide weapon if character totally invisible
  if gmultiplayergame=1 or entityelement(e).ai.alphafade=0
   hide object tobj
  else
   show object tobj
  endif
  `
 endif

endif

return

_entity_controllighting:

rem handle entity lighintg
gosub _lighting_applyentitycolor

return

_entity_storemainai:
 `
 rem store old behaviour (for internal AI changes such as HURT)
 if entityelement(e).ai.usinginternalai=0
  entityelement(e).ai.oldwaypointstate=entityelement(e).ai.waypoint.state
  entityelement(e).ai.oldalphafade=entityelement(e).ai.alphafade
  entityelement(e).ai.oldstate$=entityelement(e).ai.state$ rem GUI-X9 (String States)
  entityelement(e).ai.usinginternalai=1
  entityelement(e).logiccount=0
  `
  rem V109 - 210308 - prevents death anim from throw going back to middle of main anim which might be 2600-2650! goes through all anims
  entityelement(e).ai.oldanimframe=entityelement(e).animframe
  entityelement(e).ai.olddestanimframe=entityelement(e).destanimframe
  `
 endif
 `
return

_entity_setnewai:
 rem store old behaviour
 gosub _entity_storemainai
 rem setting waypoint state to 1 causes animation to retriger on return
 if entityelement(e).health<=0
  entityelement(e).ai.oldwaypointstate=999
 else
  if entityelement(e).ai.waypoint.state>0 and entityelement(e).ai.waypoint.state<99
   entityelement(e).ai.oldwaypointstate=1
  else
   entityelement(e).ai.oldwaypointstate=0
  endif
 endif
 rem trigger entity behaviour (aifile$)
 gosub _ai_findlibindex
 entityelement(e).ai.libindex=libindex
 entityelement(e).ai.waypoint.state=0
 entityelement(e).ai.alphafade=99
 entityelement(e).ai.destalphafade=100
 entityelement(e).ai.oldalphafade=99
 entityelement(e).ai.alphafadeupdate=1
 entityelement(e).ai.state$="0" rem GUI-X9 (String States)
 rem some resets to prevent cross-code
 entityelement(e).animframe=entityelement(e).destanimframe
 entityelement(e).animtime=0
 rem ensure it is immediate
 entityelement(e).logiccount=0
return

_entity_hasbulletrayhit:
 `
 rem optimise : only entities with range of the players range (of gun)
 `
 rem bulletray is x1#,y1#,z1#,x2#,y2#,z2#=bulletrayhit,gunrange#
 brayx1#=x1# : brayy1#=y1# : brayz1#=z1#
 brayx2#=x2# : brayy2#=y2# : brayz2#=z2#
 bulletrayhit=0 : bulletrayhitdist#=0.0
 `
 rem if bullet ray passed waterlevel, create a splash at intersection
 if (brayy1#>waterheight# and brayy2#<waterheight#) and wateron=1 or (brayy1#<waterheight# and brayy2#>waterheight#) and wateron=1
  `
  rem calculate intersect vector
  tbix#=brayx2#-brayx1#
  tby#=brayy1# : tbiy#=brayy2#-brayy1#
  tbz#=brayz1# : tbiz#=brayz2#-brayz1#
  trange=sqrt(abs(tbix#*tbix#)+abs(tbiz#*tbiz#))
  trange#=trange
  tbix#=tbix#/trange#
  tbiy#=tbiy#/trange#
  tbiz#=tbiz#/trange#
  tperc#=(brayy1#-waterheight#)/abs(tbiy#)
  tbx#=brayx1#+(tbix#*tperc#)
  tby#=brayy1#+(tbiy#*tperc#)
  tbz#=brayz1#+(tbiz#*tperc#)
  `
  rem create a small splash at this point
  rem and only if water does ripple
  if waterdecalripple<>0
   `
   decalid=splashdecalid
   decalorient=0
   decalx=tbx#
   decalscalemodx=10
   decalscalemody=decalscalemodx+rnd(10)
   `decalscalemodx=100
   `decalscalemody=decalscalemodx
   decaly=waterheight#-((100-decalscalemody)/2)
   decalz=tbz#
   decalalpha=50
   originatore=0 : gosub _decalelement_create
   `
   rem play splash sound
   tmatindex=17 : tsoundtrigger=material(tmatindex).impactid
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=decalx : tsy#=decaly : tsz#=decalz
   tvol#=100.0 : gosub _ode_triggermaterialsound
   tsoundtrigger=0
   `
   rem create a ripple at intersect point
   decalid=waterdecalripple
   decalorient=0
   decalx=tbx#
   decaly=waterheight#+1.0
   decalz=tbz#
   decalorient=2
   decalscalemodx=25 : decalscalemody=decalscalemodx
   decalalpha=15
   originatore=0 : gosub _decalelement_create
   `
  endif
  `
 endif
 `
 rem go through entities
 tclosestdist#=99999.0
 tcloseste=0 : tlimbifany=-1
 for e=1 to entityelementlist
  gosub _entity_controlrecalcdist
  if dist#<gunrange# and entityelement(e).obj>0
   rem within range of gun
   rem AirMod - Line Modified for No Bullet collision
   if entityelement(e).active<>0 and entityelement(e).nobulletcol <> 1
    `
    rem if character (animated by GPU, work out general hit (faster paced target)
    usethelimbdatafromintersectcommand=0
    dst#=0.0 : entid=entityelement(e).bankindex
    if entityprofile(entid).ischaracter=1 and entityprofile(entid).limbmax<=1
     rem V111 beta8 - 020708 - character bullet detect based on fixed size of character (30x30 and variable height (stood/ducked)
     if gmultiplayergame=0
      rem Add V111 BETA8 - 020708 - add scaling to this detection
      tbbase#=0
      tbheight#=object size y(entityelement(e).obj)
      if entityelement(e).crouchprofile=1 then tbheight#=tbheight#*0.68
     else
      tbbase#=0 : tbheight#=55 : if entityelement(e).crouchprofile=1 then tbheight#=40
     endif
     tbwide#=object size x(entityelement(e).obj)/2
     if tbwide#<object size z(entityelement(e).obj)/2 then tbwide#=object size z(entityelement(e).obj)/2
     if (entityelement(e).collisionactive=1 and entityelement(e).invincibleactive=0) or gmultiplayergame=0
      dstx#=object position x(entityelement(e).obj)
      dsty#=entityelement(e).y : rem v111beta8 object position y(entityelement(e).obj)
      dstz#=object position z(entityelement(e).obj)
      tbx#=brayx1# : tbix#=brayx2#-brayx1#
      tby#=brayy1# : tbiy#=brayy2#-brayy1#
      tbz#=brayz1# : tbiz#=brayz2#-brayz1#
      trange=sqrt(abs(tbix#*tbix#)+abs(tbiz#*tbiz#))
      trange#=trange/10.0
      tbix#=tbix#/trange#
      tbiy#=tbiy#/trange#
      tbiz#=tbiz#/trange#
      for st=1 to trange step 10
       if tbx#>=dstx#-tbwide# and tbx#<=dstx#+tbwide#
        if tby#>=dsty#+tbbase# and tby#<=dsty#+tbheight#
         if tbz#>=dstz#-tbwide# and tbz#<=dstz#+tbwide#
          ttbix#=tbx#-brayx1#
          ttbiy#=tby#-brayy1#
          ttbiz#=tbz#-brayz1#
          dst#=sqrt(abs(ttbix#*ttbix#)+abs(ttbiy#*ttbiy#)+abs(ttbiz#*ttbiz#))
          st=trange
          exit
         endif
        endif
       endif
       tbx#=tbx#+tbix#
       tby#=tby#+tbiy#
       tbz#=tbz#+tbiz#
      next st
     endif
    else
     rem FPSC - 210111 - New U77 intersect object command returns bone number in checklist valueb (when force CPU animation, i.e. set object effect obj,effno,forcecpu=1)
     rem and will be used when LIMBMAX > 1 (i.e. character FPE determines limbs need to be detected)
     dst#=intersect object(entityelement(e).obj,brayx1#,brayy1#,brayz1#,brayx2#,brayy2#,brayz2#)
     usethelimbdatafromintersectcommand=1
    endif
    `
    rem if intersect
    if dst#>0
     if dst#<tclosestdist#
      tclosestdist#=dst# : tcloseste=e
      if usethelimbdatafromintersectcommand=1
       tlimbifany=checklist value b(1)
      endif
     endif
    endif
    `
   endif
  endif
 next e
 `
return

_entity_completerayhit:
 `
 if tcloseste>0
  `
  rem work on closest entity hit
  e=tcloseste
  gosub _entity_controlrecalcdist
  dst#=tclosestdist#
  `
  rem work out bullet force
  distx#=brayx2#-brayx1# : disty#=brayy2#-brayy1# : distz#=brayz2#-brayz1#
  fulldst#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  x#=brayx1#+((distx#/fulldst#)*dst#)
  y#=brayy1#+((disty#/fulldst#)*dst#)
  z#=brayz1#+((distz#/fulldst#)*dst#)
  `
  rem FPSC - 210111 - V118 - store if a shot hit a limb/bone number
  tentid=entityelement(e).bankindex
  if tlimbifany>=0 and tlimbifany<=99
   entityelement(e).shotdamagetype=entitybodypart(tentid,tlimbifany)
  endif
  `
  rem X9 - 070208 - enhance bullet damage if the entity is prone to a headshot
  if entityprofile(tentid).ischaracter=1
   entityheadshotvalue=entityelement(e).ai.headshot
   if entityheadshotvalue>0 and gheadshotdamage>0
    rem X9 - 080308 - headshot value has significance (specify one uses internal default, other value denotes height of head)
    if entityheadshotvalue=1 then entityheadshotvalue=43
    if tlimbifany>=0 and tlimbifany<=99
     rem FPSC - 210111 - V118 - new method is to check limb against body part number
     if entitybodypart(tentid,tlimbifany)=1
      rem perfect geometry based head shot
      bulletdamage=gheadshotdamage
     endif
     `rem can use head limb to find head (and whether we hit it)
     `if entityelement(e).obj>0
     ` if object exist(entityelement(e).obj)=1
     `  if entityprofile(tentid).headlimb=tlimbifany
     `   if limb exist(entityelement(e).obj,tlimbifany)=1
     `    rem perfect geometry based head shot
     `    bulletdamage=gheadshotdamage
     `   endif
     `  endif
     ` endif
     `endif
    else
     rem have to use maths to find head
     if entityelement(e).animdo>=31 and entityelement(e).animdo<40
      rem crouched
      if y#>(entityelement(e).y+(entityheadshotvalue-12.24))
       bulletdamage=gheadshotdamage
      endif
     else
      rem stood
      if y#>(entityelement(e).y+entityheadshotvalue)
       bulletdamage=gheadshotdamage
      endif
     endif
    endif
    `
   endif
   `
  endif
  `
  rem work out relative direction to throw entity from entity angle
  tdir=0
  distx#=entityelement(e).x-brayx1# : distz#=entityelement(e).z-brayz1#
  tentitya#=wrapvalue(atanfull(distx#,distz#))-wrapvalue(entityelement(e).ry)
  if tentitya#<0.0 then tentitya#=tentitya#+360.0
  if tentitya#>=360.0 then tentitya#=tentitya#-360.0
  if tentitya#>180-45 and tentitya#<180+45
   tdir=1
  else
   if tentitya#>315 or tentitya#<45
    tdir=2
   else
    if tentitya#>45 and tentitya#<180-45
     tdir=4
    else
     tdir=3
    endif
   endif
  endif
  `
  if tdir>0
   `
   rem Pierce
   if bulletraytype<>2
    `
    rem affect limb if hit
    if tlimbifany>0
     if entityelement(e).obj>0
      if object exist(entityelement(e).obj)=1
       tentid=entityelement(e).bankindex
       if entityprofile(tentid).headlimb=tlimbifany
        if limb exist(entityelement(e).obj,tlimbifany)=1
         if rnd(1)=1 then tr=6 else tr=-6
         entityelement(e).ai.headangle=tr
        endif
       endif
      endif
     endif
    endif
    `
   endif
   `
   rem if entity prone to damage deal damage to entity (based on distance)
   tentid=entityelement(e).bankindex
   tperc#=(gunrange#-dst#)/gunrange#
   if dst#<200 then tperc#=1.0
   tdamage=bulletdamage : dec tdamage,rnd(tdamage/5)
   Rem Scene commander, player damage multiplyer
   truedam#=tperc#
   if playerdammult#<>0 then truedam#=truedam#*playerdammult#
   tdamage=tdamage*truedam#

   tdamagesource=0 : timpacttype=bulletraytype
   tdamagex#=x# : tdamagey#=y# : tdamagez#=z#
   tuseentityowndecaldamage=1
      Rem Scene Commander shot by what weapon.
   entityelement(e).shotby=gunid
   entityelement(e).shotbyammo$=ammopool(firemode(gunid,firemode).settings.poolindex).name$
   rem arena game there are no knock-downs (multiplayer)
   if gmultiplayergame=1
    timpacttype=1
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).ischaracter=1
     multiplayerdamagecollected=multiplayerdamagecollected+tdamage
     multiplayerdamagechar=e
    else
     gosub _entity_deducthealth
    endif
   else
    gosub _entity_deducthealth
   endif
   `
   rem report bullet hit entity
   bulletrayhitdist#=dst#
   bulletrayhit=e
   `
  endif
  `
 endif
 `
return

_entity_spherecollision:
 `
 rem go through entities
 spheree=-1
 for e=1 to entityelementlist
  if entityelement(e).active=1
   distx#=entityelement(e).x-spherex#
   disty#=entityelement(e).y-spherey#
   distz#=entityelement(e).z-spherez#
   spdist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
   obj=entityelement(e).obj
   if obj>0
   Rem Scene commander, object size check causing issues with flak/entity collision - reverted to x2
    if spdist#<object size(obj)*2
     idist#=intersect object(obj,spherex#,spherey#,spherez#,spherenx#,sphereny#,spherenz#)
     if idist#>0 and idist#<=spdist#
      spheree=e : exit
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_addforcesphere:
 `
 rem optimise : only entities with range of the sphere
 `
 rem go through entities
 for tte=1 to entityelementlist
  rem if entity prone to damage
  ttentid=entityelement(tte).bankindex
  rem work out if in range of force
  distx#=entityelement(tte).x-spherex#
  disty#=entityelement(tte).y-spherey#
  distz#=entityelement(tte).z-spherez#
  spdist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  tblastradius#=400.0*sphereforce#
  if spdist#<tblastradius#
   rem calculate force
   tix#=distx#/spdist# : tiy#=disty#/spdist# : tiz#=distz#/spdist#
   tforce#=(tblastradius#-spdist#)/tblastradius#
   rem work out if direct or indirect damage (raycast)
   tdirectdamage=0
   if static raycast(spherex#,spherey#+2.5,spherez#,entityelement(tte).x,entityelement(tte).y+2.5,entityelement(tte).z)=0
    tdirectdamage=1
   endif
   if tdirectdamage=1
    rem add simple force to entity
    if entityelement(tte).eleprof.isimmobile=0
     if entityelement(tte).eleprof.physics=1
      rem apply force using physics
      todeforce#=tforce#*75 : rem a bit stronger force movement!
      todee=tte : tdx#=tix#*todeforce# : tdz#=tiz#*todeforce#
      if disty#>10.0
       tdy#=(tiy#*todeforce#)+(0.25*todeforce#)
      else
       tdy#=tiy#*todeforce#
      endif
      todefalloff#=0.0 : twithpointforce=0
      tpx#=spherex# : tpy#=spherey# : tpz#=spherez#
      gosub _ode_applyforce
     else
      rem apply regular force calc
      entityelement(tte).force.ix=entityelement(tte).force.ix+(tix#*tforce#)
      if abs(disty#)<10.0
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)+(1.5*tforce#)
      else
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)
      endif
      entityelement(tte).force.iz=entityelement(tte).force.iz+(tiz#*tforce#)
      entityelement(tte).force.active=1
     endif
     rem entity rotates to such large blast
     entityelement(tte).mover.da=atanfull(distx#*-1.0,distz#*-1.0)
    endif
   endif
   rem suggest damage to entity if strong enough force
   if tforce#>0.2
    rem indirect damage is a hugely reduced value
    if tdirectdamage=0 then tforce#=tforce#/50.0 rem changed to 50.0
    rem actual entity damage
    tdamagex#=entityelement(tte).x : tdamagey#=entityelement(tte).y : tdamagez#=entityelement(tte).z
    tdamage=tforce#*1.2*spheredamage : rem increased damage slightly to conform with expected V1.0 damage levels (terrorstrike)
    if forcedamageon=0 then tdamage=0
    tdamagesource=0 : timpacttype=3 : tdir=0
    ste=e : sttentid=tentid
    tentid=entityelement(tte).bankindex
    e=tte
    if entityprofile(tentid).ischaracter=1
     rem characters can shrug off some explosion force
     if tdamage<30 then timpacttype=1
     entityelement(e).shotby=996
     entityelement(e).shotbyammo$=""
     gosub _entity_deducthealth
    else
     gosub _entity_delayeddeducthealth
    endif
    e=ste : tentid=sttentid
   endif
  endif
 next tte
 `
 rem initial blast if player close
 distx#=camera position x()-spherex#
 disty#=camera position y()-spherey#
 distz#=camera position z()-spherez#
 spdist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
 tblastradius#=400.0*sphereforce#
 if spdist#<tblastradius#
  rem damage power
  tpower#=(tblastradius#-spdist#)/tblastradius#
  rem work out if direct damage or indirect
  tdirectdamage=0
  sphtx#=spherex#+((distx#/spdist#)*20.0)
  sphtz#=spherez#+((distz#/spdist#)*20.0)
  if static raycast(sphtx#,spherey#+2.5,sphtz#,camera position x(),camera position y(),camera position z())=0
   tdirectdamage=1
  endif
  if tdirectdamage=1
   rem force applied to player from blast (fly force is cumilative and bleeds into camforce)
   camflyforcex#=camflyforcex#+((distx#/dist#)*(spheredamage*25)*tpower#)
   camflyforcey#=camflyforcey#+((spheredamage*25)*tpower#)
   camflyforcez#=camflyforcez#+((distz#/dist#)*(spheredamage*25)*tpower#)
   camshake#=camshake#+tdamage# : camshakedir=rnd(1)
   if abs(camshake#)>20
    if camshake#>20 then camshake#=20.0
    if camshake#<-20 then camshake#=-20.0
   endif
  endif
  if tpower#>0.2
   rem indirect damage is a hugely reduced value
   if tdirectdamage=0 then tpower#=tpower#/50.0
   rem damage to player (if strong enough force)
   tdamage#=spheredamage*tpower#
   tdamage=tdamage# : if tdamage>0 then gosub _player_takedamage
  endif
 endif
 `
return

_entity_resolveobjective:
 rem e assumed to be active=0, ie tse<>e
 tokay=0 : tleadere=entityelement(e).spawn.leaderid
 if tleadere=0
  rem instant complete - no spawn versions
  tleadere=e
  tokay=1
 else
  if entityelement(tleadere).spawn.upto=0
   tokay=1 : rem complete unless child still alive (active)
   for tse=1+tleadere to tleadere+entityelement(tleadere).spawn.max
    if tse<>e
     tsobj=entityelement(tse).obj
     if tsobj>0
      if object exist(tsobj)=1
       if entityelement(tse).active<>0
        rem entity alive
        tokay=0
       endif
      endif
     endif
    endif
   next tse
  endif
 endif
 if tokay=1
  rem handle objective
  if gamewarmupcount=0
   rem Only if game in full swing
   mi=entityelement(tleadere).eleprof.isobjective : if mi>0 then playerobjective(mi)=1
  endif
 endif
return

_entity_delayeddeducthealth:
 `
 rem store damage to be dealt when delay runs out
 if entityelement(e).delaydamagecount<=0
  rem Scene Commander, if no set delay use 10 seconds.
   if entityelement(e).delaydamagetimer>0.0
      entityelement(e).delaydamagecount=entityelement(e).delaydamagetimer
      else
      entityelement(e).delaydamagecount=10
    endif
  entityelement(e).delaydamagesource=tdamagesource
  entityelement(e).delaydamage=tdamage
  entityelement(e).delayimpact=timpacttype
  entityelement(e).delaydamagex#=tdamagex#
  entityelement(e).delaydamagey#=tdamagey#
  entityelement(e).delaydamagez#=tdamagez#
  entityelement(e).delaydir=tdir
 endif
 `
return

_entity_controldelayeddamage:
 `
 rem count down to delayed damage (fuel exploding)
 if entityelement(e).delaydamagecount>0
  entityelement(e).delaydamagecount=entityelement(e).delaydamagecount-1`*timeelapsed#
  if entityelement(e).delaydamagecount=0
   tdamagesource=entityelement(e).delaydamagesource
   tdamage=entityelement(e).delaydamage
   timpacttype=entityelement(e).delayimpact
   tdamagex#=entityelement(e).delaydamagex#
   tdamagey#=entityelement(e).delaydamagey#
   tdamagez#=entityelement(e).delaydamagez#
   tdir=entityelement(e).delaydir
   gosub _entity_deducthealth
  endif
 endif
 `
return

_entity_deducthealth:
 `
 rem takes TDAMAGE,TDIR and TIMPACTTYPE
 tresult=0 : tentid=entityelement(e).bankindex
      if entityelement(e).isimmune=1
         tdamage=0
      endif
   entityelement(e).lastdamagetimer=timer()
 rem AirMod - Update Last Hit Pos
 if obj > 0
  if entityprofile(tentid).headlimb<>-1
   if limb exist(obj,entityprofile(tentid).headlimb)
    entityelement(e).lastdamagex#=tdamagex#-limb position x(obj,entityprofile(tentid).headlimb)
    entityelement(e).lastdamagey#=tdamagey#-limb position y(obj,entityprofile(tentid).headlimb)
    entityelement(e).lastdamagez#=tdamagez#-limb position z(obj,entityprofile(tentid).headlimb)
   else
    entityelement(e).lastdamagex#=tdamagex#-entityelement(e).x
    entityelement(e).lastdamagey#=tdamagey#-entityelement(e).y
    entityelement(e).lastdamagez#=tdamagez#-entityelement(e).z
   endif
  else
   entityelement(e).lastdamagex#=tdamagex#-entityelement(e).x
   entityelement(e).lastdamagey#=tdamagey#-entityelement(e).y
   entityelement(e).lastdamagez#=tdamagez#-entityelement(e).z
  endif
 endif
 `
 rem entity damage makes a material sound
 tsoundtrigger=0 : tsoundmaterial=0
 if entityprofile(tentid).ischaracter=0 and tdamage>1
  tmatindex=entityprofile(tentid).materialindex-1
  if tmatindex>=0 and tmatindex<=gmaterialmax
   tsoundtrigger=material(tmatindex).impactid
   tsoundmaterial=1+tmatindex
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
  endif
 endif
 `
 rem FPGC - 110610 - FPGC characters are invincible
 if entityprofile(tentid).ischaracter=1
  if fpgcgenre=0 then entityelement(e).eleprof.strength=0
 endif
 `
 rem work out effect on health and lives
 if entityelement(e).eleprof.strength>0
  if entityelement(e).health>0 or gmultiplayergame=1
   rem multiplayer arena deals damage via server, opposed to directly to entity in single player mode
   if gmultiplayergame=1
    rem actual damage sent to server to control
    gosub _multi_dealentityedamage
   else
    rem deduct the health points (non-multiplayer only)
    entityelement(e).health=entityelement(e).health-tdamage
    entityelement(e).shotdamage=entityelement(e).shotdamage+tdamage
    entityelement(e).shotdamagesource=tdamagesource
    rem if hit, and character, give a priority to deal with AI (and duration to last the action)
    if entityprofile(tentid).ischaracter=1
     gosub _entity_stealpriorityandgivetoe
     if entityelement(e).priorityai=1
      entityelement(e).priorityduration=60
      entityelement(e).logiccount=0
     endif
    endif
   endif
   rem work out if dead or alive
   if entityelement(e).health<=0
    rem entity killed
    entityelement(e).health=0
    entityelement(e).shotdamage=0
    entityelement(e).shotdamagesource=0
    entityelement(e).eleprof.lives=entityelement(e).eleprof.lives-1
    rem if entity has more lives
    if entityelement(e).eleprof.lives>0
     rem rejuvinate entity
     entityelement(e).health=entityelement(e).eleprof.strength
     tresult=2
    else
     rem set as killed
     entityelement(e).beenkilled=1
     Rem Hockeykid - 250210 - Dark AI kill entity
     if entityelement(e).beenkilled=1 and ai entity exist(entityelement(e).obj)
      ai kill entity entityelement(e).obj
     endif
     rem V119 - 020711 - Hockeykid - make attachment object into a physics object
     `if entityelement(e).obj>0
     ` if object in screen(entityelement(e).obj)=1
         tobj=entityelement(e).attachmentobj
         if tobj>0
         if object exist(tobj) then gosub _ode_applyphysicstoattachment
         endif
     ` endif
    ` endif

     rem mission objective counter
     gosub _entity_resolveobjective
     rem dead perminantly
     tresult=3
     rem get explodable flag (0-none/1-bang/2-scorch leftover)
     texplodable=entityelement(e).eleprof.explodable
     rem remove entity from physics world
     if entityelement(e).eleprof.physics<>0
      tobj=entityelement(e).obj
      if texplodable<>2 then phyobjremove(tobj)=1
     endif
     rem entity destruction makes a material destroy sound
     if entityprofile(tentid).ischaracter=0
      rem non-character entities made from a material?
      tmatindex=entityprofile(tentid).materialindex-1
      `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
      if tmatindex>=0 and tmatindex<=gmaterialmax
       tsoundtrigger=material(tmatindex).destroyid
       tsoundmaterial=1+tmatindex
       tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
      endif
      rem debris from total destruction (regular physics only objects?)
      debrisshapeindex=entityprofile(tentid).debrisshapeindex
      if entityelement(e).eleprof.physics=1
       rem May shed debris..
       tobj=entityelement(e).obj
       frox#=entityelement(e).x : froy#=entityelement(e).y : froz#=entityelement(e).z
       `froa#=object angle y(tobj)
       frocopyorientfrom=tobj
       if debrisshapeindex>0
        rem place debris to explode in place of real object
        debristextureused=entityelement(e).eleprof.texdid
        debrissizex#=object size x(tobj) : debrissizey#=object size y(tobj) : debrissizez#=object size z(tobj)
        debrisexplodable=texplodable
        rem FPGC - 030710 - calculate correct lighting for debris
        recx#=entityelement(e).x
        recy#=entityelement(e).y
        recz#=entityelement(e).z
        recentityindex=e
        gosub _lighting_managegloballightingreciever
        gosub _part_createfragment
        rem Forces object invisible (replaced by fragments)
        tobj=entityelement(e).obj
        hide object tobj:entityelement(e).ishidden=2
       else
        if texplodable=2 and explosionscorch<>0
         rem not quite explode, just scorch (as though internally fried)
         tobj=entityelement(e).obj
         set blend mapping on tobj, 1, explosionscorch, 3, 6
         set object transparency tobj,0
        endif
       endif
      else
       rem obj not hidden, as phyobjectremove used
      endif
      `
     else
      rem entity character grunts in death
      tplrid=entityelement(e).fakeplayerid : tsnd=15
      tplrid=changeplrforsound(tplrid,tsnd)
      if playersound(tplrid,tsnd)>0
       playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
      endif
     endif
     `
     rem May trigger explosion if entity needs one
     if texplodable=1
      rem the visual and audio bang part
      frox#=entityelement(e).x : froy#=entityelement(e).y : froz#=entityelement(e).z
      gosub _part_triggerexplosion
      rem the force part
      spheredamage=entityelement(e).eleprof.explodedamage
      spherex#=frox# : spherey#=froy# : spherez#=froz#
      sphereforce#=1.0 : gosub _entity_addforcesphere
      rem characters disappear when they explode
      if entityprofile(tentid).ischaracter=1
       rem destroy object completely
       gosub _ode_switchoffe
       rem hide object
       tobj=entityelement(e).obj
       hide object tobj
       rem hide blob shadow if any
       if entityelement(e).attachmentblobobj>0
        if object exist(entityelement(e).attachmentblobobj)=1
         hide object entityelement(e).attachmentblobobj
        endif
       endif
       rem triggers the throwback scripts to skip, direct to destroy AI
       tresult=4
      endif
     endif
     `
    endif
    rem killing blows makes character fall!
    timpacttype=2
   else
    rem entity can sometimes shrug off a fall-over-hit
    if timpacttype=3
     rem flak reactions always thrown
     timpacttype=2
    else
     if timpacttype=2
      if entityelement(e).health>entityelement(e).eleprof.strength/2
       timpacttype=1
      else
       if rnd(3)=1 then timpacttype=1
      endif
     endif
    endif
    rem entity hurt
    tresult=1
    if entityprofile(tentid).ischaracter=1
     rem entity character grunts in hurt
     tplrid=entityelement(e).fakeplayerid : tsnd=12+rnd(2)
     tplrid=changeplrforsound(tplrid,tsnd)
     if playersound(tplrid,tsnd)>0
      playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,5.0)
     endif
     entityelement(e).darkai.ambushx#=tdamagex#
     entityelement(e).darkai.ambushz#=tdamagez#
     entityelement(e).darkai.ambushed=1 : rem instant attack
    endif
   endif
  endif
 else
  rem FLAK is always throwing
  if timpacttype=3 then timpacttype=2 : tresult=1
 endif
 `
 rem FPGC - 080710 - DarkAI characters CANNOT be thrown back (they mess up AI consistency, i.e. they move, rotate while lying on floor :)
 tobj=entityelement(e).obj
 `if tobj>0
  `if timpacttype=2 and ai entity exist(tobj)=1
   `timpacttype=1
  `endif
 `endif
 `
 rem play and sounds that are due (entity hurt, damage, destroy)
 gosub _ode_triggermaterialsound
 `
 rem play decal only if requested (set in _entity_completerayhit)
 if tuseentityowndecaldamage=1 then tuseentityowndecaldamage=0 : gosub _decal_triggermaterialdebris
 `
 rem if character, result translates as reaction
 if tresult>0
  tentid=entityelement(e).bankindex
  if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).animmax>0
   rem V110 BETA5 - 080608 - if exploded, straight to destroy script!
   if tresult=4
    aifile$=entityelement(e).eleprof.aidestroy$
    gosub _entity_setnewai
    rem FPGC - 220210 - any waypoint activity must stop right away
    entityelement(e).ai.waypoint.state=999
    entityelement(e).mover.moved=0
   else
    rem only if not already reacting
    if entityelement(e).ai.libindex=entityelement(e).ai.libmain or entityelement(e).ai.libindex=entityelement(e).ai.libshoot or tresult=3 or tresult=2
     if timpacttype=2
      `
      rem FPGC - 220210 - if RAGDOLL appears in DESTROY script name, go straight to DESTROY script (no throw anim!)
      tdestroyasragdoll=0
      tdestroyname$=lower$(entityelement(e).eleprof.aidestroy$)
      for tn=1 to len(entityelement(e).eleprof.aidestroy$)-7
       if left$(tdestroyname$,7)="ragdoll"
        tdestroyasragdoll=1
       endif
       tdestroyname$=right$(tdestroyname$,len(tdestroyname$)-1)
      next tn
      rem Hockeykid - 070611 - If we have more spawns we don't have the time to ragdoll! Just throw back until last spawnlife
      spawne=entityelement(e).spawn.leaderid
      if spawne>0
       if entityelement(spawne).spawn.upto>0 then tdestroyasragdoll=0
      endif
      if tresult=2 then tdestroyasragdoll=0
      `
      rem FPGC - 230210 - if shutgun style damage (throw to floor), but ragdoll, ignore
      rem FPGC - 160511 - if nothrowscript set, ALWAYS ignore throw script (MB)
      if (entityelement(e).health<=0 and entityprofile(tentid).nothrowscript=0) or (entityelement(e).health>0 and tresult=2)
       `if (entityelement(e).health>0 and timpacttype=2 and tdestroyasragdoll=1) or entityprofile(tentid).nothrowscript=1
       rem ignore
       rem Blast
       if tdestroyasragdoll=1 and object in screen(entityelement(e).obj)<>0
        aifile$="people\throwragdollback.fpi"
        if tdir=1 then aifile$="people\throwragdollback.fpi"
        if tdir=2 then aifile$="people\throwragdollfore.fpi"
        if tdir=3 then aifile$="people\throwragdollright.fpi"
        if tdir=4 then aifile$="people\throwragdollleft.fpi"
       else
        aifile$="people\throwback.fpi"
        if tdir=1 then aifile$="people\throwback.fpi"
        if tdir=2 then aifile$="people\throwfore.fpi"
        if tdir=3 then aifile$="people\throwleft.fpi"
        if tdir=4 then aifile$="people\throwright.fpi"
        if ai entity exist(entityelement(e).obj) then Gosub _ai_findlibindex : entityelement(e).darkai.throwing=libindex : ai set entity active entityelement(e).obj,0
       endif
       gosub _entity_setnewai
       `
       rem any waypoint activity must stop right away
       entityelement(e).ai.waypoint.state=999
       entityelement(e).mover.moved=0
      endif
      `
     endif
    endif
   endif
  else
   rem non-character reaction
   if tresult=3
    aifile$=entityelement(e).eleprof.aidestroy$
    gosub _entity_setnewai
   endif
  endif
 endif
 `
return

_entity_findplayerstartposition:

rem Scan present elements for player start markers
playerstartx#=0
playerstartlives=0
playerstartstrength=0
playerstarthasweapon=0
playerstarthasweaponqty=0
playerhurtfall=0
playerspeedratio#=1.0

for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives<>-1
  rem Player Start Marker
  if playerstartx#=0 or rnd(2)=0
   playerstartx#=entityelement(e).x
   playerstarty#=entityelement(e).y
   playerstartz#=entityelement(e).z
   playerstartrx#=0
   playerstartry#=entityelement(e).ry
   playerstartlives=entityelement(e).eleprof.lives
   playerstartstrength=entityelement(e).eleprof.strength
   playerstarthasweapon=entityelement(e).eleprof.hasweapon
   playerstarthasweaponqty=entityelement(e).eleprof.quantity
   playerhurtfall=entityelement(e).eleprof.hurtfall
   playerspeedratio#=entityelement(e).eleprof.speed/100.0
  endif
 endif
next e

rem FPSCV104 - make playerspeed reasonable - RC2 - min is now zero
if playerspeedratio#<0.0 then playerspeedratio#=0.0
if playerspeedratio#>2.0 then playerspeedratio#=2.0

rem if checkpoint, override position
if checkpointentity<>-1
 e=checkpointentity
 playerstartx#=entityelement(e).x
 playerstarty#=entityelement(e).y
 playerstartz#=entityelement(e).z
 playerstartrx#=0
 playerstartry#=entityelement(e).ry
endif

rem FPGC - 160909 - can now have infinite player lives and strength (zero)
`if playerstartlives=0 then playerstartlives=1
`if playerstartstrength=0 then playerstartstrength=100

rem Default settings
if playerhurtfall=0 then playerhurtfall=0 : rem FPGC - 150709 - default is NEVER GET HURT
if playerspeedratio#=0.0 then playerspeedratio#=1.0

rem If from level 2 onwards, replace player start details with current-save-state
if level>1
 playerstartlives=saveplayerstate.lives
 rem FPSXV10X - actually replaced the MAX health, naughty naughty
 `playerstartstrength=saveplayerstate.health
 weaponammoindex=saveplayerstate.weaponindexholding
 playerstarthasweapon=weaponslot(weaponammoindex).pref
endif

return

_entity_switchtostaticformultiplayer:
 `
 rem usually no physics as most dynamic entities are converted to static here for the construction process
 if gmultiplayergame=1
  for e=1 to entityelementlist
   if entityelement(e).staticflag=0
    entid=entityelement(e).bankindex
    if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0 and entityprofile(entid).ishealth=0
     if entityelement(e).eleprof.isimmobile=1
      rem door or window
      entityelement(e).eleprof.physics=3
     else
      rem something else
      entityelement(e).staticflag=1
      entityelement(e).eleprof.physics=0
     endif
    else
     rem weapon, ammo or character, or health
     entityelement(e).eleprof.physics=0
    endif
   endif
  next e
 endif
 `
return


rem
rem Artificial Intelegence Core
rem

_ai_setkeywords:

rem Set all condition keywords
dim conword$(AICONDLAST)
conword$(AICONDNEVER)="never"
conword$(AICONDALWAYS)="always"
conword$(AICONDSTATE)="state"
conword$(AICONDRANDOM)="random"
conword$(AICONDHEALTH)="health"
conword$(AICONDHEALTHLESS)="healthless"
conword$(AICONDHEALTHGREATER)="healthgreater"
conword$(AICONDQUANTITY)="quantity"
conword$(AICONDSPEED)="speed"
conword$(AICONDRATEOFFIRE)="rateoffire"
conword$(AICONDVAREQUAL)="varequal"
conword$(AICONDVARNOTEQUAL)="varnotequal"
conword$(AICONDVARGREATER)="vargreater"
conword$(AICONDVARLESS)="varless"
conword$(AICONDPLRHEALTHLESS)="plrhealthless"
conword$(AICONDPLRHEALTHGREATER)="plrhealthgreater"
conword$(AICONDLEVELEQUAL)="levelequal"
conword$(AICONDLEVELNOTEQUAL)="levelnotequal"
conword$(AICONDASSOCIATED)="playerassociated"
conword$(AICONDSHADERVARIABLE)="shadervariable"
conword$(AICONDSHADERVARIABLELESS)="shadervariableless"
conword$(AICONDSHADERVARIABLEGREATER)="shadervariablegreater"
conword$(AICONDPLRDISTWITHIN)="plrdistwithin"
conword$(AICONDPLRDISTFURTHER)="plrdistfurther"
conword$(AICONDPLRALIVE)="plralive"
conword$(AICONDPLRHIGHER)="plrhigher"
conword$(AICONDPLRELEVWITHIN)="plrelevwithin"
conword$(AICONDPLRELEVFURTHER)="plrelevfurther"
conword$(AICONDPLRFACING)="plrfacing"
conword$(AICONDPLRUNDERWATER)="plrunderwater"
conword$(AICONDUNDERWATER)="underwater"
conword$(AICONDPLRNOTFACING)="plrnotfacing"
conword$(AICONDANYWITHIN)="anywithin"
conword$(AICONDANYFURTHER)="anyfurther"
conword$(AICONDPLRCANBESEEN)="plrcanbeseen"
conword$(AICONDPLRCANNOTBESEEN)="plrcannotbeseen"
conword$(AICONDPLRHASKEY)="plrhaskey"
conword$(AICONDPLRUSINGACTION)="plrusingaction"
conword$(AICONDSHOTDAMAGE)="shotdamage"
conword$(AICONDIFWEAPON)="ifweapon"
conword$(AICONDSHOTDAMAGETYPE)="shotdamagetype"
conword$(AICONDCANTAKE)="cantake"
conword$(AICONDACTIVATED)="activated"
conword$(AICONDPLRWITHINZONE)="plrwithinzone"
conword$(AICONDENTITYWITHINZONE)="entitywithinzone"
conword$(AICONDPLRINGUNSIGHT)="plringunsight"
conword$(AICONDNEARACTIVATABLE)="nearactivatable"
conword$(AICONDNEWWEAPONCANBESEEN)="newweaponcanbeseen"
conword$(AICONDNOISEHEARD)="noiseheard"
conword$(AICONDANYWITHINZONE)="anywithinzone"
conword$(AICONDANYKEYWITHINZONE)="anykeywithinzone"
conword$(AICONDRAYCAST)="raycast"
conword$(AICONDRAYCASTUP)="raycastup"
conword$(AICONDRAYCASTBACK)="raycastback"
conword$(AICONDNORAYCASTUP)="noraycastup"
conword$(AICONDFRAMEATEND)="frameatend"
conword$(AICONDFRAMEATSTART)="frameatstart"
conword$(AICONDFRAMEWITHIN)="framewithin"
conword$(AICONDFRAMEBEYOND)="framebeyond"
conword$(AICONDANIMATIONOVER)="animationover"
conword$(AICONDALPHAFADEEQUAL)="alphafadeequal"
conword$(AICONDREACHTARGET)="reachtarget"
conword$(AICONDLOSETARGET)="losetarget"
conword$(AICONDHEADANGLEGREATER)="headanglegreater"
conword$(AICONDHEADANGLELESS)="headangleless"
conword$(AICONDSOUNDFINISHED)="soundfinished"
conword$(AICONDWAYPOINTSTATE)="waypointstate"
conword$(AICONDIFMARKER)="ifmarker"
conword$(AICONDIFPLRTRAIL)="ifplrtrail"
conword$(AICONDHUDSELECTIONMADE)="hudselectionmade"
conword$(AICONDTIMERGREATER)="timergreater"
conword$(AICONDESCAPEKEYPRESSED)="escapekeypressed"
conword$(AICONDSCANCODEKEYPRESSED)="scancodekeypressed"
conword$(AICONDHUDEDITDONE)="hudeditdone"
conword$(AICONDHUDHAVENAME)="hudhavename"
rem AirMod - New Conditions >>>
conword$(AICONDPLRBLOCKING)="plrblocking"
conword$(AICONDINVIEW)="inview"
conword$(AICONDPICKOBJECT)="pickobject"
conword$(AICONDVELOCITY)="velocitygreater"
rem AirMod - Done <<<
Rem Hockeykid - 250210 - added etimer
conword$(AICONDETIMERGREATER)="etimergreater"
Rem Hockeykid - 020310 - added keypressed
conword$(AICONDKEYPRESSED)="keypressed"
Rem Hockeykid - 170610 - New condition to detect if the entit has a weapon or not
conword$(AICONDHASWEAPON)="hasweapon"
Rem Hockeykid - 250210 - Dark AI start
conword$(AICONDDARKAISTRAFEL)="strafingleft"
conword$(AICONDDARKAISTRAFER)="strafingright"
conword$(AICONDDARKAIMOVINGF)="movingforwards"
conword$(AICONDDARKAIMOVINGB)="movingbackwards"
conword$(AICONDDARKAIIDLE)="idle"
conword$(AICONDDARKAICANSHOOT)="aicanshoot"
conword$(AICONDAIDUCKING)="ducking"
conword$(AICONDAIHEARDSOUND)="aiheardsound"
conword$(AICONDAIACTION)="aiaction"
conword$(AICONDAIISAI)="isdarkai"
conword$(AICONDAITEAM)="aiteam"
conword$(AICONDAIATPOINT)="aiatpoint"
conword$(AICONDAICALLED)="aicalled"
conword$(AICONDAITARGETDISTWITHIN)="aitargetdistwithin"
conword$(AICONDAITARGETDISTFURTHER)="aitargetdistfurther"
conword$(AICONDAIATCOVER)="aiatcover"
conword$(AICONDAICALLEDBYPLR)="aicalledbyplr"
conword$(AICONDAIHASTARGET)="aihastarget"
conword$(AICONDDARKAIRUNNINGF)="runningforwards"
rem Dark AI end
conword$(AICONDHUDSELECTED)="hudselected" : rem V118 - 110810 - knxrb - Hud Layers
rem V118 - 110810 - knxrb - Setup.ini Conditions
conword$(AICONDSETUPSHADER)="shadervar"
conword$(AICONDSETUPSHADOWS)="shadowsvar"
conword$(AICONDSETUPTEXQUALITY)="texqualityvar"
conword$(AICONDSETUPMOUSESENS)="mousesensitivityvar"
conword$(AICONDSETUPASPECTRATIO)="aspectratiovar"
conword$(AICONDSETUPPOSTPROCESSING)="postprocessingvar"
conword$(AICONDSETUPWIDTH)="widthvar"
conword$(AICONDSETUPHEIGHT)="heightvar"
conword$(AICONDSETUPDEPTH)="depthvar"
conword$(AICONDSETUPANTIALIAS)="antialiasvar"
conword$(AICONDSETUPMOUSEINVERT)="mouseinvertvar" : rem V118 - 130810 - knxrb - Invert Mouse
conword$(AICONDSETUPPARTICLESUSED)="particlesvar" : rem V118 - 140810 - knxrb - Disable Particles
conword$(AICONDSETUPAUTORES)="autoresvar" : rem V118 - 160810 - knxrb - Auto Resolution
rem V118 - 120810 - knxrb - 'mousestate=X' command
conword$(AICONDMOUSESTATE)="mousestate"
rem GUI-X9 (knxrb) >>>
conword$(AICONDHUDMOUSEDOWN)="hudmousedown"
conword$(AICONDHUDMOUSEUP)="hudmouseup"
conword$(AICONDHUDMOUSEOVER)="hudmouseover"
conword$(AICONDSAVEVISIBLE)="savegamevisible"
conword$(AICONDLOADVISIBLE)="loadgamevisible"
conword$(AICONDSTOPWATCHGREATER)="swgreater"
conword$(AICONDSTOPWATCHLESS)="swless"
conword$(AICONDSTOPWATCHRUNNING)="swrunning"
conword$(AICONDSETUPVAREQUAL)="svarequal"
conword$(AICONDCURSORIMAGE)="cursorimage"
conword$(AICONDCHOICEVALUEEQUAL)="choicevalueequal"
conword$(AICONDSLIDERVALUEEQUAL)="slidervalueequal"
rem GUI-X9 (knxrb) <<<
`
rem v118 - 110511 - cinematic hands (terry cox) >>>>
conword$(AICONDPREVENTEDSELECTINGGUN)="plrpreventedselectinggun"
rem cinematic hands <<<<

Rem Scene commander conditions
conword$(AICONDMOUSECONDITION)="mouseclick"
conword$(AICONDAIRGREATER)="airgreater"
conword$(AICONDAIRLESSER)="airlesser"
conword$(AICONDAIREQUAL)="airequal"
conword$(AICONDSAMEFLOORASPLR)="samefloorasplr"
conword$(AICONDPLRFLOOREQUAL)="plrfloorequal"
conword$(AICONDENTFLOOREQUAL)="entityfloorequal"
conword$(AICONDISIMMUNE)="plrimmune"
conword$(AICONDWEAPONSGREATER)="plrweaponsgreater"
conword$(AICONDWEAPONSLESSER)="plrweaponslesser"
conword$(AICONDWEAPONSEQUAL)="plrweaponsequal"
conword$(AICONDWEAPONINSLOT)="weaponinslot"
conword$(AICONDCURRENTWEAPON)="plrcurrentweapon"
Rem Scene Commander, V1.19 beta 2
conword$(AICONDPLRRUNNING)="plrrunning"
conword$(AICONDPLRNOTRUNNING)="plrnotrunning"
conword$(AICONDPLRCROUCHING)="plrcrouching"
conword$(AICONDPLRNOTCROUCHING)="plrnotcrouching"
conword$(AICONDZOOMED)="plrzoomed"
conword$(AICONDNOTZOOMED)="plrnotzoomed"
conword$(AICONDPLRUSINGRELOAD)="plrusingreload"
conword$(AICONDPLRONGROUND)="plronground"
conword$(AICONDPLRJUMPING)="plrjumping"
conword$(AICONDPLRNOTJUMPING)="plrnotjumping"
conword$(AICONDFIREMODE)="firemode"
conword$(AICONDONRADAR)="onradar"
conword$(AICONDLASTFIRED)="plrlastfired"
conword$(AICONDRADARGREATER)="radargreater"
conword$(AICONDRADAREQUAL)="radarequal"

conword$(AICONDENTITYPLRGREATER)="entityishigher"
conword$(AICONDENTITYPLRLESSER)="entityislower"

conword$(AICONDFLOORHIGHER)="entityfloorhigher"
conword$(AICONDFLOORLOWER)="entityfloorlower"

conword$(AICONDFLASHING)="flashing"
conword$(AICONDSPAWNSLEFT)="spawnsleft"
conword$(AICONDSPAWNSGREATER)="spawnsgreater"
conword$(AICONDSHOTBY)="damageby"
conword$(AICONDPLRNOTUSINGRELOAD)="plrnotusingreload"
conword$(AICONDNOTONRADAR)="notonradar"
conword$(AICONDPLRCARRYING)="plrcarrying"
conword$(AICONDPLRNOTCARRYING)="plrnotcarrying"
conword$(AICONDLASTDAMAGETIME)="damagetimegreater"
conword$(AICONDCURRENTJAMMED)="currentweaponjammed"
conword$(AICONDENTITYISIMMUNE)="entityimmune"
conword$(AICONDENTITYISNOTIMMUNE)="entitynotimmune"
conword$(AICONDPLRWEAPONIDLE)="plrweaponidle"
conword$(AICONDPLRWEAPONNOTIDLE)="plrweaponnotidle"
conword$(AICONDOBJECTRANGELESS)="objectiverangelesser"
conword$(AICONDOBJECTRANGEGREATER)="objectiverangegreater"
conword$(AICONDSOUNDPLAYING)="soundplaying"
conword$(AICONDSOUNDNOTPLAYING)="soundnotplaying"
conword$(AICONDWATEREQUAL)="waterequal"
conword$(AICONDWATERLESSER)="waterlesser"
conword$(AICONDWATERGREATER)="watergreater"
conword$(AICONDWATERISON)="waterison"
conword$(AICONDSHOTBYAMMO)="shotbyammo"
conword$(AICONDPLRFIRED)="plrfired"
conword$(AICONDPLRFIREDGREATER)="plrfiredgreater"
conword$(AICONDPLRFIREDLESSER)="plrfiredlesser"
conword$(AICONDSTATEGREATER)="stategreater"
conword$(AICONDSTATELESSER)="statelesser"
conword$(AICONDLMBGREATER)="lmbgreater"
conword$(AICONDLMBLESSER)="lmblesser"
conword$(AICONDRMBGREATER)="rmbgreater"
conword$(AICONDRMBLESSER)="rmblesser"

rem Set all action keywords
dim actword$(AIACTLAST)
actword$(AIACTNONE)="none"
actword$(AIACTDESTROY)="destroy"
actword$(AIACTSUSPEND)="suspend"
actword$(AIACTFLOORLOGIC)="floorlogic"
actword$(AIACTNOGRAVITY)="nogravity"
actword$(AIACTGLOBALVAR)="globalvar"
actword$(AIACTLOCALVAR)="localvar"
actword$(AIACTSETVAR)="setvar"
actword$(AIACTINCVAR)="incvar"
actword$(AIACTDECVAR)="decvar"
actword$(AIACTDIMVAR)="dimvar"
actword$(AIACTDIMLOCALVAR)="dimlocalvar"
actword$(AIACTADDVAR)="addvar"
actword$(AIACTSUBVAR)="subvar"
actword$(AIACTMULVAR)="mulvar"
actword$(AIACTDIVVAR)="divvar"
actword$(AIACTMODVAR)="modvar"
actword$(AIACTWRAPVAR)="wrapvar"
actword$(AIACTRUNFPIDEFAULT)="runfpidefault"
actword$(AIACTRUNFPI)="runfpi"
actword$(AIACTWIN)="win"
actword$(AIACTSELECTSHADERVARIABLE)="selectshadervariable"
actword$(AIACTSETSHADERVARIABLE)="setshadervariable"
actword$(AIACTINCSHADERVARIABLE)="incshadervariable"
actword$(AIACTDECSHADERVARIABLE)="decshadervariable"
actword$(AIACTSTATE)="state"
actword$(AIACTINCSTATE)="incstate"
actword$(AIACTMOVEUP)="moveup"
actword$(AIACTMOVEFORE)="movefore"
actword$(AIACTMOVEBACK)="moveback"
actword$(AIACTRUNFORE)="runfore"
actword$(AIACTFREEZE)="freeze"
actword$(AIACTROTATEY)="rotatey"
actword$(AIACTROTATEIY)="rotateiy"
actword$(AIACTNOROTATE)="norotate"
actword$(AIACTROTATETOPLR)="rotatetoplr"
actword$(AIACTRESETHEAD)="resethead"
actword$(AIACTROTATEHEAD)="rotatehead"
actword$(AIACTROTATEHEADRANDOM)="rotateheadrandom"
actword$(AIACTFORCEBACK)="forceback"
actword$(AIACTFORCEFORE)="forcefore"
actword$(AIACTFORCELEFT)="forceleft"
actword$(AIACTFORCERIGHT)="forceright"
actword$(AIACTFORCEBOUNCE)="forcebounce"
actword$(AIACTSPINRATE)="spinrate"
actword$(AIACTFLOATRATE)="floatrate"
actword$(AIACTSETFRAME)="setframe"
actword$(AIACTINCFRAME)="incframe"
actword$(AIACTDECFRAME)="decframe"
actword$(AIACTANIMATE)="animate"
actword$(AIACTADVFRAME)="advframe"
actword$(AIACTANIMATIONNORMAL)="animationnormal"
actword$(AIACTANIMATIONREVERSE)="animationreverse"
actword$(AIACTRAGDOLL)="ragdoll"
actword$(AIACTCARRYALL)="carryall"
actword$(AIACTPLRASS)="associateplayer"
actword$(AIACTPLRNOASS)="unassociateplayer"
actword$(AIACTPLRMOVEUP)="plrmoveup"
actword$(AIACTPLRMOVEDOWN)="plrmovedown"
actword$(AIACTPLRMOVEEAST)="plrmoveeast"
actword$(AIACTPLRMOVEWEST)="plrmovewest"
actword$(AIACTPLRMOVENORTH)="plrmovenorth"
actword$(AIACTPLRMOVESOUTH)="plrmovesouth"
actword$(AIACTPLRMOVETO)="plrmoveto"
actword$(AIACTPLRMOVEIFUSED)="plrmoveifused"
actword$(AIACTPLRFREEZE)="plrfreeze"
actword$(AIACTPLRDISABLE)="plrdisable"
actword$(AIACTACTIVATEIFUSED)="activateifused"
actword$(AIACTACTIVATEIFUSEDNEAR)="activateifusednear"
actword$(AIACTACTIVATETARGET)="activatetarget"
actword$(AIACTACTIVATEALLINZONE)="activateallinzone"
actword$(AIACTACTIVATE)="activate"
actword$(AIACTPLRADDHEALTH)="plraddhealth"
actword$(AIACTPLRSUBHEALTH)="plrsubhealth"
actword$(AIACTPLRSETHEALTH)="plrsethealth"
actword$(AIACTADDHEALTH)="addhealth"
actword$(AIACTSUBHEALTH)="subhealth"
actword$(AIACTSETHEALTH)="sethealth"
actword$(AIACTSETTARGET)="settarget"
actword$(AIACTROTATETOTARGET)="rotatetotarget"
actword$(AIACTLOOKATTARGET)="lookattarget"
actword$(AIACTMOVETOTARGET)="movetotarget"
actword$(AIACTCOLLECTTARGET)="collecttarget"
actword$(AIACTSETTARGETNAME)="settargetname"
actword$(AIACTCHOOSESTRAFE)="choosestrafe"
actword$(AIACTSTRAFE)="strafe"
actword$(AIACTPIVOTRANDOM)="pivotrandom"
actword$(AIACTLOOKATPLR)="lookatplr"
actword$(AIACTSOUND)="plrsound"
actword$(AIACT3DSOUND)="sound"
actword$(AIACTLOOPSOUND)="loopsound"
actword$(AIACTSTOPSOUND)="stopsound"
actword$(AIACTTALK)="talk"
actword$(AIACTTALKORDERED)="talkordered"
actword$(AIACTTALKRANDOM)="talkrandom"
actword$(AIACTALTTEXTURE)="alttexture"
actword$(AIACTSETALPHAFADE)="setalphafade"
actword$(AIACTINCALPHAFADE)="incalphafade"
actword$(AIACTDECALPHAFADE)="decalphafade"
actword$(AIACTRUNDECAL)="rundecal"
actword$(AIACTSHAPEDECAL)="shapedecal"
actword$(AIACTTRIGGERFORCE)="triggerforce"
actword$(AIACTWAYPOINTSTART)="waypointstart"
actword$(AIACTWAYPOINTSTOP)="waypointstop"
actword$(AIACTWAYPOINTREVERSE)="waypointreverse"
actword$(AIACTWAYPOINTNEXT)="waypointnext"
actword$(AIACTWAYPOINTPREV)="waypointprev"
actword$(AIACTWAYPOINTRANDOM)="waypointrandom"
actword$(AIACTDROPMARKER)="dropmarker"
actword$(AIACTNEXTMARKER)="nextmarker"
actword$(AIACTRESETMARKERS)="resetmarkers"
actword$(AIACTFOLLOWPLR)="followplr"
actword$(AIACTPLRTAKE)="playertake"
actword$(AIACTPLRDROP)="playerdrop"
actword$(AIACTPLRDROPCURRENT)="playerdropcurrent"
actword$(AIACTSHOOTPLR)="shootplr"
actword$(AIACTUSEWEAPON)="useweapon"
actword$(AIACTRELOADWEAPON)="reloadweapon"
actword$(AIACTCOLOFF)="coloff"
actword$(AIACTCOLON)="colon"
actword$(AIACTSPAWNON)="spawnon"
actword$(AIACTSPAWNOFF)="spawnoff"
actword$(AIACTHEADSHOT)="headshot"
actword$(AIACTHEADSHOTDAMAGE)="headshotdamage"
actword$(AIACTAMBIENCE)="ambience"
actword$(AIACTAMBIENCERED)="ambiencered"
actword$(AIACTAMBIENCEGREEN)="ambiencegreen"
actword$(AIACTAMBIENCEBLUE)="ambienceblue"
actword$(AIACTFOG)="fog"
actword$(AIACTFOGRED)="fogred"
actword$(AIACTFOGGREEN)="foggreen"
actword$(AIACTFOGBLUE)="fogblue"
`markblosser - add FOGSTART, FOGEND
actword$(AIACTFOGSTART)="fogstart"
actword$(AIACTFOGEND)="fogend"
`markblosser - add SETPOSTEFFECT
actword$(AIACTSETPOSTEFFECT)="setposteffect"
actword$(AIACTSKY)="sky"
actword$(AIACTSKYSCROLL)="skyscroll"
actword$(AIACTNEWJUMPHEIGHT)="newjumpheight"
actword$(AIACTBACKDROP)="backdrop"
actword$(AIACTMUSIC)="music"
actword$(AIACTMUSICOVERRIDE)="musicoverride"
actword$(AIACTMUSICVOLUME)="musicvolume"
actword$(AIACTSOUNDSCALE)="soundscale"
actword$(AIACTVIDEO)="video"
actword$(AIACTWEBLINK)="weblink"
actword$(AIACTEXPLODE)="explode"
actword$(AIACTLIGHTON)="lighton"
actword$(AIACTLIGHTOFF)="lightoff"
actword$(AIACTLIGHTRED)="lightred"
actword$(AIACTLIGHTGREEN)="lightgreen"
actword$(AIACTLIGHTBLUE)="lightblue"
actword$(AIACTLIGHTRANGE)="lightrange"
actword$(AIACTLIGHTINTENSITY)="lightintensity"
actword$(AIACTHUDUSERVAR)="huduservar"
actword$(AIACTHUDRESET)="hudreset"
actword$(AIACTHUDX)="hudx"
actword$(AIACTHUDY)="hudy"
actword$(AIACTHUDZ)="hudz"
actword$(AIACTHUDSIZEX)="hudsizex"
actword$(AIACTHUDSIZEY)="hudsizey"
actword$(AIACTHUDSIZEZ)="hudsizez"
actword$(AIACTHUDRED)="hudred"
actword$(AIACTHUDGREEN)="hudgreen"
actword$(AIACTHUDBLUE)="hudblue"
actword$(AIACTHUDIMAGE)="hudimage"
actword$(AIACTHUDIMAGEFINE)="hudimagefine"
actword$(AIACTHUDFONT)="hudfont"
actword$(AIACTHUDSIZE)="hudsize"
actword$(AIACTHUDTEXT)="hudtext"
actword$(AIACTHUDTYPE)="hudtype"
actword$(AIACTHUDHIDE)="hudhide"
actword$(AIACTHUDSHOW)="hudshow"
actword$(AIACTHUDUNSHOW)="hudunshow"
actword$(AIACTHUDNAME)="hudname"
actword$(AIACTHUDANIM)="hudanim"
actword$(AIACTHUDFADEOUT)="hudfadeout"
actword$(AIACTHUDMAKE)="hudmake"
actword$(AIACTNEWGAME)="newgame"
actword$(AIACTLOADGAME)="loadgame"
actword$(AIACTSAVEGAME)="savegame"
actword$(AIACTCONTINUEGAME)="continuegame"
actword$(AIACTQUITGAME)="quitgame"
actword$(AIACTPAUSEGAME)="pausegame"
actword$(AIACTRESUMEGAME)="resumegame"
actword$(AIACTHOSTGAME)="hostgame"
actword$(AIACTJOINGAME)="joingame"
actword$(AIACTREPEATGAME)="repeatgame"
actword$(AIACTTIMERSTART)="timerstart"
actword$(AIACTQUICKLOADGAME)="quickloadgame"
actword$(AIACTQUICKSAVEGAME)="quicksavegame"
rem AirMod - New Actions >>>
actword$(AIACTSETIFUSED)="setifused"
actword$(AIACTSETUSEKEY)="setusekey"
actword$(AIACTRESETPLRWEAPONS)="resetplrweapons"
actword$(AIACTBACKDROPVID)="backdropvideo"
actword$(AIACTBLOODSPURT)="bloodspurt"
actword$(AIACTNOBULLETCOL)="nobulletcol"
actword$(AIACTALTAMMO)="isaltammo"
actword$(AIACTBLOODSPLASH)="bloodsplash"
actword$(AIACTCAMSHAKE)="camshake"
actword$(AIACTCAMFOV)="camfov"
actword$(AIACTCAMFOVINC)="camfovinc"
actword$(AIACTHIDEWEAPON)="hideplrweapon"
actword$(AIACTSHOWLASTWEAPON)="showplrweapon"
actword$(AIACTCAMPOINTOBJECT)="plrpointatobject"
rem AirMod - Done <<<
actword$(AIACTSETUPDYNAMICSHADOWS)="setup_dynamicshadows"
actword$(AIACTSETUPUSEEFFECTS)="setup_useeffects"
actword$(AIACTSETUPDIVIDETEXTURESIZE)="setup_dividetexturesize"
actword$(AIACTSETUPMOUSESENSITIVITY)="setup_mousesensitivity"
actword$(AIACTSETUPASPECTRATIO)="setup_aspectratio"
actword$(AIACTSETUPPOSTPROCESSING)="setup_postprocessing"
actword$(AIACTSETUPWIDTH)="setup_width"
actword$(AIACTSETUPHEIGHT)="setup_height"
actword$(AIACTSETUPDEPTH)="setup_depth"
actword$(AIACTSETUPANTIALIAS)="setup_antialias"
actword$(AIACTSETUPMOUSEINVERT)="setup_mouseinvert" : rem V118 - 130810 - knxrb - Invert Mouse
actword$(AIACTSETUPPARTICLESUSED)="setup_particles" : rem V118 - 140810 - knxrb - Disable Particles
actword$(AIACTSETUPAUTORES)="setup_autores" : rem V118 - 160810 - knxrb - Auto Resolution
actword$(AIACTRESET)="reset"
actword$(AIACTSAVESETUP)="savesetup"
actword$(AIACTPASSTOSETUP)="passtosetup"
actword$(AIACTFPGCRAWTEXTR)="fpgcrawtextr"
actword$(AIACTFPGCRAWTEXTG)="fpgcrawtextg"
actword$(AIACTFPGCRAWTEXTB)="fpgcrawtextb"
actword$(AIACTFPGCRAWTEXTX)="fpgcrawtextx"
actword$(AIACTFPGCRAWTEXTY)="fpgcrawtexty"
actword$(AIACTFPGCRAWTEXTSIZE)="fpgcrawtextsize"
actword$(AIACTFPGCRAWTEXTFONT)="fpgcrawtextfont"
actword$(AIACTFPGCRAWTEXTOFF)="fpgcrawtextoff"
actword$(AIACTFPGCRAWTEXT)="fpgcrawtext"
actword$(AIACTETIMERSTART)="etimerstart"
Rem Hockeykid - 250210 - Dark AI commands
actword$(AIACTADDAITEAM)="addaiteam"
actword$(AIACTAIALLYFOLLOW)="allyfollow"
actword$(AIACTAISETTARGET)="aisettarget"
actword$(AIACTAIMOVERANDOM)="aimoverandom"
actword$(AIACTAIREMOVE)="airemove"
actword$(AIACTAIMOVEMENT)="allowmove"
actword$(AIACTAIACTIVE)="setaiactive"
actword$(AIACTTOGGLEACTIVE)="alwaysactive"
actword$(AIACTAIACTION)="aiaction"
actword$(AIACTAIFOLLOWPLR)="aifollowplr"
actword$(AIACTAIMOVETOSOUND)="aimovetosound"
actword$(AIACTAIMOVEAWAYFROMSOUND)="aimoveawayfromsound"
actword$(AIACTAIADDPOINT)="aiaddpoint"
actword$(AIACTAIGOTOPOINT)="aigotopoint"
actword$(AIACTAICALLTEAM)="aicallteam"
actword$(AIACTAIRESPONDTOCALL)="airespondtocall"
actword$(AIACTAIMOVETOCOVER)="aimovetocover"
actword$(AIACTAIMOVETOTARGET)="aimovetotarget"
actword$(AIACTAISTOP)="aistop"
actword$(AIACTAIUSEMELEE)="aiusemelee"
actword$(AIACTAISETMELEEDAMAGE)="aisetmeleedamage"
actword$(AIACTAIROTATETOTARGET)="airotatetotarget"
actword$(AIACTAIROTATEY)="airotatey"
actword$(AIACTAILOOKAROUND)="ailookaround"
actword$(AIACTAIROTATETOSOUND)="airotatetosound"
actword$(AIACTAIPLRCALLTEAM)="aiplrcallteam"
actword$(AIACTAISETSPEED)="aisetspeed"
actword$(AIACTAIRESPONDTOPLAYER)="airespondtoplrcall"
actword$(AIACTAITOGLLEATTACK)="aiattackawareness"
actword$(AIACTAICLEARTARGET)="aicleartarget"
actword$(AIACTAIENABLEFULLAIM)="aiusefullaim"
actword$(AIACTAIEYELEVEL)="aiseteyelevel"
actword$(AIACTAIADDALLY)="aiaddally"
actword$(AIACTAIADDENEMY)="aiaddenemy"
actword$(AIACTAIADDNEUTRAL)="aiaddneutral"
actword$(AIACTAIAUTOFACTIONOFF)="aiautofactionoff"
actword$(AIACTAISETVIEWRANGE)="aisetviewrange"
actword$(AIACTHUDLAYER)="hudlayer" : rem V118 - 110810 - knxrb - Hud Layers
actword$(AIACTSETHUDXPOS)="sethudxpos" : rem V118 - 160810 - knxrb - Hud - sethudx Command
actword$(AIACTNEXTLEVEL)="nextlevel"
rem GUI-X9 (knxrb) >>>
actword$(AIACTLOADIMAGE)="loadimage"
actword$(AIACTMAKEHUD)="makehud"
actword$(AIACTSETHUDX)="sethudx"
actword$(AIACTSETHUDY)="sethudy"
actword$(AIACTSETHUDW)="sethudw"
actword$(AIACTSETHUDH)="sethudh"
actword$(AIACTSETHUDCOLOUR)="sethudcolour"
actword$(AIACTSETHUDCOLOR)="sethudcolor"
actword$(AIACTSETHUDALPHA)="sethudalpha"
actword$(AIACTSETHUDNIMAGE)="sethudnimage"
actword$(AIACTSETHUDOIMAGE)="sethudoimage"
actword$(AIACTMAKECHECKBOX)="makecheckbox"
actword$(AIACTSETCHECKBOXX)="setcheckboxx"
actword$(AIACTSETCHECKBOXY)="setcheckboxy"
actword$(AIACTSETCHECKBOXW)="setcheckboxw"
actword$(AIACTSETCHECKBOXH)="setcheckboxh"
actword$(AIACTSETCHECKBOXCOLOUR)="setcheckboxcolour"
actword$(AIACTSETCHECKBOXCOLOR)="setcheckboxcolor"
actword$(AIACTSETCHECKBOXALPHA)="setcheckboxalpha"
actword$(AIACTSETCHECKBOXNIMAGE)="setcheckboxnimage"
actword$(AIACTSETCHECKBOXCIMAGE)="setcheckboxcimage"
actword$(AIACTSETCHECKBOXSTATE)="setcheckboxchecked"
actword$(AIACTMAKESLIDER)="makeslider"
actword$(AIACTSETSLIDERX)="setsliderx"
actword$(AIACTSETSLIDERY)="setslidery"
actword$(AIACTSETSLIDERW)="setsliderw"
actword$(AIACTSETSLIDERH)="setsliderh"
actword$(AIACTSETSLIDERCOLOUR)="setslidercolour"
actword$(AIACTSETSLIDERCOLOR)="setslidercolor"
actword$(AIACTSETSLIDERALPHA)="setslideralpha"
actword$(AIACTSETSLIDERVALUE)="setslidervalue"
actword$(AIACTMAKECHOICE)="makechoice"
actword$(AIACTSETCHOICEX)="setchoicex"
actword$(AIACTSETCHOICEY)="setchoicey"
actword$(AIACTSETCHOICEW)="setchoicew"
actword$(AIACTSETCHOICEH)="setchoiceh"
actword$(AIACTSETCHOICECOLOUR)="setchoicecolour"
actword$(AIACTSETCHOICECOLOR)="setchoicecolor"
actword$(AIACTSETCHOICEALPHA)="setchoicealpha"
actword$(AIACTADDCHOICESTATE)="addchoicevalue"
actword$(AIACTSETCHOICESTATE)="setchoicevalue"
actword$(AIACTSETCURSOR)="setcursor"
actword$(AIACTHIDEALL)="hideall"
actword$(AIACTREPLACEIMAGE)="replaceimage"
actword$(AIACTSHOWHUD)="showhud"
actword$(AIACTHIDEHUD)="hidehud"
actword$(AIACTSHOWCURSOR)="showcursor"
actword$(AIACTHIDECURSOR)="hidecursor"
actword$(AIACTCLEARGUI)="resetgui"
actword$(AIACTMAKESTOPWATCH)="makesw"
actword$(AIACTSTARTSTOPWATCH)="startsw"
actword$(AIACTSTOPSTOPWATCH)="stopsw"
actword$(AIACTMAKESETUPVAR)="makesvar"
actword$(AIACTSETSETUPVARVALUE)="setsvarvalue"
actword$(AIACTSETSETUPVARLINE)="setsvarline"
actword$(AIACTREADSETUPVARVALUE)="readsetupline"
actword$(AIACTSAVESETUPVARS)="savesvars"
actword$(AIACTSETHUDCLICKABLE)="hudclickable"
actword$(AIACTSETSETUPTOCOMP)="setsvartogui"
actword$(AIACTSHOWCHOICE)="showchoice"
actword$(AIACTHIDECHOICE)="hidechoice"
actword$(AIACTSHOWSLIDER)="showslider"
actword$(AIACTHIDESLIDER)="hideslider"
actword$(AIACTSHOWCHECKBOX)="showcheckbox"
actword$(AIACTHIDECHECKBOX)="hidecheckbox"
actword$(AIACTSETHUDNUMERIC)="sethudnumeric"
actword$(AIACTSETHUDVALUE)="sethudvalue"
actword$(AIACTEYEHURTTIME)="eyehudtime"
actword$(AIACTFADERSPEED)="faderspeed"
actword$(AIACTUSEGUIX9)="usegui"
rem GUI-X9 (knxrb) <<<
actword$(AIACTHIDESHADOW)="hideshadow"
Rem Water
actword$(AIACTWATERHEIGHT)="waterheight"
actword$(AIACTWATER)="water"
actword$(AIACTWATERFOGDIST)="waterfogdist"
actword$(AIACTWATERSPEED)="waterspeed"
actword$(AIACTWATERFOGRED)="waterfogred"
actword$(AIACTWATERFOGGREEN)="waterfoggreen"
actword$(AIACTWATERFOGBLUE)="waterfogblue"
actword$(AIACTWATERRED)="waterred"
actword$(AIACTWATERGREEN)="watergreen"
actword$(AIACTWATERBLUE)="waterblue"
actword$(AIACTWATERHEIGHTOFZONE)="waterheightofzone"
Rem Scene commander, water performance options
actword$(AIACTWATERFLEC)="waterreflection"
rem LightRay Addition
rem LRMod
actword$(AIACTLRAYSET)="lrayset"
actword$(AIACTLRAYACT)="lrayactive"
actword$(AIACTLRBLOOMACT)="bloomactive"
actword$(AIACTLRDEBUGDEACTIVE)="lrdebugdeactive"

rem GUI-X9 (knxrb) <>>><
actword$(AIACTFORCEGUISUB)="updategui"
rem GUI-X9 (knxrb) <<<

rem v118 - 110511 - cinematic hands (terry cox) >>>>
actword$(AIACTDISABLEFIREBUTTON)="disablefirebutton"
actword$(AIACTSTARTCINEMATICHANDS)="startcinematichands"
actword$(AIACTPREVENTPLAYERSELECTINGGUN)="preventplrselectinggun"
actword$(AIACTGETNEWWEAPON)="getcinematichands"
actword$(AIACTREMOVECURRENTWEAPON)="removecurrentweapon"
actword$(AIACTDISABLEBLOCKINGBUTTON)="disablecinematichandsbutton"
rem cinematic hands <<<<
rem set entiy speed (markblosser)
actword$(AIACTSETENTITYSPEED)="setentityspeed"
rem set animate command speed (markblosser)
actword$(AIACTSETANIMATESPEED)="setanimatespeed"

rem Scene Commander actions
actword$(AIACTWOBBLE)="plrwobble"
actword$(AIACTTILTON)="plrdeath"
actword$(AIACTTILTSPEED)="plrdeathspeed"
actword$(AIACTTILTBOUNCE)="plrdeathbounce"
actword$(AIACTUNSKIP)="playfullvideo"
actword$(AIACTPLRACTION)="plraction"
actword$(AIACTFORCEMOVE)="plrforcemove"
actword$(AIACTEMITFORCE)="emitforce"
actword$(AIACTFORCEDAMAGEON)="forcedamageon"
actword$(AIACTCROSSHAIRON)="crosshair"
actword$(AIACTWEAPONTOSLOT)="weapontoslot"
actword$(AIACTARMON)="armon"
actword$(AIACTARMADD)="arminc"
actword$(AIACTARMDEC)="armdec"
actword$(AIACTARMX)="setarmx"
actword$(AIACTARMY)="setarmy"
actword$(AIACTSETARM)="setarm"
actword$(AIACTAIRON)="airon"
actword$(AIACTADDAIR)="addair"
actword$(AIACTAIRTIME)="setairtime"
actword$(AIACTDROWNTIME)="setdrowntime"
actword$(AIACTAIRMAX)="setairmax"
actword$(AIACTSETAIR)="setair"
actword$(AIACTSETAIRX)="setairx"
actword$(AIACTSETAIRY)="setairy"
actword$(AIACTINSTANTDROWN)="instantdrown"
actword$(AIACTIMMUNE)="plrsetimmune"
actword$(AIACTARROWON)="arrowkeys"
actword$(AIACTCROUCHON)="crouchkey"
actword$(AIACTPEEKON)="peekkey"
actword$(AIACTJUMPON)="jumpkey"
actword$(AIACTWALKON)="walkkeys"
actword$(AIACTRUNON)="runkeys"
actword$(AIACTFORCEDAMAGE)="setforcedamage"
actword$(AIACTCOMPASSON)="compasson"
actword$(AIACTCOMPASSOFF)="compassoff"
actword$(AIACTCOMPASSX)="compassx"
actword$(AIACTCOMPASSY)="compassy"
actword$(AIACTCOMPASSSPIN)="compassspin"
actword$(AIACTNEEDLESPIN)="needlespin"
actword$(AIACTRADAR)="radaron"
actword$(AIACTRADARX)="radarx"
actword$(AIACTRADARY)="radary"
actword$(AIACTRADARROTATE)="rotateblip"
actword$(AIACTRADARRANGE)="radarrange"
actword$(AIACTSPEEDMOD)="plrspeedmod"
actword$(AIACTADDFPGCRAWTEXT)="addrawtext"
actword$(AIACTSETOBJECTIVE)="setisobjective"
actword$(AIACTSETOBJECTIVEX)="setobjectivex"
actword$(AIACTSETOBJECTIVEY)="setobjectivey"
actword$(AIACTOBJECTIVEMODE)="setobjectivemode"
actword$(AIACTSETVARRND)="setvarrnd"
actword$(AIACTRANDOMIZE)="randomize"
actword$(AIACTMAXSLOTS)="setmaxweapons"
actword$(AIACTEDAMMULT)="entitydamagemult"
actword$(AIACTPLRSTRENGTH)="plrstrength"

actword$(AIACTCULLRANGE)="cullrange"
actword$(AIACTCULLMODE)="cullmode"
actword$(AIACTHIDEOBJ)="hide"
actword$(AIACTSHOWOBJ)="show"
actword$(AIACTCULLMODI)="cullmod"

actword$(AIACTFOOTFALL)="plrfootfall"
actword$(AIACTSWAPALT)="swaptoalt"
actword$(AIACTROTATEPLRX)="plrrotatex"
actword$(AIACTROTATEPLRY)="plrrotatey"
actword$(AIACTENTROTX)="entrotatex"
actword$(AIACTENTROTY)="entrotatey"
actword$(AIACTENTROTZ)="entrotatez"
actword$(AIACTMOVEPLRX)="moveplrx"
actword$(AIACTMOVEPLRY)="moveplry"
actword$(AIACTMOVEPLRZ)="moveplrz"
actword$(AIACTSCALE)="scale"
actword$(AIACTHOLSTER)="holster"
actword$(AIACTNOAIR)="globalnoair"
actword$(AIACTSETDROWNDAMAGE)="setnoairdamage"
actword$(AIACTPLRPICKON)="plrpickon"
actword$(AIACTPLRPICKRANGE)="plrpickrange"
actword$(AIACTFLASH)="emitflash"
actword$(AIACTFLASHRED)="setflashred"
actword$(AIACTFLASHGREEN)="setflashgreen"
actword$(AIACTFLASHBLUE)="setflashblue"
actword$(AIACTFLASHRANGE)="setflashrange"
actword$(AIACTLOGICBURST)="logicburst"
actword$(AIACTPLRDAM)="plrdamagemult"
actword$(AIACTDESTROYIN)="timedestroy"
actword$(AIACTSETLISTKEY)="setlistkey"
actword$(AIACTRAWTEXTVAR)="addrawvar"
actword$(AIACTSIN)="sin"
actword$(AIACTCOS)="cos"
actword$(AIACTSCALEHUDX)="scalehudx"
actword$(AIACTSCALEHUDY)="scalehudy"
actword$(AIACTCHANGEHUDALPHA)="changehudalpha"
actword$(AIACTWATERFLOW)="waterflow"
actword$(AIACTWATERCURRENT)="watercurrent"
actword$(AIACTREMOVEWEAPON)="removeplrweapon"
actword$(AIACTGIVEWEAPON)="giveplrweapon"
actword$(AIACTENTITYSETIMMUNE)="entitysetimmune"
actword$(AIACTRESETONRELOAD)="resetglobalsonload"
actword$(AIACTENTITYCAM)="entitycam"
actword$(AIACTPLAYERCAM)="plrcam"
actword$(AIACTLASTCAM)="lastcam"
actword$(AIACTCUSTGUNANIM)="playgunanimation"
actword$(AIACTUSEENTROT)="camrotationon"
actword$(AIACTSETCAMOFFSETX)="setcamoffsetx"
actword$(AIACTSETCAMOFFSETY)="setcamoffsety"
actword$(AIACTSETCAMOFFSETZ)="setcamoffsetz"
actword$(AIACTSETCAMROTX)="setcamrotx"
actword$(AIACTSETCAMROTY)="setcamroty"
actword$(AIACTSETCAMROTZ)="setcamrotz"
actword$(AIACTSCALELIMB)="scalelimb"
actword$(AIACTHIDELIMB)="hidelimb"
actword$(AIACTSHOWLIMB)="showlimb"
actword$(AIACTPLAYPRESET)="presetgunanimation"
actword$(AIACTLOCKEMPLACEMENT)="lockemplacement"
actword$(AIACTFREEEMPLACEMENT)="freeemplacement"
actword$(AIACTCULLIMMOBILE)="cullevenifimmobile"
actword$(AIACTPLRACC)="plraccuracymult"
actword$(AIACTENTITYACC)="entityaccuracymult"
actword$(AIACTDEBUGCURSOR)="debugcursor"
actword$(AIACTDEBUGVAR)="debugvar"
actword$(AIACTDEBUGTEXT)="debugtext"
actword$(AIACTWIREFRAME)="wireframe"
actword$(AIACTPLAYEROFFSETON)="plrcamoffseton"
actword$(AIACTPLAYEROFFSETX)="plrcamoffsetx"
actword$(AIACTPLAYEROFFSETY)="plrcamoffsety"
actword$(AIACTPLAYEROFFSETZ)="plrcamoffsetz"
actword$(AIACTMUTATE)="mutate"
actword$(AIACTOBJECTRANGE)="setobjectiverange"
actword$(AIACTLINKTOPLAYER)="linktoplr"
actword$(AIACTFREEFROMPLAYER)="freefromplr"
actword$(AIACTALWAYSRUN)="plralwaysrun"
actword$(AIACTOBJMET)="objmet"
actword$(AIACTLINKENTITYROTX)="linkxrotation"
actword$(AIACTLINKENTITYROTY)="linkyrotation"
actword$(AIACTLINKENTITYROTZ)="linkzrotation"
actword$(AIACTPLROFFSETANGLEX)="plroffsetanglex"
actword$(AIACTPLROFFSETANGLEY)="plroffsetangley"
actword$(AIACTPLROFFSETANGLEZ)="plroffsetanglez"
actword$(AIACTENTITYOFFSETANGLEX)="offsetanglex"
actword$(AIACTENTITYOFFSETANGLEY)="offsetangley"
actword$(AIACTENTTIYOFFSETANGLEZ)="offsetanglez"
actword$(AIACTSHOWWEAPON)="swapplrweapon"
actword$(AIACTNOSELECT)="lockslot"
actword$(AIACTDELAYTIMER)="setdamagedelay"
actword$(AIACTCREATESPLASHSOUND)="createbulletsplashsound"
actword$(AIACTSHOWFLAK)="showflakexplosion"
actword$(AIACTMAKEVIDEOTEXTURE)="makevideotexture"
actword$(AIACTUSEVIDEOTEXTURE)="usevideotexture"
actword$(AIACTDELETEVIDEOTEXTURE)="deletevideotexture"
actword$(AIACTPAUSEVIDEOTEXTURE)="pausevideotexture"
actword$(AIACTRESUMEVIDEOTEXTURE)="resumevideotexture"
actword$(AIACTVIDEOTEXTURESPEED)="setvideotexturespeed"
actword$(AIACTVIDEOTEXTUREVOLUME)="setvideotexturevolume"
actword$(AIACTSTOPVIDEOTEXTURE)="stopvideotexture"
actword$(AIACTSETBULLETCOL)="setbulletcoloff"
actword$(AIACTSYNCRATE)="setsyncrate"
actword$(AIACTFLASHLIGHT)="flashlight"
actword$(AIACTFLASHLIGHTRED)="flashlightred"
actword$(AIACTFLASHLIGHTGREEN)="flashlightgreen"
actword$(AIACTFLASHLIGHTBLUE)="flashlightblue"
actword$(AIACTFLASHLIGHTRANGE)="flashlightrange"
actword$(AIACTUSEFADE)="usefade"
actword$(AIACTSHOWAIR)="alwaysshowair"
actword$(AIACTDELAYDESTROY)="delaydestroy"

return

_ai_reset_presaveposition:

rem V109BETA5 - reset globals on new game
rem V113BETA4 - only reset GLOBALs BEFORE loading a saved position
if resetonreload=1
for n=0 to 99 : aiglobals(n)=0 : next n
endif

return

_ai_reset:

rem Reset counters
actstringmax=0
conindexcount=0
aicondseqcount=0
actindexcount=0
aiactseqcount=0
hudmax=0

return

_ai_stopentsounds:
 `
 rem stop any looping sound
 if entityelement(e).firesoundloop>0 then stop sound entityelement(e).firesoundloop
 entityelement(e).firesoundloop=0
 rem and entity sounds
 if entityelement(e).soundset>0
  if sound exist(entityelement(e).soundset)=1 then stop sound entityelement(e).soundset
 endif
 if entityelement(e).soundset1>0
  if sound exist(entityelement(e).soundset1)=1 then stop sound entityelement(e).soundset1
 endif
 if entityelement(e).soundlooping>0
  if sound exist(entityelement(e).soundlooping)=1 then stop sound entityelement(e).soundlooping
  entityelement(e).soundlooping=0
 endif
 `
return

_ai_control:

if aiindex>0
 if ai entity exist(entityelement(e).obj) and entityelement(e).darkai.throwing>0 and entityelement(e).darkai.throwing<>aiindex then entityelement(e).darkai.throwing=0 : ai set entity active entityelement(e).obj,entityelement(e).darkai.active
 `
 rem used to update timestamps if resumegame happens
 tensureentitytimestampsupdated=0
 `
 if gshowdebugtextingamestate=1
  if debugviewtog=1
   if entityelement(e).priorityai<>0 then ink rgb(255,255,255),0
   print upper$(entityelement(e).eleprof.name$)
   if entityelement(e).priorityai<>0 then ink rgb(128,255,128),0
  endif
 endif
 `
 rem Go through all triggers
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  `
  rem Result of condition
  dw as DWORD : dw=0
  airesult=1
  `
  rem Process conditions in 'conindex' (all have to be true)
  aiconttimer as DWORD : aiconttimer=0
  for seq=aicond(conindex).first to aicond(conindex).last
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     if aiconditionseq(seq).type>10 or aiconttimer<>0
      if aiconttimer=0 then print " : ";
      if aiconttimer<>0 then print ", ";
      if aiconttimer=0 then aiconttimer=timer()
      print conword$(aiconditionseq(seq).type)+"("+str$(aiconditionseq(seq).valuea)+","+str$(aiconditionseq(seq).valueb)+")";
     endif
    endif
   endif

  rem Plystire - This will allow the engine to replace variable names with the value of the variable
  if left$(aiconditionseq(seq).string1,1)="%"
   rem Find the variable being called for and replace valuea with it's value
   tuvar$=right$(aiconditionseq(seq).string1,len(aiconditionseq(seq).string1)-1)
   tfound=0
   for uvar=0 to array count(uservars(0))
    if uservars(uvar).name=tuvar$ and uservars(uvar).used=1
     rem found the variable
     tfound=1
     aiconditionseq(seq).valuea=uservars(uvar).value
     exit
    endif
   next uvar
   `
   if tfound=0
    for lvar = 0 to 99
     if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name=tuvar$ and aiuserlocals(e,lvar).used=1
      rem Found the variable, let's add to it
      aiconditionseq(seq).valuea=aiuserlocals(e,lvar).value
      rem And Exit the For loop
      tfound=1
      exit
     endif
    next lvar
   endif
   `
   rem if we didn't find the value, give it a 0
   if tfound=0 then aiconditionseq(seq).valuea=0
  endif
  if left$(aiconditionseq(seq).string2,1)="%"
   rem Find the variable being called for and replace valuea with it's value
   tuvar$=right$(aiconditionseq(seq).string2,len(aiconditionseq(seq).string2)-1)
   tfound=0
   for uvar=0 to array count(uservars(0))
    if uservars(uvar).name=tuvar$ and uservars(uvar).used=1
     rem found the variable
     tfound=1
     aiconditionseq(seq).valueb=uservars(uvar).value
     exit
    endif
   next uvar
   `
   if tfound=0
    for lvar = 0 to 99
     if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name=tuvar$ and aiuserlocals(e,lvar).used=1
      rem Found the variable, let's add to it
      aiconditionseq(seq).valueb=aiuserlocals(e,lvar).value
      rem And Exit the For loop
      tfound=1
      exit
     endif
    next lvar
   endif
   `
   rem if we didn't find the value, give it a 0
   if tfound=0 then aiconditionseq(seq).valueb=0
  endif
  rem Plystire - This section will allow the engine to replace certain tags with important engine variables
  select aiconditionseq(seq).string1
   case "$PH"
    aiconditionseq(seq).valuea=player(1).health
   endcase
   case "$PL"
    aiconditionseq(seq).valuea=player(1).lives
   endcase
   case "$RA"
    aiconditionseq(seq).valuea=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$A"
    aiconditionseq(seq).valuea=-1
    if gunid<>0
     aiconditionseq(seq).valuea=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$RCA"
    aiconditionseq(seq).valuea=weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$CA"
    aiconditionseq(seq).valuea=-1
    if gunid<>0
     aiconditionseq(seq).valuea=weaponammo(weaponammoindex+ammooffset)
    endif
    endcase
    case "$CLA"
    aiconditionseq(seq).valuea=-1
    if gunid<>0
     aiconditionseq(seq).valuea=weaponclipammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$EH"
    aiconditionseq(seq).valuea=entityelement(e).health
   endcase
   case "$EA"
    aiconditionseq(seq).valuea=entityelement(e).currentammo
   endcase
   case "$EPX"
    aiconditionseq(seq).valuea=entityelement(e).x
   endcase
   case "$EPY"
    aiconditionseq(seq).valuea=entityelement(e).y
   endcase
   case "$EPZ"
    aiconditionseq(seq).valuea=entityelement(e).z
   endcase
   case "$EAX"
    aiconditionseq(seq).valuea=entityelement(e).rx
   endcase
   case "$EAY"
    aiconditionseq(seq).valuea=entityelement(e).ry
   endcase
   case "$EAZ"
    aiconditionseq(seq).valuea=entityelement(e).rz
   endcase
   case "$CAX"
    aiconditionseq(seq).valuea=camera angle x(0)
   endcase
   case "$CAY"
    aiconditionseq(seq).valuea=camera angle y(0)
   endcase
   case "$CAZ"
    aiconditionseq(seq).valuea=camera angle z(0)
   endcase
   case "$CPX"
    aiconditionseq(seq).valuea=camera position x(0)
   endcase
   case "$CPY"
    aiconditionseq(seq).valuea=camera position y(0)
   endcase
   case "$CPZ"
    aiconditionseq(seq).valuea=camera position z(0)
   endcase
   case "$MMX"
    aiconditionseq(seq).valuea=dcamx#
   endcase
   case "$MMY"
    aiconditionseq(seq).valuea=dcamy#
   endcase
   case "$MMZ"
    aiconditionseq(seq).valuea=dcamz#
   endcase
Rem Scene Commander
    case "$ARM"
    aiconditionseq(seq).valuea=armour
    endcase
    case "$AIR"
    aiconditionseq(seq).valuea=airleft
    endcase
    case "$FPS"
   aiconditionseq(seq).valuea=screen fps()
   endcase
   case "$WAT"
   aiconditionseq(seq).valuea=waterheight#
   endcase
   case "$MAX"
   aiconditionseq(seq).valuea=maxslots
   endcase

   case "$DIS"

   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiconditionseq(seq).valuea=plrdistance#

   endcase

   case "$DIF"

   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiconditionseq(seq).valuea=(plrdistance#/100)*8.33

   endcase

   case "$DIM"

   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    aiconditionseq(seq).valuea=(plrdistance#/100)*2.54

   endcase

  endselect
  `
  select aiconditionseq(seq).string2
   case "$PH"
    aiconditionseq(seq).valueb=player(1).health
   endcase
   case "$PL"
    aiconditionseq(seq).valueb=player(1).lives
   endcase
   case "$RA"
    aiconditionseq(seq).valueb=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$A"
    aiconditionseq(seq).valueb=-1
    if gunid<>0
     aiconditionseq(seq).valueb=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$RCA"
    aiconditionseq(seq).valueb=weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$CA"
    aiconditionseq(seq).valueb=-1
    if gunid<>0
     aiconditionseq(seq).valueb=weaponammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$CLA"
    aiconditionseq(seq).valuea=-1
    if gunid<>0
     aiconditionseq(seq).valueb=weaponclipammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$EH"
    aiconditionseq(seq).valueb=entityelement(e).health
   endcase
   case "$EA"
    aiconditionseq(seq).valueb=entityelement(e).currentammo
   endcase
   case "$EPX"
    aiconditionseq(seq).valueb=entityelement(e).x
   endcase
   case "$EPY"
    aiconditionseq(seq).valueb=entityelement(e).y
   endcase
   case "$EPZ"
    aiconditionseq(seq).valueb=entityelement(e).z
   endcase
   case "$EAX"
    aiconditionseq(seq).valueb=entityelement(e).rx
   endcase
   case "$EAY"
    aiconditionseq(seq).valueb=entityelement(e).ry
   endcase
   case "$EAZ"
    aiconditionseq(seq).valueb=entityelement(e).rz
   endcase
   case "$CAX"
    aiconditionseq(seq).valueb=camera angle x(0)
   endcase
   case "$CAY"
    aiconditionseq(seq).valueb=camera angle y(0)
   endcase
   case "$CAZ"
    aiconditionseq(seq).valueb=camera angle z(0)
   endcase
   case "$CPX"
    aiconditionseq(seq).valueb=camera position x(0)
   endcase
   case "$CPY"
    aiconditionseq(seq).valueb=camera position y(0)
   endcase
   case "$CPZ"
    aiconditionseq(seq).valueb=camera position z(0)
   endcase
   case "$MMX"
    aiconditionseq(seq).valueb=dcamx#
   endcase
   case "$MMY"
    aiconditionseq(seq).valueb=dcamy#
   endcase
   case "$MMZ"
    aiconditionseq(seq).valueb=dcamz#
   endcase
Rem Scene Commander
    case "$ARM"
    aiconditionseq(seq).valueb=armour
    endcase
    case "$AIR"
    aiconditionseq(seq).valueb=airleft
    endcase
    case "$FPS"
   aiconditionseq(seq).valueb=screen fps()
   endcase
   case "$WAT"
   aiconditionseq(seq).valueb=waterheight#
   endcase
   case "$MAX"
   aiconditionseq(seq).valueb=maxslots
   endcase
   case "$DIS"
tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiconditionseq(seq).valueb=plrdistance#
   endcase
   case "$DIF"
tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiconditionseq(seq).valueb=(plrdistance#/100)*8.33
   endcase
   case "$DIM"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    aiconditionseq(seq).valueb=(plrdistance#/100)*2.54
   endcase

  endselect
   `
   select aiconditionseq(seq).type
    case AICONDNEVER: airesult=0 : endcase
    case AICONDALWAYS: airesult=airesult : endcase
    case AICONDSTATE:
     conda$=entityelement(e).ai.state$
     condb$=aiconditionseq(seq).string1
     if conda$<>condb$ then airesult=0
    endcase
    case AICONDRANDOM:
     conda=aiconditionseq(seq).valuea
     if rnd(conda)>0 then airesult=0
    endcase
    case AICONDHEALTH:
     conda=entityelement(e).health
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDHEALTHLESS:
     conda=entityelement(e).health
     condb=aiconditionseq(seq).valuea
     if conda>=condb then airesult=0
    endcase
    case AICONDHEALTHGREATER:
     conda=entityelement(e).health
     condb=aiconditionseq(seq).valuea
     if conda<=condb then airesult=0
    endcase
    case AICONDQUANTITY:
     conda=entityelement(e).eleprof.quantity
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDSPEED:
     conda=entityelement(e).eleprof.speed
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDRATEOFFIRE:
     condb=entityelement(e).eleprof.rateoffire
     if condb<=0
      airesult=0
     else
      if condb>=100
       rem always fire
      else
       if rnd(100-condb)>0 then airesult=0
      endif
     endif
    endcase
    `
    case AICONDVAREQUAL:
     rem Plystire 109 - Merging the variable conditions into one
     if aiconditionseq(seq).string2=""
      tindex=aivariableindex
      if aivariablemode=0
       conda=aiglobals(tindex)
      else
       conda=ailocals(e,tindex)
      endif
      condb=aiconditionseq(seq).valuea
      if conda<>condb then airesult=0
     else
      rem Use the better system ;)
      if left$(aiconditionseq(seq).string1,1)<>"$" and left$(aiconditionseq(seq).string1,1)<>"%"
       if asc(left$(aiconditionseq(seq).string1,1))<asc("0") or asc(left$(aiconditionseq(seq).string1,1))>asc("9")
        tvarfound=0
        rem Let's find the variable we need to check
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).used = 1
          if uservars(uvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = uservars(uvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next uvar
        `
        rem Let's find the variable we need to check
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).used = 1
          if aiuserlocals(e,lvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = aiuserlocals(e,lvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next lvar
        `
       else
        conda = aiconditionseq(seq).valuea
       endif
      else
       conda = aiconditionseq(seq).valuea
      endif
      rem Now check the values
      if conda <> aiconditionseq(seq).valueb then airesult=0
      rem If we couldn't find the variable, then fail the condition
      if tvarfound=0 then airesult = 0
     endif
    endcase
    case AICONDVARNOTEQUAL:
     rem Plystire 109 - Merging the variable conditions into one
     if aiconditionseq(seq).string2=""
      tindex=aivariableindex
      if aivariablemode=0
       conda=aiglobals(tindex)
      else
       conda=ailocals(e,tindex)
      endif
      condb=aiconditionseq(seq).valuea
      if conda=condb then airesult=0
     else
      rem Use the better system ;)
      if left$(aiconditionseq(seq).string1,1)<>"$" and left$(aiconditionseq(seq).string1,1)<>"%"
       if asc(left$(aiconditionseq(seq).string1,1))<asc("0") or asc(left$(aiconditionseq(seq).string1,1))>asc("9")
        tvarfound=0
        rem Let's find the variable we need to check
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).used = 1
          if uservars(uvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = uservars(uvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next uvar
        `
        rem Let's find the variable we need to check
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).used = 1
          if aiuserlocals(e,lvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = aiuserlocals(e,lvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next lvar
        `
       else
        conda = aiconditionseq(seq).valuea
       endif
      else
       conda = aiconditionseq(seq).valuea
      endif
      rem Now check the values
      if conda = aiconditionseq(seq).valueb then airesult=0
      rem If we couldn't find the variable, then fail the condition
      if tvarfound=0 then airesult = 0
     endif
    endcase
    case AICONDVARGREATER:
     rem Plystire 109 - Merging the variable conditions into one
     if aiconditionseq(seq).string2=""
      tindex=aivariableindex
      if aivariablemode=0
       conda=aiglobals(tindex)
      else
       conda=ailocals(e,tindex)
      endif
      condb=aiconditionseq(seq).valuea
      if conda<=condb then airesult=0
     else
      rem Use the better system ;)
      if left$(aiconditionseq(seq).string1,1)<>"$" and left$(aiconditionseq(seq).string1,1)<>"%"
       if asc(left$(aiconditionseq(seq).string1,1))<asc("0") or asc(left$(aiconditionseq(seq).string1,1))>asc("9")
        tvarfound=0
        rem Let's find the variable we need to check
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).used = 1
          if uservars(uvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = uservars(uvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next uvar
        `
        rem Let's find the variable we need to check
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).used = 1
          if aiuserlocals(e,lvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = aiuserlocals(e,lvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next lvar
        `
       else
        conda = aiconditionseq(seq).valuea
       endif
      else
       conda = aiconditionseq(seq).valuea
      endif
      rem Now check the values
      if conda < aiconditionseq(seq).valueb then airesult=0
      rem If we couldn't find the variable, then fail the condition
      if tvarfound=0 then airesult = 0
     endif
    endcase
    case AICONDVARLESS:
     rem Plystire 109 - Merging the variable conditions into one
     if aiconditionseq(seq).string2=""
      tindex=aivariableindex
      if aivariablemode=0
       conda=aiglobals(tindex)
      else
       conda=ailocals(e,tindex)
      endif
      condb=aiconditionseq(seq).valuea
      if conda>=condb then airesult=0
     else
      rem Use the better system ;)
      if left$(aiconditionseq(seq).string1,1)<>"$" and left$(aiconditionseq(seq).string1,1)<>"%"
       if asc(left$(aiconditionseq(seq).string1,1))<asc("0") or asc(left$(aiconditionseq(seq).string1,1))>asc("9")
        rem Let's find the variable we need to check
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).used = 1
          if uservars(uvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = uservars(uvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next uvar
        `
        rem Let's find the variable we need to check
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).used = 1
          if aiuserlocals(e,lvar).name = aiconditionseq(seq).string1
           rem Found it, now let's check it
           conda = aiuserlocals(e,lvar).value
           rem And Exit the For Loop
           tvarfound=1
           exit
          endif
         endif
        next lvar
        `
       else
        conda = aiconditionseq(seq).valuea
       endif
      else
       conda = aiconditionseq(seq).valuea
      endif
      rem Now check the values
      if conda > aiconditionseq(seq).valueb then airesult=0
      rem If we couldn't find the variable, then fail the condition
      if tvarfound=0 then airesult = 0
     endif
    endcase
    `
    case AICONDPLRHEALTHLESS:
     conda=player(1).health
     condb=aiconditionseq(seq).valuea
     if conda>=condb then airesult=0
    endcase
    case AICONDPLRHEALTHGREATER:
     conda=player(1).health
     condb=aiconditionseq(seq).valuea
     if conda<=condb then airesult=0
    endcase
    `
    case AICONDLEVELEQUAL:
     conda=level
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDLEVELNOTEQUAL:
     conda=level
     condb=aiconditionseq(seq).valuea
     if conda=condb then airesult=0
    endcase
    `
    case AICONDSHADERVARIABLE:
     conda=entityshadervar(e,globalselectedshadervar)
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDSHADERVARIABLELESS:
     conda=entityshadervar(e,globalselectedshadervar)
     condb=aiconditionseq(seq).valuea
     if conda>=condb then airesult=0
    endcase
    case AICONDSHADERVARIABLEGREATER:
     conda=entityshadervar(e,globalselectedshadervar)
     condb=aiconditionseq(seq).valuea
     if conda<=condb then airesult=0
    endcase
    `
    case AICONDPLRDISTWITHIN:
     conda#=dist#
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDPLRDISTFURTHER:
     conda#=dist#
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDPLRALIVE:
     conda=player(1).health
     if conda<1 then conda=0
     if conda>1 then conda=1
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDPLRHIGHER:
     conda#=disty#
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDPLRELEVWITHIN:
     tmpy#=(entityelement(e).y+45.0)-mey#
     conda#=abs(atanfull(dist#,tmpy#)-90)
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDPLRELEVFURTHER:
     tmpy#=(entityelement(e).y+45.0)-mey#
     conda#=abs(atanfull(dist#,tmpy#)-90)
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDPLRFACING:
     tmp=aiconditionseq(seq).valuea
     if tmp=0 then tmp=35
     tmpx#=entityelement(e).x-mex#
     tmpz#=entityelement(e).z-mez#
     rem FPGC - 100310 - adjust actual viewing angle with VR tracker
     tmpcamy#=camera angle y()
     if gvrmode<>0 then tmpcamy#=tmpcamy#-vrmodetrackery#
     tentitya#=wrapvalue(atanfull(tmpx#,tmpz#))-tmpcamy#
     tentitya#=wrapvalue(tentitya#)
     `if tentitya#<0.0 then tentitya#=tentitya#+360.0
     `if tentitya#>=360.0 then tentitya#=tentitya#-360.0
     if (tentitya#>0-tmp and tentitya#<0+tmp) or (tentitya#>360-tmp and tentitya#<360+tmp)
      airesult=1
      rem player facing entity
     else
      airesult=0
     endif
    endcase
    `
    case AICONDPLRNOTFACING:
     tmp=aiconditionseq(seq).valuea
     if tmp=0 then tmp=35
     tmpx#=entityelement(e).x-mex#
     tmpz#=entityelement(e).z-mez#
     rem FPGC - 100310 - adjust actual viewing angle with VR tracker
     tmpcamy#=camera angle y()
     if gvrmode<>0 then tmpcamy#=tmpcamy#-vrmodetrackery#
     tentitya#=wrapvalue(atanfull(tmpx#,tmpz#))-tmpcamy#
     tentitya#=wrapvalue(tentitya#)
     `if tentitya#<0.0 then tentitya#=tentitya#+360.0
     `if tentitya#>=360.0 then tentitya#=tentitya#-360.0
     if (tentitya#>0-tmp and tentitya#<0+tmp) or (tentitya#>360-tmp and tentitya#<360+tmp)
      rem player facing entity
      airesult=0
     else
      airesult=1
     endif
    endcase
    `
    case AICONDPLRUNDERWATER:
     if wateron=1
      conda=aiconditionseq(seq).valuea
      if conda=0 and playerunderwater=1 then airesult=0
      if conda=1 and playerunderwater=0 then airesult=0
     endif
    endcase
    case AICONDUNDERWATER:
     if wateron=1
      conda=aiconditionseq(seq).valuea
      tactualtopofobject#=object position y(entityelement(e).obj)+(object size y(entityelement(e).obj)/2.0)
      if conda=0 and tactualtopofobject#<waterheight# then airesult=0
      if conda=1 and tactualtopofobject#>waterheight# then airesult=0
     endif
    endcase
    `
    case AICONDANYWITHIN:
     tokay=0
     condx=entityelement(e).x/25
     condy=entityelement(e).y/100
     condz=entityelement(e).z/-25
     condb=aiconditionseq(seq).valuea/25
     for taix=(condb*-1) to condb
      for taiz=(condb*-1) to condb
       if condx+taix>=0 and condx+taix<=viscolx
        if condz+taiz>=0 and condz+taiz<=viscolz
         tte=viscolmap(condx+taix,condy,condz+taiz)
         if tte<>0
          if tte>0
           ttentid=entityelement(tte).bankindex
           if entityprofile(ttentid).ischaracter=1
            tokay=1
           endif
          else
           rem FPSCV105RC2 - only player (-1), not void blocks (-2)
           if tte=-1
            tokay=1
           endif
          endif
         endif
        endif
       endif
      next taiz
     next taix
     if tokay=0 then airesult=0
    endcase
    case AICONDANYFURTHER:
     tokay=0
     condx=entityelement(e).x/25
     condy=entityelement(e).y/100
     condz=entityelement(e).z/-25
     condb=aiconditionseq(seq).valuea/25
     for taix=(condb*-1) to condb
      for taiz=(condb*-1) to condb
       if condx+taix>=0 and condx+taix<=viscolx
        if condz+taiz>=0 and condz+taiz<=viscolz
         tte=viscolmap(condx+taix,condy,condz+taiz)
         if tte<>0
          if tte>0
           ttentid=entityelement(tte).bankindex
           if entityprofile(ttentid).ischaracter=1
            tokay=1
           endif
          else
           rem FPSCV105RC2 - only player (-1), not void blocks (-2)
           if tte=-1
            tokay=1
           endif
          endif
         endif
        endif
       endif
      next taiz
     next taix
     if tokay=1 then airesult=0
    endcase
    case AICONDPLRCANBESEEN:
     if (player(1).lives=0 and playerstartlives>0) or (player(1).health=0 and playerstartstrength>0)
      airesult=0
     else
      entityelement(e).mover.viewconeused=10
      tdiffangle#=diffangle#-entityelement(e).ai.headangle
      conda#=abs(tdiffangle#-entityelement(e).mover.da)
      if conda#>180 then conda#=360-conda#
      conda#=abs(conda#)
      condb#=entityelement(e).eleprof.coneangle
      if entityelement(e).eleprof.coneangle=0 then condb#=361
      if conda#>=condb#
       airesult=0
      else
       if obj=0
        airesult=0
       else
        if entityprofile(entid).headlimb<>-1
         tmpx#=limb position x(obj,entityprofile(entid).headlimb)
         tmpy#=limb position y(obj,entityprofile(entid).headlimb)
         tmpz#=limb position z(obj,entityprofile(entid).headlimb)
        else
         tmpx#=object position x(obj)
         tmpy#=object position y(obj)+55.0
         tmpz#=object position z(obj)
        endif
        tvisibility=0 : gosub _player_determinevisibility
        if tvisibility=1
         rem vertical angle of sight
         tconda#=atanfull(dist#,tmpy#-mey#)-90
         tcondb#=aiconditionseq(seq).valuea
         if tcondb#=0 then tcondb#=22
         if tconda#<tcondb#
          inc gameperfentities2
          rem new intermitent raycast
          tokaystate=entityelement(e).raycastlaststate
          if entityelement(e).raycastcount<=0
           entityelement(e).raycastlaststate=static raycast(tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
           entityelement(e).raycastcount=15
          else
           entityelement(e).raycastcount=entityelement(e).raycastcount-1
          endif
          if tokaystate=0
           if tvisibilityifbreak>0
            rem must shoot transparent obstacle to player sighting!
            entityelement(e).possibletarget=1+tvisibilityifbreak
           else
            rem clean shot to player
            entityelement(e).possibletarget=1
           endif
          else
           airesult=0
          endif
         else
          airesult=0
         endif
        else
         airesult=0
        endif
       endif
      endif
     endif
    endcase
    case AICONDPLRCANNOTBESEEN:
     if (player(1).lives>0 or playerstartlives=0) and (player(1).health>0 or playerstartstrength=0)
      entityelement(e).mover.viewconeused=10
      tdiffangle#=diffangle#-entityelement(e).ai.headangle
      conda#=abs(tdiffangle#-entityelement(e).mover.da)
      if conda#>180 then conda#=360-conda#
      conda#=abs(conda#)
      condb#=entityelement(e).eleprof.coneangle
      if conda#<condb#
       if obj=0
        airesult=0
       else
        if entityprofile(entid).headlimb<>-1
         tmpx#=limb position x(obj,entityprofile(entid).headlimb)
         tmpy#=limb position y(obj,entityprofile(entid).headlimb)
         tmpz#=limb position z(obj,entityprofile(entid).headlimb)
        else
         tmpx#=object position x(obj)
         tmpy#=object position y(obj)+55.0
         tmpz#=object position z(obj)
        endif
        tvisibility=0 : gosub _player_determinevisibility
        if tvisibility=1
         tconda#=atanfull(dist#,tmpy#-mey#)-90
         tcondb#=aiconditionseq(seq).valuea
         if tcondb#=0 then tcondb#=22
         if tconda#<tcondb#
          inc gameperfentities2
          rem new intermitent raycast
          tokaystate=entityelement(e).raycastlaststate
          if entityelement(e).raycastcount<=0
           entityelement(e).raycastlaststate=static raycast(tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
           entityelement(e).raycastcount=15
          else
           entityelement(e).raycastcount=entityelement(e).raycastcount-1
          endif
          if tokaystate=0
           airesult=0
          endif
         endif
        endif
       endif
      endif
     endif
    endcase
    case AICONDPLRHASKEY:
     gosub _entity_playerhavekey
     conda=aiconditionseq(seq).valuea
     if tokay<>conda then airesult=0
    endcase
    case AICONDPLRUSINGACTION:
     gplayercanpressenterhere=1
     conda=aiconditionseq(seq).valuea
     condb=player(1).usingaction
     if conda<>condb then airesult=0
    endcase
    `
    case AICONDSHOTDAMAGE:
     conda=aiconditionseq(seq).valuea
     condb=entityelement(e).shotdamage
     if condb>0 and condb>conda
      entityelement(e).possibletarget=1+entityelement(e).shotdamagesource
     else
      airesult=0
     endif
     entityelement(e).shotdamage=0
     entityelement(e).shotdamagesource=0
    endcase
    case AICONDIFWEAPON:
     conda=aiconditionseq(seq).valuea
     if entityelement(e).fireweapon=0
      tokay=0 : tgunid=entityelement(e).currentweapon
      if tgunid>0
       if entityelement(e).currentammo>0 or firemode(tgunid,0).settings.reloadqty=0
        tokay=1
       endif
      endif
      if conda=0 and tokay=1 then airesult=0
      if conda=1 and tokay=0 then airesult=0
     else
      airesult=0
     endif
    endcase
    case AICONDSHOTDAMAGETYPE:
     conda=aiconditionseq(seq).valuea
     condb=entityelement(e).shotdamagetype
     if condb=conda
      entityelement(e).possibletarget=1+entityelement(e).shotdamagesource
      entityelement(e).shotdamagetype=0
     else
      airesult=0
     endif
    endcase
    case AICONDCANTAKE:
     tokay=1
     if entityprofile(entid).ishealth>0
      rem check if NEED it, single player says do not waste
      if gmultiplayergame=0
       if player(1).health>=playerstartstrength
        tokay=0
       endif
      endif
     endif
     if tokay=0 then airesult=0
    endcase
    `
    case AICONDACTIVATED:
     conda=aiconditionseq(seq).valuea
     condb=entityelement(e).activated
     if conda<>condb then airesult=0
    endcase
    case AICONDPLRWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     tokay=0
     if mex#<condx1 then tokay=1
     if mey#<condy1 then tokay=1
     if mez#>condz1 then tokay=1
     if mex#>condx2 then tokay=1
     if mey#>condy2 then tokay=1
     if mez#<condz2 then tokay=1
     conda=aiconditionseq(seq).valuea
     if tokay<>conda
      rem player is within zone
      mi=entityelement(e).eleprof.isobjective : if mi>0 then playerobjective(mi)=1
     else
      airesult=0
     endif
    endcase
    case AICONDENTITYWITHINZONE:
     rem If I push a crate into the trigger zone, then detect for that CRATE
     rem TODO - if find one, set it as the TARGET
    endcase
    case AICONDPLRINGUNSIGHT:
     conda#=abs(diffangle#-entityelement(e).mover.da)
     if conda#>180 then conda#=360-conda#
     conda#=abs(conda#)
     if conda#>=5 then airesult=0
    endcase
    case AICONDNEARACTIVATABLE:
     tokay=0
     for tae=1 to entityelementlist
      if entityelement(tae).active=1
       if entityelement(tae).activated=aiconditionseq(seq).valuea
        cdistx#=entityelement(tae).x-entityelement(e).x
        cdisty#=entityelement(tae).y-entityelement(e).y
        cdistz#=entityelement(tae).z-entityelement(e).z
        cdist#=sqrt(abs(cdistx#*cdistx#)+abs(cdisty#*cdisty#)+abs(cdistz#*cdistz#))
        if cdist#<70.0
         tokay=1 : entityelement(e).possibletarget=1+tae
         tae=entityelementlist+1 : exit
        endif
       endif
      endif
     next tae
     if tokay=0 then airesult=0
    endcase
    `
    case AICONDNEWWEAPONCANBESEEN:
     tentitytype=1 : gosub _entity_conescanforentity
     tplrid=entityelement(e).fakeplayerid
     if tfounde>0 and tplrid>0
      tgunbestdamage=0
      for pint=1 to player(tplrid).inventorymax
       te=playerinventory(tplrid,pint).index
       tentid=entityelement(te).bankindex
       tgunid=entityprofile(tentid).isweapon
       if tgunid>0
        if firemode(tgunid,0).settings.damage>tgunbestdamage then tgunbestdamage=firemode(tgunid,0).settings.damage
       endif
      next pint
      tokay=0
      tent2id=entityelement(tfounde).bankindex
      tgun2id=entityprofile(tent2id).isweapon
      if tgun2id>0
       if firemode(tgun2id,0).settings.damage>tgunbestdamage then tokay=1
      endif
      if tokay=1 then entityelement(e).possibletarget=1+tfounde
      if tokay=0 then airesult=0
     else
      airesult=0
     endif
    endcase
    `
    case AICONDNOISEHEARD:
     if bcsoundstrength#>0
      conda=aiconditionseq(seq).valuea
      cdistx#=bcsoundx#-entityelement(e).x
      cdisty#=bcsoundy#-entityelement(e).y
      cdistz#=bcsoundz#-entityelement(e).z
      cdist#=sqrt(abs(cdistx#*cdistx#)+abs(cdisty#*cdisty#)+abs(cdistz#*cdistz#))
      if cdist#>50.0
       rem not too close (as this would be itself making the noise)
       if bcsoundstrength#*10>cdist#
        rem heard something (-1 is sound coord target)
        entityelement(e).possibletarget=-1
       else
        airesult=0
       endif
      else
       airesult=0
      endif
     else
      airesult=0
     endif
    endcase
    `
    case AICONDANYWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     conda=aiconditionseq(seq).valuea
     condfound=0
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1
       tokay=0
       if entityelement(te).x<condx1 then tokay=1
       if entityelement(te).y<condy1 then tokay=1
       if entityelement(te).z>condz1 then tokay=1
       if entityelement(te).x>condx2 then tokay=1
       if entityelement(te).y>condy2 then tokay=1
       if entityelement(te).z<condz2 then tokay=1
       if tokay=0
        condfound=te : exit
       endif
      endif
     next te
     if conda=1
      if condfound=0
       airesult=0
      endif
     else
      if condfound<>0
       airesult=0
      endif
     endif
    endcase
    case AICONDANYKEYWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     conda=aiconditionseq(seq).valuea
     condfound=0
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1
       tokay=0
       if entityelement(te).x<condx1 then tokay=1
       if entityelement(te).y<condy1 then tokay=1
       if entityelement(te).z>condz1 then tokay=1
       if entityelement(te).x>condx2 then tokay=1
       if entityelement(te).y>condy2 then tokay=1
       if entityelement(te).z<condz2 then tokay=1
       if tokay=0
        if lower$(entityelement(te).eleprof.name$)=lower$(entityelement(e).eleprof.usekey$)
         condfound=te : exit
        endif
       endif
      endif
     next te
     if conda=1
      if condfound=0
       airesult=0
      endif
     else
      if condfound<>0
       airesult=0
      endif
     endif
    endcase
    `
    case AICONDFRAMEATEND:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframefinish : condb#=tactualframe
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEATSTART:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframestart : condb#=tactualframe
       if conda#>condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEWITHIN:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       conda=aiconditionseq(seq).valuea
       condb#=aiconditionseq(seq).valueb/100.0
       tbaseframe=conda : gosub _entity_getactualframefinish : condc#=tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condc#=condc#-tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condb#=tactualframe+(condc#*condb#)
       if conda#>condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEBEYOND:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       conda=aiconditionseq(seq).valuea
       condb#=aiconditionseq(seq).valueb/100.0
       tbaseframe=conda : gosub _entity_getactualframefinish : condc#=tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condc#=condc#-tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condb#=tactualframe+(condc#*condb#)
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    case AICONDANIMATIONOVER:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframefinish : condb#=tactualframe-5.0
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    `
    case AICONDREACHTARGET:
     te=entityelement(e).actualtarget-1
     if te>0
      tdistx#=entityelement(te).x-entityelement(e).x
      tdistz#=entityelement(te).z-entityelement(e).z
     else
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
     endif
     conda#=sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))
     condb#=aiconditionseq(seq).valuea
     if conda#>=5.0 then airesult=0
    endcase
    case AICONDLOSETARGET:
     conda=entityelement(e).losttargetcount
     condb=aiconditionseq(seq).valuea
     if conda<condb then airesult=0
    endcase
    `
    case AICONDHEADANGLEGREATER:
     conda#=entityelement(e).ai.headangle
     condb#=aiconditionseq(seq).valuea
     if conda#<condb# then airesult=0
    endcase
    case AICONDHEADANGLELESS:
     conda#=entityelement(e).ai.headangle
     condb#=aiconditionseq(seq).valuea
     if conda#>condb# then airesult=0
    endcase
    `
    case AICONDSOUNDFINISHED:
     conda#=0
     if entityelement(e).soundlooping>0
      if sound playing(entityelement(e).soundlooping)=1 then conda#=1
     endif
     condb#=aiconditionseq(seq).valuea
     if condb#=1
      if conda#=1 then airesult=0
     else
      if conda#=0 then airesult=0
     endif
    endcase
    `
    case AICONDRAYCAST:
    remstart
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj)
      tmpy#=object position y(obj)
      tmpz#=object position z(obj)
      tmpx1#=tmpx#
      tmpz1#=tmpz#
      tmpheight#=40
      tnorm#=abs(entityelement(e).force.ix)+abs(entityelement(e).force.iz)
      tvx#=entityelement(e).force.ix/tnorm#
      tvz#=entityelement(e).force.iz/tnorm#
      tvel#=aiconditionseq(seq).valueb
      tmpx2#=tmpx#+(tvx#*tvel#)
      tmpz2#=tmpz#+(tvz#*tvel#)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if tmpy#>-50
       if static raycast(tmpx1#,tmpy#+tmpheight#,tmpz1#,tmpx2#,tmpy#+tmpheight#,tmpz2#)=0 then airesult=0
      endif
     endif
     remend

     Rem Scene Commander, replaced RAYCAST code to fix reported false reporting error. Thanks to Terry for fix.
      if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      tmpa#=object angle y(obj) : tmpheight#=50
      conda#=aiconditionseq(seq).valuea
      condb#=aiconditionseq(seq).valueb
      tmpx1#=tmpx#+(sin(tmpa#)*conda#)
      tmpz1#=tmpz#+(cos(tmpa#)*conda#)
      tmpx2#=tmpx#+(sin(tmpa#)*condb#)
      tmpz2#=tmpz#+(cos(tmpa#)*condb#)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy#+tmpheight#,tmpz1#,tmpx2#,tmpy#+tmpheight#,tmpz2#)=0 then airesult=0
     endif
    endcase
    case AICONDRAYCASTUP:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if tmpy#>-50
       if static raycast(tmpx#,tmpy#+aiconditionseq(seq).valuea,tmpz#,tmpx#,tmpy#+aiconditionseq(seq).valueb,tmpz#)=0 then airesult=0
      endif
     endif
    endcase
    case AICONDRAYCASTBACK:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      tmpa#=object angle y(obj) : tmpheight#=50
      conda#=aiconditionseq(seq).valuea*-1
      condb#=aiconditionseq(seq).valueb*-1
      tmpx1#=tmpx#+(sin(tmpa#)*conda#)
      tmpz1#=tmpz#+(cos(tmpa#)*conda#)
      tmpx2#=tmpx#+(sin(tmpa#)*condb#)
      tmpz2#=tmpz#+(cos(tmpa#)*condb#)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy#+tmpheight#,tmpz1#,tmpx2#,tmpy#+tmpheight#,tmpz2#)=0 then airesult=0
     endif
    endcase
    case AICONDNORAYCASTUP:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if static raycast(tmpx#,tmpy#+aiconditionseq(seq).valuea,tmpz#,tmpx#,tmpy#+aiconditionseq(seq).valueb,tmpz#)<>0 then airesult=0
      if tmpy#<-50 then airesult=0
     endif
    endcase
    case AICONDALPHAFADEEQUAL:
     conda#=entityelement(e).ai.alphafade
     condb#=aiconditionseq(seq).valuea
     if conda#<>condb# then airesult=0
    endcase
    case AICONDWAYPOINTSTATE:
     conda=entityelement(e).ai.waypoint.state
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    `
    case AICONDIFMARKER:
     conda=entitybreadcrumbs(e,0).x
     condb=aiconditionseq(seq).valuea
     if condb=0 and conda>0 then airesult=0
     if condb=1 and conda=0 then airesult=0
    endcase
    case AICONDIFPLRTRAIL:
     rem player trail!
     conda=0
     condb=aiconditionseq(seq).valuea
     if condb=0 and conda>0 then airesult=0
     if condb=1 and conda=0 then airesult=0
    endcase
    `
    `
    case AICONDHUDSELECTIONMADE:
     conda=aiconditionseq(seq).valuea
     if conda>0
      if hudselectionmade<>conda then airesult=0 else hudselectionmade=0
     else
      if hudselectionmade=0 then airesult=0 else hudselectionmade=0
     endif
    endcase
    case AICONDETIMERGREATER:
     conda=timer()-entityelement(e).etimer
     condb=aiconditionseq(seq).valuea
     if conda<condb then airesult=0
    endcase
    case AICONDTIMERGREATER:
     conda=timer()-hudtimer
     condb=aiconditionseq(seq).valuea
     if conda<condb then airesult=0
    endcase
    case AICONDESCAPEKEYPRESSED:
     conda=aiconditionseq(seq).valuea
     if control_escapekey()=1 and conda=0 then airesult=0
     if control_escapekey()=0 and conda=1 then airesult=0
    endcase
    case AICONDSCANCODEKEYPRESSED:
     conda=aiconditionseq(seq).valuea
     condb=scancode()
     if condb<>conda then airesult=0
    endcase
    case AICONDHUDEDITDONE:
     for thudid=1 to hudmax
      if hud(thudid).maintype=8 and hud(thudid).hide=0 and hud(thudid).typemode<20
       airesult=0
      endif
     next thudid
    endcase
    case AICONDHUDHAVENAME:
     conda=aiconditionseq(seq).valuea
     if hudhaveplayername=0 and conda=1 then airesult=0
     if hudhaveplayername=1 and conda=0 then airesult=0
    endcase
    rem AirMod - New Conditions >>>
    case AICONDPLRBLOCKING
     conda=aiconditionseq(seq).valuea
     if conda<>player(1).state.blockingaction then airesult = 0
    endcase
    case AICONDINVIEW
     conda=aiconditionseq(seq).valuea
     if conda<>object in screen(obj) then airesult=0
    endcase
    case AICONDPICKOBJECT
     conda=aiconditionseq(seq).valuea
     tpickobject = pick object(screen width()/2,screen height()/2,obj,obj)
     if conda=0 and obj=tpickobject then airesult=0
     if conda=1 and obj<>tpickobject then airesult=0
    endcase
    case AICONDVELOCITY:
     conda=aiconditionseq(seq).valuea
     tvx# = ode get body linear velocity x(obj)
     tvy# = ode get body linear velocity y(obj)
     tvz# = ode get body linear velocity z(obj)
     airesult=0
     if tvx# > conda then airesult=1
     if tvy# > conda then airesult=1
     if tvz# > conda then airesult=1
    endcase
    rem AirMod - Done <<<
    case AICONDKEYPRESSED:
     if keystate(aiconditionseq(seq).valuea)<>aiconditionseq(seq).valueb then airesult=0
    endcase
    case AICONDHASWEAPON:
     if entityprofile(entid).ischaracter<>0
      if aiconditionseq(seq).valuea=1 and entityelement(e).eleprof.hasweapon=0 then airesult=0
      if aiconditionseq(seq).valuea=0 and entityelement(e).eleprof.hasweapon<>0 then airesult=0
     endif
    endcase
    Rem Hockeykid - 250210 - Dark AI conditions
    case AICONDDARKAISTRAFEL:
     conda=aiconditionseq(seq).valuea
     taction=entityelement(e).darkai.action
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.action=3 and conda=0 then airesult=0
      if entityelement(e).darkai.action<>3 and conda=1 then airesult=0
     endif
    endcase
    case AICONDDARKAISTRAFER:
     conda=aiconditionseq(seq).valuea
     taction=entityelement(e).darkai.action
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.action=4 and conda=0 then airesult=0
      if entityelement(e).darkai.action<>4 and conda=1 then airesult=0
     endif
    endcase
    case AICONDDARKAIMOVINGF:
     conda=aiconditionseq(seq).valuea
     taction=entityelement(e).darkai.action
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.action=1 and conda=0 then airesult=0
      if entityelement(e).darkai.action<>1 and conda=1 then airesult=0
     endif
    endcase
    case AICONDDARKAIMOVINGB:
     conda=aiconditionseq(seq).valuea
     taction=entityelement(e).darkai.action
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.action=2 and conda=0 then airesult=0
      if entityelement(e).darkai.action<>2 and conda=1 then airesult=0
      movingwork=airesult
     endif
    endcase
    case AICONDDARKAIIDLE:
     conda=aiconditionseq(seq).valuea
     taction=entityelement(e).darkai.action
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.action=0 and conda=0 then airesult=0
      if entityelement(e).darkai.action<>0 and conda=1 then airesult=0
     endif
    endcase
   case AICONDDARKAICANSHOOT:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      if ai get entity can fire(entityelement(e).obj)=1 and conda=0 then airesult=0
      if ai get entity can fire(entityelement(e).obj)<>1 and conda=1 then airesult=0
     endif
    endcase
    case AICONDAIDUCKING:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      if ai get entity is ducking(entityelement(e).obj)=1 and conda=0 then airesult=0
      if ai get entity is ducking(entityelement(e).obj)=0 and conda=1 then airesult=0
     endif
    endcase
    case AICONDAIISAI:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj) and conda=0 then airesult=0
     if ai entity exist(entityelement(e).obj)=0 and conda=1 then airesult=0
    endcase
    case AICONDAITEAM:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.team<>conda then airesult=0
     endif
    endcase
    Rem HockeyKid - 100310 - Added heard sound condition
    case AICONDAIHEARDSOUND:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
        for i=1 to entityelementlist
         if entityelement(i).obj=entityelement(e).obj then obje=i : exit
        next i
        entityelement(obje).darkai.hearingrange=conda
        if AIHeardSound(obje)=0 then airesult=0 else airesult=1
     endif
    endcase
    case AICONDAIACTION:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.state<>conda then airesult=0
     endif
    endcase
    case AICONDAITARGETDISTWITHIN:
     if ai entity exist(entityelement(e).obj)
      conda=aiconditionseq(seq).valuea
      Rem Hockeykid - 300710 - Do not allow the objects in the way (glass etc) to mix up the ai
      if entityelement(e).targetinway>0
       target=entityelement(e).realtarget
      else
       target=entityelement(e).actualtarget
      endif
      if target>0
       tte=target-1
       if target>1 then tobj=entityelement(tte).obj
       if target=1 then tobj=physicsplayerborble
       distx#=object position x(tobj)-entityelement(e).x
       disty#=object position y(tobj)-entityelement(e).y
       distz#=object position z(tobj)-entityelement(e).z
       tddist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
       if tddist#>=conda then airesult=0
      endif
      if target=0 then airesult=0
     endif
    endcase
    case AICONDAITARGETDISTFURTHER:
     if ai entity exist(entityelement(e).obj)
      conda=aiconditionseq(seq).valuea
      Rem Hockeykid - 300710 - Do not allow the objects in the way (glass etc) to mix up the ai
      if entityelement(e).targetinway>0
       target=entityelement(e).realtarget
      else
       target=entityelement(e).actualtarget
      endif
      if target>0
       tte=target-1
       if target>1 then tobj=entityelement(tte).obj
       if target=1 then tobj=physicsplayerborble
       distx#=object position x(tobj)-entityelement(e).x
       disty#=object position y(tobj)-entityelement(e).y
       distz#=object position z(tobj)-entityelement(e).z
       tddist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
       if tddist#<=conda then airesult=0
      endif
      if target=0 then airesult=0
     endif
    endcase
    case AICONDAIATPOINT:
     conda=aiconditionseq(seq).valuea
     condb=aiconditionseq(seq).valueb
     if ai entity exist(entityelement(e).obj) and conda>0
      foundi=0
      for i=1 to array count(points())
       if points(i).id=conda then foundi=i : exit
      next i
      i=foundi
      airesult=0
      if points(i).x<>object position x(entityelement(e).obj) and condb=0 or points(i).z<>object position z(entityelement(e).obj) and condb=0 then airesult=1
      if entityelement(e).x>=points(i).x-5 and entityelement(e).x<=points(i).x+5 and entityelement(e).z>=points(i).z-5 and entityelement(e).z<=points(i).z+5 and condb=1 then airesult=1
      if entityelement(e).x<points(i).x-5 and condb=0 or entityelement(e).x>points(i).x+5 and condb=0 or entityelement(e).z<points(i).z-5 and condb=0 or entityelement(e).z>points(i).z+5 and condb=0 then airesult=1
      if points(i).x=0 and points(i).z=0 then airesult=0
     endif
    endcase
    case AICONDAICALLED:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      call=entityelement(e).darkai.called
      if call=physicsplayerborble then call=0
      if call>0 and conda=0 then airesult=0
      if call=0 and conda=1 then airesult=0
     endif
    endcase
    case AICONDAICALLEDBYPLR:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.called=physicsplayerborble and conda=0 then airesult=0
      if entityelement(e).darkai.called<>physicsplayerborble and conda=1 then airesult=0
     endif
    endcase
    case AICONDAIATCOVER:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).x>=entityelement(e).darkai.coverx-3 and entityelement(e).x<=entityelement(e).darkai.coverx+3 and entityelement(e).z>=entityelement(e).darkai.coverz-3 and entityelement(e).z<=entityelement(e).darkai.coverz+3
       if conda=0 then airesult=0
      else
       if conda=1 then airesult=0
      endif
     endif
    endcase
    case AICONDAIHASTARGET:
     conda=aiconditionseq(seq).valuea
     if ai entity exist(entityelement(e).obj)
      if conda=1 and entityelement(e).actualtarget=0 then airesult=0
      if conda=0 and entityelement(e).actualtarget<>0 then airesult=0
     endif
    endcase
    case AICONDDARKAIRUNNINGF:
     conda=aiconditionseq(seq).valuea
     taction=entityelement(e).darkai.action
     if ai entity exist(entityelement(e).obj)
      if entityelement(e).darkai.action=5 and conda=0 then airesult=0
      if entityelement(e).darkai.action<>5 and conda=1 then airesult=0
     endif
    endcase
    rem V118 - 110810 - knxrb - Hud Layers
    case AICONDHUDSELECTED:
      cHName$ = aiconditionseq(seq).string1
      if cHName$ <> hudHName$ then airesult=0 else hudHName$ = ""
    endcase
    case AICONDSETUPSHADER:
      if aiconditionseq(seq).valuea <> guseeffectstate then airesult=0
    endcase
    case AICONDSETUPSHADOWS:
      if aiconditionseq(seq).valuea <> gdynamicshadowsstate then airesult=0
    endcase
    case AICONDSETUPTEXQUALITY:
      if aiconditionseq(seq).valuea <> gdividetexturesize then airesult=0
    endcase
    case AICONDSETUPMOUSESENS:
      if aiconditionseq(seq).valuea <> gmousesensitivity then airesult=0
    endcase
    case AICONDSETUPASPECTRATIO:
      if aiconditionseq(seq).valuea <> gaspectratio then airesult=0
    endcase
    case AICONDSETUPPOSTPROCESSING:
      if aiconditionseq(seq).valuea <> gpostprocessing then airesult=0
    endcase
    case AICONDSETUPWIDTH:
      if aiconditionseq(seq).valuea <> gdisplaywidth then airesult=0
    endcase
    case AICONDSETUPHEIGHT:
      if aiconditionseq(seq).valuea <> gdisplayheight then airesult=0
    endcase
    case AICONDSETUPDEPTH:
      if aiconditionseq(seq).valuea <> gdisplaydepth then airesult=0
    endcase
    case AICONDSETUPANTIALIAS:
      if aiconditionseq(seq).valuea <> gantialias then airesult=0
    endcase
    rem V118 - 130810 - knxrb - Invert Mouse
    case AICONDSETUPMOUSEINVERT:
      if aiconditionseq(seq).valuea <> gminvert then airesult=0
    endcase
    rem V118 - 140810 - knxrb - Disable Particles
    case AICONDSETUPPARTICLESUSED:
      if aiconditionseq(seq).valuea <> gparticlesnotused then airesult=0
    endcase
    rem V118 - 160810 - knxrb - Auto Resolution
    case AICONDSETUPAUTORES:
      if aiconditionseq(seq).valuea <> gautores then airesult=0
    endcase
    rem V118 - 120810 - knxrb - 'mousestate=X' command
    case AICONDMOUSESTATE:
      if aiconditionseq(seq).valuea <> control_mouseclick() then airesult=0
    endcase
    rem GUI-X9 (knxrb) >>>
    case AICONDHUDMOUSEDOWN:
        if lower$(MouseDownHud$) = lower$(aiconditionseq(seq).string1)
            if aiconditionseq(seq).valueb = 0
                airesult=0
            else
                MouseDownHud$ = ""
            endif
        else
            if aiconditionseq(seq).valueb = 1
                airesult=0
            else
                MouseDownHud$ = ""
            endif
        endif
    endcase
    case AICONDHUDMOUSEUP:
        if lower$(MouseUpHud$) = lower$(aiconditionseq(seq).string1)
            if aiconditionseq(seq).valueb = 0
                airesult=0
            else
                MouseUpHud$ = ""
            endif
        else
            if aiconditionseq(seq).valueb = 1
                airesult=0
            else
                MouseUpHud$ = ""
            endif
        endif
    endcase
    case AICONDHUDMOUSEOVER:
        if lower$(MouseOverHud$) = lower$(aiconditionseq(seq).string1)
            if aiconditionseq(seq).valueb = 0
                airesult=0
            else
                MouseOverHud$ = ""
            endif
        else
            if aiconditionseq(seq).valueb = 1
                airesult=0
            else
                MouseOverHud$ = ""
            endif
        endif
    endcase
    case AICONDSAVEVISIBLE:
        if GUISave = 1
            if aiconditionseq(seq).valuea = 0 then airesult=0
        else
            if aiconditionseq(seq).valuea = 1 then airesult=0
        endif
    endcase
    case AICONDLOADVISIBLE:
        if GUILoad = 1
            if aiconditionseq(seq).valuea = 0 then airesult=0
        else
            if aiconditionseq(seq).valuea = 1 then airesult=0
        endif
    endcase
    case AICONDSTOPWATCHGREATER:
        if aiconditionseq(seq).string1 <> "" and aiconditionseq(seq).string2 <> ""
            cID = -1 : cID = GUITimerFromName(aiconditionseq(seq).string1)
            if cID > -1
                 if guitimer(cID).Started = 1
                    tTime = timer()-guitimer(cID).Time
                    if tTime <= val(aiconditionseq(seq).string2) then airesult = 0
                 endif
            endif
        endif
    endcase
    case AICONDSTOPWATCHLESS:
        if aiconditionseq(seq).string1 <> "" and aiconditionseq(seq).string2 <> ""
            cID = -1 : cID = GUITimerFromName(aiconditionseq(seq).string1)
            if cID > -1
                 if guitimer(cID).Started = 1
                     tTime = timer()-guitimer(cID).Time
                     if tTime >= val(aiconditionseq(seq).string2) then airesult = 0
                 endif
            endif
        endif
    endcase
    case AICONDSTOPWATCHRUNNING:
        if aiconditionseq(seq).string1 <> "" and aiconditionseq(seq).string2 <> ""
            cID = -1 : cID = GUITimerFromName(aiconditionseq(seq).string1)
            if cID > -1
                 if guitimer(cID).Started = 1
                     if guitimer(cID).Started = 1 and aiconditionseq(seq).string2 = "0" then airesult = 0
                     if guitimer(cID).Started = 0 and aiconditionseq(seq).string2 = "1" then airesult = 0
                 endif
            endif
        endif
    endcase
    case AICONDSETUPVAREQUAL:
        if aiconditionseq(seq).string1 <> "" and aiconditionseq(seq).string2 <> ""
            cID = -1 : cID = GUISVarFromName(aiconditionseq(seq).string1)
            if cID > -1
               if guisvar(cID).Value <> aiconditionseq(seq).string2 then airesult=0
            endif
        endif
    endcase
    case AICONDCURSORIMAGE:
        if aiconditionseq(seq).string1 <> "" and aiconditionseq(seq).string2 <> ""
            cID = -1 : cID = GUIImageFromname(aiconditionseq(seq).string1)
            if cID > -1
               if MouseSprite = cID and aiconditionseq(seq).string2 = "0" then airesult = 0
               if MouseSprite <> cID and aiconditionseq(seq).string2 = "1" then airesult = 0
            endif
        endif
    endcase
    case AICONDCHOICEVALUEEQUAL:
        if aiconditionseq(seq).string1 <> "" and aiconditionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiconditionseq(seq).string1)
            if cID > -1
               if lower$(guichoice(cID).SelectedState) <> lower$(aiconditionseq(seq).string2) then airesult=0
            endif
        endif
    endcase
    case AICONDSLIDERVALUEEQUAL:
        if aiconditionseq(seq).string1 <> "" and aiconditionseq(seq).string2 <> ""
            cID = -1 : cID = GUISliderFromName(aiconditionseq(seq).string1)
            if cID > -1
               if lower$(str$(guislider(cID).SVal)) <> lower$(aiconditionseq(seq).string2) then airesult=0
            endif
        endif
    endcase
    rem GUI-X9 (knxrb) <<<
    `
    rem cinematic hands (terry cox) >>>>
    case AICONDPREVENTEDSELECTINGGUN:
       if preventplrselectinggun=0 then airesult=0
    endcase
    rem cinematic hands <<<<

    Rem Scene commander conditions

case AICONDMOUSECONDITION:

conda=aiconditionseq(seq).valuea
condb=0

temp=mouseclick()

airesult=0

if temp=conda then airesult=1

endcase

case AICONDAIRGREATER:
airesult=0
conda=aiconditionseq(seq).valuea
condb=airleft
if conda>condb then airesult=1
endcase

case AICONDAIRLESSER:
airesult=0
conda=aiconditionseq(seq).valuea
condb=airleft
if conda<condb then airesult=1
endcase

case AICONDAIREQUAL:airesult=0

conda=aiconditionseq(seq).valuea
condb=airleft
if conda=condb then airesult=1
endcase

case AICONDSAMEFLOORASPLR:

playerlevel=int(object position y(physicsplayerborble))/100
          if playerlevel<0 then playerlevel=0
          if playerlevel>19 then playerlevel=19

         entitylevel=int(entityelement(e).y)/100
          if entitylevel<0 then entitylevel=0
          if entitylevel>19 then entitylevel=19

 if playerlevel=entitylevel
airesult=1
else
airesult=0
endif
endcase

case AICONDPLRFLOOREQUAL:

conda=aiconditionseq(seq).valuea


   playerlevel=int(object position y(physicsplayerborble))/100
   if playerlevel<0 then playerlevel=0
      if playerlevel>19 then playerlevel=19


 if playerlevel=conda
airesult=1
else
airesult=0
endif
endcase

case AICONDENTFLOOREQUAL:

conda=aiconditionseq(seq).valuea

   entitylevel=int(entityelement(e).y)/100
          if entitylevel<0 then entitylevel=0
          if entitylevel>19 then entitylevel=19

 if entitylevel=conda
airesult=1
else
airesult=0
endif
endcase


case AICONDISIMMUNE:
     conda=aiconditionseq(seq).valuea

     if conda<>isimmune
     airesult=0
     else
      airesult=1
     endif

     endcase

     case AICONDWEAPONSGREATER:

     conda=aiconditionseq(seq).valuea
     airesult=0

     Rem Scene Commander, count weapons for max slots.
  weaps=0
  For count=1 to 10
  if weaponslot(count).pref<>0 then inc weaps,1
  next count

 if weaps>conda
 airesult=1
 endif


     endcase

     case AICONDWEAPONSLESSER:

     conda=aiconditionseq(seq).valuea
     airesult=0
   Rem Scene Commander, count weapons for max slots.
    weaps=0
    For count=1 to 10
      if weaponslot(count).pref<>0 then inc weaps,1
      next count

      if weaps<conda
      airesult=1
      endif

     endcase

     case AICONDWEAPONSEQUAL:

     conda=aiconditionseq(seq).valuea
     airesult=0

      weaps=0
      For count=1 to 10
      if weaponslot(count).pref<>0 then inc weaps,1
      next count

      if weaps=conda
      airesult=1
      endif


     endcase

     case AICONDWEAPONINSLOT:


      conda=aiconditionseq(seq).valuea
      condb=aiconditionseq(seq).valueb
      if conda>0 and conda<10
      slot1=weaponslot(conda).got
      else
      slot1=0
      endif
      if condb>0 and condb<10
      slot2=condb
      else
      slot2=0
      endif

      airesult=0
      foundgunid=0
      findgun$=lower$(aiconditionseq(seq).string1)

      if slot2=0
         else
            gosub _gun_findweaponindexbyname
             if foundgunid>0
               if weaponslot(slot2).got=foundgunid
               airesult=1
               endif
            endif
         endif


         if foundgunid=0
            if slot1<>0
            airesult=1
            endif
         endif



     endcase

     case AICONDCURRENTWEAPON:
          `
          local weapslot as integer
          local wn$ as string
          local pos as integer : pos=0
          local temp$ as string
          local character$ as string
          local ascii as integer
          local isnumeric as boolean

          if gunid = 0
            airesult = 0
          else
            wn$ = aiconditionseq(seq).string1
            for i = 1 to len(wn$)
                character$ = mid$(wn$,i)
                ascii = asc(character$)
                if ascii > 47 and ascii < 58
                    isnumeric = 1
                else
                    isnumeric = 0
                    exit
                endif
            next i
            if isnumeric
                weapslot = val(aiconditionseq(seq).string1)
                if weaponslot(weapslot).got <> gunid then airesult = 0
            else
                pos = find last char$(wn$,"\")
                if pos > 0
                    temp$ = gun(gunid).name$
                else
                    pos = find last char$(gun(gunid).name$,"\")
                    if pos > 0
                        temp$ = right$(gun(gunid).name$,len(gun(gunid).name$)-pos)
                    else
                        temp$ = gun(gunid).name$
                    endif
                endif
                if lower$(temp$) <> lower$(wn$) then airesult = 0
            endif
          endif
//      rem Scene Commander, find current weapon, there maybe a better way of doing this.
//      findslot=0
//
//    findgun$=lower$(aiconditionseq(seq).string1)
//    airesult=0
//    foundgunid=0
//
//    if gunid=0
//     else
//       gosub _gun_findweaponindexbyname
//       if foundgunid>0
//          if foundgunid=gunid
//          airesult=1
//       endif
//       endif
//
//
//     if airesult=0
//
//      for f=1 to 10
//       if weaponslot(f).got=gunid
//       findslot=f
//       exit
//       endif
//      next f
//
//      if aiconditionseq(seq).valuea=findslot
//       airesult=1
//       else
//       airesult=0
//      endif
//     endif
//    endif

     endcase

     Rem Scene Commander V1.19 beta 2

     case AICONDPLRRUNNING:

    airesult=0
    if isrunning<>0
    airesult=1
    endif

    endcase

    case AICONDPLRNOTRUNNING:
    airesult=0
    if isrunning=0
    airesult=1
    endif

    endcase

    case AICONDPLRCROUCHING:
    airesult=0
    if crouchmode<>0
    airesult=1
    endif

    endcase

   case AICONDPLRNOTCROUCHING:
   airesult=0
   if crouchmode=0
   airesult=1
   endif

   endcase

   case AICONDZOOMED:
   airesult=0
   if gunzoommode<>0
   airesult=1
   endif

   endcase

   case AICONDNOTZOOMED:
   airesult=0
   if gunzoommode=0
   airesult=1
   endif

   endcase

   case AICONDPLRUSINGRELOAD:
   airesult=0
   if plrreloading<>0
   airesult=1
   endif
   endcase

   case AICONDPLRNOTUSINGRELOAD:

   airesult=0
   if plrreloading=0
   airesult=1
   endif

   endcase

   case AICONDPLRONGROUND:
      airesult=0
        if abs(grav#)<5.5 and jumpaction=0 and physuspendgravity=0 and aiconditionseq(seq).valuea=1
         airesult=1
         endif

        if abs(grav#)>5.5 and jumpaction=0 and physuspendgravity=0 and aiconditionseq(seq).valuea=0
        airesult=1
        endif


    endcase

   case AICONDPLRJUMPING:
      airesult=0
    if jumpaction<>0
    airesult=1
    endif

    endcase

   case AICONDPLRNOTJUMPING:
   airesult=0
   if jumpaction=0
   airesult=1
   endif

   endcase

   case AICONDFIREMODE:
   airesult=0
   if firemode=aiconditionseq(seq).valuea
   airesult=1
   endif

   endcase

   case AICONDONRADAR:

   airesult=0
   if entityelement(e).onradar=1
   airesult=1
   endif

   endcase

   case AICONDNOTONRADAR:

   airesult=0
   if entityelement(e).onradar=0
   airesult=1
   endif

   endcase

   case AICONDLASTFIRED:

   findgun$=lower$(aiconditionseq(seq).string1)

   if lastfired=0
   airesult=0
   else
      gosub _gun_findweaponindexbyname
      if foundgunid>0
         if foundgunid=lastfired then airesult=1
         lastfired=0
      endif
   endif

   if lastfired<>0
   conda=aiconditionseq(seq).valuea
      if conda>0 and conda<11
         if weaponslot(conda).got=lastfired
         airesult=1
         lastfired=0
         endif
      endif
   endif

   endcase

case AICONDRADARGREATER:
airesult=0
temprange=aiconditionseq(seq).valuea
tempmode=aiconditionseq(seq).valueb

if tempmode=1 and entityelement(e).radardistance>temprange then airesult=1
if tempmode=0 and entityelement(e).radardistance>temprange then airesult=1

endcase

case AICONDRADAREQUAL:
airesult=0
temprange=aiconditionseq(seq).valuea
tempmode=aiconditionseq(seq).valueb

if tempmode=1 and entityelement(e).radardistance=temprange then airesult=1
if tempmode=0 and entityelement(e).radardistance<>temprange then airesult=1

endcase

case AICONDENTITYPLRGREATER:
airesult=0
conda=aiconditionseq(seq).valuea


condb=entityelement(e).y-object position y(physicsplayerborble)
   if condb>0
      if condb>conda
         airesult=1
      endif

   endif

endcase

case AICONDENTITYPLRLESSER:
airesult=0
conda=aiconditionseq(seq).valuea


condb=entityelement(e).y-object position y(physicsplayerborble)
   if condb<0
      if abs(condb)>conda
         airesult=1
      endif

   endif

endcase


case AICONDFLOORHIGHER:

conda=aiconditionseq(seq).valuea
if conda<0 then conda=0
if conda>19 then conda=19

         playerlevel=int(object position y(physicsplayerborble))/100
          if playerlevel<0 then playerlevel=0
          if playerlevel>19 then playerlevel=19

            entitylevel=int(entityelement(e).y)/100
          if entitylevel<0 then entitylevel=0
          if entitylevel>19 then entitylevel=19

 if  (playerlevel-entitylevel)>conda
airesult=1
else
airesult=0
endif
endcase

case AICONDFLOORLOWER:

conda=aiconditionseq(seq).valuea
if conda<0 then conda=0
if conda>19 then conda=19

         playerlevel=int(object position y(physicsplayerborble))/100
          if playerlevel<0 then playerlevel=0
          if playerlevel>19 then playerlevel=19

            entitylevel=int(entityelement(e).y)/100
          if entitylevel<0 then entitylevel=0
          if entitylevel>19 then entitylevel=19

 if  (entitylevel-playerlevel)>conda
airesult=1
else
airesult=0
endif
endcase

case AICONDFLASHING:
airesult=0
conda=aiconditionseq(seq).valuea

if spotflash=0 and conda=0
airesult=1
endif

if spotflash<>0 and conda=1
airesult=1
endif

endcase

Rem Scene Commander- based on code supplied by Ched80 - used with permission.
case AICONDSPAWNSLEFT:
airesult=0
condb=aiconditionseq(seq).valueb
tte=entityelement(e).spawn.leaderid
conda=aiconditionseq(seq).valuea
if condb=1 and conda=entityelement(tte).spawn.upto then airesult=1
if condb=0 and conda<>entityelement(tte).spawn.upto then airesult=1
endcase
Rem Scene Commander- based on code supplied by Ched80 - used with permission.
case AICONDSPAWNSGREATER:
airesult=0
condb=aiconditionseq(seq).valueb
tte=entityelement(e).spawn.leaderid
conda=aiconditionseq(seq).valuea
if conda>entityelement(tte).spawn.upto and condb=1 then airesult=1
if conda<entityelement(tte).spawn.upto and condb=0 then airesult=1
endcase

case AICONDSHOTBY:

   findgun$=lower$(aiconditionseq(seq).string1)
   airesult=0
   foundgunid=0
   if entityelement(e).shotby=0
   airesult=0
   else
      gosub _gun_findweaponindexbyname
      if foundgunid>0
         if foundgunid=entityelement(e).shotby
         airesult=1
         entityelement(e).shotby=0
         endif
      endif
   endif

   if lower$(findgun$)="collision" and entityelement(e).shotby=993
   airesult=1:entityelement(e).shotby=0
   endif
   if lower$(findgun$)="melee" and entityelement(e).shotby=994
   airesult=1:entityelement(e).shotby=0
   endif
   if lower$(findgun$)="indirect" and entityelement(e).shotby=995
   airesult=1:entityelement(e).shotby=0
   endif
   if lower$(findgun$)="flak" and entityelement(e).shotby=996
   airesult=1:entityelement(e).shotby=0
   endif
   if lower$(findgun$)="falling" and entityelement(e).shotby=997
   airesult=1:entityelement(e).shotby=0
   endif

   if entityelement(e).shotby<>0
   conda=aiconditionseq(seq).valuea
      if conda>0 and conda<11
         if weaponslot(conda).got=entityelement(e).shotby
         airesult=1:entityelement(e).shotby=0
         endif
      endif
   endif


   endcase

   case AICONDPLRCARRYING:

   airesult=0
   if camerapicked<>0
   airesult=1
   endif


   endcase

   case AICONDPLRNOTCARRYING:

   airesult=0
   if camerapicked<>0
   airesult=1
   endif

   endcase

   case AICONDLASTDAMAGETIME:
      airesult=0
     conda=timer()-entityelement(e).lastdamagetimer
     condb=aiconditionseq(seq).valuea
     if conda>condb then airesult=1
    endcase

   case AICONDCURRENTJAMMED:

      airesult=0
      if gunid>0
         if firemode(gunid,firemode).settings.jammed=1
         airesult=1
         endif
      endif

   endcase

   case AICONDENTITYISIMMUNE:

      airesult=0
      if entityelement(e).isimmune=1
         airesult=0
      endif

   endcase

   case AICONDENTITYISNOTIMMUNE:
   airesult=0
   if entityelement(e).isimmune=0
      airesult=1
   endif

   endcase

   case AICONDPLRWEAPONIDLE:

   airesult=0
   if gunid>0
      if gunmode>=31 and gunmode<=35
      airesult=1
      endif
   endif

   endcase

   case AICONDPLRWEAPONNOTIDLE:

   airesult=0
   if gunid>0
      if gunmode<31 or gunmode>35
      airesult=1
      endif
   endif

   endcase

   case AICONDOBJECTRANGELESS:

   airesult=0

   if entityelement(e).objectivecurrentrange<aiconditionseq(seq).valuea

   airesult=1

   endif

   endcase

   case AICONDOBJECTRANGEGREATER:

   airesult=0

   if entityelement(e).objectivecurrentrange>aiconditionseq(seq).valuea

   airesult=1

   endif

   endcase

   case AICONDSOUNDPLAYING:

   if entityelement(e).soundplaying>0
      if sound playing(entityelement(e).soundplaying)=1
      airesult=1
      else
      airesult=0
      endif
   endif
   endcase

case AICONDSOUNDNOTPLAYING:

   if entityelement(e).soundplaying>0
      if sound playing(entityelement(e).soundplaying)=1
      airesult=0
      else
      airesult=1
      endif
   endif
   endcase

 case AICONDWATEREQUAL:
   airesult=0
   if aiconditionseq(seq).valuea=waterheight#
   airesult=1
   endif
 endcase

case AICONDWATERLESSER:
   airesult=0
   if waterheight#<aiconditionseq(seq).valuea
   airesult=1
   endif
endcase

case AICONDWATERGREATER:
   airesult=0
   if waterheight#>aiconditionseq(seq).valuea
   airesult=1
   endif
endcase

case AICONDWATERISON:
   airesult=0
   if wateron=aiconditionseq(seq).valuea
   airesult=1
   endif
endcase

case AICONDSHOTBYAMMO:
   airesult=0
   if entityelement(e).shotbyammo$<>""
      if lower$(entityelement(e).shotbyammo$)=lower$(aiconditionseq(seq).string1)
      airesult=1
      entityelement(e).shotbyammo$=""
      endif
   endif

endcase

case AICONDPLRFIRED:

   if lastfired=0
   airesult=0
   else
   airesult=1
   endif

   endcase

case AICONDPLRFIREDGREATER:

   conda=timer()-lastfiredtime
   condb=aiconditionseq(seq).valuea
   if conda<condb
   airesult=0
   else
   airesult=1
   endif

endcase

case AICONDPLRFIREDLESSER:

   if timer()-lastfiredtime>=aiconditionseq(seq).valuea
   airesult=0
   else
   airesult=1
   endif

endcase

case AICONDSTATEGREATER:

      conda=0
      condb=0
      airesult=0
     conda$=entityelement(e).ai.state$
     condb$=aiconditionseq(seq).string1
     if asc(left$(conda$,1))>=asc("0") or asc(left$(conda$,1))<=asc("9")
        if asc(left$(condb$,1))>=asc("0") or asc(left$(condb$,1))<=asc("9")
        conda=val(conda$)
        condb=val(condb$)
        endif
      endif
     if conda>condb then airesult=1
    endcase

   case AICONDSTATELESSER:

      conda=0
      condb=0
      airesult=0
     conda$=entityelement(e).ai.state$
     condb$=aiconditionseq(seq).string1
     if asc(left$(conda$,1))>=asc("0") or asc(left$(conda$,1))<=asc("9")
        if asc(left$(condb$,1))>=asc("0") or asc(left$(condb$,1))<=asc("9")
        conda=val(conda$)
        condb=val(condb$)
        endif
      endif
     if conda<condb then airesult=1
    endcase

    case AICONDLMBGREATER:

    airesult=1
    if lmbheld=0
    airesult=0
    else
    if timer()-lmbheldtime<=aiconditionseq(seq).valuea
    airesult=0
    endif
    endif

    endcase

    case AICONDLMBLESSER:

    airesult=1
    if lmbheld=0
    airesult=0
    else
    if timer()-lmbheldtime>=aiconditionseq(seq).valuea
    airesult=0
    endif
    endif


    endcase

    case AICONDRMBGREATER:

    airesult=1
    if rmbheld=0
    airesult=0
    else
    if timer()-rmbheldtime<=aiconditionseq(seq).valuea
    airesult=0
    endif
    endif


    endcase

    case AICONDRMBLESSER:

   airesult=1
    if rmbheld=0
    airesult=0
    else
    if timer()-rmbheldtime>=aiconditionseq(seq).valuea
    airesult=0
    endif
    endif


    endcase



   endselect
   `
   rem nw addition, if airesult prematurely zero can leave NOW
   if airesult=0 then seq=aicond(conindex).last
   `
  next seq
  if gshowdebugtextingamestate=1
   if debugviewtog=1
    if aiconttimer<>0 then print " : ";
   endif
  endif
  `
  rem Process action if all true
  if airesult=1
   `
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     if aiconttimer=0 then aiconttimer=timer() : print " : ";
     print strarr$(1);
    endif
   endif
   `
   rem Process all actions in sequence
   actindex=aicond(conindex).action
   for seq=aiaction(actindex).first to aiaction(actindex).last
    if gshowdebugtextingamestate=1
     if debugviewtog=1
      print actword$(aiactionseq(seq).type)+"("+str$(aiactionseq(seq).value)+")"+", ";
     endif
    endif
    `
  rem Plystire - This will allow the engine to replace variable names with the value of the variable
  if left$(aiactionseq(seq).string1,1)="%"
   rem Find the variable being called for and replace valuea with it's value
   tuvar$=right$(aiactionseq(seq).string1,len(aiactionseq(seq).string1)-1)
   tfound=0
   for uvar=0 to array count(uservars(0))
    if uservars(uvar).name=tuvar$ and uservars(uvar).used=1
     rem found the variable
     tfound=1
     aiactionseq(seq).value=uservars(uvar).value
     exit
    endif
   next uvar
   `
   for lvar=0 to 99
    if aiuserlocals(e,lvar).name=tuvar$ and aiuserlocals(e,lvar).used=1 and aiuserlocals(e,lvar).newsystem=1
     rem found the variable
     tfound=1
     aiactionseq(seq).value=aiuserlocals(e,lvar).value
     exit
    endif
   next lvar
   `
   rem if we didn't find the value, give it a 0
   if tfound=0 then aiactionseq(seq).value=0 : aiactionseq(seq).valueisvar=0
   if tfound>0 then aiactionseq(seq).valueisvar=1
  else
   aiactionseq(seq).valueisvar=0
  endif
  if left$(aiactionseq(seq).string2,1)="%"
   rem Find the variable being called for and replace valuea with it's value
   tuvar$=right$(aiactionseq(seq).string2,len(aiactionseq(seq).string2)-1)
   tfound=0
   for uvar=0 to array count(uservars(0))
    if uservars(uvar).name=tuvar$ and uservars(uvar).used=1
     rem found the variable
     tfound=1
     aiactionseq(seq).valueb=uservars(uvar).value
     exit
    endif
   next uvar
   `
   for lvar=0 to 99
    if aiuserlocals(e,lvar).name=tuvar$ and aiuserlocals(e,lvar).used=1 and aiuserlocals(e,lvar).newsystem=1
     rem found the variable
     tfound=1
     aiactionseq(seq).valueb=aiuserlocals(e,lvar).value
     exit
    endif
   next lvar
   `
   rem if we didn't find the value, give it a 0
   if tfound=0 then aiactionseq(seq).valueb=0
  endif
  rem Plystire - This section will allow the engine to replace certain tags with important engine variables
  select aiactionseq(seq).string1
   case "$PH"
    aiactionseq(seq).value=player(1).health
   endcase
   case "$PL"
    aiactionseq(seq).value=player(1).lives
   endcase
   case "$RA"
    aiactionseq(seq).value=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$A"
    aiactionseq(seq).value=-1
    if gunid<>0
     aiactionseq(seq).value=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$RCA"
    aiactionseq(seq).value=weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$CA"
    aiactionseq(seq).value=-1
    if gunid<>0
     aiactionseq(seq).value=weaponammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$CLA"
    aiactionseq(seq).value=-1
    if gunid<>0
     aiactionseq(seq).value=weaponclipammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$EH"
    aiactionseq(seq).value=entityelement(e).health
   endcase
   case "$EA"
    aiactionseq(seq).value=entityelement(e).currentammo
   endcase
   case "$EPX"
    aiactionseq(seq).value=entityelement(e).x
   endcase
   case "$EPY"
    aiactionseq(seq).value=entityelement(e).y
   endcase
   case "$EPZ"
    aiactionseq(seq).value=entityelement(e).z
   endcase
   case "$EAX"
    aiactionseq(seq).value=entityelement(e).rx
   endcase
   case "$EAY"
    aiactionseq(seq).value=entityelement(e).ry
   endcase
   case "$EAZ"
    aiactionseq(seq).value=entityelement(e).rz
   endcase
   case "$CAX"
    aiactionseq(seq).value=camera angle x(0)
   endcase
   case "$CAY"
    aiactionseq(seq).value=camera angle y(0)
   endcase
   case "$CAZ"
    aiactionseq(seq).value=camera angle z(0)
   endcase
   case "$CPX"
    aiactionseq(seq).value=camera position x(0)
   endcase
   case "$CPY"
    aiactionseq(seq).value=camera position y(0)
   endcase
   case "$CPZ"
    aiactionseq(seq).value=camera position z(0)
   endcase
   case "$MMX"
    aiactionseq(seq).value=dcamx#
   endcase
   case "$MMY"
    aiactionseq(seq).value=dcamy#
   endcase
   case "$MMZ"
    aiactionseq(seq).value=dcamz#
   endcase
Rem Scene Commander
    case "$ARM"
    aiactionseq(seq).value=armour
    endcase
    case "$AIR"
    aiactionseq(seq).value=airleft
    endcase
    case "$FPS"
   aiactionseq(seq).value=screen fps()
   endcase
   case "$WAT"
   aiactionseq(seq).value=waterheight#
   endcase
   case "$MAX"
   aiactionseq(seq).value=maxslots
   endcase
   case "$DIS"

   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiactionseq(seq).value=plrdistance#

   endcase

   case "$DIF"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiactionseq(seq).value=(plrdistance#/100)*8.33

   endcase

   case "$DIM"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    aiactionseq(seq).value=(plrdistance#/100)*2.54

   endcase


  endselect
  `
  select aiactionseq(seq).string2
   case "$PH"
    aiactionseq(seq).valueb=player(1).health
   endcase
   case "$PL"
    aiactionseq(seq).valueb=player(1).lives
   endcase
   case "$RA"
    aiactionseq(seq).valueb=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$A"
    aiactionseq(seq).valueb=-1
    if gunid<>0
     aiactionseq(seq).valueb=weaponclipammo(weaponammoindex+ammooffset)+weaponammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$RCA"
    aiactionseq(seq).valueb=weaponammo(weaponammoindex+ammooffset)
   endcase
   case "$CA"
    aiactionseq(seq).valueb=-1
    if gunid<>0
     aiactionseq(seq).valueb=weaponammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$CLA"
    aiactionseq(seq).valueb=-1
    if gunid<>0
     aiactionseq(seq).valueb=weaponclipammo(weaponammoindex+ammooffset)
    endif
   endcase
   case "$EH"
    aiactionseq(seq).valueb=entityelement(e).health
   endcase
   case "$EA"
    aiactionseq(seq).valueb=entityelement(e).currentammo
   endcase
   case "$EPX"
    aiactionseq(seq).valueb=entityelement(e).x
   endcase
   case "$EPY"
    aiactionseq(seq).valueb=entityelement(e).y
   endcase
   case "$EPZ"
    aiactionseq(seq).valueb=entityelement(e).z
   endcase
   case "$EAX"
    aiactionseq(seq).valueb=entityelement(e).rx
   endcase
   case "$EAY"
    aiactionseq(seq).valueb=entityelement(e).ry
   endcase
   case "$EAZ"
    aiactionseq(seq).valueb=entityelement(e).rz
   endcase
   case "$CAX"
    aiactionseq(seq).valueb=camera angle x(0)
   endcase
   case "$CAY"
    aiactionseq(seq).valueb=camera angle y(0)
   endcase
   case "$CAZ"
    aiactionseq(seq).valueb=camera angle z(0)
   endcase
   case "$CPX"
    aiactionseq(seq).valueb=camera position x(0)
   endcase
   case "$CPY"
    aiactionseq(seq).valueb=camera position y(0)
   endcase
   case "$CPZ"
    aiactionseq(seq).valueb=camera position z(0)
   endcase
   case "$MMX"
    aiactionseq(seq).valueb=dcamx#
   endcase
   case "$MMY"
    aiactionseq(seq).valueb=dcamy#
   endcase
   case "$MMZ"
    aiactionseq(seq).valueb=dcamz#
   endcase
Rem Scene Commander
    case "$ARM"
    aiactionseq(seq).valueb=armour
    endcase
    case "$AIR"
    aiactionseq(seq).valueb=airleft
    endcase
    case "$FPS"
   aiactionseq(seq).valueb=screen fps()
   endcase
   case "$WAT"
   aiactionseq(seq).valueb=waterheight#
   endcase
   case "$MAX"
   aiactionseq(seq).valueb=maxslots
   endcase

   case "$DIS"

   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiactionseq(seq).valueb=plrdistance#

   endcase

   case "$DIF"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   aiactionseq(seq).valueb=(plrdistance#/100)*8.33

   endcase

   case "$DIM"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    aiactionseq(seq).valueb=(plrdistance#/100)*2.54

   endcase
  endselect
    `
    select aiactionseq(seq).type
     `
     case AIACTSTATE:
      entityelement(e).ai.state$=aiactionseq(seq).string1 rem GUI-X9 (String States)
     endcase
     case AIACTINCSTATE:
      entityelement(e).ai.state$=str$(val(entityelement(e).ai.state$)+aiactionseq(seq).value) rem GUI-X9 (String States)
     endcase
     `
     case AIACTDESTROY:

     Rem Scene commander, moved to allow destruction call from points of the source.
      gosub _killentity

     endcase
     case AIACTSUSPEND:
      rem deactivate entity (like a corpse)
      entityelement(e).ishidden=2
      entityelement(e).active=0
      entityelement(e).beenkilled=1
      entityelement(e).logiccount=0 : entityelement(e).logiccountburst=120
      rem stop any looping sound
      if entityelement(e).firesoundloop>0 then stop sound entityelement(e).firesoundloop
      entityelement(e).firesoundloop=0
      rem clear entity from col map
      tx=entityelement(e).x/25
      ty=entityelement(e).y/100
      tz=entityelement(e).z/-25
      viscolmap(tx,ty,tz)=0
     endcase
     case AIACTFLOORLOGIC:
      entityelement(e).nofloorlogic=1+entityelement(e).y
      rem V109 BETA11 - 130508 - gravity off causes characters to float when this is used
      rem should use NOGRAVITY action seperately for the former effect
      `entityelement(e).nogravity=1
      `if gmultiplayergame=0
      ` if entityelement(e).eleprof.physics<>0
      `  rem switch off gravity for this object
      `  if obj>0 then ode set gravity obj,0
      ` endif
      `endif
      rem V117 - 171209 - used for antigravity platforms too (skips viscolmap check when nofloorlogic field not zero)
     endcase
     case AIACTNOGRAVITY:
      entityelement(e).nogravity=1
      if gmultiplayergame=0
       if entityelement(e).eleprof.physics<>0
        rem switch off gravity for this object
        if obj>0 then ode set gravity obj,0
       endif
      endif
     endcase
     `
     case AIACTGLOBALVAR:
      aivariablemode=0
      aivariableindex=aiactionseq(seq).value
      if aivariableindex<0 then aivariableindex=0
      if aivariableindex>99 then aivariableindex=99
     endcase
     case AIACTLOCALVAR:
      aivariablemode=1
      aivariableindex=aiactionseq(seq).value
      if aivariableindex<0 then aivariableindex=0
      if aivariableindex>99 then aivariableindex=99
     endcase
     case AIACTSETVAR:
      rem Plystire 109 - Merge this command with our system
      if aiactionseq(seq).string2=""
       if aivariablemode=0
        aiglobals(aivariableindex)=aiactionseq(seq).value
       else
        ailocals(e,aivariableindex)=aiactionseq(seq).value
       endif
      else
       rem Use the better system ;)
       tvarfound=0
       rem Using our strings from the parser, let's find the var the user wants to set
       if left$(aiactionseq(seq).string1,1)="$"
        setintervar(e,aiactionseq(seq).string1,aiactionseq(seq).valueb)
        else
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).name = aiactionseq(seq).string1
          rem Found the variable, let's set it
          uservars(uvar).value = aiactionseq(seq).valueb
          tvarfound=1
          rem And Exit the For loop
          exit

         endif
        next uvar
        `
        if tvarfound=0
         for lvar = 0 to 99
          if aiuserlocals(e,lvar).name = aiactionseq(seq).string1
           rem Found the variable, let's set it
           aiuserlocals(e,lvar).value = aiactionseq(seq).valueb
           rem And Exit the For loop
           exit
          endif
         next lvar
        endif
        `
       endif
      endif
     endcase

      case AIACTINCVAR:
      rem Plystire 109 - Merge this command with our system
      if aiactionseq(seq).string2=""
       if aivariablemode=0
        inc aiglobals(aivariableindex),aiactionseq(seq).value
       else
        inc ailocals(e,aivariableindex),aiactionseq(seq).value
       endif
      else
       rem Using our strings from the parser, let's find the var the user wants to set
       if left$(aiactionseq(seq).string1,1)="$"
        ttt=getintervar(e,aiactionseq(seq).string1)
        ttt=ttt+aiactionseq(seq).valueb
        setintervar(e,aiactionseq(seq).string1,ttt)
       else
        tvarfound=0
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          inc uservars(uvar).value, aiactionseq(seq).valueb
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next uvar
        `
        if tvarfound=0
         for lvar = 0 to 99
          if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
           rem Found the variable, let's add to it
           inc aiuserlocals(e,lvar).value, aiactionseq(seq).valueb
           rem And Exit the For loop
           tvarfound=1
           exit
          endif
         next lvar
        endif
        `
       endif
      endif
     endcase

     case AIACTDECVAR:
      rem Plystire 109 - Merge this command with our system
      if aiactionseq(seq).string2=""
       if aivariablemode=0
        dec aiglobals(aivariableindex),aiactionseq(seq).value
       else
        dec ailocals(e,aivariableindex),aiactionseq(seq).value
       endif
      else
       rem Using our strings from the parser, let's find the var the user wants to set
       if left$(aiactionseq(seq).string1,1)="$"
        ttt=getintervar(e,aiactionseq(seq).string1)
        ttt=ttt-aiactionseq(seq).valueb
        setintervar(e,aiactionseq(seq).string1,ttt)
       else
        tvarfound=0
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).name = aiactionseq(seq).string1
          rem Found the variable, let's subtract from it
          dec uservars(uvar).value, aiactionseq(seq).valueb
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next uvar
        `
        if tvarfound=0
         for lvar = 0 to 99
          if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
           rem Found the variable, let's add to it
           dec aiuserlocals(e,lvar).value, aiactionseq(seq).valueb
           rem And Exit the For loop
           tvarfound=1
           exit
          endif
         next lvar
        endif
        `
       endif
      endif
     endcase

     Rem Hockeykid - Expand on Plystire's variable system to allow for local variables
     case AIACTDIMLOCALVAR:
      rem Let's find an UNUSED variable and set it to the name given
      for lvar = 0 to 99
       rem Let's also look for vars already declared as this
       if aiuserlocals(e,lvar).name = aiactionseq(seq).string1
        rem This variable already exists, let's just ignore it and exit the For Loop
        exit
       endif
       `
       if aiuserlocals(e,lvar).used=0
        aiuserlocals(e,lvar).value=0
        aiuserlocals(e,lvar).name = aiactionseq(seq).string1
        aiuserlocals(e,lvar).used=1
        aiuserlocals(e,lvar).newsystem=1
        exit
       endif
      next lvar
     endcase
     rem Plystire - Code behind User Variables
     case AIACTDIMVAR:
      rem Let's find an UNUSED variable and set it to the name given
      for uvar = 0 to array count(uservars(0))
       rem Let's also look for vars already declared as this
       if uservars(uvar).name = aiactionseq(seq).string1
        rem This variable already exists, let's just ignore it and exit the For Loop
        exit
       endif
       `
      next uvar
      if uvar>array count(uservars(0))
       rem Let's set it up and default it to 0 for the user
       array insert at bottom uservars(0)
       uservars(uvar).used = 1
       uservars(uvar).name = aiactionseq(seq).string1
       uservars(uvar).value = 0
      endif
     endcase
     case AIACTADDVAR:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt=ttt+aiactionseq(seq).valueb
       setintervar(e,aiactionseq(seq).string1,ttt)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's add to it
         inc uservars(uvar).value, aiactionseq(seq).valueb
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          inc aiuserlocals(e,lvar).value, aiactionseq(seq).valueb
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase
     case AIACTSUBVAR:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt=ttt-aiactionseq(seq).valueb
       setintervar(e,aiactionseq(seq).string1,ttt)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's subtract from it
         dec uservars(uvar).value, aiactionseq(seq).valueb
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          dec aiuserlocals(e,lvar).value, aiactionseq(seq).valueb
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase
     case AIACTMULVAR:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt=ttt*aiactionseq(seq).valueb
       setintervar(e,aiactionseq(seq).string1,ttt)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's multiply it
         uservars(uvar).value = uservars(uvar).value * aiactionseq(seq).valueb
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          aiuserlocals(e,lvar).value=aiuserlocals(e,lvar).value * aiactionseq(seq).valueb
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase
     case AIACTDIVVAR:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt=ttt/aiactionseq(seq).valueb
       setintervar(e,aiactionseq(seq).string1,ttt)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's divide it
         uservars(uvar).value = uservars(uvar).value / aiactionseq(seq).valueb
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          aiuserlocals(e,lvar).value=aiuserlocals(e,lvar).value / aiactionseq(seq).valueb
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase
     case AIACTMODVAR:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt=ttt mod aiactionseq(seq).valueb
       setintervar(e,aiactionseq(seq).string1,ttt)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's modulus it with the value given
         uservars(uvar).value = uservars(uvar).value mod aiactionseq(seq).valueb
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          aiuserlocals(e,lvar).value=aiuserlocals(e,lvar).value mod aiactionseq(seq).valueb
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase
     case AIACTWRAPVAR:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt=wrapvalue(ttt)
       setintervar(e,aiactionseq(seq).string1,ttt)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's wrap it's value
         uservars(uvar).value = wrapvalue(uservars(uvar).value)
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          aiuserlocals(e,lvar).value=wrapvalue(aiuserlocals(e,lvar).value)
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase
     `
     case AIACTRUNFPIDEFAULT:
      rem leave and run new DEFAULT AI script
      trundefaultscriptinternal=1
      if aiactionseq(seq).value=0 then trundefaultscript=1+entityelement(e).ai.libinit
      if aiactionseq(seq).value=1 then trundefaultscript=1+entityelement(e).ai.libmain
      if aiactionseq(seq).value=2 then trundefaultscript=1+entityelement(e).ai.libdestroy
      if aiactionseq(seq).value=3 then trundefaultscript=1+entityelement(e).ai.libshoot
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     case AIACTRUNFPI:
      rem Switch FPI AI Scripts via SPECIFIED FILE
      trundefaultscriptinternal=0
      trundefaultscript=1+aiactionseq(seq).value
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     `
     case AIACTWIN:
      rem V118 - 150211 - force all as complete
      for mi=1 to 99 : playerobjective(mi)=1 : next mi
     endcase
     `
     case AIACTSELECTSHADERVARIABLE:
      globalselectedshadervar=aiactionseq(seq).value
      if globalselectedshadervar<0 then globalselectedshadervar=0
      if globalselectedshadervar>4 then globalselectedshadervar=4
     endcase
     case AIACTSETSHADERVARIABLE:
      entityshadervar(e,globalselectedshadervar)=aiactionseq(seq).value
      rem set shader value in effect shader for entity element
      teffectid=entityelement(e).eleprof.usingeffect
      if teffectid>0
       r=make vector4(1)
       tmp1#=entityshadervar(e,1)
       tmp2#=entityshadervar(e,2)
       tmp3#=entityshadervar(e,3)
       tmp4#=entityshadervar(e,4)
       set vector4 1,tmp1#/100.0,tmp2#/100.0,tmp3#/100.0,tmp4#/100.0
       set effect constant vector teffectid,"ShaderVariables",1
       r=delete vector4(1)
      endif
     endcase
     case AIACTINCSHADERVARIABLE:
      tmp=aiactionseq(seq).value
      if tmp<1 then tmp=1
      entityshadervar(e,globalselectedshadervar)=entityshadervar(e,globalselectedshadervar)+tmp
      rem set shader value in effect shader for entity element
      teffectid=entityelement(e).eleprof.usingeffect
      if teffectid>0
       r=make vector4(1)
       tmp1#=entityshadervar(e,1)
       tmp2#=entityshadervar(e,2)
       tmp3#=entityshadervar(e,3)
       tmp4#=entityshadervar(e,4)
       set vector4 1,tmp1#/100.0,tmp2#/100.0,tmp3#/100.0,tmp4#/100.0
       set effect constant vector teffectid,"ShaderVariables",1
       r=delete vector4(1)
      endif
     endcase
     case AIACTDECSHADERVARIABLE:
      tmp=aiactionseq(seq).value
      if tmp<1 then tmp=1
      entityshadervar(e,globalselectedshadervar)=entityshadervar(e,globalselectedshadervar)-tmp
      rem set shader value in effect shader for entity element
      teffectid=entityelement(e).eleprof.usingeffect
      if teffectid>0
       r=make vector4(1)
       tmp1#=entityshadervar(e,1)
       tmp2#=entityshadervar(e,2)
       tmp3#=entityshadervar(e,3)
       tmp4#=entityshadervar(e,4)
       set vector4 1,tmp1#/100.0,tmp2#/100.0,tmp3#/100.0,tmp4#/100.0
       set effect constant vector teffectid,"ShaderVariables",1
       r=delete vector4(1)
      endif
     endcase
     `
     case AIACTMOVEUP:
      if obj>0
       tmpx#=object position x(obj)
       tmpy#=object position y(obj)
       tmpz#=object position z(obj)
       temp#=(entityelement(e).eleprof.speed/100.0)*(aiactionseq(seq).value*timeelapsed#)
       entityelement(e).y=tmpy#+temp#
       gosub _entity_controlrecalcdist
       position object obj,tmpx#,entityelement(e).y,tmpz#
      endif
     endcase
     case AIACTMOVEFORE:
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
      tmp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
      rem V110 BETA5 - 080608 - must have minimum move distance or movement fails (for slow entities)
      if tmp#<2.0 then tmp#=2.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase

      case AIACTMOVEBACK:
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
      tmp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
      rem V110 BETA5 - 080608 - must have minimum move distance or movement fails (for slow entities)
      if tmp#>0.0 then tmp#=-tmp#
      if tmp#>-2.0 then tmp#=-2.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase

     case AIACTRUNFORE:
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
      tmp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
      rem V110 BETA5 - 080608 - must have minimum move distance or movement fails (for slow entities)
      if tmp#<2.0 then tmp#=2.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=1
     endcase
     case AIACTFREEZE:
      entityelement(e).mover.dx=entityelement(e).x
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.dz=entityelement(e).z
      entityelement(e).ai.headangle=0.0
      entityelement(e).ai.headdestangle=0.0
      entityelement(e).ai.waypoint.state=999
      entityelement(e).mover.moved=0
      entityelement(e).mover.run=0
      entityelement(e).strafemode=0
      entityelement(e).mover.ix=0
      entityelement(e).mover.iz=0
      entityelement(e).mover.strafe=0
      entityelement(e).mover.stepcount=0
      entityelement(e).plrtrailindex=0
     endcase
     `
     case AIACTROTATEY:
      tmp#=aiactionseq(seq).value
      entityelement(e).mover.da=entityelement(e).mover.da+tmp#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
     endcase
     case AIACTROTATETOPLR:
      entityelement(e).ai.headangle=0.0
      entityelement(e).ai.headdestangle=0.0
      entityelement(e).mover.da=wrapvalue(diffangle#)
     endcase
     case AIACTROTATEIY:
      tmp#=aiactionseq(seq).value
      entityelement(e).ry=entityelement(e).ry+tmp#
      entityelement(e).mover.da=entityelement(e).ry
      if obj>0
       yrotate object obj,entityelement(e).ry
      endif
     endcase
     case AIACTNOROTATE:
      entityelement(e).norotate=aiactionseq(seq).value
     endcase
     `
     case AIACTRESETHEAD:
      entityelement(e).ai.headdestangle=0.0
      tmp#=aiactionseq(seq).value
      entityelement(e).ai.headdownangle=tmp#
     endcase
     case AIACTROTATEHEAD:
      tmp#=aiactionseq(seq).value
      entityelement(e).ai.headdestangle=tmp#
     endcase
     case AIACTROTATEHEADRANDOM:
      tmp#=(rnd(1)*2)-1
      tmp#=rnd(aiactionseq(seq).value)*tmp#
      entityelement(e).ai.headdestangle=tmp#
     endcase
     `
     case AIACTFORCEBOUNCE:
      if tmpframe=aiactionseq(seq).value=0
       entityelement(e).force.ix=0
       entityelement(e).force.iz=0
      else
       entityelement(e).force.ix=entityelement(e).force.ix*-0.5
       entityelement(e).force.iz=entityelement(e).force.iz*-0.5
      endif
     endcase
     `
     case AIACTSPINRATE:
      entityelement(e).spinrate=aiactionseq(seq).value
      rem to have spin, must disable physics
      if entityelement(e).eleprof.physics<>0
       gosub _ode_switchoffe
       entityelement(e).eleprof.physics=0
      endif
     endcase
     case AIACTFLOATRATE:
      entityelement(e).floatrate=aiactionseq(seq).value
      rem to have float, must disable physics
      if entityelement(e).eleprof.physics<>0
       gosub _ode_switchoffe
       entityelement(e).eleprof.physics=0
      endif
     endcase
     `
     case AIACTSETFRAME:
      tmpframe=aiactionseq(seq).value
      tbaseframe=tmpframe : gosub _entity_getactualframestart : tmpframe#=tactualframe
      entityelement(e).animframe=tmpframe#
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
      entityelement(e).animdo=-1
      if obj>0
       stop object obj
       set object interpolation obj,100
       set object frame obj,tmpframe#
      endif
     endcase
     case AIACTINCFRAME:
      tmpframe=aiactionseq(seq).value
      rem leefix - X9 V109 - 020308 - can leave script and come back and INCFRAME will scroll all anims
      tbaseframe=tmpframe : gosub _entity_getactualframestart : tmpframe#=tactualframe
      if entityelement(e).animframe<tmpframe#
       rem ANIMATE or other caused frame to leave range of this animation, so resture it
       entityelement(e).animframe=tmpframe#
      endif
      tbaseframe=tmpframe : gosub _entity_getactualframefinish : tmpframe#=tactualframe
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
     endcase
     case AIACTDECFRAME:
      tmpframe=aiactionseq(seq).value
      rem leefix - X9 V109 - 020308 - can leave script and come back and INCFRAME will scroll all anims
      tbaseframe=tmpframe : gosub _entity_getactualframefinish : tmpframe#=tactualframe
      if entityelement(e).animframe>tmpframe#
       rem ANIMATE or other caused frame to leave range of this animation, so resture it
       entityelement(e).animframe=tmpframe#
      endif
      tbaseframe=tmpframe : gosub _entity_getactualframestart : tmpframe#=tactualframe
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
     endcase
     case AIACTANIMATE:
      tmpframe1=entityelement(e).animdo
      tmpframe2=aiactionseq(seq).value
      if tmpframe1<>tmpframe2
       entityelement(e).animset=1+aiactionseq(seq).value
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
      endif
     endcase
     case AIACTADVFRAME:
      tmpframe=aiactionseq(seq).value
      tmpframe#=entityelement(e).destanimframe-entityelement(e).animframe
      tmpframe#=(tmpframe#/100.0)*tmpframe
      entityelement(e).animframe=entityelement(e).animframe+tmpframe#
     endcase
     case AIACTANIMATIONNORMAL:
      entityelement(e).animdir=0
     endcase
     case AIACTANIMATIONREVERSE:
      entityelement(e).animdir=1
     endcase
     `
     case AIACTSOUND:
      tmpx#=camera position x()
      tmpy#=camera position y()
      tmpz#=camera position z()
      if aiactionseq(seq).value=-1
       playinternal3dsound(entityelement(e).soundset,tmpx#,tmpy#,tmpz#)
       entityelement(e).soundlooping=entityelement(e).soundset
      else
       if aiactionseq(seq).value=-2
        playinternal3dsound(entityelement(e).soundset1,tmpx#,tmpy#,tmpz#)
        entityelement(e).soundlooping=entityelement(e).soundset1
       else
        playinternal3dsound(aiactionseq(seq).value,tmpx#,tmpy#,tmpz#)
        entityelement(e).soundlooping=aiactionseq(seq).value
       endif
      endif
      broadcast3dsound(tmpx#,tmpy#,tmpz#,100.0,0)
      entityelement(e).soundistalking=0
     endcase
     case AIACT3DSOUND:
      tmpx#=entityelement(e).x
      tmpy#=entityelement(e).y
      tmpz#=entityelement(e).z
      if aiactionseq(seq).value=-1
       playinternal3dsound(entityelement(e).soundset,tmpx#,tmpy#,tmpz#)
       entityelement(e).soundlooping=entityelement(e).soundset
      else
       if aiactionseq(seq).value=-2
        playinternal3dsound(entityelement(e).soundset1,tmpx#,tmpy#,tmpz#)
        entityelement(e).soundlooping=entityelement(e).soundset1
       else
        playinternal3dsound(aiactionseq(seq).value,tmpx#,tmpy#,tmpz#)
        entityelement(e).soundlooping=aiactionseq(seq).value
       endif
      endif
      broadcast3dsound(tmpx#,tmpy#,tmpz#,100.0,0)
      entityelement(e).soundistalking=0
     endcase
     case AIACTLOOPSOUND:
      tmpx#=entityelement(e).x
      tmpy#=entityelement(e).y
      tmpz#=entityelement(e).z
      if aiactionseq(seq).value=-1
       tsnd=entityelement(e).soundset
      else
       if aiactionseq(seq).value=-2
        tsnd=entityelement(e).soundset1
       else
        tsnd=aiactionseq(seq).value
       endif
      endif
      loopinternal3dsound(tsnd,tmpx#,tmpy#,tmpz#)
      entityelement(e).soundlooping=tsnd
      entityelement(e).soundistalking=0
     endcase
     case AIACTSTOPSOUND:
      if aiactionseq(seq).value=0
       if entityelement(e).soundset>0 then stop sound entityelement(e).soundset
      else
       if aiactionseq(seq).value=1
        if entityelement(e).soundset1>0 then stop sound entityelement(e).soundset1
       endif
      endif
      if entityelement(e).soundlooping>0
       if sound exist(entityelement(e).soundlooping)=1
        stop sound entityelement(e).soundlooping
       endif
       entityelement(e).soundlooping=0
      endif
      entityelement(e).soundistalking=0
     endcase
     case AIACTTALK:
      currentsoundtalkmode=0
      gosub _ai_action_talk
     endcase
     case AIACTTALKORDERED:
      currentsoundtalkmode=1
      gosub _ai_action_talk
     endcase
     case AIACTTALKRANDOM:
      currentsoundtalkmode=2
      gosub _ai_action_talk
     endcase
     `
     case AIACTALTTEXTURE:
      rem FPGC - 030710 - switched to entity flag and subroutine (for load game position code)
      entityelement(e).alttextureused=aiactionseq(seq).value
      gosub _entity_updatealttexture
     endcase
     `
     case AIACTSETALPHAFADE:
      entityelement(e).ai.alphafade=aiactionseq(seq).value
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
      if obj>0
       set alpha mapping on obj,entityelement(e).ai.alphafade
      endif
     endcase
     case AIACTINCALPHAFADE:
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
     endcase
     case AIACTDECALPHAFADE:
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
     endcase
     `
     case AIACTRUNDECAL:
      tdecalmode=aiactionseq(seq).value
      if tdecalmode=-1
       entityelement(e).decalindex=0
      else
       entityelement(e).decalindex=1
       rem V118 - 140810 - knxrb - Disable Particles
       if gparticlesnotused = 1 and tdecalmode = 7
        entityelement(e).decalmode = 2 `Use 2 as default for disabled particles
       else
        entityelement(e).decalmode=tdecalmode
       endif
       if entityelement(e).decalmode=6
        if entityelement(e).currentweapon=0
         entityelement(e).decalindex=0
        endif
       endif
      endif
     endcase
     case AIACTSHAPEDECAL:
      if obj>0
       entityelement(e).decalsizex=object size x(obj)
       entityelement(e).decalsizey=object size y(obj)
      endif
     endcase
     `
     case AIACTTRIGGERFORCE:
      taddforcesphere=aiactionseq(seq).value
     endcase
     `
     case AIACTRAGDOLL:
      rem FPGC - 210210 - by popular demand, ragdoll via script
      rem FPGC - 280710 - added flag to ensure non-supported models NEVER use ragdoll (bone splat issue)
      rem Hockeykid - 070611 - Make sure that we're allowed to ragdoll if we have more lives or spawns
      spawne=entityelement(e).spawn.leaderid
      if spawne>0
       tokay=0
       if entityelement(spawne).spawn.upto<=0 then tokay=1
      else
       tokay=1
      endif

      rem Scene Commander, no ragdoll if off screen.

      if entityelement(e).obj>0
         if tokay=1 and object in screen(entityelement(e).obj)=0
         tokay=0
         endif
      endif

      rem markblosser - 102911 - breaks model pack 52 characters whose lives never reach 0, death is controlled purely in script
      `if entityprofile(entid).ischaracter=1 and entityprofile(entid).noragdoll=0 and entityelement(e).eleprof.lives<=0 and tokay=1
      if entityprofile(entid).ischaracter=1 and entityprofile(entid).noragdoll=0 and entityelement(e).eleprof.lives<=1 and entityelement(e).health<=0 and tokay=1
       if entityelement(e).ragdollon=0
        entityelement(e).ragdollon=1
        ODE Create Ragdoll from bone model obj,0.6 : rem was 0.8 up to 171007 (was 0.6 on 300707)
        detach object from static obj
        rem set friction and weight for the character as a ragdoll
        `ode set contact fdir1 obj,entityprofile(tttentid).phyfriction FPGC - 100710 - correction
        ode set contact fdir1 obj,entityprofile(entid).phyfriction
        rem ragdoll must use 'percentage' as each bone has its own mass
        ode set body mass obj,1.0
        rem stabalize the object
        ode set linear velocity obj,0,0,0
        ode set angular velocity obj,0,0,0
       endif
      endif
     endcase
     `
     case AIACTCARRYALL:
      rem FPGC - 170610 - when called on entity not using collision to carry any other entities in its field (lift)
      for carrye=1 to entityelementlist
       if entityelement(carrye).x>entityelement(e).x-50
        if entityelement(carrye).x<entityelement(e).x+50
         if entityelement(carrye).y>entityelement(e).y
          if entityelement(carrye).y<entityelement(e).y+100
           if entityelement(carrye).z<entityelement(e).z+50
            if entityelement(carrye).z>entityelement(e).z-50
             tcarryobj=entityelement(carrye).obj
             if tcarryobj>0 and carrye<>e and (camerapicked=0 or (camerapicked>0 and carrye<>camerapickede))
              if object exist(tcarryobj)=1
               `
               if entityelement(e).collisionactive=0
                rem COLOFF - lift is moving
                if entityelement(carrye).collisionactive=1
                 entityelement(carrye).collisionactive=0
                 if entityelement(carrye).eleprof.physics<>0
                  tttobj=ttobj : ttte=e
                  e=carrye : gosub _ode_switchoffe
                  ttobj=tttobj : e=ttte
                 else
                  set object collision off tcarryobj
                 endif
                 if entityelement(carrye).eleprof.physics<100
                  rem FPGC -170610 - special physics foe lift
                  entityelement(carrye).eleprof.physics=entityelement(carrye).eleprof.physics+100
                 endif
                endif
                entityelement(carrye).y=entityelement(e).y+object collision center y(tcarryobj)+5
                position object tcarryobj,entityelement(carrye).x,entityelement(carrye).y,entityelement(carrye).z
               else
                rem COLON - lift stopped
                if entityelement(carrye).collisionactive=0
                 entityelement(carrye).collisionactive=1
                 rem activate object collision
                 if entityelement(carrye).eleprof.physics<>0
                  tttobj=ttobj : ttte=e : tttentid=entid
                  e=carrye
                  gosub _ode_setupewithphysics
                  gosub _ode_ensureeisnotpenetrated
                  ttobj=tttobj : e=ttte : entid=tttentid
                 else
                  set object collision on tcarryobj
                 endif
                 if entityelement(carrye).eleprof.physics>=100
                  rem FPGC -170610 - special physics foe lift
                  entityelement(carrye).eleprof.physics=entityelement(carrye).eleprof.physics-100
                 endif
                endif
               endif
               `
              endif
             endif
            endif
           endif
          endif
         endif
        endif
       endif
      next carrye
     endcase
     `
     case AIACTPLRASS:
      gosub _player_resettrail
      meridinglift=1+e
     endcase
     case AIACTPLRNOASS:
      meridinglift=0
     endcase
     `
     case AIACTPLRMOVEUP:
      memovingy#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVEDOWN:
      memovingy#=-(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVEEAST:
      memovingx#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVEWEST:
      memovingx#=-(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVENORTH:
      memovingz#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVESOUTH:
      memovingz#=-(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVETO:
      tname$=aiactionseq(seq).string1
      norotate=aiactionseq(seq).value
      gosub _entity_findname
      if foundte>0
       tranmex#=entityelement(foundte).x
       tranmey#=entityelement(foundte).y+75.0 : rem FPGC - 180610 - from 55 (stuck below gantry)
       tranmez#=entityelement(foundte).z
       Rem Scene Commander addition, new Y value allows toggling of rotation on/off
       if norotate=0
       tranmeangley#=entityelement(foundte).ry+180
       else
       tranmeangley#=camera angle y(0)
       endif
       gosub _player_resettrail
       meridingtransporter=1
      endif
     endcase
     case AIACTPLRMOVEIFUSED:
      tname$=entityelement(e).eleprof.ifused$
      norotate=aiactionseq(seq).value
      gosub _entity_findname
      if foundte>0
       tranmex#=entityelement(foundte).x
       tranmey#=entityelement(foundte).y+75.0 : rem FPGC - 180610 - from 55 (stuck below gantry)
       tranmez#=entityelement(foundte).z
       Rem Scene Commander addition, new Y value allows toggling of rotation on/off
       if norotate=0
       tranmeangley#=entityelement(foundte).ry+180
       else
       tranmeangley#=camera angle y(0)
       endif
       gosub _player_resettrail
       meridingtransporter=1
      endif
     endcase
     case AIACTPLRFREEZE:
      tstate=aiactionseq(seq).value
      if tstate>0
       mefrozentype=1
       mefrozen=timer()+tstate
      else
       mefrozentype=0
       mefrozen=0
      endif
     endcase
     case AIACTPLRDISABLE:
      tstate=aiactionseq(seq).value
      if tstate>0
       mefrozentype=2
       mefrozen=timer()+tstate
      else
       mefrozentype=0
       mefrozen=0
      endif
     endcase
     `
     case AIACTACTIVATEIFUSED:
      tname$=entityelement(e).eleprof.ifused$
      tstate=aiactionseq(seq).value
      gosub _entity_activatename
     endcase
     case AIACTACTIVATEIFUSEDNEAR:
      tname$=entityelement(e).eleprof.ifusednear$
      tstate=aiactionseq(seq).value
      gosub _entity_activatename
     endcase
     case AIACTACTIVATETARGET:
      te=entityelement(e).actualtarget-1
      if te>0
       entityelement(te).activated=aiactionseq(seq).value
       entityelement(te).logiccount=0 : entityelement(te).logiccountburst=120
       entityelement(te).dormant=0
      endif
     endcase
     case AIACTACTIVATE:
      entityelement(e).activated=aiactionseq(seq).value
      entityelement(e).logiccount=0 : entityelement(e).logiccountburst=120
      entityelement(e).dormant=0
     endcase
     case AIACTACTIVATEALLINZONE:
      tactivated=aiactionseq(seq).value
      condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
      condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
      condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
      condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
      condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
      condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
      condy1=condy1/100 : condy1=condy1*100
      condy2=condy2/100 : condy2=condy2*100
      gosub _entity_activateallinzone
     endcase
     `
     case AIACTPLRADDHEALTH:
      if aiactionseq(seq).value<0
       tdamage=abs(aiactionseq(seq).value)
       gosub _player_takedamage
      else
       player(1).health=player(1).health+aiactionseq(seq).value
       if player(1).health>playerstartstrength then player(1).health=playerstartstrength
      endif
     endcase
     case AIACTPLRSUBHEALTH:
      if aiactionseq(seq).value<0
       player(1).health=player(1).health+abs(aiactionseq(seq).value)
       if player(1).health>playerstartstrength then player(1).health=playerstartstrength
      else
       tdamage=aiactionseq(seq).value
       gosub _player_takedamage
      endif
     endcase
     case AIACTPLRSETHEALTH:
      player(1).health=aiactionseq(seq).value
      if player(1).health>playerstartstrength then player(1).health=playerstartstrength
     endcase
     `
     case AIACTADDHEALTH:
      entityelement(e).health=entityelement(e).health+aiactionseq(seq).value
      if entityelement(e).health<=0
       rem entity deducted to death!
       entityelement(e).health=1 : tdamage=1
       tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
       obj=entityelement(e).obj
       entityelement(e).shotby=995
       gosub _entity_deducthealth
      endif
     endcase
     case AIACTSUBHEALTH:
      tdamage=aiactionseq(seq).value
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y  : tdamagez#=entityelement(e).z
      obj=entityelement(e).obj
      entityelement(e).shotby=995
      gosub _entity_deducthealth
     endcase
     case AIACTSETHEALTH:
      entityelement(e).health=aiactionseq(seq).value
      if entityelement(e).health<=0
       rem entity deducted to death!
       entityelement(e).health=1 : tdamage=1
       tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
       obj=entityelement(e).obj
       entityelement(e).shotby=995
       gosub _entity_deducthealth
      endif
     endcase
     `
     rem set entity speed (markblosser)
     case AIACTSETENTITYSPEED:
      entityelement(e).eleprof.speed=aiactionseq(seq).value
     endcase
     case AIACTSETANIMATESPEED:
      entityelement(e).animatespeed=aiactionseq(seq).value/100
     endcase

     case AIACTSETTARGET:
      if entityelement(e).possibletarget<>0
       oldtarget=entityelement(e).actualtarget
       entityelement(e).actualtarget=entityelement(e).possibletarget

       if entityelement(e).actualtarget>1
         tte=entityelement(e).actualtarget-1
         entityelement(e).actualtargetx=entityelement(tte).x
         entityelement(e).actualtargety=entityelement(tte).y
         entityelement(e).actualtargetz=entityelement(tte).z
         entityelement(e).losttargetcount=0
       else
        if entityelement(e).actualtarget=-1
         entityelement(e).actualtargetx=bcsoundx#
         entityelement(e).actualtargety=bcsoundy#
         entityelement(e).actualtargetz=bcsoundz#
         entityelement(e).losttargetcount=0
        else
         `
         Rem Hockeykid - 170610 - Ensure that Dark AI entities cannot use settarget for targeting the player
         if AI Entity Exist(entityelement(e).obj)=1 then entityelement(e).actualtarget=oldtarget
         if AI Entity Exist(entityelement(e).obj)=0
          rem target is player
          tdx#=(mex#-entityelement(e).x)
          tdy#=(mey#-entityelement(e).y)
          tdz#=(mez#-entityelement(e).z)
          tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)+abs(tdy#*tdy#))+0.001
          tdxh#=(tdx#/tdd#)*10.0
          tdzh#=(tdz#/tdd#)*10.0
          ttactualtargetx=mex#-tdxh#
          ttactualtargety=mey#-phyeyeheight# : rem too much -meheight#
          ttactualtargetz=mez#-tdzh#
          `
          rem only if actual target position has CHANGED!
          taquirelinetoplr=0
          if int(entityelement(e).actualtargetx/100)<>int(ttactualtargetx/100) or int(entityelement(e).actualtargety/100)<>int(ttactualtargety/100) or int(entityelement(e).actualtargetz/100)<>int(ttactualtargetz/100)
           rem new position of target, so check ground before use it
           entityelement(e).actualtargetx=ttactualtargetx
           entityelement(e).actualtargety=ttactualtargety
           entityelement(e).actualtargetz=ttactualtargetz
           rem can go straight to players position to start trail if plr level(ish)
           traily#=entityelement(e).actualtargety
           if entityelement(e).plrtrailindex<>0
            rem entity already has trail, but might be 'follow the leader' nonesense
            rem if there is good ground between player and entity, give opportunity to skip
            tokay=1
            tstbx#=entityelement(e).x
            tstby#=entityelement(e).y
            tstbz#=entityelement(e).z
            tdxi#=tdx#/tdd# : tdyi#=tdy#/tdd# : tdzi#=tdz#/tdd#
            for tst#=0.0 to tdd# step 90.0
             tstx#=tstbx#+(tdxi#*tst#)
             tsty#=tstby#+(tdyi#*tst#)
             tstz#=tstbz#+(tdzi#*tst#)
             inc gameperfentities3
             entityelement(e).raycastcount=0
             if static raycast(tstx#,tsty#,tstz#,tstx#,tsty#-50,tstz#)=0
              tokay=0
             endif
            next tst#
            if tokay=1 then taquirelinetoplr=2
           endif
           `
          else
           entityelement(e).losttargetcount=0
          endif
          if taquirelinetoplr=2
           if abs(traily#-entityelement(e).y)<10.0
            rem if on same level
            taquirelinetoplr=1
           endif
           if traily#<entityelement(e).y
            rem if player lower than entity
            taquirelinetoplr=1
           endif
          endif
          if taquirelinetoplr=1
           trailx#=mex# : trailz#=mez#
           trailaction=1 : gosub _player_leavetrail
           entityelement(e).plrtrailindex=playertrailmax-1
           if entityelement(e).plrtrailindex<1 then entityelement(e).plrtrailindex=100
          endif
          `
         endif
        endif
       endif
       entityelement(e).possibletarget=0
`       interferes with target lock, but character is stuck (like a barrier)
`       entityelement(e).losttargetcount=0
      endif
     endcase
     case AIACTROTATETOTARGET:
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
      tdiffangle#=atanfull(tdistx#,tdistz#)
      if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
      entityelement(e).mover.da=wrapvalue(tdiffangle#)
     endcase
     case AIACTLOOKATTARGET:
      rem FPGC - 280410 - if player is target, head tracks current player position (good for talking)
      tokay=0
      if entityelement(e).actualtarget=1 and (player(1).health>0 or playerstartstrength=0) then tokay=1
      if tokay=1
       rem current player ccoordinate used
       tdistx#=mex#-entityelement(e).x
       tdistz#=mez#-entityelement(e).z
      else
       rem last known target coordinate
       tdistx#=entityelement(e).actualtargetx-entityelement(e).x
       tdistz#=entityelement(e).actualtargetz-entityelement(e).z
      endif
      tdiffangle#=wrapvalue(atanfull(tdistx#,tdistz#))-wrapvalue(entityelement(e).mover.da)
      if tdiffangle#>180 then tdiffangle#=tdiffangle#-360
      if abs(tdiffangle#)>aiactionseq(seq).value then tdiffangle#=0
      entityelement(e).ai.headdestangle=tdiffangle#
     endcase
     case AIACTMOVETOTARGET:
      tokay=0
      if entityelement(e).actualtarget<>1 then tokay=1
      if entityelement(e).actualtarget=1 and (player(1).health>0 or playerstartstrength=0) then tokay=1
      if tokay=1
       tdistx#=entityelement(e).actualtargetx-entityelement(e).x
       tdistz#=entityelement(e).actualtargetz-entityelement(e).z
       tdiffangle#=atanfull(tdistx#,tdistz#)
       tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))
       if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
       entityelement(e).mover.da=wrapvalue(tdiffangle#)
       tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
       entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
       entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
       entityelement(e).mover.dy=entityelement(e).actualtargety
       entityelement(e).mover.moved=1
       entityelement(e).mover.run=aiactionseq(seq).value
       entityelement(e).mover.strafe=0
      endif
     endcase
     case AIACTCOLLECTTARGET:
      te=entityelement(e).actualtarget-1
      if te>0
       tobj=entityelement(te).obj
       if tobj>0
        if entityelement(te).x<>-99999
         rem Not already collected
         `detach object from static tobj : hide object tobj
         hide object tobj:entityelement(e).ishidden=2
         entityelement(te).x=-99999
         entityelement(te).y=-99999
         entityelement(te).z=-99999
         tplrid=entityelement(e).fakeplayerid
         if tplrid>0
          pint=player(tplrid).inventorymax : inc pint
          playerinventory(tplrid,pint).new=1
          playerinventory(tplrid,pint).index=te
          player(tplrid).inventorymax=pint
          rem make NPC player responsible for weapon selection (change to entity control)
          tentid=entityelement(te).bankindex : tgunid=entityprofile(tentid).isweapon
          if tgunid>0
           entityelement(e).currentweapon=tgunid
          endif
         endif
         entityelement(e).actualtarget=0
        endif
       endif
      endif
     endcase
     case AIACTCHOOSESTRAFE:
      entityelement(e).strafemode=rnd(2)
     endcase
     case AIACTSTRAFE:
`      if entityelement(e).strafemode=0 then entityelement(e).mover.strafe=0
`      if entityelement(e).strafemode=1 then entityelement(e).mover.strafe=aiactionseq(seq).value
`      if entityelement(e).strafemode=2 then entityelement(e).mover.strafe=aiactionseq(seq).value*-1
      rem replaced with immediate strafe
      tdiffangle#=aiactionseq(seq).value
      entityelement(e).mover.da=entityelement(e).mover.da+tdiffangle#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z : tdist#=15.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.strafe=0
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTPIVOTRANDOM:
      tmp#=aiactionseq(seq).value
      tdiffangle#=rnd(tmp#*2)-tmp#
      entityelement(e).mover.da=entityelement(e).mover.da+tdiffangle#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z : tdist#=5.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.strafe=0
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTLOOKATPLR:
      tdistx#=mex#-entityelement(e).x
      tdistz#=mez#-entityelement(e).z
      tdiffangle#=wrapvalue(atanfull(tdistx#,tdistz#))-wrapvalue(entityelement(e).mover.da)
      if tdiffangle#>180 then tdiffangle#=tdiffangle#-360
      if abs(tdiffangle#)>aiactionseq(seq).value then tdiffangle#=0
      entityelement(e).ai.headdestangle=tdiffangle#
     endcase
     case AIACTSETTARGETNAME:
      tstrindex=aiactionseq(seq).value
      tname$=actstring$(tstrindex)
      gosub _entity_findname
      if foundte>0
       entityelement(e).actualtarget=1+foundte
       entityelement(e).possibletarget=0
       if entityelement(e).actualtarget>1
        tte=entityelement(e).actualtarget-1
        entityelement(e).actualtargetx=entityelement(tte).x
        entityelement(e).actualtargety=entityelement(tte).y
        entityelement(e).actualtargetz=entityelement(tte).z
        entityelement(e).losttargetcount=0
       endif
      endif
     endcase
     `
     case AIACTWAYPOINTSTART:
      rem find nearest waypoint
      twdistbest#=99999.9 : twbest=0
      for w=1 to waypointcoordmax
       twdx#=abs(waypointcoord(w).x-entityelement(e).x)
       twdy#=abs(waypointcoord(w).y-entityelement(e).y)
       twdz#=abs(waypointcoord(w).z-entityelement(e).z)
       twdist#=sqrt((twdx#*twdx#)+(twdy#*twdy#)+(twdz#*twdz#))
       if twdist#<1000.0
        inc gameperfentities3
        entityelement(e).raycastcount=0
        if static raycast(entityelement(e).x,entityelement(e).y+35,entityelement(e).z,waypointcoord(w).x,waypointcoord(w).y+35,waypointcoord(w).z)=0
         if twdist#<twdistbest#
          twdistbest#=twdist# : twbest=w
         endif
        endif
       endif
      next w
      if twbest>0
       entityelement(e).ai.waypoint.current=twbest
       entityelement(e).ai.waypoint.tracker=waypointcoord(twbest).index
       entityelement(e).ai.waypoint.direction=1
       entityelement(e).ai.waypoint.state=1
      else
       rem if no start, place state in limbo away from WP activity
       entityelement(e).ai.waypoint.state=99
       rem special animation directive to enter idle mode
       entityelement(e).animset=1+1
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
      endif
      entityelement(e).losttargetcount=0
     endcase
     case AIACTWAYPOINTSTOP:
      entityelement(e).mover.dx=entityelement(e).x
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.dz=entityelement(e).z
      entityelement(e).ai.waypoint.state=99 : rem still waypoint activity
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTWAYPOINTREVERSE:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        entityelement(e).ai.waypoint.direction=2
        w=entityelement(e).ai.waypoint.current
        if w>waypoint(entityelement(e).ai.waypoint.tracker).start
         entityelement(e).ai.waypoint.current=w-1
        endif
       else
        entityelement(e).ai.waypoint.direction=1
        w=entityelement(e).ai.waypoint.current
        if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
         entityelement(e).ai.waypoint.current=w+1
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTNEXT:
      if entityelement(e).ai.waypoint.current>0
       tgoaheadandincdec=0
       if entityelement(e).ai.waypoint.state=99
        rem FPGC - 100610 - if previously used STOP (99), and then instruct NEXT, should NOT increment node destination!
        rem except in the case where the entity is already AT the destination (cases where a STOP is actioned when state=3 in script)
        w=entityelement(e).ai.waypoint.current
        distx#=waypointcoord(w).x-entityelement(e).x
        distz#=waypointcoord(w).z-entityelement(e).z
        wpdist#=sqrt(abs(distx#*distx#)+abs(distz#*distz#))
        if wpdist#<=10.0*(entityelement(e).eleprof.speed/100.0)
         rem radius bigger to avoid catch twenty two
         tgoaheadandincdec=1
        endif
       else
        tgoaheadandincdec=1
       endif
       if tgoaheadandincdec=1
        if entityelement(e).ai.waypoint.direction=1
         w=entityelement(e).ai.waypoint.current
         if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
          entityelement(e).ai.waypoint.current=w+1
         endif
        else
         w=entityelement(e).ai.waypoint.current
         if w>waypoint(entityelement(e).ai.waypoint.tracker).start
          entityelement(e).ai.waypoint.current=w-1
         endif
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTPREV:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        entityelement(e).ai.waypoint.current=entityelement(e).ai.waypoint.current-1
       else
        entityelement(e).ai.waypoint.current=entityelement(e).ai.waypoint.current+1
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTRANDOM:
      if entityelement(e).ai.waypoint.current>0
       r=rnd(1)
       if r=0
        w=entityelement(e).ai.waypoint.current
        linkto=waypointcoord(w).link
        entityelement(e).ai.waypoint.current=linkto
        entityelement(e).ai.waypoint.tracker=waypointcoord(linkto).index
       else
        if entityelement(e).ai.waypoint.direction=1
         w=entityelement(e).ai.waypoint.current
         if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
          entityelement(e).ai.waypoint.current=w+1
         endif
        else
         w=entityelement(e).ai.waypoint.current
         if w>waypoint(entityelement(e).ai.waypoint.tracker).start
          entityelement(e).ai.waypoint.current=w-1
         endif
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     `
     case AIACTDROPMARKER:
      tindex=entitybreadcrumbs(e,0).x
      if tindex<50
       rem find center of tile
       tcx=(int(entityelement(e).x/100)*100)+50
       tcy=(int(entityelement(e).y/100)*100)+10
       tcz=(int(entityelement(e).z/100)*100)-50
       tgeoblock=0
       tmpx1#=tcx
       tmpy1#=tcy+50
       tmpz1#=tcz
       tmpx2#=entitybreadcrumbs(e,tindex).x
       tmpy2#=entitybreadcrumbs(e,tindex).y+50
       tmpz2#=entitybreadcrumbs(e,tindex).z
       inc gameperfentities3
       entityelement(e).raycastcount=0
       if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
        tcx=entityelement(e).x
        tcy=entityelement(e).y
        tcz=entityelement(e).z
       endif
       if entitybreadcrumbs(e,tindex).x=tcx and entitybreadcrumbs(e,tindex).y=tcy and entitybreadcrumbs(e,tindex).z=tcz
        rem same as current crumb
       else
        rem new one
        if tindex<50
         inc tindex
         entitybreadcrumbs(e,0).x=tindex
         entitybreadcrumbs(e,tindex).x=tcx
         entitybreadcrumbs(e,tindex).y=tcy
         entitybreadcrumbs(e,tindex).z=tcz
        endif
       endif
      endif
     endcase
     case AIACTNEXTMARKER:
      tindex=entitybreadcrumbs(e,0).x
      tmpx1#=entityelement(e).x
      tmpy1#=entityelement(e).y+40
      tmpz1#=entityelement(e).z
      tmpx2#=entitybreadcrumbs(e,tindex).x
      tmpy2#=entitybreadcrumbs(e,tindex).y+40
      tmpz2#=entitybreadcrumbs(e,tindex).z
      inc gameperfentities3
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
       rem entity lost or trapped, or clipping geometry
       tmpx2#=(entitybreadcrumbs(e,tindex).x+rnd(150))-75
       tmpz2#=(entitybreadcrumbs(e,tindex).z+rnd(150))-75
       inc gameperfentities3
       entityelement(e).raycastcount=0
       if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)=0
        entitybreadcrumbs(e,tindex).x=tmpx2#
        entitybreadcrumbs(e,tindex).z=tmpz2#
       endif
      endif
      rem keep looking until clear path found
      inc gameperfentities3
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)=0
       if tindex>0
        tdistx#=entitybreadcrumbs(e,tindex).x-entityelement(e).x
        tdistz#=entitybreadcrumbs(e,tindex).z-entityelement(e).z
        if entityelement(e).mover.moved=0
         tdiffangle#=atanfull(tdistx#,tdistz#)
         tdist#=sqrt((tdistx#*tdistx#)+(tdistz#*tdistz#))
         if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
         entityelement(e).mover.da=wrapvalue(tdiffangle#)
         tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
         entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
         entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
         entityelement(e).mover.dy=entitybreadcrumbs(e,tindex).y
         entityelement(e).mover.moved=1
         entityelement(e).mover.run=0
        endif
        if abs(tdistx#+tdistz#)<2.0
         dec tindex : entitybreadcrumbs(e,0).x=tindex
        endif
       endif
      else
       rem no, that path was blocked
       entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
      endif
     endcase
     case AIACTRESETMARKERS:
      entitybreadcrumbs(e,0).x=0
      entityelement(e).mover.moved=0
      entityelement(e).mover.run=0
     endcase
     case AIACTFOLLOWPLR:
      rem LEGACY - DarkAI should improve this failed code significantly
      if entityelement(e).plrtrailindex>0
       if entityelement(e).plrtrailindex<>playertrailmax
        ttrailindex=entityelement(e).plrtrailindex+1
        if ttrailindex>100 then ttrailindex=1
        if playertrial(ttrailindex).time>0
         tdistx#=playertrial(ttrailindex).x-entityelement(e).x
         tdistz#=playertrial(ttrailindex).z-entityelement(e).z
         if sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))<20.0
          entityelement(e).plrtrailindex=entityelement(e).plrtrailindex+1
          if entityelement(e).plrtrailindex>100
           entityelement(e).plrtrailindex=1
          endif
         endif
         if entityelement(e).mover.moved=0
          tdiffangle#=atanfull(tdistx#,tdistz#)
          if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
          entityelement(e).mover.da=wrapvalue(tdiffangle#)
          tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
          entityelement(e).mover.dx=playertrial(ttrailindex).x
          entityelement(e).mover.dy=playertrial(ttrailindex).y
          entityelement(e).mover.dz=playertrial(ttrailindex).z
          entityelement(e).mover.run=aiactionseq(seq).value
          entityelement(e).mover.moved=1
         endif
        else
         entityelement(e).plrtrailindex=0
        endif
       else
        rem reached player, no more following just look at plr
        tdistx#=mex#-entityelement(e).x
        tdistz#=mez#-entityelement(e).z
        tdiffangle#=atanfull(tdistx#,tdistz#)
        if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
        entityelement(e).mover.da=wrapvalue(tdiffangle#)
       endif
      else
       rem if no place in trail, find newest node that was at entities level
       tcount=0 : ttrailindex=playertrailmax-1
       `set cursor 0,0
       while tcount<100
        if playertrial(ttrailindex).time>0
         `print "plry=";playertrial(ttrailindex).y;" enty=";entityelement(e).y;" diff=";abs(playertrial(ttrailindex).y-entityelement(e).y)
         if abs(playertrial(ttrailindex).y-entityelement(e).y)<40.0 then exit
        endif
        dec ttrailindex : if ttrailindex<1 then ttrailindex=100
        inc tcount
       endwhile
       if tcount<100
        rem if point is good to go, go to it
        if playertrial(ttrailindex).time>0
`         dec ttrailindex : if ttrailindex<1 then ttrailindex=100 `why one less? already deducted above
         entityelement(e).plrtrailindex=ttrailindex
        else
         entityelement(e).plrtrailindex=0
        endif
       else
        rem could not find any trail
        entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
       endif
      endif
      `
      rem if debug, show which trail marker by flashing it
      if gshowdebugtextingamestate=1
       if entityelement(e).plrtrailindex>0
        ttrailindex=entityelement(e).plrtrailindex+1
        if ttrailindex>100 then ttrailindex=1
        tdobj=gamdebugobjoffset+ttrailindex
        if object exist(tdobj)=1 then set object emissive tdobj,rgb(rnd(255),rnd(255),rnd(255))
       endif
      endif
      `
     endcase
     `
     case AIACTPLRTAKE:
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1
        mptrigger=1 : mptriggervalue1=e
        gosub _multi_mptrigger
       endif
       `
       rem if child of spawn leader, reset spawn count
       spawne=entityelement(e).spawn.leaderid
       if spawne=0 then spawne=e
       entityelement(spawne).spawn.leadercount=entityelement(spawne).spawn.delay
       `
       rem switch off obj
       if obj>0
        gosub _ode_switchoffe
        hide object obj:entityelement(e).ishidden=2
        set object collision off obj
       endif
       `
       rem V110 BETA4 - 070608 - if always active, a collected item keeps script running (for possible PLAYERDROP)
       if entityelement(e).eleprof.phyalways<>0
        rem do not kill entity, keep it running
       else
        rem stop any looping sound
        gosub _ai_stopentsounds
        rem reset values
        entityelement(e).beenkilled=1
        entityelement(e).active=0
       endif
       `
       rem clear entity from col map
       tx=entityelement(e).x/25
       ty=entityelement(e).y/100
       tz=entityelement(e).z/-25
       if tx>=0 and ty>=0 and tz>=0
        if tx<=viscolx and ty<=viscoly and tz<=viscolz
         if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
        endif
       endif
       `
       rem mission objective counter
       gosub _entity_resolveobjective
       `
       rem only allow weapons
       pint=player(1).inventorymax : inc pint
       if pint<100
        playerinventory(1,pint).new=1
        playerinventory(1,pint).index=e
        player(1).inventorymax=pint
       endif
       `
     endcase
     case AIACTPLRDROP:
      entityelement(e).x=mex#
      entityelement(e).y=mey#-15-phyeyeheight# : rem V111 BETA3 - dropped objects no longer float
      entityelement(e).z=mez#
      entityelement(e).active=1
      gosub _entity_controlrecalcdist
      if obj>0
       position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
       set object collision on obj
       show object obj:entityelement(e).ishidden=0
      endif
      rem in case drop originated outside (not .drop=x)
      for pint=1 to player(1).inventorymax
       if playerinventory(1,pint).index=e then player(1).command.drop=pint : exit
      next pint
     endcase
     case AIACTPLRDROPCURRENT:
      rem only drop if entity is also being currently in use (current)
      tentid=entityelement(e).bankindex : ttgunid=entityprofile(tentid).isweapon
      if ttgunid>0 and ttgunid=gunid
       entityelement(e).x=mex#
       entityelement(e).y=mey#-15-phyeyeheight#
       entityelement(e).z=mez#
       entityelement(e).active=1
       gosub _entity_controlrecalcdist
       if obj>0
        position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
        set object collision on obj
        show object obj:entityelement(e).ishidden=0
       endif
       rem in case drop originated outside (not .drop=x)
       for pint=1 to player(1).inventorymax
        if playerinventory(1,pint).index=e then player(1).command.drop=pint : exit
       next pint
      endif
     endcase
     `
     case AIACTSHOOTPLR:
      rem replace with shoot sequence
      trundefaultscriptinternal=1
      trundefaultscript=1+entityelement(e).ai.libshoot
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     `
     case AIACTUSEWEAPON:
      rem fire weapon (entity may have)
      tgunid=entityelement(e).currentweapon
      if tgunid>0
       if entityelement(e).currentammo>0 or firemode(tgunid,0).settings.reloadqty=0
        if entityelement(e).currentammo>0
         entityelement(e).currentammo=entityelement(e).currentammo-1
        endif
        entityelement(e).fireweapon=1
        entityelement(e).fireweapontimer=timer()
        rem FPSCV105RC2 - strength of fire (throw grenade when plr close)
        if aiactionseq(seq).value>0
         entityelement(e).firestrength=aiactionseq(seq).value
        else
         entityelement(e).firestrength=100
        endif
       endif
      else
       rem does enemy make dry-fire sound
      endif
     endcase
     case AIACTRELOADWEAPON:
      tgunid=entityelement(e).currentweapon
      if tgunid>0
       tneedfromclip=firemode(tgunid,0).settings.reloadqty-entityelement(e).currentammo
       if tneedfromclip>0
        entityelement(e).currentammo=firemode(tgunid,0).settings.reloadqty
        entityelement(e).currentclipammo=entityelement(e).currentclipammo-tneedfromclip
       endif
      endif
     endcase
     `
     case AIACTCOLOFF:
      if obj>0
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1 then mptrigger=2 : mptriggervalue1=e : gosub _multi_mptrigger
       `
       entityelement(e).collisionactive=0
       if entityelement(e).eleprof.physics<>0
        gosub _ode_switchoffe
       else
        set object collision off obj
       endif
      endif
     endcase
     case AIACTCOLON:
      if obj>0
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1 then mptrigger=2 : mptriggervalue1=e : gosub _multi_mptrigger
       `
       rem entity collision solid
       entityelement(e).collisionactive=1
       rem activate object collision
       if entityelement(e).eleprof.physics<>0
        gosub _ode_setupewithphysics
        gosub _ode_ensureeisnotpenetrated
       else
        set object collision on obj
       endif
       rem ensure plr is pushed out of entity influence
       tdx#=mex#-entityelement(e).x
       tdz#=mez#-entityelement(e).z
       tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
       if tdd#<30.0
        tda#=atanfull(tdx#,tdz#)
        camforcex#=newxvalue(entityelement(e).x,tda#,30.0)-camerapositionx
        camforcez#=newzvalue(entityelement(e).z,tda#,30.0)-camerapositionz
       endif
       rem ensure ALL entities are pushed out of entity influence (this is why second door zoomed away)
       for te=1 to entityelementlist
        if entityelement(te).active=1 and entityelement(te).eleprof.physics<=2
         if entityelement(te).eleprof.isimmobile=0
          tdx#=entityelement(te).x-entityelement(e).x
          tdz#=entityelement(te).z-entityelement(e).z
          tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
          if tdd#<30.0
           rem TE-entity within solid entity
           tda#=atanfull(tdx#,tdz#)
           entityelement(te).mover.dx=newxvalue(entityelement(e).x,tda#,30.0)
           entityelement(te).mover.dz=newzvalue(entityelement(e).z,tda#,30.0)
           entityelement(te).mover.dy=entityelement(e).y
           entityelement(te).mover.moved=1
           entityelement(te).mover.run=0
          endif
         endif
        endif
       next te
      endif
     endcase
     case AIACTSPAWNON:
      entityelement(e).spawn.atstart=1
     endcase
     case AIACTSPAWNOFF:
      entityelement(e).spawn.atstart=0
     endcase
     `
     case AIACTHEADSHOT:
      entityelement(e).ai.headshot=aiactionseq(seq).value
     endcase
     case AIACTHEADSHOTDAMAGE:
      gheadshotdamage=aiactionseq(seq).value
     endcase
     `
     case AIACTAMBIENCE:
      guivisualsettings.ambience=aiactionseq(seq).value
      forceambientlightsetting=10 : guivisualsettings.updateflag=1
      guivisualsettings.ambiencescripted=1
      gosub _lighting_postdefaults
     endcase
     case AIACTAMBIENCERED:
      hudambiencered=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTAMBIENCEGREEN:
      hudambiencegreen=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTAMBIENCEBLUE:
      hudambienceblue=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTFOG:
      if aiactionseq(seq).value>0
       `fog on
       rem FPSCV104 added global vars for fog
       hudfogon=1
       if aiactionseq(seq).value>1
        hudfognear=aiactionseq(seq).value
        if aiactionseq(seq).value>1000
         hudfogfar=4000.0
        else
         hudfogfar=1000.0
        endif
       else
        hudfognear=0
        hudfogfar=1000.0
       endif
       `fog distance hudfognear,hudfogfar
       `fog color hudfogred,hudfoggreen,hudfogblue
      else
       `fog off
       hudfogon=0
       hudfognear=-2000
       hudfogfar=-10000
      endif
     endcase
     case AIACTFOGRED:
      hudfogred=aiactionseq(seq).value
      `fog color hudfogred,hudfoggreen,hudfogblue
     endcase
     case AIACTFOGGREEN:
      hudfoggreen=aiactionseq(seq).value
      `fog color hudfogred,hudfoggreen,hudfogblue
     endcase
     case AIACTFOGBLUE:
      hudfogblue=aiactionseq(seq).value
      `fog color hudfogred,hudfoggreen,hudfogblue
     endcase
     `markblosser - add new fogstart,fogend,and fogoffset commands
     case AIACTFOGSTART:
      hudfognear=aiactionseq(seq).value
     endcase
     case AIACTFOGEND:
      hudfogfar=aiactionseq(seq).value
     endcase
     `markblosser - add setposteffect command
     case AIACTSETPOSTEFFECT:
      effectfilename$=""
      effectfilename$="effectbank\postprocess\" +lower$(aiactionseq(seq).filename) + ".fx"
      rem make sure post effect file exists
      if file exist(effectfilename$)
       rem make sure post-processing object exists, if not, ignore effect
       if object exist (65536)=1
        select effectfilename$
         case "effectbank\postprocess\gasmask.fx"
          texture object 65536,0,65536
          texture object 65536,1,65538
          texture object 65536,2,65539
         endcase
         case "effectbank\postprocess\refract.fx"
          texture object 65536,0,65536
          texture object 65536,1,65540
         endcase
         case "effectbank\postprocess\multi.fx"
          texture object 65536,0,65536
          texture object 65536,1,65541
          texture object 65536,2,65542
         endcase
         case "effectbank\postprocess\filmreel.fx"
          texture object 65536,0,65536
          texture object 65536,1,65543
         endcase
         case "effectbank\postprocess\rain.fx"
          texture object 65536,0,65536
          texture object 65536,1,65544
          texture object 65536,2,65545
         endcase
        endselect
        if effect exist(65535)=1 then delete effect 65535
        load effect effectfilename$,65535,0
        set object effect 65536,65535
       endif
      endif
     endcase
     case AIACTSKY:
      rem Already done during loading of AI-Asset
     endcase
     case AIACTSKYSCROLL:
      rem Already done during loading of AI-Asset
     endcase
     `
     `
     `
     case AIACTNEWJUMPHEIGHT:
      playerdefaultjumpheight=aiactionseq(seq).value
     endcase
     `
     `
     `
     case AIACTBACKDROP:
      if aiactionseq(seq).value>0
       rem AirMod - Stop Backdrop Animation if existent
       if animation exist(1) then stop animation 1 : delete animation 1
       set sprite 65534,0,0
       sprite 65534,-10000,-10000,aiactionseq(seq).value
       size sprite 65534,screen width(),screen height()
       paste sprite 65534,0,0
      endif
     endcase
     case AIACTMUSIC:
      if musicoverridden=0
       if lastmusicplayed>0
        if sound exist(lastmusicplayed)=1 then stop sound lastmusicplayed
        lastmusicplayed=0
       endif
       rem V109BETA4 - 240408 - support for sound set music playback
       tmusictogoplay=0
       if aiactionseq(seq).value=-1
        tmusictogoplay=entityelement(e).soundset
       else
        if aiactionseq(seq).value=-2
         tmusictogoplay=entityelement(e).soundset1
        else
         tmusictogoplay=aiactionseq(seq).value
        endif
       endif
       if tmusictogoplay>0
        hudmusicvolume=100
        loop sound tmusictogoplay
        set sound volume tmusictogoplay,80+(hudmusicvolume/5)
        lastmusicplayed=tmusictogoplay
       endif
      endif
     endcase
     case AIACTMUSICOVERRIDE:
      rem Copy of above (but it cannot be removed with a MUSIC command (global script)
      if lastmusicplayed>0
       if sound exist(lastmusicplayed)=1 then stop sound lastmusicplayed
       lastmusicplayed=0
      endif
      rem V109BETA4 - 240408 - support for sound set music playback
      tmusictogoplay=0
      if aiactionseq(seq).value=-1
       tmusictogoplay=entityelement(e).soundset
      else
       if aiactionseq(seq).value=-2
        tmusictogoplay=entityelement(e).soundset1
       else
        tmusictogoplay=aiactionseq(seq).value
       endif
      endif
      if tmusictogoplay>0
       hudmusicvolume=100
       loop sound tmusictogoplay
       set sound volume tmusictogoplay,80+(hudmusicvolume/5)
       lastmusicplayed=tmusictogoplay
      endif
      musicoverridden=tmusictogoplay
     endcase
     case AIACTMUSICVOLUME:
      hudmusicvolume=aiactionseq(seq).value
      if lastmusicplayed>0
       if sound exist(lastmusicplayed)=1
        set sound volume lastmusicplayed,80+(hudmusicvolume/5)
       endif
      endif
     endcase
     case AIACTSOUNDSCALE:
      tmp#=aiactionseq(seq).value
      tmp#=tmp#/100.0 : scale listener tmp#
     endcase
     `
     case AIACTVIDEO:
      videofilename$=""
      if aiactionseq(seq).value=-1
       videofilename$=entityelement(e).eleprof.soundset$
      else
       if aiactionseq(seq).value=-2
        videofilename$=entityelement(e).eleprof.soundset1$
       else
        tstringindex=aiactionseq(seq).value
        if tstringindex>0
         videofilename$=actstring$(tstringindex)
        endif
       endif
      endif
      if videofilename$<>""
       if file exist(videofilename$)=1
        lastvideoplayed=1
        load animation videofilename$,lastvideoplayed
        play animation lastvideoplayed,0,0,screen width(),screen height()
        while animation playing(lastvideoplayed)=1
        Rem Scene Commander unskippible video
        if unskip=0
            if control_escapekey()=1 then exit
            if spacekey()=1 then exit
            if control_mouseclick()<>0 then exit
        endif
         sync
        endwhile
        while control_escapekey()=1 or spacekey()=1 or control_mouseclick()<>0 : sync : endwhile
        unskip=0
        delete animation lastvideoplayed
        lastvideoplayed=0
        tensureentitytimestampsupdated=1
       endif
      endif
     endcase
     `
     case AIACTWEBLINK:
      rem launch if it is a web site address, else silently fail
      weblinkaddress$=""
      weblinkaddress$=aiactionseq(seq).string1
      if weblinkaddress$="$0"
       weblinkaddress$=entityelement(e).eleprof.soundset$
      else
       if weblinkaddress$="$1"
        weblinkaddress$=entityelement(e).eleprof.soundset1$
      endif
      endif
        rem launch if it is a web site address, else silently fail
        if weblinkaddress$<>""
            if lower$( left$(weblinkaddress$,3) )="www"
                weblinkaddress$ = "http:\\" + weblinkaddress$
                window to back
                execute file "iexplore.exe",weblinkaddress$,"C:\Program Files\Internet Explorer",1
                window to front
            endif
        endif
     endcase

     `
     case AIACTEXPLODE:
      texplodable=entityelement(e).eleprof.explodable
      tentid=entityelement(e).bankindex
      `
      if texplodable=1
       rem the visual and audio bang part
       frox#=entityelement(e).x : froy#=entityelement(e).y : froz#=entityelement(e).z
       gosub _part_triggerexplosion
       rem the force part
       spheredamage=entityelement(e).eleprof.explodedamage
       spherex#=frox# : spherey#=froy# : spherez#=froz#
       sphereforce#=1.0 : gosub _entity_addforcesphere
       rem characters disappear when they explode
       if entityprofile(tentid).ischaracter=1
        rem destroy object completely
        gosub _ode_switchoffe
        rem hide object
        tobj=entityelement(e).obj
        hide object tobj:entityelement(e).ishidden=2
        rem hide blob shadow if any
        if entityelement(e).attachmentblobobj>0
         if object exist(entityelement(e).attachmentblobobj)=1
          hide object entityelement(e).attachmentblobobj
         endif
        endif
        rem triggers the throwback scripts to skip, direct to destroy AI
        tresult=4
       endif
      endif
      `
      if texplodable=2 and explosionscorch<>0
       rem not quite explode, just scorch (as though internally fried)
       tobj=entityelement(e).obj
       set blend mapping on tobj, 1, explosionscorch, 3, 6
       set object transparency tobj,0
      endif
      `
      Rem entity is scriptable flak - blow it up as if it were a normal piece of flak
      if texplodable=3
       tobj=entityelement(e).obj
       rem USED TO hide flak object - Lets let it live so we can have flak objects blow up multiple times
       `hide object tobj
       rem trigger exploder
       frox#=object position x(tobj)
       froy#=object position y(tobj)
       froz#=object position z(tobj)
       gosub _part_triggerexplosion
       rem make sound seem louder by moving it closer to player
       playinternal3dsound(flak(tflakid).sound.sndexplodeid,decalx,decaly,decalz)
       rem ONLY affect decal with ZBIAS if explosion that needs to be seen by player in full
       if object exist(tobj)=1 then enable object zbias tobj,-500.0,0.0
       rem initial blast creates scorch (in six directions)
       for tscdir=1 to 6
        if tscdir=1 then t=static raycast(frox#+0,froy#,froz#,frox#-400,froy#,froz#) `200
        if tscdir=2 then t=static raycast(frox#+0,froy#,froz#,frox#+400,froy#,froz#)
        if tscdir=3 then t=static raycast(frox#,froy#+0,froz#,frox#,froy#-400,froz#)
        if tscdir=4 then t=static raycast(frox#,froy#+0,froz#,frox#,froy#+400,froz#)
        if tscdir=5 then t=static raycast(frox#,froy#,froz#+0,frox#,froy#,froz#-400)
        if tscdir=6 then t=static raycast(frox#,froy#,froz#+0,frox#,froy#,froz#+400)
        tsize#=45-rnd(30) : if t=1 then add static scorch tsize#,4+rnd(3)
       next tscdir
       rem initial blast creates light flash
       spotflash=100 : tx#=decalx : ty#=decaly : tz#=decalz
       tcolr=255
       tcolg=255
       tcolb=0
       gosub _lighting_spotflash
       rem all entities that can take damage (characters, windows)
       tx#=object position x(tobj) : ty#=object position y(tobj) : tz#=object position z(tobj)
       spheredamage=flak(entityelement(e).isflak).profile.damage
       spherex#=tx# : spherey#=ty# : spherez#=tz# : sphereforce#=1.0
       gosub _entity_addforcesphere
       disable object zbias tobj
      endif
     endcase
     `
     case AIACTLIGHTON:
      tokay=0
      entityelement(e).eleprof.light.islit=1
      if gdynamiclightingstate=1
       if entityelement(e).eleprof.light.index<=array count(infinilight())
        if infinilight(entityelement(e).eleprof.light.index).islit=0
         infinilight(entityelement(e).eleprof.light.index).islit=1 : tokay=1
        endif
       endif
      endif
      rem V118 - entities need to be jogged so they re-capture the new lighting profile
      if tokay=1
       for tttte=1 to entityelementlist
        ldistx#=infinilight(entityelement(e).eleprof.light.index).x-entityelement(tttte).x
        ldisty#=infinilight(entityelement(e).eleprof.light.index).y-entityelement(tttte).y
        ldistz#=infinilight(entityelement(e).eleprof.light.index).z-entityelement(tttte).z
        ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
        if ldist#<=infinilight(entityelement(e).eleprof.light.index).range
         entityelement(tttte).colr=-1
        endif
       next tttte
      endif
     endcase
     case AIACTLIGHTOFF:
      tokay=0
      entityelement(e).eleprof.light.islit=0
      if gdynamiclightingstate=1
       if entityelement(e).eleprof.light.index<=array count(infinilight())
        if infinilight(entityelement(e).eleprof.light.index).islit=1
         infinilight(entityelement(e).eleprof.light.index).islit=0 : tokay=1
        endif
       endif
      endif
      rem V118 - entities need to be jogged so they re-capture the new lighting profile
      if tokay=1
       for tttte=1 to entityelementlist
        ldistx#=infinilight(entityelement(e).eleprof.light.index).x-entityelement(tttte).x
        ldisty#=infinilight(entityelement(e).eleprof.light.index).y-entityelement(tttte).y
        ldistz#=infinilight(entityelement(e).eleprof.light.index).z-entityelement(tttte).z
        ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
        if ldist#<=infinilight(entityelement(e).eleprof.light.index).range
         entityelement(tttte).colr=-1
        endif
       next tttte
      endif
     endcase
     case AIACTLIGHTRED:
      tokay=0
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(aiactionseq(seq).value,rgbg(dw),rgbb(dw))
      if gdynamiclightingstate=1
       if infinilight(entityelement(e).eleprof.light.index).colrgb.r<>aiactionseq(seq).value
        infinilight(entityelement(e).eleprof.light.index).colrgb.r=aiactionseq(seq).value : tokay=1
       endif
      endif
      rem V118 - entities need to be jogged so they re-capture the new lighting profile
      if tokay=1
       for tttte=1 to entityelementlist
        ldistx#=infinilight(entityelement(e).eleprof.light.index).x-entityelement(tttte).x
        ldisty#=infinilight(entityelement(e).eleprof.light.index).y-entityelement(tttte).y
        ldistz#=infinilight(entityelement(e).eleprof.light.index).z-entityelement(tttte).z
        ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
        if ldist#<=infinilight(entityelement(e).eleprof.light.index).range
         entityelement(tttte).colr=-1
        endif
       next tttte
      endif
     endcase
     case AIACTLIGHTGREEN:
      tokay=0
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(rgbr(dw),aiactionseq(seq).value,rgbb(dw))
      if gdynamiclightingstate=1
       if infinilight(entityelement(e).eleprof.light.index).colrgb.g<>aiactionseq(seq).value
        infinilight(entityelement(e).eleprof.light.index).colrgb.g=aiactionseq(seq).value : tokay=1
       endif
      endif
      rem V118 - entities need to be jogged so they re-capture the new lighting profile
      if tokay=1
       for tttte=1 to entityelementlist
        ldistx#=infinilight(entityelement(e).eleprof.light.index).x-entityelement(tttte).x
        ldisty#=infinilight(entityelement(e).eleprof.light.index).y-entityelement(tttte).y
        ldistz#=infinilight(entityelement(e).eleprof.light.index).z-entityelement(tttte).z
        ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
        if ldist#<=infinilight(entityelement(e).eleprof.light.index).range
         entityelement(tttte).colr=-1
        endif
       next tttte
      endif
     endcase
     case AIACTLIGHTBLUE:
      tokay=0
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(rgbr(dw),rgbg(dw),aiactionseq(seq).value)
      if gdynamiclightingstate=1
       if infinilight(entityelement(e).eleprof.light.index).colrgb.b<>aiactionseq(seq).value
        infinilight(entityelement(e).eleprof.light.index).colrgb.b=aiactionseq(seq).value : tokay=1
       endif
      endif
      rem V118 - entities need to be jogged so they re-capture the new lighting profile
      if tokay=1
       for tttte=1 to entityelementlist
        ldistx#=infinilight(entityelement(e).eleprof.light.index).x-entityelement(tttte).x
        ldisty#=infinilight(entityelement(e).eleprof.light.index).y-entityelement(tttte).y
        ldistz#=infinilight(entityelement(e).eleprof.light.index).z-entityelement(tttte).z
        ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
        if ldist#<=infinilight(entityelement(e).eleprof.light.index).range
         entityelement(tttte).colr=-1
        endif
       next tttte
      endif
     endcase
     case AIACTLIGHTRANGE:
      tokay=0
      entityelement(e).eleprof.light.range=aiactionseq(seq).value
      if gdynamiclightingstate=1
       if infinilight(entityelement(e).eleprof.light.index).range<>aiactionseq(seq).value
        infinilight(entityelement(e).eleprof.light.index).range=aiactionseq(seq).value : tokay=1
       endif
      endif
      rem V118 - entities need to be jogged so they re-capture the new lighting profile
      if tokay=1
       for tttte=1 to entityelementlist
        ldistx#=infinilight(entityelement(e).eleprof.light.index).x-entityelement(tttte).x
        ldisty#=infinilight(entityelement(e).eleprof.light.index).y-entityelement(tttte).y
        ldistz#=infinilight(entityelement(e).eleprof.light.index).z-entityelement(tttte).z
        ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
        if ldist#<=infinilight(entityelement(e).eleprof.light.index).range
         entityelement(tttte).colr=-1
        endif
       next tttte
      endif
     endcase
     case AIACTLIGHTINTENSITY:
      tokay=0
      intensity#=aiactionseq(seq).value
      intensity#=intensity#/100.0
      dw=entityelement(e).eleprof.light.color
      if gdynamiclightingstate=1
       if infinilight(entityelement(e).eleprof.light.index).colrgb.r<>rgbr(dw)*intensity#
        infinilight(entityelement(e).eleprof.light.index).colrgb.r=rgbr(dw)*intensity# : tokay=1
       endif
       if infinilight(entityelement(e).eleprof.light.index).colrgb.g<>rgbg(dw)*intensity#
        infinilight(entityelement(e).eleprof.light.index).colrgb.g=rgbg(dw)*intensity# : tokay=1
       endif
       if infinilight(entityelement(e).eleprof.light.index).colrgb.b<>rgbb(dw)*intensity#
        infinilight(entityelement(e).eleprof.light.index).colrgb.b=rgbb(dw)*intensity# : tokay=1
       endif
      endif
      rem V118 - entities need to be jogged so they re-capture the new lighting profile
      if tokay=1
       for tttte=1 to entityelementlist
        ldistx#=infinilight(entityelement(e).eleprof.light.index).x-entityelement(tttte).x
        ldisty#=infinilight(entityelement(e).eleprof.light.index).y-entityelement(tttte).y
        ldistz#=infinilight(entityelement(e).eleprof.light.index).z-entityelement(tttte).z
        ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
        if ldist#<=infinilight(entityelement(e).eleprof.light.index).range
         entityelement(tttte).colr=-1
        endif
       next tttte
      endif
     endcase
     `
     case AIACTHUDRESET:
      workhudx=0 : workhudy=0 : workhudz=0
      workhudsizex=0 : workhudsizey=0 : workhudsizez=0
      workhudred=255 : workhudgreen=255 : workhudblue=255 : workhudimage=0 : workhudimagefile$=""
      workhudfont$="" : workhudsize=0 : workhudtext$=""
      workhudtype=0 : workhudmake$=""
      workhudname$=""
      workhudhide=0
      rem Need to reset the hud uservar as well
      workhuduservar=-1 : workhuduservarlocal=0
     endcase
     case AIACTHUDX:
      workhudx=(gdisplaywidth/100.0)*aiactionseq(seq).value
     endcase
     case AIACTHUDY:
      workhudy=(gdisplayheight/100.0)*aiactionseq(seq).value
     endcase
     case AIACTHUDZ:
      workhudz=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEX:
      workhudsizex=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEY:
      workhudsizey=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEZ:
      workhudsizez=aiactionseq(seq).value
     endcase
     case AIACTHUDRED:
      workhudred=aiactionseq(seq).value
     endcase
     case AIACTHUDGREEN:
      workhudgreen=aiactionseq(seq).value
     endcase
     case AIACTHUDBLUE:
      workhudblue=aiactionseq(seq).value
     endcase
     case AIACTHUDIMAGE:
      `workhudimage=aiactionseq(seq).value FPGC - 231109 - need to retain image filename for game reload
      tindex=aiactionseq(seq).value
      workhudimagevalue$=left$(actstring$(tindex),4)
      workhudimagefile$=right$(actstring$(tindex),len(actstring$(tindex))-4)
      workhudimage=val(workhudimagevalue$)
     endcase
     case AIACTHUDIMAGEFINE:
      `workhudimage=aiactionseq(seq).value FPGC - 231109 - need to retain image filename for game reload
      tindex=aiactionseq(seq).value
      workhudimagevalue$=left$(actstring$(tindex),4)
      workhudimagefile$=right$(actstring$(tindex),len(actstring$(tindex))-4)
      workhudimage=val(workhudimagevalue$)
     endcase
     case AIACTHUDFONT:
      tindex=aiactionseq(seq).value
      workhudfont$=actstring$(tindex)
     endcase
     case AIACTHUDSIZE:
      workhudsize=aiactionseq(seq).value
     endcase
     case AIACTHUDTEXT:
      tindex=aiactionseq(seq).value
      workhudtext$=actstring$(tindex)
     endcase
     case AIACTHUDTYPE:
      workhudtype=aiactionseq(seq).value
     endcase
     case AIACTHUDHIDE:
      workhudhide=aiactionseq(seq).value
     endcase
     case AIACTHUDSHOW:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).hide=0
        if hud(thudid).maintype=8
         if hud(thudid).typemode>=20
          hud(thudid).typemode=hud(thudid).typemode-20
         endif
         clear entry buffer
         set text size 30
        endif
       endif
      next thudid
     endcase
     case AIACTHUDUNSHOW:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).hide=1
       endif
      next thudid
     endcase
     case AIACTHUDNAME:
      tindex=aiactionseq(seq).value
      workhudname$=actstring$(tindex)
     endcase
     case AIACTHUDANIM:
      `workhudimage=aiactionseq(seq).value FPGC - 231109 - need to retain image filename for game reload
      tindex=aiactionseq(seq).value
      workhudimagevalue$=left$(actstring$(tindex),4)
      workhudimagefile$=right$(actstring$(tindex),len(actstring$(tindex))-4)
      workhudimage=val(workhudimagevalue$)
     endcase
     case AIACTHUDFADEOUT:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).fadeout=150
       endif
      next thudid
     endcase
     case AIACTHUDMAKE:
      tindex=aiactionseq(seq).value
      workhudmake$=actstring$(tindex)
      gosub _ai_hud_add
     endcase
     rem Plystire - Added this action to set a HUD to corespond with a User Variable when set as Numeric type
     case AIACTHUDUSERVAR:
      rem First we gotta find the variable the user wants to use
      foundvar=0
      for uvar = 0 to array count(uservars())
       if uservars(uvar).name = aiactionseq(seq).string1 and uservars(uvar).used = 1
        rem Found it, let's set up the workhud to use it
        workhuduservar = uvar : foundvar=1
        rem And Exit the For Loop
        exit
       endif
      next uvar
      if foundvar=0
       for lvar = 0 to 99
        if aiuserlocals(e,lvar).name = aiactionseq(seq).string1 and aiuserlocals(e,lvar).used = 1
         rem Found it, let's set up the workhud to use it
         workhuduservar = lvar : foundvar=1 : workhuduservarlocal=e
         rem And Exit the For Loop
         exit
        endif
       next lvar
      endif
     endcase
     rem V118 - 110810 - knxrb - Hud Layers
     case AIACTHUDLAYER:
      hName$ = aiactionseq(seq).string1
      for hudid=1 to hudmax
          if lower$(hud(hudid).name$) = lower$(hName$)
            hud(hudid).layer = aiactionseq(seq).valueb
          endif
      next hudid
     endcase
     rem V118 - 160810 - knxrb - Hud - sethudx Command
     case AIACTSETHUDXPOS:
      hName$ = aiactionseq(seq).string1
      for hudid=1 to hudmax
          if lower$(hud(hudid).name$) = lower$(hName$)
            hud(hudid).posx = (gdisplaywidth/100.0)*aiactionseq(seq).valueb `-((hud(hudid).width/2)*gratiox#)
          endif
      next hudid
     endcase
     `
     case AIACTNEWGAME:
      rem Continue Only
      continueokay=1
     endcase
     case AIACTLOADGAME:
      rem Continue And Load
      if guiUsed = 0
          saveload.loadswitch=1
          saveloadfile$=""
          inputpositionmouse(screen width()/2,(screen height()/4)*3.5)
          cleardelta=mousemovex() : cleardelta=mousemovey()
          gosub _saveload_maindialogloop
          if saveloadfile$<>""
           rem Load level from scratch (using loadsavedlevel$)
           loadsavedlevel$=saveloadfile$ : saveloadfile$=""
           continueokay=1 : levelwon=3
          endif
          inputpositionmouse(screen width()/2,(screen height()/4)*3.5)
          cleardelta=mousemovex() : cleardelta=mousemovey()
          hudselectionmade=0
      else
        rem GUI-X9 (knxrb)
        initLoadSave = 0 : GUILoad = 1 : gosub _gui_run
      endif
     endcase
     case AIACTSAVEGAME:
      if guiUsed = 0
          rem Continue And Save
          saveload.loadswitch=0
          saveloadfile$=""
          inputpositionmouse(screen width()/2,(screen height()/4)*3.5)
          cleardelta=mousemovex() : cleardelta=mousemovey()
          gosub _saveload_maindialogloop
          if saveloadfile$<>""
           rem Save the current game position using 'saveloadfile$'
           gosub _saveload_savegame
           saveloadfile$=""
          endif
          while control_mouseclick()<>0 : endwhile
          inputpositionmouse(screen width()/2,(screen height()/4)*3.5)
          cleardelta=mousemovex() : cleardelta=mousemovey()
          hudselectionmade=0
      else
        rem GUI-X9 (knxrb)
        initLoadSave = 0 : GUISave = 1 : gosub _gui_run
      endif
     endcase
     case AIACTQUICKLOADGAME:
      rem Quick Load no prompt
      if gtestgamemodefromeditor=0
       saveloadfile$="gamesaves\slot"+str$(1)+".dat"
       if file exist(saveloadfile$)=1
        saveload.loadswitch=1
        loadsavedlevel$=saveloadfile$
        continueokay=1 : levelwon=3
        hudselectionmade=0
       endif
       saveloadfile$=""
      endif
     endcase
     case AIACTQUICKSAVEGAME:
      rem Quick Save no prompt
      if gtestgamemodefromeditor=0
       gosub _saveload_savebox_earlygrab
       gosub _saveload_savebox_initlist
       saveload.loadswitch=0
       saveload.slotselected=1
       gosub _saveload_savebox_dosave
       gosub _saveload_savegame
       hudselectionmade=0
       saveloadfile$=""
      endif
     endcase
     case AIACTCONTINUEGAME:
      rem Continue And Leave Level
      continueokay=1 : levelwon=2
     endcase
     case AIACTQUITGAME:
      rem Continue And Quit Out
      continueokay=1 : loopapp=0 : levelwon=2
     endcase
     case AIACTPAUSEGAME:
      rem User pressed ESCAPE, and is now in pause mode
      gosub _saveload_savebox_earlygrab
      cleardelta=mousemovex() : cleardelta=mousemovey()
      inputpositionmouse(screen width()/2,(screen height()/4)*3)
      hudselectionmade=0 : ttemp=control_mouseclick()
      showgamemenu=1

      for f=10 to 20
      if animation exist(f)=1
         if animation playing(f)=1
         animations(f-9).paused=2
         pause animation f
         endif
      endif
      next f
      `
      rem FPGC - 110809 - when in pause mode, freeze all 3D object frames (record here)
      `for o=1 to 65535
       `frozenframes#(o)=0.0
      ` if object exist(o)=1
        `if object visible(o)=1
         `frozenframes#(o)=object frame(o)
       ` endif
       `endif
    `  next o
      `
      rem FPGC - 080710 - resume any paused soundloops and animations
      for lsi=1 to entityelementmax
            frobj=entityelement(lsi).obj
         if frobj>0
            if object exist(frobj)
               entityelement(lsi).frozen.frames=object frame(frobj)
            endif
         endif
       rem V118 - 120810 - knxrb - etimer fix from Scene Commander
       entityelement(lsi).etimerpaused=entityelement(lsi).etimer
       entityelement(lsi).lastdamagepaused=entityelement(lsi).lastdamagetimer

       if entityelement(lsi).firesoundloop>0
        if sound exist(entityelement(lsi).firesoundloop)=1
         pause sound entityelement(lsi).firesoundloop
        endif
       endif
      next lsi
      `
     endcase
     case AIACTRESUMEGAME:
      showgamemenu=0
      while control_mouseclick()<>0 : endwhile
      cleardelta=mousemovex() : cleardelta=mousemovey()
      tensureentitytimestampsupdated=1


      for f=10 to 20
      if animation exist(f)=1
         if animations(f-9).paused=2
         resume animation f
         animations(f-9).paused=0
         endif
      endif
      next f
      `
      rem FPGC - 080710 - resume any paused soundloops and animations
      for lsi=1 to entityelementmax
         frobj=entityelement(lsi).obj
         if frobj>0
            if object exist(frobj)
               set object frame frobj,entityelement(lsi).frozen.frames
            endif
         endif

       rem V118 - 120810 - knxrb - etimer fix from Scene Commander
       entityelement(lsi).etimer=entityelement(lsi).etimerpaused
       entityelement(lsi).lastdamagetimer=entityelement(lsi).lastdamagepaused
       if entityelement(lsi).firesoundloop>0
        if sound exist(entityelement(lsi).firesoundloop)=1
         resume sound entityelement(lsi).firesoundloop
        endif
       endif
      next lsi
      `
     endcase
     case AIACTHOSTGAME:
      createorjoin=1
      gmultiplayergame=1
     endcase
     case AIACTJOINGAME:
      createorjoin=2
      gmultiplayergame=1
     endcase
     case AIACTREPEATGAME:
      rem flag a repeat of the game (without reloading then remove comments)
      repeatsamelevel=1
     endcase
     case AIACTETIMERSTART:
         entityelement(e).etimer=timer()
     endcase
     case AIACTTIMERSTART:
      hudtimer=timer()
     endcase
     rem AirMod - New Actions >>>
     case AIACTSETIFUSED:
      `tindex=aiactionseq(seq).value
      taiactionstring$=aiactionseq(seq).string1
      entityelement(e).eleprof.ifused$ = taiactionstring$
     endcase
     case AIACTSETUSEKEY:
      `tindex=aiactionseq(seq).value
      taiactionstring$=aiactionseq(seq).string1
      entityelement(e).eleprof.usekey$ = taiactionstring$
     endcase
     case AIACTRESETPLRWEAPONS:
      `Reset
      undim weaponslot()
      undim weaponammo()
      undim weaponclipammo()
      undim weaponhud()
      `Re-Define
      dim weaponslot(10) as weaponslottype
      dim weaponammo(20) as integer
      dim weaponclipammo(20) as integer
      for ws=1 to 10 : weaponslot(ws).pref=0 : next ws
      dim weaponhud(10) as integer
      `Remove Current Weapon
      if gunid<>0
       gunmode=31 : gunselectionafterhide=0
      endif
     endcase
     case AIACTBACKDROPVID:
      videofilename$=""
      if aiactionseq(seq).value=-1
       videofilename$=entityelement(e).eleprof.soundset$
      else
       if aiactionseq(seq).value=-2
        videofilename$=entityelement(e).eleprof.soundset1$
       else
        tstringindex=aiactionseq(seq).value
        if tstringindex>0
         videofilename$=actstring$(tstringindex)
        endif
       endif
      endif
      if videofilename$<>""
       if file exist(videofilename$)=1
         if animation exist(1) then stop animation 1 : delete animation 1
         load animation videofilename$,1
         place animation 1,0,0,screen width(),screen height()
         loop animation 1
       endif
      endif
     endcase
     case AIACTBLOODSPURT:
      tbloodspurtmode = aiactionseq(seq).value
      gosub _entity_doblood
     endcase
     case AIACTNOBULLETCOL:
      entityelement(e).nobulletcol=1
     endcase
     case AIACTALTAMMO:
      entityelement(e).isaltammo=1
     endcase
     case AIACTBLOODSPLASH:
      tindex=aiactionseq(seq).value
      tscorchtype3=8+rnd(3)
      tscorchsize3#=10.0 + rnd(20)`+((tbullethitflesh/100.0)*(20.0+rnd(20)))
      tobjx# = object position x(obj)
      tobjy# = object position y(obj)
      tobjz# = object position z(obj)
      t=static raycast(tobjx#,tobjy#,tobjz#,tobjx#+tindex,tobjy#,tobjz#)
      if t > 0 then add static scorch tscorchsize3#,tscorchtype3
      t=static raycast(tobjx#,tobjy#,tobjz#,tobjx#-tindex,tobjy#,tobjz#)
      if t > 0 then add static scorch tscorchsize3#,tscorchtype3
      t=static raycast(tobjx#,tobjy#,tobjz#,tobjx#,tobjy#+tindex,tobjz#)
      if t > 0 then add static scorch tscorchsize3#,tscorchtype3
      t=static raycast(tobjx#,tobjy#,tobjz#,tobjx#,tobjy#-tindex,tobjz#)
      if t > 0 then add static scorch tscorchsize3#,tscorchtype3
      t=static raycast(tobjx#,tobjy#,tobjz#,tobjx#,tobjy#,tobjz#+tindex)
      if t > 0 then add static scorch tscorchsize3#,tscorchtype3
      t=static raycast(tobjx#,tobjy#,tobjz#,tobjx#,tobjy#,tobjz#-tindex)
      if t > 0 then add static scorch tscorchsize3#,tscorchtype3
     endcase
     case AIACTCAMSHAKE:
      camshake#=camshake#+aiactionseq(seq).value
     endcase
     case AIACTCAMFOV:
      airmod_camfov_d#=aiactionseq(seq).value
     endcase
     case AIACTCAMFOVINC:
      airmod_camfov_d#=airmod_camfov_d#+aiactionseq(seq).value
     endcase
     case AIACTHIDEWEAPON:
      `Remove Current Weapon
      airmod_last_weapon = gunid
      if gunid<>0
       gunmode=31 : gunselectionafterhide=0
      endif
     endcase
     case AIACTSHOWLASTWEAPON:
      player(plrid).command.newweapon=airmod_last_weapon
     endcase
     case AIACTCAMPOINTOBJECT:
      point camera object position x(obj),object position y(obj)+aiactionseq(seq).value,object position z(obj)
     endcase
     rem AirMod - Done <<<
     Rem Hockeykid - 250210 - Dark AI
      case AIACTADDAITEAM:
       obj=entityelement(e).obj : team=aiactionseq(seq).value
       Gosub _darkai_addai
      endcase
      case AIACTAIACTIVE:
      if ai entity exist(entityelement(e).obj)
       ai set entity active entityelement(e).obj,aiactionseq(seq).value
       entityelement(e).darkai.active=aiactionseq(seq).value
       if aiactionseq(seq).value=0 then entityelement(e).darkai.aistop=1
       if aiactionseq(seq).value<>0 then entityelement(e).darkai.aistop=0
      endif
      endcase
      case AIACTAIACTION:
       entityelement(e).darkai.actionmode=aiactionseq(seq).value
      endcase
      case AIACTTOGGLEACTIVE:
       entityelement(e).eleprof.phyalways=aiactionseq(seq).value
      endcase
      case AIACTAICLEARTARGET:
       if ai entity exist(entityelement(e).obj)
        entityelement(e).actualtarget=0
        entityelement(e).targetinway=0
        entityelement(e).realtarget=0
       endif
      endcase
      case AIACTAISETTARGET:
       obj=entityelement(e).obj
       tent = 0
       if ai entity exist(obj)
        entityelement(e).ttarget=AI Get Entity Target ID (obj,1)
        ttarget=entityelement(e).ttarget

        if ttarget>0
         entityelement(e).targetinway=0
         if ttarget = physicsplayerborble
          if player(1).health>0 or playerstartstrength=0
           entityelement(e).actualtarget=1
           entityelement(e).actualtargetx=mex#
           entityelement(e).actualtargety=mey#
           entityelement(e).actualtargetz=mez#
           entityelement(e).losttargetcount=0
          else
           entityelement(e).actualtarget=0
           entityelement(e).losttargetcount=0
           ai entity remove target entityelement(e).obj,ttarget
          endif
         else
          `if array count(phyobjele())>=ttarget
          for l=1 to entityelementlist
           if entityelement(l).obj=ttarget then tent = l : exit
          next l
          if tent>0
           if ai entity exist(entityelement(tent).obj)
            entityelement(e).actualtarget=tent+1
            if entityelement(e).actualtarget>0
             tte=entityelement(e).actualtarget-1
             entityelement(e).actualtargety=entityelement(tte).y
             entityelement(e).actualtargetx=entityelement(tte).x
             entityelement(e).actualtargetz=entityelement(tte).z
             entityelement(e).losttargetcount=0
            endif
           endif
          endif
          `
         endif
         tmpx#=entityelement(e).x
         tmpy#=entityelement(e).y
         tmpz#=entityelement(e).z
         `
         tmpx2#=entityelement(e).actualtargetx
         tmpy2#=entityelement(e).actualtargety
         tmpz2#=entityelement(e).actualtargetz
         `
         tvisibility=0 : gosub _target_determinevisibility
         if tvisibilityifbreak>0
          tte=tvisibilityifbreak
          entityelement(e).realtarget=entityelement(e).actualtarget
          entityelement(e).actualtarget=tte+1
          entityelement(e).targetinway=1
          entityelement(e).actualtargety=entityelement(tte).y
          entityelement(e).actualtargetx=entityelement(tte).x
          entityelement(e).actualtargetz=entityelement(tte).z
         endif
         `
        endif
       endif
      endcase
     case AIACTAIENABLEFULLAIM:
      if ai entity exist(entityelement(e).obj)
       entid=entityelement(e).bankindex
       entityelement(e).darkai.useaim=aiactionseq(seq).value
       `if entityprofile(entid).spine=-1 or entityprofile(entid).spine2=-1 then entityelement(e).darkai.useaim=0
       if entityelement(e).darkai.useaim=0 then entityelement(e).spineraim=0
      endif
     endcase
     case AIACTAIREMOVE:
      if ai entity exist(entityelement(e).obj)
       ai kill entity entityelement(e).obj
      endif
     endcase
     case AIACTAIMOVERANDOM:
      if ai entity exist(entityelement(e).obj)
       Rem Hockeykid - 030310 - Reset control mode to manual
       if entityelement(e).darkai.control=1 then entityelement(e).darkai.control=0 : ai set entity control entityelement(e).obj,0
       if entityelement(e).darkai.team=1 and entityelement(e).darkai.follow=1 then Gosub _darkai_stopfollow
       entityelement(e).darkai.actionmode=2
      endif
     endcase
     case AIACTAIFOLLOWPLR:
      if ai entity exist(entityelement(e).obj)
       if aiactionseq(seq).value=1 then entityelement(e).darkai.actionmode=1
       if aiactionseq(seq).value=0 then entityelement(e).darkai.actionmode=4
      endif
     endcase
     case AIACTAIMOVETOSOUND:
      if ai entity exist(entityelement(e).obj)
       entityelement(e).darkai.actionmode=5
      endif
     endcase
     case AIACTAIMOVEAWAYFROMSOUND:
      if ai entity exist(entityelement(e).obj)
       entityelement(e).darkai.actionmode=6
      endif
     endcase
     case AIACTAICALLTEAM:
      if ai entity exist(entityelement(e).obj)
       maxdist#=aiactionseq(seq).value
       Gosub _darkai_callteam
      endif
     endcase
     case AIACTAIPLRCALLTEAM:
      maxdist#=aiactionseq(seq).value
      Gosub _darkai_plrcallteam
     endcase
     case AIACTAISETSPEED:
      If Ai Entity Exist(entityelement(e).obj)
       entid=entityelement(e).bankindex
       entityprofile(entid).speed=aiactionseq(seq).value
       entityelement(e).eleprof.speed=aiactionseq(seq).value
       ai set entity speed entityelement(e).obj,entityelement(e).eleprof.speed/2.0
      Endif
     endcase
     case AIACTAIMOVETOCOVER:
      if ai entity exist(entityelement(e).obj)
       Rem if =0 move to cover based on a targets X Z
       Rem if no target move to safe zone
       if aiactionseq(seq).value=0 then entityelement(e).darkai.actionmode=9
       Rem Move to save zone right off the bat
       if aiactionseq(seq).value=1 then entityelement(e).darkai.actionmode=10
       Rem Hockeykid - 050410 - Move to cover based on enemy X Z
       if entityelement(e).darkai.actionmode=9
        if ai get entity count targets(entityelement(e).obj)>0
         toppri=ai get entity target id(entityelement(e).obj,1)
         if toppri>0 and toppri<65535
          if object exist(toppri)=1
           ai entity move to cover entityelement(e).obj,object position x(toppri),object position z(toppri)
           entityelement(e).darkai.movingtocover=1
           entityelement(e).darkai.coverx=ai get entity destination x(entityelement(e).obj)
           entityelement(e).darkai.coverz=ai get entity destination z(entityelement(e).obj)
          endif
         endif
        else
         Gosub _darkai_find_safezone
         if tbesti>0
          i=tbesti
          targetcontainer=AIFindContainer(aisafezone(i).y+25)
          ai entity go to position entityelement(e).obj,aisafezone(i).x,aisafezone(i).z,targetcontainer
          aisafezone(i).occupied=1
          entityelement(e).darkai.movingtocover=1
          entityelement(e).darkai.coverx=aisafezone(i).x
          entityelement(e).darkai.coverz=aisafezone(i).z
         endif
        endif
        entityelement(e).darkai.actionmode=0
        `entityelement(e).darkai.state=STATE_COVER
       endif
       Rem Hockeykid - 050410 - Move to cover based on safe zone
       if entityelement(e).darkai.actionmode=10
        Gosub _darkai_find_safezone
        if tbesti>0
         i=tbesti
         targetcontainer=AIFindContainer(aisafezone(i).y+25)
         ai entity go to position entityelement(e).obj,aisafezone(i).x,aisafezone(i).z,targetcontainer
         aisafezone(i).occupied=1
         entityelement(e).darkai.movingtocover=1
         entityelement(e).darkai.coverx=aisafezone(i).x
         entityelement(e).darkai.coverz=aisafezone(i).z
        endif
        entityelement(e).darkai.actionmode=0
        `entityelement(e).darkai.state=STATE_COVER
        endif
       endif
     endcase
     case AIACTAIMOVETOTARGET:
      if ai entity exist(entityelement(e).obj) and entityelement(e).actualtarget>0
       tte=entityelement(e).actualtarget-1
       if entityelement(e).actualtarget=1 `then tobj=physicsplayerborble else tobj=entityelement(tte).obj
        targetcontainer=AIFindContainer(object position y(physicsplayerborble))
        ai entity go to position entityelement(e).obj,object position x(physicsplayerborble),object position z(physicsplayerborble),targetcontainer
        `entityelement(e).darkai.state=987 `test to block other interfering activities to test 'pure' move to target
       else
        targetcontainer=AIFindContainer(entityelement(tte).y+25)
        ai entity go to position entityelement(e).obj,entityelement(tte).x,entityelement(tte).z,targetcontainer
       endif
      endif
     endcase
     case AIACTAIRESPONDTOCALL:
      if ai entity exist(entityelement(e).obj)
       if entityelement(e).darkai.called>0 and entityelement(e).darkai.called<>physicsplayerborble
        i=entityelement(e).darkai.called
        if entityelement(e).darkai.control=1 then entityelement(e).darkai.control=0 : ai set entity control entityelement(e).obj,0
        x#=Object Position X(entityelement(e).darkai.called)
        z#=Object Position Z(entityelement(e).darkai.called)
        y#=Object Position Y(entityelement(e).darkai.called)
        targetcontainer=AIFindContainer(y#+25)
        ai entity go to position entityelement(e).obj,x#,z#,targetcontainer
        entityelement(e).darkai.called=-1
        entityelement(e).darkai.calldelay2=timer()
       endif
      endif
     endcase
     case AIACTAITOGLLEATTACK:
      if AI Entity Exist(entityelement(e).obj)
         if aiactionseq(seq).value=1 then entityelement(e).darkai.autoattackoff=0
         if aiactionseq(seq).value=0 then entityelement(e).darkai.autoattackoff=1
      endif
     endcase
     case AIACTAIRESPONDTOPLAYER:
      if ai entity exist(entityelement(e).obj)
       if entityelement(e).darkai.called=physicsplayerborble
        i=entityelement(e).darkai.called
        if entityelement(e).darkai.control=1 then entityelement(e).darkai.control=0 : ai set entity control entityelement(e).obj,0
        x#=Object Position X(i)
        z#=Object Position Z(i)
        y#=Object Position Y(i)
        targetcontainer=AIFindContainer(y#+25)
        ai entity go to position entityelement(e).obj,x#,z#,targetcontainer
        entityelement(e).darkai.called=-1
        entityelement(e).darkai.calldelay2=timer()
       endif
      endif
     endcase
     case AIACTAIADDPOINT:
      pointfound=0
      if array count(points())=0 then array insert at bottom points()
      for i=1 to array count(points())
       if points(i).id=aiactionseq(seq).value then pointi=i : pointfound=1 : exit
      next i
      if pointfound=0
       array insert at bottom points()
       xp=array count(points())
      else
       xp=pointi
      endif
      points(xp).x=entityelement(e).x
      points(xp).y=entityelement(e).y
      points(xp).z=entityelement(e).z
      points(xp).id=aiactionseq(seq).value
     endcase
     case AIACTAIGOTOPOINT:
      pointi=0
      if array count(points())>0 and ai entity exist(entityelement(e).obj)
       for i=1 to array count(points())
        if points(i).id=aiactionseq(seq).value
         entityelement(e).darkai.path=i
         if entityelement(e).darkai.control=1 then entityelement(e).darkai.control=0 : ai set entity control entityelement(e).obj,0
         entityelement(e).darkai.actionmode=8
         exit
        endif
       next i
      endif
     endcase
     case AIACTAISTOP:
      if ai entity exist(entityelement(e).obj)
       if entityelement(e).darkai.control=1 then entityelement(e).darkai.control=0 : ai set entity control entityelement(e).obj,0
       targetcontainer=AIFindContainer(entityelement(e).y+25)
       ai entity go to position entityelement(e).obj,entityelement(e).x,entityelement(e).z,targetcontainer
      endif
     endcase
     case AIACTAIUSEMELEE:
      if ai entity exist(entityelement(e).obj)
       blood=aiactionseq(seq).value
       if entityelement(e).actualtarget>1
        tte=entityelement(e).actualtarget-1
        Rem do damage
        tdamagesource=0 : timpacttype=1 : tdamage=entityelement(e).darkai.meleedamage
        tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y  : tdamagez#=entityelement(e).z
        stte=e : e=tte : damagede=e
        entityelement(e).shotby=994
        gosub _entity_deducthealth
        e=stte
        Rem Create Blood
        if blood=1
         middlebody=1
         gosub _create_blood
        endif

       endif
       if entityelement(e).actualtarget=1
        tdamage=entityelement(e).darkai.meleedamage
        gosub _player_takedamage
       endif
      endif
     endcase
     case AIACTAISETMELEEDAMAGE:
      if ai entity exist(entityelement(e).obj)
       entityelement(e).darkai.meleedamage=aiactionseq(seq).value
      endif
     endcase
     case AIACTAIROTATEY:
      if ai entity exist(entityelement(e).obj)
       ai set entity angle y entityelement(e).obj,aiactionseq(seq).value
      endif
     endcase
     case AIACTAILOOKAROUND:
      if ai entity exist(entityelement(e).obj)
       ai entity look around entityelement(e).obj,aiactionseq(seq).value,aiactionseq(seq).valueb
      endif
     endcase
     case AIACTAIROTATETOTARGET:
      if ai entity exist(entityelement(e).obj)
       if entityelement(e).actualtarget>0
        if entityelement(e).actualtarget=1
         ai entity look at position entityelement(e).obj,object position x(physicsplayerborble),object position z(physicsplayerborble)
         `entityelement(e).mover.da=atanfull(object position x(physicsplayerborble),object position z(physicsplayerborble))
         `
         if entityelement(e).darkai.useaim=1
          ex1#=object position x(physicsplayerborble) : ey1#=object position y(physicsplayerborble) : ez1#=object position z(physicsplayerborble)
          ex2#=entityelement(e).x : ey2#=entityelement(e).y : ez2#=entityelement(e).z
          ey1eyeoffset=phyeyeheight#+25
          Gosub _ai_find_angle
          entityelement(e).spineraim=entityangle#/2
         endif
         `
        else
         tte=entityelement(e).actualtarget-1
         if entityelement(tte).obj>0
          ai entity look at position entityelement(e).obj,object position x(entityelement(tte).obj),object position z(entityelement(tte).obj)
          `entityelement(e).mover.da=atanfull(object position x(entityelement(tte).obj),object position z(entityelement(tte).obj))
          `
          if entityelement(e).darkai.useaim=1
           ex1#=object position x(entityelement(tte).obj) : ey1#=object position y(entityelement(tte).obj) : ez1#=object position z(entityelement(tte).obj)
           ex2#=entityelement(e).x : ey2#=entityelement(e).y : ez2#=entityelement(e).z
           If entityelement(tte).eyeoffset=0 then entityelement(tte).eyeoffset=80
           ey1eyeoffset=(entityelement(tte).eyeoffset/2)
           Gosub _ai_find_angle
           entityelement(e).spineraim=entityangle#/2
          endif
         endif
         `
        endif
       endif
      endif
     endcase
     case AIACTAIROTATETOSOUND:
      if ai entity exist(entityelement(e).obj)
       arraycount=array count(ischaracter())
       for i=1 to arraycount
        tte=ischaracter(i)
        if entityelement(e).obj=entityelement(tte).obj then ttte=tte : exit
       next i
       sound=AIHeardSound(ttte)
       if sound>0
        ai entity look at position entityelement(e).obj,aisound(sound).x,aisound(sound).z
        `entityelement(e).ry=atanfull(aisound(sound).x,aisound(sound).z)
       endif
      endif
     endcase
     case AIACTAIEYELEVEL:
      if ai entity exist(entityelement(e).obj)
       entityelement(e).eyeoffset=aiactionseq(seq).value
      endif
     endcase
     case AIACTAIADDALLY:
      tindex=aiactionseq(seq).value
      string$=actstring$(tindex)
      AIParseFactions(string$,2)
     endcase
     case AIACTAIADDENEMY:
      tindex=aiactionseq(seq).value
      string$=actstring$(tindex)
      AIParseFactions(string$,1)
     endcase
     case AIACTAIADDNEUTRAL:
      tindex=aiactionseq(seq).value
      string$=actstring$(tindex)
      AIParseFactions(string$,3)
     endcase
     case AIACTAIAUTOFACTIONOFF:
      mutualfactionoff=aiactionseq(seq).value
     endcase
     case AIACTAISETVIEWRANGE:
      ai set entity view range entityelement(e).obj,aiactionseq(seq).value
     endcase
     Rem End Dark AI
     `
     case AIACTPASSTOSETUP:
      if grealgameviewstate=1
       found=0
       dim setupdata$(999)
       load array exeroot$+"\"+setupfilename$,setupdata$()
       pass$=aiactionseq(seq).string1
       value=aiactionseq(seq).valueb
       `Allow variable values to be saved for specific lines for the options screen (saves on amount of extra commands needed in fpi)
       if left$(lower$(pass$),len("useeffects"))="useeffects" then value=newuseeffects
       if left$(lower$(pass$),len("dynamicshadows"))="dynamicshadows" then value=newdynamicshadows
       if left$(lower$(pass$),len("dividetexturesize"))="dividetexturesize" then value=newdividetexturesize
       if left$(lower$(pass$),len("mousesensitivity"))="mousesensitivity" then value=newmousesensitivity
       if left$(lower$(pass$),len("aspectratio"))="aspectratio" then value=newaspectratio
       if left$(lower$(pass$),len("postprocessing"))="postprocessing" then value=newpostprocessing
       if left$(lower$(pass$),len("width"))="width" then value=newwidth
       if left$(lower$(pass$),len("height"))="height" then value=newheight
       if left$(lower$(pass$),len("depth"))="depth" then value=newdepth
       if left$(lower$(pass$),len("antialias"))="antialias" then value=newantialias
       if left$(lower$(pass$),len("invmouse"))="invmouse" then value=newmouseinvert
       if left$(lower$(pass$),len("particleused"))="particleused" then value=newparticlesused
       if left$(lower$(pass$),len("autores"))="autores" then value=newautores
       for i=0 to 999
        field$=lower$(setupdata$(i))
        num=len(pass$)
        if left$(field$,num)=pass$ then setupdata$(i)=pass$+"="+str$(value) : found=1 : exit
       next i
       `
       if found=0
        for i=levelfpiinsetup+2 to 999
         if setupdata$(i)="" then setupdata$(i)=pass$+"="+str$(value) : exit
        next i
       endif
       `
       save array exeroot$+"\"+setupfilename$,setupdata$()
       undim setupdata$()
      endif
     endcase
     case AIACTSETUPDYNAMICSHADOWS:
      if grealgameviewstate=1 then newdynamicshadows=aiactionseq(seq).value
     endcase
     case AIACTSETUPUSEEFFECTS:
      if grealgameviewstate=1 then newuseeffects=aiactionseq(seq).value
     endcase
     case AIACTSETUPDIVIDETEXTURESIZE:
      if grealgameviewstate=1 then newdividetexturesize=aiactionseq(seq).value
     endcase
     case AIACTSETUPMOUSESENSITIVITY:
      if grealgameviewstate=1 then newmousesensitivity=aiactionseq(seq).value
     endcase
     case AIACTSETUPASPECTRATIO:
      if grealgameviewstate=1 then newaspectratio=aiactionseq(seq).value
     endcase
     case AIACTSETUPWIDTH:
      if grealgameviewstate=1 then newwidth=aiactionseq(seq).value
     endcase
     case AIACTSETUPHEIGHT:
      if grealgameviewstate=1 then newheight=aiactionseq(seq).value
     endcase
     case AIACTSETUPDEPTH:
      if grealgameviewstate=1 then newdepth=aiactionseq(seq).value
     endcase
     case AIACTSETUPPOSTPROCESSING:
      if grealgameviewstate=1 then newpostprocessing=aiactionseq(seq).value
     endcase
     case AIACTSETUPANTIALIAS:
      if grealgameviewstate=1 then newantialias=aiactionseq(seq).value
     endcase
     rem V118 - 160810 - knxrb - Auto Resolution
     case AIACTSETUPAUTORES:
      if grealgameviewstate=1 then newautores=aiactionseq(seq).value
     endcase
     rem V118 - 130810 - knxrb - Invert Mouse
     case AIACTSETUPMOUSEINVERT:
      if grealgameviewstate=1 then newmouseinvert=aiactionseq(seq).value
     endcase
     rem V118 - 140810 - knxrb - Disable Particles
     case AIACTSETUPPARTICLESUSED:
      if grealgameviewstate=1 then newparticlesused=aiactionseq(seq).value
     endcase
     case AIACTRESET:
      if grealgameviewstate=1
       Gosub _main_game_freeleveldata
       `
       rem 301212 - Pretty Horrible Solution - changed to GOTO to at least preserve the stack a little!
       Goto _start_engine
       `
      endif
     endcase
     case AIACTSAVESETUP:
      Rem REMOVED BETTER METHOD FOUND
      remstart
      if grealgameviewstate=1
       widthfound=0 : heightfound=0 : depthfound=0 : foundantialias=0 : foundmouseinv=0 : foundparticlesused = 0 : foundautores = 0
       dim setupdata$(999)
       load array exeroot$+"\"+setupfilename$,setupdata$()
       `
       for i=0 to 999
        field$=lower$(setupdata$(i))
        num=len("dynamicshadows")
        if left$(field$,num)="dynamicshadows" then setupdata$(i)="dynamicshadows="+str$(newdynamicshadows) : founddynamicshadows=1
        num=len("useeffects")
        if left$(field$,num)="useeffects" then setupdata$(i)="useeffects="+str$(newuseeffects) : founduseeffects=1
        num=len("dividetexturesize")
        if left$(field$,num)="dividetexturesize" then setupdata$(i)="dividetexturesize="+str$(newdividetexturesize) : founddividetexturesize=1
        num=len("mousesensitivity")
        if left$(field$,num)="mousesensitivity" then setupdata$(i)="mousesensitivity="+str$(newmousesensitivity) : foundmousesensitivity=1
        num=len("aspectratio")
        if left$(field$,num)="aspectratio" then setupdata$(i)="aspectratio="+str$(newaspectratio) : foundaspectratio=1
        num=len("postprocessing")
        if left$(field$,num)="postprocessing" then setupdata$(i)="postprocessing="+str$(newpostprocessing) : foundpostprocessing=1
        num=len("width")
        if left$(field$,num)="width" then setupdata$(i)="width="+str$(newwidth) : widthfound=1
        num=len("height")
        if left$(field$,num)="height" then setupdata$(i)="height="+str$(newheight) : heightfound=1
        num=len("depth")
        if left$(field$,num)="depth" then setupdata$(i)="depth="+str$(newdepth) : depthfound=1
        num=len("antialias")
        if left$(field$,num)="antialias" then setupdata$(i)="antialias="+str$(newantialias) : foundantialias=1
        num=len("particleused") : rem V118 - 140810 - knxrb - Disable Particles
        if left$(field$,num)="particleused" then setupdata$(i)="particleused="+str$(newparticlesused) : foundparticlesused=1
        num=len("autores") : rem V118 - 160810 - knxrb - Auto Resolution
        if left$(field$,num)="autores" then setupdata$(i)="autores="+str$(newautores) : foundautores=1
        num=len("invmouse") : rem V118 - 130810 - knxrb - Invert Mouse
        if left$(field$,num)="invmouse" then setupdata$(i)="invmouse="+str$(newmouseinvert) : foundmouseinv=1
        if founddynamicshadows=1 and founduseeffects=1 and founddividetexturesize=1 and foundmousesensitivity=1 and foundaspectratio=1
         if foundpostprocessing=1 and widthfound=1 and heightfound=1 and depthfound=1 and foundantialias=1 and foundmouseinv=1 and foundparticlesused=1 and foundautores=1
          exit
         endif
        endif
       next i
       `
       if depthfound=0 or heightfound=0 or widthfound=0 or founddynamicshadows=0 or founduseeffects=0 or founddividetexturesize=0 or foundmousesensitivity=0 or foundaspectratio=0 or foundpostprocessing=0 or foundantialias=0 or foundmouseinv=0 or foundparticlesused=0 or foundautores=0
        for i=levelfpiinsetup+2 to 999
         `
         if founddynamicshadows=0 and setupdata$(i)="" then setupdata$(i)="dynamicshadows="+str$(newdynamicshadows) : founddynamicshadows=1
         if founduseeffects=0 and setupdata$(i)="" then setupdata$(i)="useeffects="+str$(newuseeffects) : founduseeffects=1
         if founddividetexturesize=0 and setupdata$(i)="" then setupdata$(i)="dividetexturesize="+str$(newdividetexturesize) : founddividetexturesize=1
         if foundmousesensitivity=0 and setupdata$(i)="" then setupdata$(i)="mousesensitivity="+str$(newmousesensitivity) : foundmousesensitivity=1
         if foundaspectratio=0 and setupdata$(i)="" then setupdata$(i)="aspectratio="+str$(newaspectratio) : foundaspectratio=1
         if foundpostprocessing=0 and setupdata$(i)="" then setupdata$(i)="postprocessing="+str$(newpostprocessing) : foundpostprocessing=1
         if widthfound=0 and setupdata$(i)="" then setupdata$(i)="width="+str$(newwidth) : widthfound=1
         if heightfound=0 and setupdata$(i)="" then setupdata$(i)="height="+str$(newheight) : heightfound=1
         if depthfound=0 and setupdata$(i)="" then setupdata$(i)="depth="+str$(newdepth) : depthfound=1
         if foundantialias=0 and setupdata$(i)="" then setupdata$(i)="antialias="+str$(newantialias) : foundantialias=1
         rem V118 - 140810 - knxrb - Disable Particles
         if foundparticlesused=0 and setupdata$(i)="" then setupdata$(i)="particleused="+str$(newparticlesused) : foundparticlesused=1
         rem V118 - 160810 - knxrb - Auto Resolution
         if foundautores=0 and setupdata$(i)="" then setupdata$(i)="autores="+str$(newautores) : foundautores=1
         rem V118 - 130810 - knxrb - Invert Mouse
         if foundmouseinv=0 and setupdata$(i)="" then setupdata$(i)="invmouse="+str$(newmouseinvert) : foundmouseinv=1
         `
         if founddynamicshadows=1 and founduseeffects=1 and founddividetexturesize=1 and foundmousesensitivity=1 and foundaspectratio=1
          if foundpostprocessing=1 and widthfound=1 and heightfound=1 and depthfound=1 and foundantialias=1 and foundmouseinv=1 and foundparticlesused=1 and foundautores=1
           exit
          endif
         endif
         `
        next i
       endif
       `
       save array exeroot$+"\"+setupfilename$,setupdata$()
       undim setupdata$()
      endif
      remend
     endcase
     `
     case AIACTFPGCRAWTEXTR:
      grawtextr=aiactionseq(seq).value
     endcase
     case AIACTFPGCRAWTEXTG:
      grawtextg=aiactionseq(seq).value
     endcase
     case AIACTFPGCRAWTEXTB:
      grawtextb=aiactionseq(seq).value
     endcase
     case AIACTFPGCRAWTEXTX:
      grawtextx=aiactionseq(seq).value
     endcase
     case AIACTFPGCRAWTEXTY:
      grawtexty=aiactionseq(seq).value
     endcase
     case AIACTFPGCRAWTEXTSIZE:
      grawtextsize=aiactionseq(seq).value
     endcase
     case AIACTFPGCRAWTEXTFONT:
      tindex=aiactionseq(seq).value
      rem avoid crash when using new variable system in conjunction with this command
      if aiactionseq(seq).valueisvar=0 then grawtextfont$=actstring$(tindex)
     endcase
     case AIACTFPGCRAWTEXTOFF:
      grawtext$=""
     endcase
     case AIACTFPGCRAWTEXT:
      if aiactionseq(seq).value=-1
       grawtext$=entityelement(e).eleprof.soundset$
      else
       if aiactionseq(seq).value=-2
        grawtext$=entityelement(e).eleprof.soundset1$
       else
        if aiactionseq(seq).valueisvar=0
         tindex=aiactionseq(seq).value
         grawtext$=actstring$(tindex)
        else
         rem if using new variable system with this command, allow print out of the variable
         grawtext$=str$(aiactionseq(seq).value)
        endif
       endif
      endif
      grawtextcount=25
     endcase
     `
     case AIACTNEXTLEVEL:
      leveljump=aiactionseq(seq).value
     endcase
     `
          rem GUI-X9 (knxrb)
     case AIACTLOADIMAGE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            LoadGUIImage(aiactionseq(seq).string1,aiactionseq(seq).string2)
            if GUIImageFromName(aiactionseq(seq).string1) = -1
                LoadGUIImage(left$(aiactionseq(seq).string1,len(aiactionseq(seq).string1)-4)+".tga",aiactionseq(seq).string2)
            endif
            if GUIImageFromName(aiactionseq(seq).string1) = -1
                LoadGUIImage(left$(aiactionseq(seq).string1,len(aiactionseq(seq).string1)-4)+".dds",aiactionseq(seq).string2)
            endif
            if GUIImageFromName(aiactionseq(seq).string1) = -1
                LoadGUIImage(left$(aiactionseq(seq).string1,len(aiactionseq(seq).string1)-4)+".png",aiactionseq(seq).string2)
            endif
        endif
     endcase
     case AIACTMAKEHUD:
        ParseValues(aiactionseq(seq).string2)
        if aiactionseq(seq).string1 <> ""
            if parsetotal = 5 then MakeGUIHud(aiactionseq(seq).string1,guival(0),guival(1),val(guival(2)),val(guival(3)),-1,-1)
            if parsetotal = 6 then MakeGUIHud(aiactionseq(seq).string1,guival(0),guival(1),val(guival(2)),val(guival(3)),val(guival(4)),-1)
            if parsetotal = 7 then MakeGUIHud(aiactionseq(seq).string1,guival(0),guival(1),val(guival(2)),val(guival(3)),val(guival(4)),val(guival(5)))
        endif
     endcase
     case AIACTSETHUDX:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).Left = val(aiactionseq(seq).string2)
                guihud(hID).AL = (ScreenXPos(guihud(hID).Left)/1024)*gdisplaywidth
            endif
        endif
     endcase
     case AIACTSETHUDY:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).Top = val(aiactionseq(seq).string2)
                guihud(hID).AT = (ScreenYPos(guihud(hID).Top)/768)*gdisplayheight
            endif
        endif
     endcase
     case AIACTSETHUDW:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).Width = val(aiactionseq(seq).string2)
                guihud(hID).AW = (guihud(hID).Width/1024)*gdisplaywidth
            endif
        endif
     endcase
     case AIACTSETHUDH:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).Height = val(aiactionseq(seq).string2)
                guihud(hID).AH = (guihud(hID).Height/768)*gdisplayheight
            endif
        endif
     endcase
     case AIACTSETHUDCOLOUR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
                    if hID > -1
                        guihud(hID).dR = val(guival(0))
                        guihud(hID).dG = val(guival(1))
                        guihud(hID).dB = val(guival(2))
                        if guihud(hID).dR < 0 then guihud(hID).dR = 0
                        if guihud(hID).dR > 255 then guihud(hID).dR = 255
                        if guihud(hID).dG < 0 then guihud(hID).dG = 0
                        if guihud(hID).dG > 255 then guihud(hID).dG = 255
                        if guihud(hID).dB < 0 then guihud(hID).dB = 0
                        if guihud(hID).dB > 255 then guihud(hID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETHUDCOLOR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
                    if hID > -1
                        guihud(hID).dR = val(guival(0))
                        guihud(hID).dG = val(guival(1))
                        guihud(hID).dB = val(guival(2))
                        if guihud(hID).dR < 0 then guihud(hID).dR = 0
                        if guihud(hID).dR > 255 then guihud(hID).dR = 255
                        if guihud(hID).dG < 0 then guihud(hID).dG = 0
                        if guihud(hID).dG > 255 then guihud(hID).dG = 255
                        if guihud(hID).dB < 0 then guihud(hID).dB = 0
                        if guihud(hID).dB > 255 then guihud(hID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETHUDALPHA:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).iA = val(aiactionseq(seq).string2)
                if guihud(hID).iA < 0 then guihud(hID).iA = 0
                if guihud(hID).iA > 255 then guihud(hID).iA = 255
            endif
        endif
     endcase
     case AIACTSETHUDNIMAGE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).NormImageNo = GUIImageFromName(aiactionseq(seq).string2)
                if guihud(hID).NormImageNo > -1
                    if guihud(hID).Width = -1 Then guihud(hID).Width = image width(guihud(hID).NormImageNo)
                    if guihud(hID).Height = -1 Then guihud(hID).Height = image height(guihud(hID).NormImageNo)
                endif
            endif
        endif
     endcase
     case AIACTSETHUDOIMAGE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).OverImageNo = GUIImageFromName(aiactionseq(seq).string2)
                if guihud(hID).OverImageNo > -1
                    if guihud(hID).Width = -1 Then guihud(hID).Width = image width(guihud(hID).OverImageNo)
                    if guihud(hID).Height = -1 Then guihud(hID).Height = image height(guihud(hID).OverImageNo)
                endif
            endif
        endif
     endcase

     case AIACTMAKECHECKBOX:
        ParseValues(aiactionseq(seq).string2)
        if aiactionseq(seq).string1 <> ""
            if parsetotal = 5 then MakeGUICheckbox(aiactionseq(seq).string1,guival(0),guival(1),val(guival(2)),val(guival(3)),-1,-1)
            if parsetotal = 6 then MakeGUICheckbox(aiactionseq(seq).string1,guival(0),guival(1),val(guival(2)),val(guival(3)),val(guival(4)),-1)
            if parsetotal = 7 then MakeGUICheckbox(aiactionseq(seq).string1,guival(0),guival(1),val(guival(2)),val(guival(3)),val(guival(4)),val(guival(5)))
        endif
     endcase
     case AIACTSETCHECKBOXX:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).Left = val(aiactionseq(seq).string2)
                guicheckbox(cID).AL = (ScreenXPos(guicheckbox(cID).Left)/1024)*gdisplaywidth
            endif
        endif
     endcase
     case AIACTSETCHECKBOXY:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).Top = val(aiactionseq(seq).string2)
                guicheckbox(cID).AT = (ScreenYPos(guicheckbox(cID).Top)/768)*gdisplayheight
            endif
        endif
     endcase
     case AIACTSETCHECKBOXW:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).Width = val(aiactionseq(seq).string2)
                guicheckbox(cID).AW = (guicheckbox(cID).Width/1024)*gdisplaywidth
            endif
        endif
     endcase
     case AIACTSETCHECKBOXH:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).Height = val(aiactionseq(seq).string2)
                guicheckbox(cID).AH = (guicheckbox(cID).Height/768)*gdisplayheight
            endif
        endif
     endcase
     case AIACTSETCHECKBOXCOLOUR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
                    if cID > -1
                        guicheckbox(cID).dR = val(guival(0))
                        guicheckbox(cID).dG = val(guival(1))
                        guicheckbox(cID).dB = val(guival(2))
                        if guicheckbox(cID).dR < 0 then guicheckbox(cID).dR = 0
                        if guicheckbox(cID).dR > 255 then guicheckbox(cID).dR = 255
                        if guicheckbox(cID).dG < 0 then guicheckbox(cID).dG = 0
                        if guicheckbox(cID).dG > 255 then guicheckbox(cID).dG = 255
                        if guicheckbox(cID).dB < 0 then guicheckbox(cID).dB = 0
                        if guicheckbox(cID).dB > 255 then guicheckbox(cID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETCHECKBOXCOLOR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
                    if cID > -1
                        guicheckbox(cID).dR = val(guival(0))
                        guicheckbox(cID).dG = val(guival(1))
                        guicheckbox(cID).dB = val(guival(2))
                        if guicheckbox(cID).dR < 0 then guicheckbox(cID).dR = 0
                        if guicheckbox(cID).dR > 255 then guicheckbox(cID).dR = 255
                        if guicheckbox(cID).dG < 0 then guicheckbox(cID).dG = 0
                        if guicheckbox(cID).dG > 255 then guicheckbox(cID).dG = 255
                        if guicheckbox(cID).dB < 0 then guicheckbox(cID).dB = 0
                        if guicheckbox(cID).dB > 255 then guicheckbox(cID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETCHECKBOXALPHA:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).iA = val(aiactionseq(seq).string2)
                if guicheckbox(cID).iA < 0 then guicheckbox(cID).iA = 0
                if guicheckbox(cID).iA > 255 then guicheckbox(cID).iA = 255
            endif
        endif
     endcase
     case AIACTSETCHECKBOXNIMAGE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).NormImageNo = GUIImageFromName(aiactionseq(seq).string2)
                if guicheckbox(cID).NormImageNo > -1
                    if guicheckbox(cID).Width = -1 Then guicheckbox(cID).Width = image width(guicheckbox(cID).NormImageNo)
                    if guicheckbox(cID).Height = -1 Then guicheckbox(cID).Height = image height(guicheckbox(cID).NormImageNo)
                endif
            endif
        endif
     endcase
     case AIACTSETCHECKBOXCIMAGE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).CheckImageNo = GUIImageFromName(aiactionseq(seq).string2)
                if guicheckbox(cID).CheckImageNo > -1
                    if guicheckbox(cID).Width = -1 Then guicheckbox(cID).Width = image width(guicheckbox(cID).CheckImageNo)
                    if guicheckbox(cID).Height = -1 Then guicheckbox(cID).Height = image height(guicheckbox(cID).CheckImageNo)
                endif
            endif
        endif
     endcase
     case AIACTSETCHECKBOXSTATE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUICheckboxFromName(aiactionseq(seq).string1)
            if cID > -1
                guicheckbox(cID).CheckState = val(aiactionseq(seq).string2)
                if guicheckbox(cID).CheckState < 0 then guicheckbox(cID).CheckState = 0
                if guicheckbox(cID).CheckState > 1 then guicheckbox(cID).CheckState = 1
            endif
        endif
     endcase
     case AIACTMAKESLIDER:
        ParseValues(aiactionseq(seq).string2)
        if aiactionseq(seq).string1 <> ""
            if parsetotal = 6 then MakeGUISlider(aiactionseq(seq).string1,guival(0),guival(1),guival(2),val(guival(3)),val(guival(4)),-1,-1)
            if parsetotal = 7 then MakeGUISlider(aiactionseq(seq).string1,guival(0),guival(1),guival(2),val(guival(3)),val(guival(4)),val(guival(5)),-1)
            if parsetotal = 8 then MakeGUISlider(aiactionseq(seq).string1,guival(0),guival(1),guival(2),val(guival(3)),val(guival(4)),val(guival(5)),val(guival(6)))
        endif
     endcase
     case AIACTSETSLIDERX:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
            if cID > -1
                guislider(cID).Left = val(aiactionseq(seq).string2)
                UpdateSliderData(cID)
            endif
        endif
     endcase
     case AIACTSETSLIDERY:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
            if cID > -1
                guislider(cID).Top = val(aiactionseq(seq).string2)
                UpdateSliderData(cID)
            endif
        endif
     endcase
     case AIACTSETSLIDERW:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
            if cID > -1
                guislider(cID).Width = val(aiactionseq(seq).string2)
                UpdateSliderData(cID)
            endif
        endif
     endcase
     case AIACTSETSLIDERH:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
            if cID > -1
                guislider(cID).Height = val(aiactionseq(seq).string2)
                UpdateSliderData(cID)
            endif
        endif
     endcase
     case AIACTSETSLIDERCOLOUR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
                    if cID > -1
                        guislider(cID).dR = val(guival(0))
                        guislider(cID).dG = val(guival(1))
                        guislider(cID).dB = val(guival(2))
                        if guislider(cID).dR < 0 then guislider(cID).dR = 0
                        if guislider(cID).dR > 255 then guislider(cID).dR = 255
                        if guislider(cID).dG < 0 then guislider(cID).dG = 0
                        if guislider(cID).dG > 255 then guislider(cID).dG = 255
                        if guislider(cID).dB < 0 then guislider(cID).dB = 0
                        if guislider(cID).dB > 255 then guislider(cID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETSLIDERCOLOR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
                    if cID > -1
                        guislider(cID).dR = val(guival(0))
                        guislider(cID).dG = val(guival(1))
                        guislider(cID).dB = val(guival(2))
                        if guislider(cID).dR < 0 then guislider(cID).dR = 0
                        if guislider(cID).dR > 255 then guislider(cID).dR = 255
                        if guislider(cID).dG < 0 then guislider(cID).dG = 0
                        if guislider(cID).dG > 255 then guislider(cID).dG = 255
                        if guislider(cID).dB < 0 then guislider(cID).dB = 0
                        if guislider(cID).dB > 255 then guislider(cID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETSLIDERALPHA:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
            if cID > -1
                guislider(cID).iA = val(aiactionseq(seq).string2)
                if guislider(cID).iA < 0 then guislider(cID).iA = 0
                if guislider(cID).iA > 255 then guislider(cID).iA = 255
            endif
        endif
     endcase
     case AIACTSETSLIDERVALUE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISliderFromName(aiactionseq(seq).string1)
            if cID > -1
                guislider(cID).BVal = val(aiactionseq(seq).string2)
                if guislider(cID).BVal < 0 then guislider(cID).BVal = 0
                if guislider(cID).BVal > guislider(cID).AW then guislider(cS).BVal = guislider(cID).AW
                guislider(cID).SL = (guislider(cID).AL - (guislider(cID).AW / 2)) + ((guislider(cID).BVal/guislider(cID).AW)*guislider(cID).AW) - (guislider(cID).SW / 2)
                guislider(cID).SVal = ((guislider(cID).SL-(guislider(cID).AL-(guislider(cID).AW/2))+(guislider(cID).SW/2))/guislider(cID).AW)*guislider(cID).MaxValue
            endif
        endif
     endcase
     case AIACTMAKECHOICE:
        ParseValues(aiactionseq(seq).string2)
        if aiactionseq(seq).string1 <> ""
            if parsetotal = 8 then MakeGUIChoice(aiactionseq(seq).string1,guival(0),guival(1),guival(2),guival(3),guival(4),val(guival(5)),val(guival(6)),-1,-1)
            if parsetotal = 9 then MakeGUIChoice(aiactionseq(seq).string1,guival(0),guival(1),guival(2),guival(3),guival(4),val(guival(5)),val(guival(6)),val(guival(7)),-1)
            if parsetotal = 10 then MakeGUIChoice(aiactionseq(seq).string1,guival(0),guival(1),guival(2),guival(3),guival(4),val(guival(5)),val(guival(6)),val(guival(7)),val(guival(8)))
        endif
     endcase
     case AIACTSETCHOICEX:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
            if cID > -1
                guichoice(cID).Left = val(aiactionseq(seq).string2)
                UpdateChoiceData(cID)
            endif
        endif
     endcase
     case AIACTSETCHOICEY:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
            if cID > -1
                guichoice(cID).Top = val(aiactionseq(seq).string2)
                UpdateChoiceData(cID)
            endif
        endif
     endcase
     case AIACTSETCHOICEW:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
            if cID > -1
                guichoice(cID).Width = val(aiactionseq(seq).string2)
                UpdateChoiceData(cID)
            endif
        endif
     endcase
     case AIACTSETCHOICEH:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
            if cID > -1
                guichoice(cID).Height = val(aiactionseq(seq).string2)
                UpdateChoiceData(cID)
            endif
        endif
     endcase
     case AIACTSETCHOICECOLOUR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
                    if cID > -1
                        guichoice(cID).dR = val(guival(0))
                        guichoice(cID).dG = val(guival(1))
                        guichoice(cID).dB = val(guival(2))
                        if guichoice(cID).dR < 0 then guichoice(cID).dR = 0
                        if guichoice(cID).dR > 255 then guichoice(cID).dR = 255
                        if guichoice(cID).dG < 0 then guichoice(cID).dG = 0
                        if guichoice(cID).dG > 255 then guichoice(cID).dG = 255
                        if guichoice(cID).dB < 0 then guichoice(cID).dB = 0
                        if guichoice(cID).dB > 255 then guichoice(cID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETCHOICECOLOR:
         if aiactionseq(seq).string2 <> ""
            ParseValues(aiactionseq(seq).string2)
            if parsetotal = 4
                if aiactionseq(seq).string1 <> ""
                    cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
                    if cID > -1
                        guichoice(cID).dR = val(guival(0))
                        guichoice(cID).dG = val(guival(1))
                        guichoice(cID).dB = val(guival(2))
                        if guichoice(cID).dR < 0 then guichoice(cID).dR = 0
                        if guichoice(cID).dR > 255 then guichoice(cID).dR = 255
                        if guichoice(cID).dG < 0 then guichoice(cID).dG = 0
                        if guichoice(cID).dG > 255 then guichoice(cID).dG = 255
                        if guichoice(cID).dB < 0 then guichoice(cID).dB = 0
                        if guichoice(cID).dB > 255 then guichoice(cID).dB = 255
                    endif
                endif
            endif
        endif
     endcase
     case AIACTSETCHOICEALPHA:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
            if cID > -1
                guichoice(cID).iA = val(aiactionseq(seq).string2)
                if guichoice(cID).iA < 0 then guichoice(cID).iA = 0
                if guichoice(cID).iA > 255 then guichoice(cID).iA = 255
            endif
        endif
     endcase
     case AIACTADDCHOICESTATE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
            if cID > -1
                select guichoice(cID).TotalStates
                    case 2
                        guichoice(cID).State3 = aiactionseq(seq).string2
                    endcase
                    case 3
                        guichoice(cID).State4 = aiactionseq(seq).string2
                    endcase
                    case 4
                        guichoice(cID).State5 = aiactionseq(seq).string2
                    endcase
                    case 5
                        guichoice(cID).State6 = aiactionseq(seq).string2
                    endcase
                    case 6
                        guichoice(cID).State7 = aiactionseq(seq).string2
                    endcase
                    case 7
                        guichoice(cID).State8 = aiactionseq(seq).string2
                    endcase
                    case 8
                        guichoice(cID).State9 = aiactionseq(seq).string2
                    endcase
                 endselect
                guichoice(cID).TotalStates = guichoice(cID).TotalStates + 1
                if guichoice(cID).TotalStates = 10 then guichoice(cID).TotalStates = 9
                UpdateChoiceData(cID)
            endif
        endif
     endcase
     case AIACTSETCHOICESTATE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUIChoiceFromName(aiactionseq(seq).string1)
            if cID > -1
                if lower$(guichoice(cID).State1) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State1
                    guichoice(cID).SelectedStateNum = 0
                endif
                if lower$(guichoice(cID).State2) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State2
                    guichoice(cID).SelectedStateNum = 1
                endif
                if lower$(guichoice(cID).State3) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State3
                    guichoice(cID).SelectedStateNum = 2
                endif
                if lower$(guichoice(cID).State4) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State4
                    guichoice(cID).SelectedStateNum = 3
                endif
                if lower$(guichoice(cID).State5) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State5
                    guichoice(cID).SelectedStateNum = 4
                endif
                if lower$(guichoice(cID).State6) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State6
                    guichoice(cID).SelectedStateNum = 5
                endif
                if lower$(guichoice(cID).State7) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State7
                    guichoice(cID).SelectedStateNum = 6
                endif
                if lower$(guichoice(cID).State8) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State8
                    guichoice(cID).SelectedStateNum = 7
                endif
                if lower$(guichoice(cID).State9) = lower$(aiactionseq(seq).string2)
                    guichoice(cID).SelectedState = guichoice(cID).State9
                    guichoice(cID).SelectedStateNum = 8
                endif
                UpdateChoiceData(cID)
            endif
        endif
     endcase
     case AIACTSETCURSOR:
        if aiactionseq(seq).string1 <> ""
            cID = GUIImageFromName(aiactionseq(seq).string1)
            if cID > -1
                MouseSprite = cID
                if sprite exist(MouseSprite) then delete sprite MouseSprite
                sprite MouseSprite,-10000,-10000,MouseSprite
                set sprite MouseSprite,0,1
            endif
        endif
     endcase
     case AIACTHIDEALL:
        HideAllGUI()
        gosub _gui_run
     endcase
     case AIACTREPLACEIMAGE:
        rem if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> "" then ReplaceGUIImage(aiactionseq(seq).string1,aiactionseq(seq).string2)
     endcase
     case AIACTSHOWHUD:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).Visible = 1
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTHIDEHUD:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                guihud(hID).Visible = 0
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTSHOWCURSOR:
        GUIDC = 1
     endcase
     case AIACTHIDECURSOR:
        GUIDC = 0
     endcase
     case AIACTCLEARGUI:
        ClearAllGUI()
     endcase
     case AIACTMAKESTOPWATCH:
        if aiactionseq(seq).string1 <> ""
            if aiactionseq(seq).string2 = "0" or lower$(aiactionseq(seq).string2) = "n" then tS = 0
            if aiactionseq(seq).string2 = "1" or lower$(aiactionseq(seq).string2) = "y" then tS = 1
            MakeGUITimer(aiactionseq(seq).string1,tS)
        endif
     endcase
     case AIACTSTARTSTOPWATCH:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUITimerFromName(aiactionseq(seq).string1)
            if cID > -1
                guitimer(cID).Started = 1
                if aiactionseq(seq).string2 = "1" or lower$(aiactionseq(seq).string2) = "y" then guitimer(cID).Time = timer()
            endif
        endif
     endcase
     case AIACTSTOPSTOPWATCH:
        if aiactionseq(seq).string1 <> ""
            cID = -1 : cID = GUITimerFromName(aiactionseq(seq).string1)
            if cID > -1
                guitimer(cID).Started = 0
            endif
        endif
     endcase
     case AIACTMAKESETUPVAR:
        ParseValues(aiactionseq(seq).string2)
        if aiactionseq(seq).string1 <> ""
            if parsetotal = 3 then MakeGUISetupVar(aiactionseq(seq).string1,guival(0),guival(1))
        endif
     endcase
     case AIACTSETSETUPVARVALUE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISVarFromName(aiactionseq(seq).string1)
            if cID > -1
                guisvar(cID).Value = aiactionseq(seq).string2
            endif
        endif
     endcase
     case AIACTSETSETUPVARLINE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISVarFromName(aiactionseq(seq).string1)
            if cID > -1
                guisvar(cID).SetupLine =  aiactionseq(seq).string2
                if right$(guisvar(cID).SetupLine,1) = "=" then guisvar(cID).SetupLine=left$(guisvar(cID).SetupLine,len(guisvar(cID).SetupLine)-1)
            endif
        endif
     endcase
     case AIACTREADSETUPVARVALUE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISVarFromName(aiactionseq(seq).string1)
            if cID > -1
               dim setupdata$(999)
               load array exeroot$+"\"+setupfilename$,setupdata$()
               for i=0 to 999
                field$=lower$(setupdata$(i)) : num=len(aiactionseq(seq).string2)
                if left$(field$,num)=lower$(aiactionseq(seq).string2) then guisvar(cID).Value=right$(field$,len(field$)-(num+1)) : exit
               next i
               undim setupdata$()
            endif
        endif
     endcase
     case AIACTSAVESETUPVARS:
         SaveSetupVariables()
     endcase
     case AIACTSETHUDCLICKABLE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                if aiactionseq(seq).string2 = "0" or lower$(aiactionseq(seq).string2) = "n" then guihud(hID).IsButton = 0
                if aiactionseq(seq).string2 = "1" or lower$(aiactionseq(seq).string2) = "y" then guihud(hID).IsButton = 1
            endif
        endif
     endcase
     case AIACTSETSETUPTOCOMP:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            cID = -1 : cID = GUISVarFromName(aiactionseq(seq).string1)
            if cID > -1
                rID = GUIChoiceFromName(aiactionseq(seq).string2) : rT$ = "c"
                if rID = -1 then rID = GUISliderFromName(aiactionseq(seq).string2) : rT$ = "s"
                if rID = -1 then rID = GUICheckboxFromName(aiactionseq(seq).string2) : rT$ = "ch"
                if rID > -1 and rT$ <> ""
                    if rT$ = "c" then guisvar(cID).Value = guichoice(rID).SelectedState
                    if rT$ = "s" then guisvar(cID).Value = str$(guislider(rID).SVal)
                    if rT$ = "ch" then guisvar(cID).Value = str$(guicheckbox(rID).CheckState)
                endif
            endif
        endif
     endcase
     case AIACTSHOWCHOICE:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUIChoiceFromName(aiactionseq(seq).string1)
            if hID > -1
                guichoice(hID).Visible = 1
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTHIDECHOICE:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUIChoiceFromName(aiactionseq(seq).string1)
            if hID > -1
                guichoice(hID).Visible = 0
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTSHOWSLIDER:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUISliderFromName(aiactionseq(seq).string1)
            if hID > -1
                guislider(hID).Visible = 1
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTHIDESLIDER:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUISliderFromName(aiactionseq(seq).string1)
            if hID > -1
                guislider(hID).Visible = 0
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTSHOWCHECKBOX:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUICheckboxFromName(aiactionseq(seq).string1)
            if hID > -1
                guicheckbox(hID).Visible = 1
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTHIDECHECKBOX:
        if aiactionseq(seq).string1 <> ""
            hID = -1 : hID = GUICheckboxFromName(aiactionseq(seq).string1)
            if hID > -1
                guicheckbox(hID).Visible = 0
                gosub _gui_run
            endif
        endif
     endcase
     case AIACTSETHUDNUMERIC:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                if aiactionseq(seq).string2="0" then guihud(hID).IsNumeric = 0 : gosub _gui_run
                if aiactionseq(seq).string2="1" then guihud(hID).IsNumeric = 1 : gosub _gui_run
            endif
        endif
     endcase
     case AIACTSETHUDVALUE:
        if aiactionseq(seq).string1 <> "" and aiactionseq(seq).string2 <> ""
            hID = -1 : hID = GUIHudFromName(aiactionseq(seq).string1)
            if hID > -1
                if guihud(hID).IsNumeric = 1
                    sA = 0
                    if lower$(aiactionseq(seq).string2) = "lives"
                        guihud(hID).StrNumeric = str$(player(1).lives) : sA = 1
                    endif
                    if lower$(aiactionseq(seq).string2) = "health"
                        guihud(hID).StrNumeric = str$(player(1).health) : sA = 1
                    endif
                    if lower$(aiactionseq(seq).string2) = "ammo"
                        if weaponammoindex>0
                            if firemode(gunid,firemode).settings.reloadqty>0
                                if gun(gunid).settings.weaponisammo=1
                                    guihud(hID).StrNumeric = str$(weaponammo(weaponammoindex)) : sA = 1
                                else
                                    tpool=firemode(gunid,firemode).settings.poolindex
                                    if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo
                                   guihud(hID).StrNumeric = str$(weaponammo(weaponammoindex+ammooffset))+"\"+str$(ammo) : sA = 1
                                endif
                            else
                                guihud(hID).StrNumeric = "" : sA = 1
                            endif
                        else
                            guihud(hID).StrNumeric = "" : sA = 1
                        endif
                    endif
                    if lower$(aiactionseq(seq).string2) = "frags"
                        if ggameobjectivetype<>1
                            fr$=str$(frags(iLocalEL))
                            if ggameobjectivetype=2 then fr$=fr$+"\"+str$(ggameobjectivevalue)
                        else
                            fr$=""
                        endif
                        guihud(hID).StrNumeric = fr$ : sA = 1
                    endif
                    if lower$(aiactionseq(seq).string2) = "time"
                        if ggameobjectivetype=3
                            fr$=str$((timer()-dwStartTime)/1024)+"\"+str$(ggameobjectivevalue)
                        else
                            fr$=""
                        endif
                        guihud(hID).StrNumeric = fr$ : sA = 1
                    endif
                    if sA = 0
                        guihud(hID).StrNumeric = aiactionseq(seq).string2
                    endif
                    gosub _gui_run
                endif
            endif
        endif
     endcase
     case AIACTEYEHURTTIME:
        if aiactionseq(seq).string1 <> ""
            guihurttime = val(aiactionseq(seq).string1)
        endif
     endcase
     case AIACTFADERSPEED:
        if aiactionseq(seq).string1 <> ""
            guifaderspeed = val(aiactionseq(seq).string1)
        endif
     endcase
     case AIACTUSEGUIX9:
        if aiactionseq(seq).string1 <> ""
            guiUsed = val(aiactionseq(seq).string1)
            if guiUsed > 1 then guiUsed = 1
            if guiUsed < 0 then guiUsed = 0
        endif
     endcase
     case AIACTHIDESHADOW:
        if aiactionseq(seq).string1 <> ""
            entityelement(e).hideshadow = val(aiactionseq(seq).string1)
            if entityelement(e).hideshadow < 0 then entityelement(e).hideshadow = 0
            if entityelement(e).hideshadow > 1 then entityelement(e).hideshadow = 1
            if entityelement(e).attachmentblobobj > 0
                if object exist(entityelement(e).attachmentblobobj)
                    if entityelement(e).hideshadow=1 then hide object entityelement(e).attachmentblobobj
                endif
            endif
        endif
     endcase
     `
     Rem Water
     case AIACTWATERHEIGHT:
      oldwaterheight#=waterheight#
      waterheight#=aiactionseq(seq).value
      position object waterobj,0,waterheight#,0
     endcase
     case AIACTWATER:
      wateron=aiactionseq(seq).value
     endcase
     case AIACTWATERFOGRED:
      waterfogred=aiactionseq(seq).value
     endcase
     case AIACTWATERFOGGREEN:
      waterfoggreen=aiactionseq(seq).value
     endcase
     case AIACTWATERFOGBLUE:
      waterfogblue=aiactionseq(seq).value
     endcase
     case AIACTWATERFOGDIST:
      waterfogfar=aiactionseq(seq).value
     endcase
     case AIACTWATERSPEED:
      speed#=aiactionseq(seq).value
      if speed#>100 then speed#=100
      if speed#<0 then speed#=0
      waterbump#=(speed#/1000.0)
      set effect constant float waterfx,"WaterBump",waterbump#
     endcase
     case AIACTWATERRED:
      waterred=aiactionseq(seq).value
      set effect constant integer waterfx,"RefractColor",rgb(waterred,watergreen,waterblue)
      set effect constant integer waterfx,"ReflectColor",rgb(waterred,watergreen,waterblue)
     endcase
     case AIACTWATERGREEN:
      watergreen=aiactionseq(seq).value
      set effect constant integer waterfx,"RefractColor",rgb(waterred,watergreen,waterblue)
      set effect constant integer waterfx,"ReflectColor",rgb(waterred,watergreen,waterblue)
     endcase
     case AIACTWATERBLUE:
      waterblue=aiactionseq(seq).value
      set effect constant integer waterfx,"RefractColor",rgb(waterred,watergreen,waterblue)
      set effect constant integer waterfx,"ReflectColor",rgb(waterred,watergreen,waterblue)
     endcase
     case AIACTWATERHEIGHTOFZONE:
      oldwaterheight#=waterheight#
      waterheight#=entityelement(e).y+aiactionseq(seq).value
      position object waterobj,0,waterheight#,0
     endcase
     rem Scene Commander, water performance
      case AIACTWATERFLEC:
      waterflec=aiactionseq(seq).value
     endcase

     rem LightRay Addition
     rem LRMod
     case AIACTLRAYSET:
      rotvar#=aiactionseq(seq).value
     endcase
     case AIACTLRAYACT:
      lrsamples=aiactionseq(seq).value
      if lrsamples<>lroldsamples then lrswitchsamples=1 : lroldsamples=lrsamples
     endcase
     case AIACTLRBLOOMACT:
      lrbloomactive=aiactionseq(seq).value
      if lrbloomactive<>lroldbloomactive then lroldbloomactive=lrbloomactive : lrswitchbloomactive=1
     endcase
     case AIACTLRDEBUGDEACTIVE:
      lrdebugdeactive=aiactionseq(seq).value
     endcase
     `
     rem GUI-X9
     case AIACTFORCEGUISUB:
        gosub _gui_run
     endcase
     `
     rem v118 - 110511 - cinematic hands (terry cox) >>>>
     `here are the command case actions
         case AIACTDISABLEFIREBUTTON:
            disablefirebutton = aiactionseq(seq).value
         endcase
         case AIACTDISABLEBLOCKINGBUTTON:
            disableblockingbutton = aiactionseq(seq).value
         endcase
         case AIACTSTARTCINEMATICHANDS:
            local parameter$ as string
            local temp$ as string
            local temp1$ as string
            `
            temp$=aiactionseq(seq).string1
            startcinematichands = val(temp$)
            if startcinematichands=1 then temp1$=aiactionseq(seq).string2 : cinematichandsloop = val(temp1$)
         endcase
         case AIACTPREVENTPLAYERSELECTINGGUN:
            preventplrselectinggun = aiactionseq(seq).value
         endcase
         case AIACTGETNEWWEAPON:
            local ws as integer
            local temp$ as string
            local temp1$ as string
            local gunname$ as string
            local gunfolder$ as string
            `
            temp$=aiactionseq(seq).string1
            gunname$=lower$(temp$)
            temp1$=aiactionseq(seq).string2
            gunfolder$=lower$(temp1$)
            `
            for ws=1 to entityelementlist
                if lower$(entityelement(ws).eleprof.name$) = gunname$
                    exit
                endif
            next ws
            if ws <= entityelementmax
               `
               rem send trigger signal to sync players (multiplayer)
               if gmultiplayergame=1
                mptrigger=1 : mptriggervalue1=ws
                gosub _multi_mptrigger
               endif
               `
               rem if child of spawn leader, reset spawn count
               spawne=entityelement(ws).spawn.leaderid
               if spawne=0 then spawne=ws
               entityelement(spawne).spawn.leadercount=entityelement(spawne).spawn.delay
               `
               rem V110 BETA4 - 070608 - if always active, a collected item keeps script running (for possible PLAYERDROP)
               if entityelement(ws).eleprof.phyalways<>0
                rem do not kill entity, keep it running
               else
                rem stop any looping sound
                gosub _ai_stopentsounds
                rem reset values
                entityelement(ws).beenkilled=1
                entityelement(ws).active=0
               endif
               `
               rem clear entity from col map
               tx=entityelement(ws).x/25
               ty=entityelement(ws).y/100
               tz=entityelement(ws).z/-25
               if tx>=0 and ty>=0 and tz>=0
                if tx<=viscolx and ty<=viscoly and tz<=viscolz
                 if viscolmap(tx,ty,tz)=ws then viscolmap(tx,ty,tz)=0
                endif
               endif
               `
               rem mission objective counter
               gosub _entity_resolveobjective
               `
               rem only allow weapons
               pint=player(1).inventorymax : inc pint
               if pint<100
                playerinventory(1,pint).new=1
                playerinventory(1,pint).index=ws
                player(1).inventorymax=pint
               endif
               gosub _gun_manager
               newweapon = 1
               `
               rem Find the gun
               findgun$=gunfolder$
               gosub _gun_findweaponindexbyname
               `
               if foundgunid>0
                   keepweaponholstered = 0
                   player(plrid).command.newweapon=foundgunid
               endif
            endif
          endcase
          case AIACTREMOVECURRENTWEAPON:
            local wi as integer
            local gun_name$ as string
            local gun_token$ as string
            `
            if gunid<>0
               if find first char$(gun(gunid).name$,"\") > 0
                     gun_token$ = first token$(gun(gunid).name$,"\")
                     gun_name$ = next token$("\")
               else
                     gun_name$ = gun(gunid).name$
               endif
               for i = 1 to 10
                  if weaponslot(i).got = gunid
                     weaponslot(i).pref=0
                     weaponslot(i).got=0
                     weaponhud(i)=0
                     weaponammo(i)=0
                     weaponclipammo(i)=0
                      exit
                  endif
               next i
               gunmode=31 : gunselectionafterhide=0
               gosub _gun_control
               wait 150
            endif
         endcase

      rem cinematic hands <<<<

      rem Scene Commander Actions
  case AIACTWOBBLE:
        wobble#=aiactionseq(seq).value
     endcase

     case AIACTTILTON:

     tilton=aiactionseq(seq).value
     if tilton<1 then tilton=1
     if tilton>5 then tilton=5

     endcase

     case AIACTTILTSPEED:

     tiltspeed#=aiactionseq(seq).value

     endcase

     case AIACTTILTBOUNCE:

     tiltbounce=aiactionseq(seq).value

     endcase

      case AIACTUNSKIP:

     unskip=aiactionseq(seq).value

     if unskip<1
     unskip=0
     else
     unskip=1
     endif

     endcase

   case AIACTPLRACTION:

     temp=aiactionseq(seq).value

      if temp>-1 and temp<12
      playeraction=temp
      endif

   endcase

   case AIACTFORCEMOVE:

   forcemove=aiactionseq(seq).value

   endcase

   case AIACTEMITFORCE:

   rem logic burst to allow constant force emissions
   entityelement(e).logiccount=0
   spherex#=entityelement(e).x : spherey#=entityelement(e).y : spherez#=entityelement(e).z
   sphereforce#=aiactionseq(seq).value : gosub _entity_addforcesphere

     endcase

     case AIACTFORCEDAMAGEON:

     forcedamageon=aiactionseq(seq).value

     endcase

      case AIACTCROSSHAIRON:

     crosshairon=aiactionseq(seq).value

     endcase

case AIACTWEAPONTOSLOT:

forcedslot=aiactionseq(seq).value

if forcedslot<0 then forcedslot=0
if forcedslot>10 then forcedslot=10

      endcase

 case AIACTARMON:
a1=aiactionseq(seq).value
if a1>=0 and a1<2
armouron=a1
endif
 endcase

case AIACTARMADD:
 a1=aiactionseq(seq).value
armour=armour+a1
endcase

case AIACTARMDEC:
a1=aiactionseq(seq).value
armour=armour-a1
endcase

case AIACTARMX:
armx=(gdisplaywidth/100.0)*aiactionseq(seq).value
endcase

case AIACTARMY:
army=(gdisplayheight/100.0)*aiactionseq(seq).value
endcase

case AIACTSETARM:
armour=aiactionseq(seq).value
 endcase

 case AIACTAIRON:

     airon=aiactionseq(seq).value

     endcase

      case AIACTADDAIR:

     airleft=airleft+aiactionseq(seq).value

     endcase

     case AIACTAIRTIME:

     airtime=aiactionseq(seq).value

     endcase

     case AIACTDROWNTIME:

     drowntime=aiactionseq(seq).value

     endcase

      case AIACTAIRMAX:

      airmax=aiactionseq(seq).value

      endcase

      case AIACTSETAIR:

      airleft=aiactionseq(seq).value
      lastsetair=airleft

      endcase

      case AIACTSETAIRX:

      airx=(gdisplaywidth/100.0)*aiactionseq(seq).value

      endcase

      case AIACTSETAIRY:

      airy=(gdisplayheight/100.0)*aiactionseq(seq).value

      endcase

      case AIACTINSTANTDROWN:

      instantdrown=aiactionseq(seq).value

      endcase

      case AIACTIMMUNE:

     isimmune=aiactionseq(seq).value

     endcase

 case AIACTARROWON:
      arrowkeyson=aiactionseq(seq).value
      if arrowkeyson=0
      else
      arrowkeys=1
      endif
      endcase

      case AIACTJUMPON:
      jumponkey=aiactionseq(seq).value
      if jumponkey=0
      else
      jumponkey=1
      endif
      endcase

        case AIACTWALKON:
      walkonkeys=aiactionseq(seq).value
      if walkonkeys=0
      else
        walkonkeys=1
      endif
      endcase

        case AIACTRUNON:
      runkeys=aiactionseq(seq).value
      if runkeys=0
      else
        runkeys=1
      endif
      endcase

         case AIACTCROUCHON:
      crouchonkey=aiactionseq(seq).value
      if crouchonkey=0
      else
      crouchonkey=1
      endif
      endcase

         case AIACTPEEKON:
      peekonkeys=aiactionseq(seq).value
      if peekonkeys<1
     peekonkeys=0
      else
      peekonkeys=1
      endif
      endcase

      case AIACTFORCEDAMAGE:

     spheredamage#=aiactionseq(seq).value

     endcase

rem Compass >>>
     case AIACTCOMPASSON:
      compassOn = 1
      madeCompass = 0

     endcase
     case AIACTCOMPASSOFF:
      compassOn = 0
      madeCompass =0

     endcase
     case AIACTCOMPASSX:
       compassX =(gdisplaywidth/100.0)*aiactionseq(seq).value
     endcase
     case AIACTCOMPASSY:
      compassY = (gdisplayheight/100.0)*aiactionseq(seq).value
     endcase
     case AIACTCOMPASSSPIN:
      compassSpin = 1
      needleSpin = 0
     endcase
     case AIACTNEEDLESPIN:
      compassSpin = 0
      needleSpin = 1
     endcase
     rem Compass <<<

case AIACTRADAR:

darkradar=aiactionseq(seq).value

endcase


case AIACTRADARX:
radarx=(gdisplaywidth/100.0)*aiactionseq(seq).value
endcase

case AIACTRADARY:
radary=(gdisplayheight/100.0)*aiactionseq(seq).value
endcase

case AIACTRADARROTATE:

rotateblip=aiactionseq(seq).value

endcase

case AIACTRADARRANGE:
radarrange=aiactionseq(seq).value
endcase

case AIACTSPEEDMOD:

      temp=aiactionseq(seq).value

      speedmod#=temp

      endcase

case AIACTADDFPGCRAWTEXT:

      a$=aiactionseq(seq).string1
      grawtext$=grawtext$+a$

      endcase

case AIACTSETOBJECTIVE:

     turnoff=aiactionseq(seq).value

     if turnoff<>0 then entityelement(e).isanobjective=e
     if turnoff=0 then entityelement(e).isanobjective=0

     if madeobjective=0
      if sprite exist(objectiveobject)=1
      delete sprite objectiveobject
      if image exist(objectiveobject)=1
      delete image objectiveobject
      endif
      endif

      if file exist("databank\objective.png")
      load image "databank\objective.png",objectiveobject

      sprite objectiveobject,-100000,-100000,objectiveobject
      offset sprite objectiveobject,sprite width(objectiveobject)/2,sprite height(objectiveobject)/2
      set sprite objectiveobject,0,1
      hide sprite objectiveobject
      set sprite priority objectiveobject,1
      endif
     endif

     endcase

     case AIACTSETOBJECTIVEX:

     objectivex=(gdisplaywidth/100.0)*aiactionseq(seq).value


     endcase

      case AIACTSETOBJECTIVEY:

      objectivey=(gdisplayheight/100.0)*aiactionseq(seq).value

     endcase

     case AIACTOBJECTIVEMODE:

     objectivemode=aiactionseq(seq).value

    if objectivemode<0 then objectivemode=0
    if objectivemode>2 then objectivemode=1

     endcase

case AIACTSETVARRND:
      rem Plystire 109 - Merge this command with our system
      if aiactionseq(seq).string2=""
      rndvalue=rnd(aiactionseq(seq).value)
       if aivariablemode=0
        aiglobals(aivariableindex)=rndvalue
       else
        ailocals(e,aivariableindex)=rndvalue
       endif
      else
       rem Use the better system ;)
       tvarfound=0
       rem Using our strings from the parser, let's find the var the user wants to set
       if left$(aiactionseq(seq).string1,1)="$"
       rndvalue=rnd(aiactionseq(seq).valueb)
        setintervar(e,aiactionseq(seq).string1,rndvalue)
        else

        for uvar = 0 to array count(uservars(0))
       if uservars(uvar).name = aiactionseq(seq).string1
       rndvalue=rnd(aiactionseq(seq).valueb)
          rem Found the variable, let's set it
          uservars(uvar).value = rndvalue
          tvarfound=1
          rem And Exit the For loop
          exit

         endif
        next uvar

        `
        if tvarfound=0
         for lvar = 0 to 99
         rndvalue=rnd(aiactionseq(seq).valueb)
          if aiuserlocals(e,lvar).name = aiactionseq(seq).string1
           rem Found the variable, let's set it
           aiuserlocals(e,lvar).value = rndvalue
           rem And Exit the For loop
           exit
          endif
         next lvar
        endif
        `
       endif
      endif
     endcase

     case AIACTRANDOMIZE:
     randomize timer()
     endcase

   case AIACTMAXSLOTS:
      maxslots=aiactionseq(seq).value
      if maxslots>10 then maxslots=10
      if maxslots<0 then maxslots=0
     endcase

     case AIACTEDAMMULT:

     entityelement(e).entitydammult#=aiactionseq(seq).value/100.0

     endcase

     case AIACTPLRSTRENGTH:

      temp#=aiactionseq(seq).value
      laststrength#=cameracarryweight#
      lastthrow#=camerathrow#
      cameracarryweight#=(temp#/100.0)*4000.0
      camerathrow#=temp#

     endcase

     case AIACTCULLRANGE:

     rem Scene Commander - Sets entites cull range, if less than 150 force to 150.
     entityelement(e).cullstate=aiactionseq(seq).value
     if entityelement(e).cullstate<150 then entityelement(e).cullstate=150
     endcase

     case AIACTCULLMODE:

     rem Scene Commander - toggles global cull mode, 0=Legacy culling, 1 Legacy + Culls dynamic entites based on distance.

     if aiactionseq(seq).value>=0 and aiactionseq(seq).value<2
      cullmode=aiactionseq(seq).value
     endif

     endcase

     case AIACTHIDEOBJ:

     rem Scene Commander - hide object if NOT flagged as destroyed/taken

      if entityelement(e).ishidden<>2
         obj=entityelement(e).obj
      if obj>0
         hide object obj
      endif
      entityelement(e).ishidden=3
      endif

     endcase

      case AIACTSHOWOBJ:

       rem Scene Commander - show object if NOT flagged as destroyed/taken

      if entityelement(e).ishidden<>2
      obj=entityelement(e).obj
      if obj>0
         show object obj
      endif
      entityelement(e).ishidden=0
      endif

     endcase

   case AIACTCULLMODI:

   cullmodi=aiactionseq(seq).value

   rem Scene Commander - prevent x0 preventing display

   if cullmodi<1 then cullmodi=1

   endcase

   case AIACTFOOTFALL:

   plrfootfall=aiactionseq(seq).value
   if plrfootfall<0 then plrfootfall=0
   if plrfootfall>1 then plrfootfall=1

   endcase

   case AIACTSWAPALT:

   forcealtswap=1

   endcase

   case AIACTROTATEPLRX:

   aiactionseq(seq).value=wrapvalue(aiactionseq(seq).value)

   rotate camera aiactionseq(seq).value,camera angle y(),camera angle z()

   endcase

   case AIACTROTATEPLRY:

   aiactionseq(seq).value=wrapvalue(aiactionseq(seq).value)

   rotate camera camera angle x(),aiactionseq(seq).value,camera angle z()

   endcase

   case AIACTENTROTX:

   aiactionseq(seq).value=wrapvalue(aiactionseq(seq).value)
   entityelement(e).rx=aiactionseq(seq).value

   endcase

   case AIACTENTROTY:

   aiactionseq(seq).value=wrapvalue(aiactionseq(seq).value)
   entityelement(e).ry=aiactionseq(seq).value

   endcase

   case AIACTENTROTZ:

   aiactionseq(seq).value=wrapvalue(aiactionseq(seq).value)
   entityelement(e).rz=aiactionseq(seq).value

   endcase

   case AIACTMOVEPLRX:

   moveplrx#=aiactionseq(seq).value

   endcase

   case AIACTMOVEPLRY:

   moveplry#=aiactionseq(seq).value

   endcase

   case AIACTMOVEPLRZ:

   moveplrz#=aiactionseq(seq).value

   endcase

   case AIACTSCALE:

   tempscale=aiactionseq(seq).value
   maxscale=aiactionseq(seq).valueb

   newscale=rnd(maxscale)+tempscale

     for li = 2 to 13

      alterlimbscale(e,li,newscale)

     next li

   entid=entityelement(e).bankindex

     endcase

     case AIACTHOLSTER:

      noholster=aiactionseq(seq).value

     endcase

     case AIACTNOAIR:

     noairon=aiactionseq(seq).value

     endcase

     case AIACTSETDROWNDAMAGE:

      drowndamage=aiactionseq(seq).value

     endcase

      case AIACTPLRPICKON:

      if aiactionseq(seq).value=1
      pickrange#=lastpickrange#
      else
      lastpickrange#=pickrange#
      pickrange#=0
      endif
      endcase

      case AIACTPLRPICKRANGE:

      lastpickrange#=pickrange#
      pickrange#=aiactionseq(seq).value

      endcase

      case AIACTFLASH:

      if spotflash=0
         rem logic burst to allow constant flash emissions
      entityelement(e).logiccount=0
      tx#=entityelement(e).x
      ty#=entityelement(e).y
      tz#=entityelement(e).z

      tcolr=flashr
      tcolg=flashg
      tcolb=flashb

       spotflash=100
       gosub _lighting_spotflash
       flashrange=600
      endif

      endcase

      case AIACTFLASHRED:

      temp=aiactionseq(seq).value

      if temp>=0 and temp<256

      flashr=temp

      endif

      endcase

      case AIACTFLASHGREEN:

      temp=aiactionseq(seq).value

      if temp>=0 and temp<256

      flashg=temp

      endif


      endcase

      case AIACTFLASHBLUE:

      temp=aiactionseq(seq).value

      if temp>=0 and temp<256

      flashb=temp

      endif

      endcase

      case AIACTFLASHRANGE:

      flashrange=aiactionseq(seq).value

      endcase

      case AIACTLOGICBURST:

      entityelement(e).logiccount=0

      endcase


    case AIACTPLRDAM:

    playerdammult#=(aiactionseq(seq).value/100)

    endcase

   case AIACTDESTROYIN:

   entityelement(e).spawn.life=timer()+(aiactionseq(seq).value*1000)

   endcase

    case AIACTSETLISTKEY:

    newkey=int(aiactionseq(seq).value)
    if newkey>0 and newkey<12
    listkey(newkey)=aiactionseq(seq).valueb
    endif
    endcase

case AIACTRAWTEXTVAR:
      tempvalue=0
      rem Plystire 109 - Merge this command with our system
      if aiactionseq(seq).string2=""
       if aivariablemode=0
        tempvalue=aiglobals(aivariableindex)
       else
        tempvalue=ailocals(e,aivariableindex)
       endif
      else
       rem Use the better system ;)
       tvarfound=0
       rem Using our strings from the parser, let's find the var the user wants to get
       if left$(aiactionseq(seq).string1,1)="$"
        tempvalue=getintervar(e,aiactionseq(seq).string1)
        else
        for uvar = 0 to array count(uservars(0))
         if uservars(uvar).name = aiactionseq(seq).string1
          rem Found the variable, let's set it
          tempvalue=uservars(uvar).value
          tvarfound=1
          rem And Exit the For loop
          exit
         endif
        next uvar
        `
        if tvarfound=0
         for lvar = 0 to 99
          if aiuserlocals(e,lvar).name = aiactionseq(seq).string1
           rem Found the variable, let's set it
           tempvalue=aiuserlocals(e,lvar).value
           rem And Exit the For loop
           exit
          endif
         next lvar
        endif
        `
       endif
      endif


      grawtext$=grawtext$+str$(tempvalue)

     endcase

      case AIACTSIN:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt1=sin(ttt)
       setintervar(e,aiactionseq(seq).string1,ttt1)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's wrap it's value
         uservars(uvar).value = sin(uservars(uvar).value)
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          aiuserlocals(e,lvar).value=sin(aiuserlocals(e,lvar).value)
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase

      case AIACTCOS:
      rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
       ttt1=cos(ttt)
       setintervar(e,aiactionseq(seq).string1,ttt1)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's wrap it's value
          uservars(uvar).value = cos(uservars(uvar).value)
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          aiuserlocals(e,lvar).value=cos(aiuserlocals(e,lvar).value)
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
     endcase

      case AIACTSCALEHUDX:

      temp$=aiactionseq(seq).string1
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(temp$)
        hud(thudid).scalex=aiactionseq(seq).valueb:hud(thudid).update=1
        exit
       endif
      next thudid



      endcase

      case AIACTSCALEHUDY:

      temp$=aiactionseq(seq).string1
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(temp$)
        hud(thudid).scaley=aiactionseq(seq).valueb:hud(thudid).update=1
        exit
       endif
      next thudid

      endcase

      case AIACTCHANGEHUDALPHA:

      temp$=aiactionseq(seq).string1
         tempalpha=aiactionseq(seq).valueb
         if tempalpha<0 then tempalpha=0
         if tempalpha>255 then tempalpha=255
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(temp$)
        hud(thudid).alpha=tempalpha:hud(thudid).update=2
        exit
       endif
      next thudid

      endcase

      case AIACTWATERFLOW:
      waterflow=aiactionseq(seq).value
      endcase

      case AIACTWATERCURRENT:
      watercurrent=wrapvalue(aiactionseq(seq).value)
      endcase

      case AIACTREMOVEWEAPON:

      if len(aiactionseq(seq).string1)=1
         whichslot=aiactionseq(seq).value
               if gunid=weaponslot(whichslot).got then gunmode=31
               weaponslot(whichslot).got=0:weaponclipammo(whichslot)=0:weaponammo(whichslot)=0:weaponslot(whichslot).pref=0
         else
         findgun$=lower$(aiactionseq(seq).string1)
         gosub _gun_findweaponindexbyname
            if foundgunid>0
            for f=1 to 10
                if weaponslot(f).got=foundgunid
                if gunid=weaponslot(f).got then gunmode=31
                weaponslot(f).got=0:weaponclipammo(f)=0:weaponammo(f)=0:weaponslot(forceslot).pref=0

                endif
               next f
            endif
         endif
     endcase


      case AIACTGIVEWEAPON:
      findgun$=lower$(aiactionseq(seq).string1)
      gosub _gun_findweaponindexbyname
      done=0
      if foundgunid>0
         weaponindex=foundgunid
            for pint=1 to 10
            if weaponslot(pint).got=0 and done=0
                  gosub _player_obtainaweapon
                  done=1
            endif
            next pint
      endif

     endcase

      case AIACTENTITYSETIMMUNE:

      entityelement(e).isimmune=aiactionseq(seq).value

      endcase

      case AIACTRESETONRELOAD:

      if aiactionseq(seq).value>1 then aiactionseq(seq).value=1
      if aiactionseq(seq).value<0 then aiactionseq(seq).value=0

      resetonreload=aiactionseq(seq).value

      endcase

      case AIACTENTITYCAM:

      lastcam=ecam
      ecam=e

      endcase

      case AIACTPLAYERCAM:

      lastcam=ecam
      ecam=0

      endcase

      case AIACTLASTCAM:

      spare=lastcam
      ecam=lastcam
      lastcam=spare

      endcase

      case AIACTCUSTGUNANIM:

      custstart=aiactionseq(seq).value
      custend=aiactionseq(seq).valueb

      if gunid>0
         gunmode=9998
      endif

      endcase

case AIACTUSEENTROT:

entityelement(e).camuse=aiactionseq(seq).value

endcase

case AIACTSETCAMOFFSETX:

entityelement(e).camoffsetx=aiactionseq(seq).value

endcase

case AIACTSETCAMOFFSETY:

entityelement(e).camoffsety=aiactionseq(seq).value

endcase

case AIACTSETCAMOFFSETZ:

entityelement(e).camoffsetz=aiactionseq(seq).value

endcase

case AIACTSETCAMROTX:

entityelement(e).camrotx=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTSETCAMROTY:

entityelement(e).camroty=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTSETCAMROTZ:

entityelement(e).camrotz=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTSCALELIMB:

limbno=aiactionseq(seq).value
limbscale=aiactionseq(seq).valueb

if obj>0
  if object exist(obj)
      if limb exist(obj,limbno)
         if lower$(right$(limb name$(obj,limbno),4))="head"
            limbno=1
            alterlimbscale(e,limbno,limbscale)
            else
            scale limb obj,limbno,limbscale,limbscale,limbscale
         endif
      endif
  endif
endif

ttryy#=entityelement(e).y
      tettry=0

      while tettry<25
      if static volume(entityelement(e).x,ttryy#+33,entityelement(e).z,entityelement(e).x,ttryy#+32,entityelement(e).z,ellipseheight#)=0 then exit
      ttryy#=ttryy#+1.0
      inc tettry
     endwhile
     if tettry>=25
      rem entity stuck - so make it immobile to shut down struggle!
      entityelement(e).eleprof.isimmobile=1
     else
      rem entities can find floor initially (not playerstart,trigger,light,emission)
      entityelement(e).y=ttryy#

     position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z

     endif

endcase

case AIACTHIDELIMB:

limbno=aiactionseq(seq).value

if obj>0
  if object exist(obj)
      if limb exist(obj,limbno)
        scale limb obj,limbno,0,0,0
      endif
  endif
endif


endcase

case AIACTSHOWLIMB:

limbno=aiactionseq(seq).value
limbscale=aiactionseq(seq).valueb
if limbscale=0 then limbscale=100
if obj>0
  if object exist(obj)
      if limb exist(obj,limbno)
         scale limb obj,limbno,limbscale,limbscale,limbscale
      endif
  endif
endif


endcase

case AIACTPLAYPRESET:

temp$=lower$(aiactionseq(seq).string1)
custstart=0
custend=0

if gunid>0
if temp$<>""

   select temp$

      case "fixjam"
      custstart=firemode(gunid,firemode).action2.clearjam.s
      custend=firemode(gunid,firemode).action2.clearjam.e
      endcase

      case "handpush"
      custstart=firemode(gunid,firemode).action2.handpush.s
      custend=firemode(gunid,firemode).action2.handpush.e
      endcase

      case "handdead"
      custstart=firemode(gunid,firemode).action2.handdead.s
      custend=firemode(gunid,firemode).action2.handdead.e
      endcase

      case "jammed"
      custstart=firemode(gunid,firemode).action2.jammed.s
      custend=firemode(gunid,firemode).action2.jammed.e
      endcase

      case "swaptoalt"
      custstart=firemode(gunid,firemode).action2.swaptoalt.s
      custend=firemode(gunid,firemode).action2.swaptoalt.e
      endcase

      case "handbutton"
      custstart=firemode(gunid,firemode).action2.handbutton.s
      custend=firemode(gunid,firemode).action2.handbutton.e
      endcase

      case "handtake"
      custstart=firemode(gunid,firemode).action2.handtake.s
      custend=firemode(gunid,firemode).action2.handtake.e
      endcase

      case "select"
      custstart=firemode(gunid,firemode).action.show.s
      custend=firemode(gunid,firemode).action.show.e
      endcase

      case "idle"
      custstart=firemode(gunid,firemode).action.idle.s
      custend=firemode(gunid,firemode).action.idle.e
      endcase

      case "move"
      custstart=firemode(gunid,firemode).action.move.s
      custend=firemode(gunid,firemode).action.move.e
      endcase

      case "run"
      custstart=firemode(gunid,firemode).action.run.s
      custend=firemode(gunid,firemode).action.run.e
      endcase

      case "startreload"
      custstart=firemode(gunid,firemode).action.startreload.s
      custend=firemode(gunid,firemode).action.startreload.e
      endcase

      case "endreload"
      custstart=firemode(gunid,firemode).action.endreload.s
      custend=firemode(gunid,firemode).action.endreload.e
      endcase

      case "cock"
      custstart=firemode(gunid,firemode).action.cock.s
      custend=firemode(gunid,firemode).action.cock.e
      endcase

      case "pullup"
      custstart=firemode(gunid,firemode).action2.pullup.s
      custend=firemode(gunid,firemode).action2.pullup.e
      endcase

      case "pulldown"
      custstart=firemode(gunid,firemode).action2.pulldown.s
      custend=firemode(gunid,firemode).action2.pulldown.e
      endcase

      case "pullleft"
      custstart=firemode(gunid,firemode).action2.pullleft.s
      custend=firemode(gunid,firemode).action2.pullleft.e
      endcase

      case "pullright"
      custstart=firemode(gunid,firemode).action2.pullright.s
      custend=firemode(gunid,firemode).action2.pullright.e
      endcase




   endselect


endif

if custstart<>0
gunmode=9998
endif

endif


endcase

case  AIACTLOCKEMPLACEMENT:

lockangle=entityelement(e).ry
fieldoffire=aiactionseq(seq).value

endcase

case AIACTFREEEMPLACEMENT:

lockangle=9999

endcase

case AIACTCULLIMMOBILE:

if aiactionseq(seq).value<0 then aiactionseq(seq).value=0
if aiactionseq(seq).value>1 then aiactionseq(seq).value=1

entityelement(e).cullimmobile=aiactionseq(seq).value

endcase

case AIACTPLRACC:

playeraccmult#=(aiactionseq(seq).value/100)

endcase

case AIACTENTITYACC:

entityelement(e).entityacc=(aiactionseq(seq).value/100)

endcase

case AIACTDEBUGCURSOR:
set cursor aiactionseq(seq).value,aiactionseq(seq).valueb
endcase

case AIACTDEBUGVAR:
rem Using our strings from the parser, let's find the var the user wants to set
      if left$(aiactionseq(seq).string1,1)="$"
       ttt=getintervar(e,aiactionseq(seq).string1)
      else
       tvarfound=0
       for uvar = 0 to array count(uservars(0))
        if uservars(uvar).name = aiactionseq(seq).string1
         rem Found the variable, let's wrap it's value
         ttt=uservars(uvar).value
         rem And Exit the For loop
         tvarfound=1
         exit
        endif
       next uvar
       `
       if tvarfound=0
        for lvar = 0 to 99
         if aiuserlocals(e,lvar).newsystem=1 and aiuserlocals(e,lvar).name = aiactionseq(seq).string1
          rem Found the variable, let's add to it
          ttt=aiuserlocals(e,lvar).value
          rem And Exit the For loop
          tvarfound=1
          exit
         endif
        next lvar
       endif
       `
      endif
      print str$(ttt)
endcase

case AIACTDEBUGTEXT:
print aiactionseq(seq).string1
endcase

case AIACTWIREFRAME:

wirestate=aiactionseq(seq).value
if wirestate<0 then wirestate=0
if wirestate>0 then wirestate=1
obj=entityelement(e).obj
      if obj>0
         set object wireframe obj,wirestate
      endif

endcase


case AIACTPLAYEROFFSETON:

if aiactionseq(seq).value>1 then aiactionseq(seq).value=1
if aiactionseq(seq).value<1 then aiactionseq(seq).value=0

plrcamoffseton=aiactionseq(seq).value

endcase

case AIACTPLAYEROFFSETX:

plrcamoffsetx#=aiactionseq(seq).value

endcase

case AIACTPLAYEROFFSETY:

plrcamoffsety#=aiactionseq(seq).value

endcase

case AIACTPLAYEROFFSETZ:

plrcamoffsetz#=aiactionseq(seq).value

endcase

case AIACTMUTATE:

tempscale=aiactionseq(seq).value
maxscale=aiactionseq(seq).valueb

if obj>0
   if object exist(obj)
      perform checklist for object limbs obj
      if checklist quantity()>0
      mutations=rnd(10)+5
         for f=1 to mutations
            tlimb=rnd(checklist quantity())
            if limb exist(obj,tlimb)
               limbscale=rnd(maxscale)+tempscale
               scale limb obj,timb,limbscale,limbscale,limbscale
            endif
         next f
      endif
   endif
endif

ttryy#=entityelement(e).y
      tettry=0

      while tettry<25
      if static volume(entityelement(e).x,ttryy#+33,entityelement(e).z,entityelement(e).x,ttryy#+32,entityelement(e).z,ellipseheight#)=0 then exit
      ttryy#=ttryy#+1.0
      inc tettry
     endwhile
     if tettry>=25
      rem entity stuck - so make it immobile to shut down struggle!
      entityelement(e).eleprof.isimmobile=1
     else
      rem entities can find floor initially (not playerstart,trigger,light,emission)
      entityelement(e).y=ttryy#

     position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z

     endif
endcase

case AIACTOBJECTRANGE:

if aiactionseq(seq).value<0 then aiactionseq(seq).value=70
entityelement(e).objectiveradarrange=aiactionseq(seq).value

endcase

case AIACTLINKTOPLAYER:

eplayercam=e
gosub _ode_switchoffe
endcase

case AIACTFREEFROMPLAYER:

eplayercam=0
gosub _ode_setupewithphysics
if obj>0
   if object exist(obj)
   set object collision on obj
   endif
endif

endcase

case AIACTALWAYSRUN:

alwaysrun=aiactionseq(seq).value

if alwaysrun>=1
alwaysrun=1
else
alwaysrun=0
endif

endcase

case AIACTLINKENTITYROTX:

linkx=aiactionseq(seq).value

endcase

case AIACTLINKENTITYROTY:

linky=aiactionseq(seq).value

endcase

case AIACTLINKENTITYROTZ:

linkz=aiactionseq(seq).value

endcase

case AIACTPLROFFSETANGLEX:

plroffsetanglex#=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTPLROFFSETANGLEY:

plroffsetangley#=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTPLROFFSETANGLEZ:

plroffsetanglez#=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTENTITYOFFSETANGLEX:

entityelement(e).offsetanglex=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTENTITYOFFSETANGLEY:

entityelement(e).offsetangley=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTENTTIYOFFSETANGLEZ:

entityelement(e).offsetanglez=wrapvalue(aiactionseq(seq).value)

endcase

case AIACTSHOWWEAPON:

      tgunid=gunid
      if len(aiactionseq(seq).string1)=1
         whichslot=aiactionseq(seq).value
            if weaponslot(whichslot).got<>0
               tgunid=aiactionseq(seq).value
            endif
         else
         findgun$=lower$(aiactionseq(seq).string1)
         gosub _gun_findweaponindexbyname
            if foundgunid>0
            for f=1 to 10
                if weaponslot(f).got=foundgunid
                  tgunid=f
                endif
               next f
            endif
         endif

         spareselectkey=tgunid

endcase

case AIACTNOSELECT:

temp=aiactionseq(seq).value
if temp<1 then temp=1
if temp>10 then temp=10

weaponslot(temp).noselect=aiactionseq(seq).valueb

endcase

case AIACTDELAYTIMER:

entityelement(e).delaydamagetimer=(aiactionseq(seq).value/1000)

endcase

case AIACTCREATESPLASHSOUND:
createsplashsound=aiactionseq(seq).value
endcase

case AIACTSHOWFLAK:

showflak=aiactionseq(seq).value


endcase

case AIACTMAKEVIDEOTEXTURE:

actual=aiactionseq(seq).valueb+9
if actual>=10 or actual<=20

tfile$=lower$(aiactionseq(seq).string1)

tstring$=right$(lower$(tfile$),4)

   if file exist(tfile$)=1

   if tstring$=".avi" or tstring$=".wmv" or tstring$=".mpeg" or tstring$=".mpg" or tstring$=".mov" or tstring$=".qt"

   if animation exist(actual)=1
   delete animation actual
   endif

   load animation tfile$,actual
   addfiletocollection(tfile$)

endif
endif
endif

endcase

case AIACTUSEVIDEOTEXTURE:

actual=aiactionseq(seq).value+9
if actual>=10 or actual<=20
   if animation exist(actual)=1
   entityelement(e).videotexture=actual
   animations(actual-9).entid=e


   endif

endif


endcase

case AIACTDELETEVIDEOTEXTURE:

actual=aiactionseq(seq).value+9
if actual>=10 or actual<=20

 if animation exist(actual)=1
 delete animation actual
   if animations(actual-9).entid<>0
   entityelement(animations(actual-9).entid).videotexture=0
   endif
 endif
endif


endcase

case AIACTPAUSEVIDEOTEXTURE:


actual=aiactionseq(seq).value+9
if actual>=10 or actual<=20

 if animation exist(actual)=1
 pause animation actual
 endif
endif


endcase

case AIACTRESUMEVIDEOTEXTURE:


actual=aiactionseq(seq).value+9
if actual>=10 or actual<=20

 if animation exist(actual)=1
 resume animation actual
 endif
endif


endcase

case AIACTVIDEOTEXTURESPEED:


actual=aiactionseq(seq).value+9
percent=aiactionseq(seq).valueb
if actual>=10 or actual<=20

 if animation exist(actual)=1
 set animation speed actual,percent
 endif
endif


endcase

case AIACTVIDEOTEXTUREVOLUME:

actual=aiactionseq(seq).value+9
percent=aiactionseq(seq).valueb
if actual>=10 or actual<=20

 if animation exist(actual)=1
 set animation volume actual,percent
 endif
endif

endcase

case AIACTSTOPVIDEOTEXTURE:

actual=aiactionseq(seq).value+9
if actual>=10 or actual<=20

 if animation exist(actual)=1
 stop animation actual
      if animations(actual-9).entid<>0
      entityelement(animations(actual-9).entid).videotexture=0
      endif
 endif
endif


endcase

case AIACTSETBULLETCOL:
entityelement(e).nobulletcol=aiactionseq(seq).value
endcase

case AIACTSYNCRATE:

syncrate=aiactionseq(seq).value

endcase

case AIACTFLASHLIGHT:

flashlighton=aiactionseq(seq).value

endcase

case AIACTFLASHLIGHTRED:

tempcol=aiactionseq(seq).value
if tempcol<0 then tempcol=0
if tempcol>255 then tempcol=255

flashlightred=tempcol

endcase

case AIACTFLASHLIGHTGREEN:

tempcol=aiactionseq(seq).value
if tempcol<0 then tempcol=0
if tempcol>255 then tempcol=255

flashlightgreen=tempcol

endcase

case AIACTFLASHLIGHTBLUE:

tempcol=aiactionseq(seq).value
if tempcol<0 then tempcol=0
if tempcol>255 then tempcol=255

flashlightblue=tempcol

endcase

case AIACTFLASHLIGHTRANGE:

flashlightrange=aiactionseq(seq).value

endcase

case AIACTUSEFADE:

entityelement(e).usefade=aiactionseq(seq).value

endcase

case AIACTSHOWAIR:

alwaysshowair=aiactionseq(seq).value

endcase

case AIACTDELAYDESTROY:

entityelement(e).delaydestroy=aiactionseq(seq).value
entityelement(e).delaydestroytimer=timer()
entityelement(e).delaytimeactive=1
endcase

   endselect




    rem Scene commander actions end
    `
   next seq
   `
  else
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     if aiconttimer<>0
      print strarr$(2);
     endif
    endif
   endif
  endif
  `
  if gshowdebugtextingamestate=1
   if debugviewtog=1
    if aiconttimer<>0
     print "."
    endif
   endif
  endif
  `
 rem next trigger
 next conindex
 `
 if tensureentitytimestampsupdated=1
  tensureentitytimestampsupdated=0
  for ttse=1 to entityelementlist
   if entityelement(ttse).active=1
    entityelement(ttse).logictimestamp=timer()
   endif
  next ttse
  timestamp=timer()
 endif
 `
endif

return

_ai_action_talk:
 `
 rem Coded inside FPI ACTION CASE and takes currentsoundfile$ and currentsoundtalkmode
 rem Determine if final string used refers to a SOUND ZONE or not
 if aiactionseq(seq).value=-1
  currentsoundfile$=entityelement(e).eleprof.soundset$
 else
  if aiactionseq(seq).value=-2
   currentsoundfile$=entityelement(e).eleprof.soundset1$
  else
   currentsoundfile$=aiactionseq(seq).filename
  endif
 endif
 rem Determine if straight talk, or ordered, or random
 if currentsoundtalkmode=0
  playsoundvalue=aiactionseq(seq).value
 else
  rem ordered/random needs to use filename
  `if aiactionseq(seq).value=-1
   `currentsoundfile$=entityelement(e).eleprof.soundset$
   `aiactionseq(seq).filename=currentsoundfile$
   `aiactionseq(seq).value=0
  `endif
  `rem ordered/random needs to use filename
  `if aiactionseq(seq).value=-2
   `currentsoundfile$=entityelement(e).eleprof.soundset1$
   `aiactionseq(seq).filename=currentsoundfile$
   `aiactionseq(seq).value=0
  `endif
  rem logic for ordered or random
  rem play speech
  `aiactionseq(seq).value=loadinternalsoundcore(aiactionseq(seq).filename,0)
  playsoundvalue=loadinternalsoundcore(currentsoundfile$,0)
  `if aiactionseq(seq).value=0
  if playsoundvalue=0
   `tfile$="languagebank\"+language$+"\"+aiactionseq(seq).filename
   `aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
   tfile$="languagebank\"+language$+"\"+currentsoundfile$
   playsoundvalue=loadinternalsoundcore(tfile$,0)
  endif
  `currentsoundfile$=aiactionseq(seq).filename
  rem find next
  if currentsoundtalkmode=1
   rem find next ordered (blahX.wav) where X is the order number
   `ttn$=left$(right$(aiactionseq(seq).filename,5),1)
   ttn$=left$(right$(currentsoundfile$,5),1)
   ttnn=val(ttn$)
   if ttnn>=1 and ttnn<=9
    inc ttnn
    if ttnn>9 then ttnn=2
    `ttn$=left$(aiactionseq(seq).filename,len(aiactionseq(seq).filename)-5)+str$(ttnn)+".wav"
    ttn$=left$(currentsoundfile$,len(currentsoundfile$)-5)+str$(ttnn)+".wav"
    if file exist(ttn$)=0
     `ttnn=2 : ttn$=left$(aiactionseq(seq).filename,len(aiactionseq(seq).filename)-5)+str$(ttnn)+".wav"
     ttnn=2 : ttn$=left$(currentsoundfile$,len(currentsoundfile$)-5)+str$(ttnn)+".wav"
    endif
    `aiactionseq(seq).filename=ttn$
    currentsoundfile$=ttn$
   endif
  endif
  if currentsoundtalkmode=2
   rem random
   `ttn$=left$(right$(aiactionseq(seq).filename,5),1)
   ttn$=left$(right$(currentsoundfile$,5),1)
   ttnn=val(ttn$)
   count=100
   repeat
    ttnn2=2+rnd(7)
    `ttn$=left$(aiactionseq(seq).filename,len(aiactionseq(seq).filename)-5)+str$(ttnn2)+".wav"
    ttn$=left$(currentsoundfile$,len(currentsoundfile$)-5)+str$(ttnn2)+".wav"
    dec count
   until (file exist(ttn$)=1 and ttnn2<>ttnn) or count<=0
   if count>0
    `aiactionseq(seq).filename=ttn$
    currentsoundfile$=ttn$
   endif
  endif
  rem store next filename in entity for next time
  if aiactionseq(seq).value=-1
   entityelement(e).eleprof.soundset$=currentsoundfile$
   entityelement(e).soundset=playsoundvalue
  else
   if aiactionseq(seq).value=-2
    entityelement(e).eleprof.soundset1$=currentsoundfile$
    entityelement(e).soundset1=playsoundvalue
   endif
  endif
 endif
 rem Play talk
 tmpx#=camera position x()
 tmpy#=camera position y()
 tmpz#=camera position z()
 tsoundzoneinstead=0
 for te=1 to entityelementlist
  if te<>e and entityelement(te).active=1
   rem Talker inside zone
   if left$(lower$(currentsoundfile$),6)="inzone"
    tentid=entityelement(te).bankindex
    if entityprofile(tentid).ismarker=3
     condx1=(entityelement(te).x+(entityelement(te).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(te).y-27+(entityelement(te).eleprof.trigger.areay1*100))
     condz1=(entityelement(te).z-(entityelement(te).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(te).x+(entityelement(te).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(te).y-27+(entityelement(te).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(te).z-(entityelement(te).eleprof.trigger.areaz2*100))-50.0
     tokay=1
     if entityelement(e).x<condx1 then tokay=0
     if entityelement(e).y<condy1 then tokay=0
     if entityelement(e).z>condz1 then tokay=0
     if entityelement(e).x>condx2 then tokay=0
     if entityelement(e).y>condy2 then tokay=0
     if entityelement(e).z<condz2 then tokay=0
     if tokay=1 and te<>lastsoundzoneusedfortalk
      rem we ensure that the zone cannot be used TWICE in succession (double waypoint trigger issue)
      lastsoundzoneusedfortalk=te
      tsoundzoneinstead=te
     endif
    endif
   else
    rem A specific zone
    if lower$(entityelement(te).eleprof.name$)=lower$(currentsoundfile$)
     tsoundzoneinstead=te : exit
    endif
   endif
  endif
 next te
 if tsoundzoneinstead>0
  rem Use sound and sound file of matching sound zone (soundset $1 NOT $0)
  tsoundindexfromsoundzone=entityelement(tsoundzoneinstead).soundset1
  playinternal3dsound(tsoundindexfromsoundzone,tmpx#,tmpy#,tmpz#)
  entityelement(e).soundlooping=tsoundindexfromsoundzone
  currentsoundfile$=entityelement(tsoundzoneinstead).eleprof.soundset1$
 else
  rem Traditionally use soundset or direct file specified
  if aiactionseq(seq).value=-1
   playinternal3dsound(entityelement(e).soundset,tmpx#,tmpy#,tmpz#)
   entityelement(e).soundlooping=entityelement(e).soundset
  else
   if aiactionseq(seq).value=-2
    playinternal3dsound(entityelement(e).soundset1,tmpx#,tmpy#,tmpz#)
    entityelement(e).soundlooping=entityelement(e).soundset1
   else
    `playinternal3dsound(aiactionseq(seq).value,tmpx#,tmpy#,tmpz#)
    `entityelement(e).soundlooping=aiactionseq(seq).value
    playinternal3dsound(playsoundvalue,tmpx#,tmpy#,tmpz#)
    entityelement(e).soundlooping=playsoundvalue
   endif
  endif
 endif
 broadcast3dsound(tmpx#,tmpy#,tmpz#,100.0,0)
 entityelement(e).soundistalking=1
 soundid=entityelement(e).soundlooping
 gosub _lipsync_playspeech
 `armgesture#=0 : rem experimental
return

_ai_load:

rem FPSCV10X : Ensure AILIST is large enough
if aiindex>=array count(ailist(0))
 dim ailist(aiindex+32) as ailiblisttype
endif

rem If not loaded, load it
if ailist(aiindex).loaded=0

rem Load AI Script
gosub _ai_loaddata

rem Only if AI data exists
desc$=ailist(aiindex).desc$
if desc$<>""
 `
 rem Go through actions to look for required resources
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  actindex=aicond(conindex).action
  for seq=aiaction(actindex).first to aiaction(actindex).last
   select aiactionseq(seq).type
    case AIACTRUNFPI:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      aifile$=tfile$ : gosub _ai_findlibindex
      aiactionseq(seq).value=libindex
      Rem Hockeykid - 140310 - Load any scripts that are needed for runfpi
      aidir$="scriptbank\"
      ai$=tfile$ : gosub _ai_locateaiindex : gosub _ai_load
     endif
    endcase
    case AIACTSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if soundfileexist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTTALK:
     gosub _ai_action_talk_processfilename
    endcase
    case AIACTTALKORDERED:
     gosub _ai_action_talk_processfilename
    endcase
    case AIACTTALKRANDOM:
     gosub _ai_action_talk_processfilename
    endcase
    case AIACT3DSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if soundfileexist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTLOOPSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if soundfileexist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,1)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTMUSIC:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     rem V109BETA4 - 250408 - added $0 and $1 choices
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if soundfileexist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTMUSICOVERRIDE:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if soundfileexist(tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTVIDEO:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$="$0"
      aiactionseq(seq).value=-1
     else
      if tfile$="$1"
       aiactionseq(seq).value=-2
      else
       if file exist(tfile$)=1
        inc actstringmax : dim actstring$(actstringmax)
        actstring$(actstringmax)=tfile$
        addfiletocollection(tfile$)
        aiactionseq(seq).value=actstringmax
       endif
      endif
     endif
    endcase
    case AIACTWEBLINK:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$="$0"
      aiactionseq(seq).value=-1
     else
      if tfile$="$1"
       aiactionseq(seq).value=-2
      else
       if file exist(tfile$)=1
        inc actstringmax : dim actstring$(actstringmax)
        actstring$(actstringmax)=tfile$
        addfiletocollection(tfile$)
        aiactionseq(seq).value=actstringmax
       endif
      endif
     endif
    endcase
    `
    case AIACTSKY:
     sky$=aiactionseq(seq).filename
     if sky$<>""
      rem Load in sky
      if guseskystate=1
       tskyname$=right$(sky$,3)
       if object exist(65123)=0
        `
        rem V109 BETA6 - replaced X file load with optional DBO convert/load
        `if file exist(tsky$)=1
        `debugviewtext(-1,strarr$(3))
        `load object tsky$,65123
        `addfiletocollection(tsky$)
        tsky$=sky$+"\"+tskyname$+".x"
        debugviewtext(-1,strarr$(3))
        tfile$=tsky$
        if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
        if file exist(tfile$)=1 or file exist(tdbofile$)=1
         if file exist(tdbofile$)=1
          tfile$=tdbofile$
          tdbofile$=""
         endif
         load object tfile$,65123
         if len(tdbofile$)>1
          save object tdbofile$,65123
          if file exist(tdbofile$)=1
           delete object 65123
           load object tdbofile$,65123
           tfile$=tdbofile$
          endif
         endif
         addfiletocollection(tfile$)


         for tfor=0 to 4
         if tfor=0 then text$="png"
          if tfor=1 then text$="dds"
          if tfor=2 then text$="tga"
          if tfor=3 then text$="jpg"
          if tfor=4 then text$="bmp"

            tsky$=sky$+"\"+tskyname$+"_U."+text$
          if file exist(tsky$)=1
          rem Scene Commander - S4 fix (allowing data to be restored here appears to fix a Windows 8 issue!).
          restore _skydata
          `tsky2$=sky$+"\"+tskyname$+"_U.":addfiletocollection(tsky$)
            addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_D."+text$ :addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_L."+text$ :addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_R."+text$ :addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_B."+text$ :addfiletocollection(tsky$)
           tsky$=sky$+"\"+tskyname$+"_F."+text$ :addfiletocollection(tsky$)
           tfor=4
          endif
         next tfor
            Rem S4real fix foe windows 8
            _skydata:
            data "_U.","_D.","_L.","_R.","_B.","_F."

         set object collision off 65123
         sk#=(100*(realrange#-4000))/5.0
         scale object 65123,sk#,sk#,sk#
         set object texture 65123,2,0
         set object light 65123,0
         set object cull 65123,0
         set object fog 65123,0
         set object mask 65123,%111
        endif
       endif
      endif
     endif
    endcase
    case AIACTSKYSCROLL:
     skyscroll$=aiactionseq(seq).filename
     if skyscroll$<>""
      rem Load in sky scroll texture
      if guseskystate=1
       if file exist(skyscroll$)=1
        addfiletocollection(skyscroll$)
        if object exist(65124)=0
         debugviewtext(-1,strarr$(4))
         make object plain 65124,9000,9000
         tskyscrollimg=loadinternalimagecompressquality(skyscroll$,5,1)
         texture object 65124,0,tskyscrollimg
         set object texture 65124,2,0
         rem hack - change to new command when DGSDK done!
`         set blend mapping on 65124,loadinternalimage("skybank\generic\skyportal.tga"),4,0
`         set blend mapping on 65124,loadinternalimage("skybank\generic\skyportal.tga"),10
         position object 65124,0,1000,0
         set object transparency 65124,1
         set object collision off 65124
         xrotate object 65124,270
         set object light 65124,0
         set object cull 65124,0
         set object fog 65124,0
         `
         rem now create a second UV data layer for static second texture (alphaportal)
         q#=1.0
         lock vertexdata for limb 65124,0
         set vertexdata uv 0,1,0,0
         set vertexdata uv 0,1,q#,0
         set vertexdata uv 1,1,0,0
         set vertexdata uv 2,1,q#,q#
         set vertexdata uv 3,1,0,0
         set vertexdata uv 4,1,0,q#
         set vertexdata uv 5,1,q#,q#
         unlock vertexdata
         `
        endif
       endif
      endif
     endif
    endcase
    case AIACTBACKDROP:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalimagequality(tfile$)
      if aiactionseq(seq).value=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
    endcase
    rem AirMod - Added Action Materials >>>
    case AIACTBACKDROPVID:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$="$0"
      aiactionseq(seq).value=-1
     else
      if tfile$="$1"
       aiactionseq(seq).value=-2
      else
       if file exist(tfile$)=1
        inc actstringmax : dim actstring$(actstringmax)
        actstring$(actstringmax)=tfile$
        addfiletocollection(tfile$)
        aiactionseq(seq).value=actstringmax
       endif
      endif
     endif
    endcase
    rem AirMod - Done <<<
    case AIACTHUDIMAGE:
     tfile$=aiactionseq(seq).filename
     `if tfile$<>"" FPGC - 231109
     ` addfiletocollection(tfile$)
     ` aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
     ` if aiactionseq(seq).value=0
     `  tfile$="languagebank\"+language$+"\"+tfile$
     `  addfiletocollection(tfile$)
     `  aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
     ` endif
     `endif
     timgvalue=0
     if tfile$<>""
      addfiletocollection(tfile$)
      timgvalue=loadinternalimagecompressquality(tfile$,5,1)
      if timgvalue=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       timgvalue=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=right$(str$(10000+timgvalue),4)+tfile$
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDIMAGEFINE:
     tfile$=aiactionseq(seq).filename
     `if tfile$<>""
     ` addfiletocollection(tfile$)
     ` aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,0,1)
     ` if aiactionseq(seq).value=0
     `  tfile$="languagebank\"+language$+"\"+tfile$
     `  addfiletocollection(tfile$)
     `  aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
     ` endif
     `endif
     timgvalue=0
     if tfile$<>""
      addfiletocollection(tfile$)
      timgvalue=loadinternalimagecompressquality(tfile$,0,1)
      if timgvalue=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       timgvalue=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=right$(str$(10000+timgvalue),4)+tfile$
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDTEXT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDFONT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDSHOW:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDUNSHOW:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDNAME:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDANIM:
     tfile$=aiactionseq(seq).filename
     `if tfile$<>""
     ` for tnum=0 to 10
     `  ttfile$=tfile$+str$(tnum)+".tga"
     `  addfiletocollection(ttfile$)
     `  tnumimg=loadinternalimagecompressquality(ttfile$,5,1)
     `  if tnum=0 then aiactionseq(seq).value=tnumimg
     ` next tnum
     `endif
     timgvalue=0
     if tfile$<>""
      for tnum=0 to 10
       ttfile$=tfile$+str$(tnum)+".tga"
       addfiletocollection(ttfile$)
       tnumimg=loadinternalimagecompressquality(ttfile$,5,1)
       if tnum=0 then timgvalue=tnumimg
      next tnum
     endif
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=right$(str$(10000+timgvalue),4)+tfile$
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDFADEOUT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDMAKE:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTSETTARGETNAME:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTAIADDALLY:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTAIADDENEMY:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTAIADDNEUTRAL:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTFPGCRAWTEXTFONT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTADDAITEAM:
     team=val(aiactionseq(seq).filename)
     teamslot=AIFindTeam(team)
     if teamslot=0
      w=AIFindEmptyTeam()
      aifaction(w,1).team=team
     endif
    endcase
    `
    case AIACTFPGCRAWTEXT:
     tdata$=aiactionseq(seq).filename
     if tdata$<>""
      if tdata$="$0"
       aiactionseq(seq).value=-1
      else
       if tdata$="$1"
        aiactionseq(seq).value=-2
       else
        inc actstringmax : dim actstring$(actstringmax)
        actstring$(actstringmax)=aiactionseq(seq).filename
        aiactionseq(seq).value=actstringmax
       endif
      endif
     endif
    endcase
    `
   endselect
  next seq
  `
 next conindex
 `
rem no AI script exists endif
endif

rem AI has been delt with and loaded
ailist(aiindex).loaded=1

rem If not loaded, load above
endif

return

_ai_action_talk_processfilename:
 tfile$=aiactionseq(seq).filename
 if tfile$<>""
  if tfile$="$0"
   aiactionseq(seq).value=-1
  else
   if tfile$="$1"
    aiactionseq(seq).value=-2
   else
    if soundfileexist(tfile$)=1
     addfiletocollection(tfile$)
     aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
     if aiactionseq(seq).value=0
      tfile$="languagebank\"+language$+"\"+tfile$
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalsoundcore(tfile$,0)
     endif
    endif
   endif
  endif
 endif
return

_ai_createentityreferences:

rem go through all AI, and link entitynames to entityelementsubscripts
for aiindex=1 to aiindexmaster
 desc$=ailist(aiindex).desc$
 if desc$<>""
  for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
   actindex=aicond(conindex).action
   for seq=aiaction(actindex).first to aiaction(actindex).last
    select aiactionseq(seq).type
     case AIACTPLRMOVETO:
      tname$=aiactionseq(seq).filename : gosub _entity_findname
      aiactionseq(seq).value=foundte
     endcase
    endselect
   next seq
  next conindex
 endif
next aiindex

return


_ai_free:

rem Only if AI data exists
rem FPGC - 191009 - and in range of array
if aiindex<=array count(ailist())
 desc$=ailist(aiindex).desc$
 if desc$<>""
  for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
   actindex=aicond(conindex).action
   for seq=aiaction(actindex).first to aiaction(actindex).last
    select aiactionseq(seq).type
     case AIACTSOUND:
      if aiactionseq(seq).value>0
       stop sound aiactionseq(seq).value
      endif
     endcase
     case AIACTTALK:
      if aiactionseq(seq).value>0
       stop sound aiactionseq(seq).value
      endif
     endcase
     case AIACTTALKORDERED:
      if aiactionseq(seq).value>0
       stop sound aiactionseq(seq).value
      endif
     endcase
     case AIACTTALKRANDOM:
      if aiactionseq(seq).value>0
       stop sound aiactionseq(seq).value
      endif
     endcase
     case AIACTMUSIC:
      if aiactionseq(seq).value>0
       stop sound aiactionseq(seq).value
      endif
     endcase
     case AIACTMUSICOVERRIDE:
      if aiactionseq(seq).value>0
       stop sound aiactionseq(seq).value
      endif
     endcase
    endselect
   next seq
  next conindex
 endif
 rem V109BETA4 - 240408 - Free global which overrides MUSIC action with MUSICOVERRIDE
 musicoverridden=0
 rem Free AI resource flag
 ailist(aiindex).loaded=0
endif

return

_ai_dividetriggerblock:

rem go through and get item from stringblock$
word$="" : value$=""
for c=1 to len(stringblock$)
 if mid$(stringblock$,c)="," or c=len(stringblock$)
  rem get one item in block
  if c=len(stringblock$)
   chunk$=stringblock$
  else
   chunk$=left$(stringblock$,c-1)
  endif
  stringblock$=right$(stringblock$,len(stringblock$)-(len(chunk$)+1))
  if len(chunk$)>0
   rem find equate seperator (or all otherwise)
   sep=0
   for c2=1 to len(chunk$)
    if mid$(chunk$,c2)="=" then sep=c2 : exit
    if c2=len(chunk$) then sep=c2+1 : exit
   next c2
   if sep>0
    `
    rem find word and value
    word$=lower$(removeedgespaces(left$(chunk$,sep-1)))
    value$=removeedgespaces(right$(chunk$,len(chunk$)-(len(word$)+1)))
    `
    rem reset value vars
    mid1=0 : mid2=0
    value1$=""
    value2$=""
    value3$=""
    `
    rem take value 1 2 3 from value
    for c=0 to len(value$)
     if mid$(value$,c)=" " and mid1=0 then mid1=c : exit
     if mid$(value$,c)=" " and mid1<>0 and mid2=0 then mid2=c : exit
    next c
    if mid1=0
     value1$=value$
    else
     if mid2=0
      value1$=left$(value$,mid1-1)
      value2$=right$(value$,len(value$)-(len(value1$)+1))
     else
      value1$=left$(value$,mid1-1)
      value2$=left$(right$(value$,mid1),(mid2-mid1)-1)
      value3$=right$(value$,len(value$)-mid2)
     endif
    endif
    `
    rem calculate values from value strings
    value1=val(value1$)
    value2=val(value2$)
    value3=val(value3$)
    `
   endif
  endif
  exit
 endif
next c

return

_ai_loaddata:

rem Ensure AI Script still exists
if file exist(aidir$+ai$)=1
`
rem About to add conditions
conindexfirst=conindexcount
`
rem Load AI Script Data from file
dim data$(350)
load array aidir$+ai$,data$()
addfiletocollection(aidir$+ai$)
founddescfield=0
for l=0 to 349
 line$=data$(l)
 `
 rem V109 BETA8 - desc issue correction (ensure desc not empty)
 if lower$(left$(line$,4))="desc" and len(line$)<8 then line$="desc = FPI Script"
 `
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem Field or Triggerline
   if left$(line$,1)<>":"
    `
    rem Standard Field Line
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem AI header
    if field$="desc" then ailist(aiindex).desc$=value$ : founddescfield=1
    `
   else
    `
    rem AI Triggerline (slice line marked by leading colon:)
    cutline$=right$(line$,len(line$)-1)
    `
    rem find : seperator
    sep=0
    for c=1 to len(cutline$)
     if mid$(cutline$,c)=":" then sep=c : exit
    next c
    if sep>0
     `
     rem conditions collected
     conditions$=left$(cutline$,sep-1)
     cutline$=right$(cutline$,len(cutline$)-(len(conditions$)+1))
     rem now rest is actions
     if len(cutline$)>0
      rem actions collected
      actions$=cutline$
     endif
     `
     rem Parse through conditions
     aicondfirst=aicondseqcount
     stringblock$=conditions$
     while len(stringblock$)>0
      gosub _ai_dividetriggerblock
      for tindex=0 to AICONDLAST
       if word$=conword$(tindex)
        if aicondseqcount+10>array count(aiconditionseq()) then dim aiconditionseq(aicondseqcount+1000) as aiconditiontype
        aiconditionseq(aicondseqcount).type=tindex
        aiconditionseq(aicondseqcount).valuea=value1
        aiconditionseq(aicondseqcount).valueb=value2
        aiconditionseq(aicondseqcount).valuec=value3
        rem Variable System - Setting the string variables passed from the parser to our conditionseq
        aiconditionseq(aicondseqcount).string1=value1$
        aiconditionseq(aicondseqcount).string2=value2$
        inc aicondseqcount
        exit
       endif
      next tindex
     endwhile
     if conindexcount+10>array count(aicond()) then dim aicond(conindexcount+100) as aiconditionitemtype
     aicond(conindexcount).first=aicondfirst
     aicond(conindexcount).last=aicondseqcount-1
     aicond(conindexcount).action=actindexcount
     inc conindexcount
     `
     rem Parse through actions
     aiactfirst=aiactseqcount
     stringblock$=actions$
     while len(stringblock$)>0
      gosub _ai_dividetriggerblock
      for tindex=0 to AIACTLAST
       if word$=actword$(tindex)
        if aiactseqcount+10>array count(aiactionseq()) then dim aiactionseq(aiactseqcount+1000) as aiactiontype
        aiactionseq(aiactseqcount).type=tindex
        aiactionseq(aiactseqcount).value=value1
        aiactionseq(aiactseqcount).filename=value$
        rem - Setting the second variable passed from the parser to our actionseq
        aiactionseq(aiactseqcount).valueb=value2
        rem - Setting the string variables passed from the parser to our actionseq
        aiactionseq(aiactseqcount).string1=value1$
        aiactionseq(aiactseqcount).string2=value2$
        inc aiactseqcount
        exit
       endif
      next tindex
     endwhile
     if actindexcount+10>array count(aiaction()) then dim aiaction(actindexcount+100) as aiactionitemtype
     aiaction(actindexcount).first=aiactfirst
     aiaction(actindexcount).last=aiactseqcount-1
     inc actindexcount
     `
    endif
    `
   endif
  endif
 endif
next l
undim data$()
`
Rem Fix desc issue (user did not even use desc)
if founddescfield=0 then ailist(aiindex).desc$="desc = FPI Script"
`
rem Finalise condition data values
conindexlast=conindexcount-1
ailist(aiindex).conditionfirst=conindexfirst
ailist(aiindex).conditionlast=conindexlast
`
rem File not exist endif
endif

return

_ai_scanfornewscriptsonly:

rem Reset count
aiindexmaster=0

rem Scan for scripts
oldir$=get dir$()
aidir$="scriptbank\"
empty array filelist$()
buildfilelist(aidir$,"")

rem Ensure scriptbank is big enough
dim scriptbank$(1+array count(filelist$()))

rem V120 - 060809 - ensure all AI arrays are big enough
dim ailist(1+array count(filelist$())) as ailiblisttype

rem If AI Script exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem AI Script filename from folder
  ai$=filelist$(chkfile)
  `
  rem Check if filename valid
  if right$(ai$,4)=".fpi"
  `
  rem Check AI Script exists in bank
  tokay=1
  if aiindexmaster>0
   for aiindex=1 to aiindexmaster
    if scriptbank$(aiindex)=ai$ then tokay=0
   next aiindex
  endif
  if tokay=1
    `
    rem Find free space in 'scriptbank'
    freeaiindex=-1
    if aiindexmaster>0
     for aiindex=1 to aiindexmaster
      if scriptbank$(aiindex)="" then freeaiindex=aiindex : exit
     next aiindex
    endif
    `
    rem New AI Script or Free One
    if freeaiindex=-1
     inc aiindexmaster
     aiindex=aiindexmaster
    else
     aiindex=freeaiindex
    endif
    `
    rem Store AI Script for later loading (below)
    scriptbank$(aiindex)=ai$
    `
   endif
   `
  endif
  `
 next chkfile
endif

rem Restore directory
set dir oldir$

return

_ai_loadallscripts:
 currentlyintheAISCIPTloader=1
 if aiindexmaster>0
  aidir$="scriptbank\"
  for aiindex=1 to aiindexmaster
   ai$=scriptbank$(aiindex)
   if lower$(left$(ai$,len(aidir$)))<>lower$(aidir$)
    gosub _ai_load
   endif
  next aiindex
 endif
 currentlyintheAISCIPTloader=0
return

_ai_loadessentialentityscripts:
 `
 rem FPGC - 100909 - as this is called at the start of each level, wipe out the old AI data now
 rem to prepare for this levels AI resources (fixes a bug where loading page script overrites in-game AIINDEX=1 script!)
 if array count(ailist(0))>=0
  for aiindex=0 to array count(ailist(0))
   ailist(aiindex).loaded=0
  next aiindex
 endif
 `
 rem FPGC - 100909 - preload scripts not referenced in entity profiles/elements
 aidir$="scriptbank\"
 ai$="people\throwback.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 ai$="people\throwfore.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 ai$="people\throwleft.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 ai$="people\throwright.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 ai$="people\throwragdollback.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 ai$="people\throwragdollfore.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 ai$="people\throwragdollleft.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 ai$="people\throwragdollright.fpi" : gosub _ai_locateaiindex : gosub _ai_load
 `
return

_ai_scanfornewscripts:

rem Scan all to get names
gosub _ai_scanfornewscriptsonly

rem Now load all AI scripts fully
gosub _ai_loadallscripts

return

_ai_findlibindex:
 libindex=-1
 if aiindexmaster>0
  for taiindex=1 to aiindexmaster
   if lower$(scriptbank$(taiindex))=lower$(aifile$) then libindex=taiindex : exit
  next taiindex
 endif
return

_ai_loadentityscriptsonlyfore:
 if e>0
  aidir$="scriptbank\"
  if entityelement(e).bankindex>0
   ai$=entityelement(e).eleprof.aiinit$ : gosub _ai_locateaiindex : gosub _ai_load
   ai$=entityelement(e).eleprof.aimain$ : gosub _ai_locateaiindex : gosub _ai_load
   ai$=entityelement(e).eleprof.aidestroy$ : gosub _ai_locateaiindex : gosub _ai_load
   ai$=entityelement(e).eleprof.aishoot$ : gosub _ai_locateaiindex : gosub _ai_load
  endif
 endif
return

_ai_locateaiindex:
 aiindex=0
 if aiindexmaster>0
  for taiindex=1 to aiindexmaster
   thisai$=scriptbank$(taiindex)
   if lower$(ai$)=lower$(thisai$)
    aiindex=taiindex
    taiindex=aiindexmaster+1
    exit
   endif
  next taiindex
 endif
return

rem
rem FUNCTIONS FOR COMMON USE
rem

`
` SUBROUTINES RELATING TO COMMON ACTIVITIES AND RESOURCES
`

_common_wipeeffectifnotexist:
 rem if file not exist, do not try to use effect
 if file exist(tfile$)=0
  rem FPGC - 080710 - also check ps_2_0 folder which might hold them
  ttfilefile$=getfile(tfile$)
  ttfilepath$="effectbank\ps_2_0\"+ttfilefile$
  if file exist(ttfilepath$)=1
   rem substitute now to save conversion later
   tfile$=ttfilepath$
  else
   rem not in main effectbank or in ps_2_0 folder, remove effect from consideration
   tfile$=""
  endif
 endif
return

_common_makeeffecttextureset:
 `
 rem used by entitycore and segmentmaker (takes tfile$ and texdir$)
 gosub _common_wipeeffectifnotexist
 `
 rem reset output
 absolutelyrequirethistexture=0
 ensureclearlayermax=0
 texdir1$=""
 texdir2$=""
 texdir3$=""
 texdir4$=""
 texdir5$=""
 `
 rem V117 - 110110 - new full shader style means D2 preferred over D (thanks to Mark Blosser PS2 shaders)
 texturingtoken$="D"
 if gnewblossershaders=1
  rem Abolishes use of unshaded D textures
  texturingtoken$="D2"
 endif
 `
 rem determine effect textures to use
 if tfile$<>"" and segnoeffects=0
  `
  rem D2=D+I+N+S
  tstr0$=left$(texdir$,len(texdir$)-4) : rem _01_D2.TGA -> _01_D2
  tstr1$=left$(texdir$,len(texdir$)-6) : rem _01_D2.TGA -> _01_
  tstr2$=right$(texdir$,4) : rem _01_D2.TGA -> .TGA
  if len(tstr2$)<=1 then tstr2$=".dds"
  `
  rem D2 must be present to indicate existence of D, N, S, I, etc
  if upper$(right$(tstr0$,2))="D2"
   `
   rem The system used by FPSC is D.I.N.S for 0,1,2,3
   hardcodedtexturestages=0
   `
   rem related to scene universe (lightmap stage present)
   ttt$="illuminationmap.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=1
   ttt$="bump.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=2
   `
   rem related to entities (lightmap stage NOT present)
   ttt$="illuminationent.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=11
   ttt$="bumpent.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=12
   ttt$="bumpbone.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=13
   `
   if hardcodedtexturestages>0
    if hardcodedtexturestages=1
     rem [LM]+[DIFF+ILLU]
     ensureclearlayermax=2
     texdir1$=tstr1$+"D2"+tstr2$
     texdir2$=tstr1$+"D2"+tstr2$
     texdir3$=tstr1$+"I"+tstr2$
    endif
    if hardcodedtexturestages=2
     rem [LM]+[DIFF+NORM]
     ensureclearlayermax=2
     texdir1$=tstr1$+texturingtoken$+tstr2$
     texdir2$=tstr1$+texturingtoken$+tstr2$
     texdir3$=tstr1$+"N"+tstr2$
     rem Absolutely must have a NORMAL MAP, or fail this effect
     absolutelyrequirethistexture=3
    endif
    if hardcodedtexturestages=11
     rem [DIFF+ILLU]
     ensureclearlayermax=1
     texdir1$=tstr1$+"D2"+tstr2$
     texdir2$=tstr1$+"I"+tstr2$
    endif
    if hardcodedtexturestages=12
     rem [DIFF+NORM]
     ensureclearlayermax=1
     texdir1$=tstr1$+texturingtoken$+tstr2$
     texdir2$=tstr1$+"N"+tstr2$
     rem Absolutely must have a NORMAL MAP, or fail this effect
     absolutelyrequirethistexture=2
    endif
    if hardcodedtexturestages=13
     rem [DIFF+NORM+SPEC]
     ensureclearlayermax=2
     texdir1$=tstr1$+texturingtoken$+tstr2$
     texdir2$=tstr1$+"N"+tstr2$
     texdir3$=tstr1$+"S"+tstr2$
     rem Absolutely must have a NORMAL MAP, or fail this effect
     absolutelyrequirethistexture=2
    endif
   else
    rem Standard DINS system
    if teffectuseslightmapstage=1
     rem [LM]+[DIFF+ILLU+NORM+SPEC+BRIH]
     texdir1$=tstr1$+texturingtoken$+tstr2$
     texdir2$=tstr1$+texturingtoken$+tstr2$
     texdir3$=tstr1$+"I"+tstr2$
     texdir4$=tstr1$+"N"+tstr2$
     texdir5$=tstr1$+"S"+tstr2$
    else
     rem [DIFF+ILLU+NORM+SPEC+BRIH]
     texdir1$=tstr1$+texturingtoken$+tstr2$
     texdir2$=tstr1$+"I"+tstr2$
     texdir3$=tstr1$+"N"+tstr2$
     texdir4$=tstr1$+"S"+tstr2$
     texdir5$=tstr1$+"B"+tstr2$
    endif
   endif
   `
   rem FPGC - 070710 - some entities do not follow pure naming conventions and are slightly modified
   rem such as Light4_G_G2.tga using the multi-use Light4_I.tga for the illumination, so we account for this
   for tcheck=1 to 4
    if tcheck=1 then tcheck$=texdir2$
    if tcheck=2 then tcheck$=texdir3$
    if tcheck=3 then tcheck$=texdir4$
    if tcheck=4 then tcheck$=texdir5$
    if right$(lower$(tcheck$),4)=".tga" then tcheck$=left$(tcheck$,len(tcheck$)-4)+".dds"
    if file exist(tcheck$)=0
     rem assuming the format name_letter_D2.tga was used (therefore name_letter_I.tga)
     rem and the intended 'common support texture' was name_I.tga or name_N.tga or name_S.tga
     rem we can detect for and change it here if the alternative filename exists
     tcheck$=left$(tcheck$,len(tcheck$)-7)+right$(tcheck$,5)
     if right$(lower$(tcheck$),4)=".tga" then tcheck$=left$(tcheck$,len(tcheck$)-4)+".dds"
     if file exist(tcheck$)=1
      if tcheck=1 then texdir2$=tcheck$
      if tcheck=2 then texdir3$=tcheck$
      if tcheck=3 then texdir4$=tcheck$
      if tcheck=4 then texdir5$=tcheck$
     endif
    endif
   next tcheck
   `
  else
   `
   rem not D2.XXX, so just use texdir$ as base texture
   texdir1$=texdir$
   `
  endif
  `
 else
  rem use no effect this time
  tfile$=""
 endif
 `
return

rem
rem MESH AND TEXTURE HANDLING
rem
`
function loadinternalmesh(tfile$)

rem Default return
meshid=0

rem Scan for existing mesh
if meshbankmax>0
 for m=1 to meshbankmax
  if tfile$=meshbank$(m) then meshid=meshbankoffset+m : exit
 next m
else
 m=meshbankmax+1
endif

rem Did not find, load it
if m>meshbankmax
 inc meshbankmax
 dim meshbank$(meshbankmax)
 if file exist(tfile$)=1
  meshid=meshbankoffset+meshbankmax
  load mesh tfile$,meshid
  meshbank$(meshbankmax)=tfile$
 endif
endif

endfunction meshid

function deleteallinternalimages()
 if imagebankmax>0
  for t=1 to imagebankmax
   imgid=imagebankoffset+t
   if image exist(imgid)=1
    delete image imgid
   endif
  next t
  imagebankmax=0
  undim imagebank$()
  dim imagebank$(imagebankmax)
 endif
 if texturebankmax>0
  for t=1 to texturebankmax
   texid=texturebankoffset+t
   if image exist(texid)=1
    delete image texid
   endif
  next t
  texturebankmax=0
  undim texturebank$()
  dim texturebank$(texturebankmax)
 endif
endfunction

function refreshallinternalimages()
 if imagebankmax>0
  for t=1 to imagebankmax
   tfile$=imagebank$(t)
   imgid=imagebankoffset+t
   loadinternalimageexcompressquality(tfile$,imgid,1,0)
  next t
 endif
endfunction

function refreshinternalimage(t)
 tfile$=imagebank$(t)
 imgid=imagebankoffset+t
 loadinternalimageexcompressquality(tfile$,imgid,1,0)
endfunction

function loadinternalimageexcompressquality(tfile$,imgid,compressmode,quality)
 if lower$(right$(tfile$,4))=".jpg" then tstarttry=2 else tstarttry=1
 if lower$(right$(tfile$,4))=".png" then tstarttry=2 else tstarttry=1
 for try=tstarttry to 3
  if try=1 then tryfile$=left$(tfile$,len(tfile$)-4)+".dds"
  if try=2 then tryfile$=tfile$
  if try=3 then tryfile$=left$(tfile$,len(tfile$)-3)+imgext$
  if image file exist(tryfile$)=1
   if gincludeonlyvideo=1 and left$(lower$(tryfile$),len(gincludeonlyname$))<>lower$(gincludeonlyname$)
    rem fill video with basic random color
    create bitmap 7,4,4
    cls rgb(rnd(255),rnd(255),rnd(255))
    get image imgid,0,0,4,4
    delete bitmap 7
    set current bitmap 0
   else
    `
    rem low texture use in editor ( Special divide reduction value of 16384=norealload )
    tempdividetexturesize=gdividetexturesize
    if segobjusedformapeditor=1 then tempdividetexturesize=8
    `
    rem FPSCV104RC10 - can skip 'real load' unless full lightmapping which requires alpha from texture
    `if gcompilestandaloneexe=1 then tempdividetexturesize=16384 : quality=0
    if gcompilestandaloneexe=1 and glightshadowsstate=0 then tempdividetexturesize=16384 : quality=0
    `
    rem load image (skip if building = quicker build)
    if quality=0
     if tempdividetexturesize=16384 and currentlyintheAISCIPTloader=1
      rem load nothing if we are loading for AI SCRIPT (which does not use the images during the construction)
     else
      load image tryfile$,imgid,quality,tempdividetexturesize
     endif
    else
     if quality=1
      load image tryfile$,imgid,quality
     else
      rem Quality Mode 2 means only reduce have as much (smaller items blur too much in QM=1)
      load image tryfile$,imgid,1,tempdividetexturesize/2
     endif
    endif
    `
    rem and perhaps save it
    if grealgameviewstate=0
     tdds$=left$(tfile$,len(tfile$)-4)+".dds"
     if file exist(tdds$)=0 and tempdividetexturesize=0
      save image tdds$,imgid,compressmode
      addfiletocollection(tdds$)
     else
      addfiletocollection(tryfile$)
     endif
    else
     addfiletocollection(tryfile$)
    endif
    `
   endif
   exit
  endif
 next try
endfunction

function loadinternalimageexcompress(tfile$,imgid,compressmode)
 loadinternalimageexcompressquality(tfile$,imgid,compressmode,0)
endfunction

function loadinternalimageex(tfile$,imgid)
 loadinternalimageexcompress(tfile$,imgid,1)
endfunction

function loadinternalimagecompressquality(tfile$,compressmode,quality)

rem Default return
imgid=0

rem Scan for existing
if imagebankmax>0
 for t=1 to imagebankmax
  if tfile$=imagebank$(t) then imgid=imagebankoffset+t : exit
 next t
else
 t=imagebankmax+1
endif

rem Did not find, load it
if t>imagebankmax
 inc imagebankmax
 dim imagebank$(imagebankmax)
 imgid=imagebankoffset+imagebankmax
 loadinternalimageexcompressquality(tfile$,imgid,compressmode,quality)
 if image exist(imgid)=1
  imagebank$(imagebankmax)=tfile$
 else
  dec imagebankmax
  imgid=0
 endif
endif

endfunction imgid

function loadinternalimagecompress(tfile$,compressmode)
 imgid=loadinternalimagecompressquality(tfile$,compressmode,0)
endfunction imgid

function loadinternalimage(tfile$)
 imgid=loadinternalimagecompress(tfile$,1)
endfunction imgid

function loadinternalimagequality(tfile$)
 imgid=loadinternalimagecompressquality(tfile$,1,1)
endfunction imgid

function loadinternaltexture(tfile$)

rem Default return
texid=0

rem Scan for existing
if texturebankmax>0
 for t=1 to texturebankmax
  if tfile$=texturebank$(t) then texid=texturebankoffset+t : exit
 next t
else
 t=texturebankmax+1
endif

rem Did not find, load it
if t>texturebankmax
 rem Attempt to load
 inc texturebankmax
 dim texturebank$(texturebankmax)
 texturebank$(texturebankmax)=tfile$
 texid=texturebankoffset+texturebankmax
 loadinternalimageex(tfile$,texid)
 if image exist(texid)=0
  rem failed to load, so reverse creation
  texturebank$(texturebankmax)=""
  dec texturebankmax : texid=0
 endif
endif

endfunction texid

function loadinternaltextureex(tfile$,compressmode,quality)

rem Default return
texid=0

rem Scan for existing
if texturebankmax>0
 for t=1 to texturebankmax
  if tfile$=texturebank$(t) then texid=texturebankoffset+t : exit
 next t
else
 t=texturebankmax+1
endif

rem Did not find, load it
if t>texturebankmax
 rem Attempt to load
 inc texturebankmax
 dim texturebank$(texturebankmax)
 texturebank$(texturebankmax)=tfile$
 texid=texturebankoffset+texturebankmax
 loadinternalimageexcompressquality(tfile$,texid,compressmode,quality)
 if image exist(texid)=0
  rem failed to load, so reverse creation
  texturebank$(texturebankmax)=""
  dec texturebankmax : texid=0
 endif
endif

endfunction texid

function loadinternaleffectunique(tfile$,makeunique)

rem Redirect the FX file if a NEWBLOSSER shader exists for it
if gnewblossershaders=1
 rem switch key built-in shaders to new PS_2_0 versions (default behaviour from V117 onwards)
 ifits$="bump.fx" : if right$(tfile$,len(ifits$))=ifits$ then tfile$="effectbank\ps_2_0\bump.fx"
 ifits$="bumpent.fx" : if right$(tfile$,len(ifits$))=ifits$ then tfile$="effectbank\ps_2_0\bumpent.fx"
 ifits$="illuminationent.fx" : if right$(tfile$,len(ifits$))=ifits$ then tfile$="effectbank\ps_2_0\illuminationent.fx"
 ifits$="illuminationmap.fx" : if right$(tfile$,len(ifits$))=ifits$ then tfile$="effectbank\ps_2_0\illuminationmap.fx"
 ifits$="bumpbone.fx" : if right$(tfile$,len(ifits$))=ifits$ then tfile$="effectbank\ps_2_0\bumpbone.fx"
 ifits$="bumpbonerev.fx" : if right$(tfile$,len(ifits$))=ifits$ then tfile$="effectbank\ps_2_0\bumpbonerev.fx"
endif

rem Default return
effectid=0

rem Scan for existing
if effectbankmax>0 and makeunique=0
 for t=1 to effectbankmax
  if tfile$=effectbank$(t) then effectid=effectbankoffset+t : exit
 next t
else
 t=effectbankmax+1
endif

rem Did not find, load it
if t>effectbankmax
 if file exist(tfile$)=1
  inc effectbankmax
  dim effectbank$(effectbankmax)
  effectid=effectbankoffset+effectbankmax
  if lower$(left$(tfile$,14))="effectbank\csg"
   load effect tfile$,effectid,1
  else
   load effect tfile$,effectid,0
  endif
  if effect exist(effectid)=1
   effectbank$(effectbankmax)=tfile$
  else
   rem could not use effect
   dec effectbankmax
   effectid=0
  endif
  addfiletocollection(tfile$)
 endif
endif

rem FPGC - 080410 - store effect ID for FASTBONE (so we can filter entities using it in depth camera)
ifits$="fastbone.fx"
if lower$(right$(tfile$,len(ifits$)))=ifits$
 inc gfastboneeffectshaderidmax
 dim gfastboneeffectshaderid(gfastboneeffectshaderidmax) as integer
 gfastboneeffectshaderid(gfastboneeffectshaderidmax)=effectid
endif

endfunction effectid

function loadinternaleffect(tfile$)
 effectid=loadinternaleffectunique(tfile$,0)
endfunction effectid

function soundfileexist(tfile$)
 soundexists=0
 if file exist(tfile$)=1
  soundexists=1
 else
  rem try as OGG
  tfileogg$=left$(tfile$,len(tfile$)-4)+".ogg"
  if file exist(tfileogg$)=1
   soundexists=1
  endif
 endif
endfunction soundexists

function loadinternalsoundcore(tfile$,mode)

Rem Terry fix for build game crash when cloning sounds.
local skipclone as boolean
skipclone = 0

rem The file to actually load (can change)
tfiletoload$=tfile$

rem Default return
soundid=0

rem No scan for existing - all sounds unique for overlay play
t=soundbankmax+1
if t>soundbankmax
 rem 041212 - as we change WAV to OGG during build process, end game can try to load WAV but
 rem only the OGG file exists in the standalone media, so detect any OGG and switch to that
 if grealgameviewstate=1
  if file exist(tfile$)=0
   tfileogg$=left$(tfile$,len(tfile$)-4)+".ogg"
   if file exist(tfileogg$)=1
    rem bingo - no WAV but found OGG, use that from now on
    tfiletoload$=tfileogg$
   endif
  endif
 endif
 tspecialogg=0 : if right$(lower$(tfiletoload$),4)=".ogg" then tspecialogg=1
 if right$(lower$(tfile$),4)=".wav" or tspecialogg=1
  if file exist(tfiletoload$)=1
   rem add this sound to game sound bank
   inc soundbankmax
   dim soundbank$(soundbankmax)
   soundid=soundbankoffset+soundbankmax
   rem FPSCV114 - can skip 'real load' if building game
   if gcompilestandaloneexe=1
    if globalsmallsound=0
     globalsmallsound=soundid
     tfile$="audiobank\voices\squeak\leap.wav"
     `load sound tfiletoload$,globalsmallsound,0,1 : rem turns out CLONE SOUND cannot clone an OGG sound (was in tfiletoload$)
     load sound tfile$,globalsmallsound,0,1
     if sound exist(globalsmallsound)=0 then globalsmallsound=0
    else
     clone sound soundid,globalsmallsound
    endif
   else
    if mode=1 and tspecialogg=0
     load 3dsound tfiletoload$,soundid,1
     if sound exist(soundid)=0 then load sound tfiletoload$,soundid,0,1
    else
     load sound tfiletoload$,soundid,0,1
    endif
   endif
   if sound exist(soundid)=0
    rem sound could not loaded
    soundbank$(soundbankmax)=""
    dec soundbankmax
    soundid=0
   else
    rem success
    soundbank$(soundbankmax)=tfile$
    addfiletocollection(tfile$)
   endif
  endif
 endif
endif

endfunction soundid

function loadinternalsound(tfile$)
 soundid=loadinternalsoundcore(tfile$,0)
endfunction soundid

function changeplrforsound(tplrid,tsnd)
 if tplrid>1 and gmultiplayergame=0
  if playersound(tplrid,tsnd)=0
   rem look for available sound that matches sound set index
   tsoundsetindex=playersoundsetindex(tplrid)
   for tscanplrid=1 to playermax
    tscansoundid=playersound(tscanplrid,tsnd)
    if tscansoundid>0
     if playersoundsetindex(tscanplrid)=tsoundsetindex
      if sound exist(tscansoundid)=1
       if sound playing(tscansoundid)=0
        tplrid=tscanplrid : scanplrid=playermax
       endif
      endif
     endif
    endif
   next tscanplrid
  endif
 endif
endfunction tplrid

function managebroadcastsound()
 if bcsoundstrength#>0.0
  dec bcsoundstrength#,1.0
  if bcsoundstrength#<0 then bcsoundstrength#=0.0
 endif
endfunction

function broadcast3dsound(x#,y#,z#,strength#,obj)
  Rem Send sound and data to AI array
  arraycount=array count(aisound())
  if obj<>0
   for i=1 to arraycount
    if aisound(i).alive=0
     if obj>0
      array2=array count(ischaracter())
      for i=1 to array2
       tte=ischaracter(i)
       if obj=entityelement(tte).obj then obje=tte : exit
      next i
      if ai entity exist(obj) then aisound(i).team=entityelement(obje).darkai.team
      if ai entity exist(obj)=0 then aisound(i).team=0
      aisound(i).x=x#
      aisound(i).y=y#
      aisound(i).z=z#
      aisound(i).time=timer()
      aisound(i).alive=1
     else
      if obj=-1
       aisound(i).team=1
       aisound(i).x=x#
       aisound(i).y=y#
       aisound(i).z=z#
       aisound(i).time=timer()
       aisound(i).alive=1
      endif
     endif
     exit
    endif
   next i
  endif
 if strength#>bcsoundstrength#
  bcsoundstrength#=strength#
  bcsoundx#=x# : bcsoundy#=y# : bcsoundz#=z#
 endif
endfunction

function playinternalBC3dsound(id,x#,y#,z#,strength#)
 if id>0
  if sound exist(id)=1
   broadcast3dsound(x#,y#,z#,strength#,0)
   position sound id,x#/10.0,y#/3.0,z#/10.0
   play sound id
   entityelement(e).soundplaying=id
  endif
 endif
endfunction

function playinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/3.0,z#/10.0
   play sound id
   entityelement(e).soundplaying=id
  endif
 endif
endfunction

function loopinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/3.0,z#/10.0
   if sound playing(id)=0 then loop sound id:entityelement(e).soundplaying=id
  endif
 endif
endfunction

function posinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/3.0,z#/10.0
  endif
 endif
endfunction

function playinternal3dsoundfactor(id,x#,y#,z#,factor#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/3.0,z#/10.0
   factor#=(factor#*2.0)+80.0
   if factor#<0 then factor#=0
   if factor#>100 then factor#=100
   set sound volume id,factor#
   play sound id
  endif
 endif
endfunction

`
` FUNCTION TO BUILD A SUB-DIRECTORY = filelist$()
`
function buildfilelist(folder$,rel$)
 if path exist(folder$)=1
  set dir folder$
  find first : fin=0
  while get file type()>-1
   file$=get file name$()
   if file$="." or file$=".."
    rem ignore . and ..
   else
    if get file type()=1
     rem folder
     buildfilelist(file$,rel$+file$+"\")
     find first
     if fin>0
      for t=1 to fin : find next : next t
     endif
    else
     rem file
     array insert at bottom filelist$()
     filelist$()=rel$+file$
    endif
   endif
   find next
   fin=fin+1
  endwhile
  set dir ".."
 endif
endfunction

`
` FUNCTIONS TO CUT-UP STRINGS
`
function getfirstdir(file$)
 firstdir$=""
 for c=1 to len(file$)
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   firstdir$=left$(file$,c) : exit
  endif
 next c
endfunction firstdir$

function getseconddir(file$)
 firstdir$="" : count=2
 for c=1 to len(file$)
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   dec count
   if count=0
    firstdir$=left$(file$,c) : exit
   endif
  endif
 next c
endfunction firstdir$

function getpath(file$)
 path$=""
 for c=len(file$) to 1 step -1
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   path$=left$(file$,c) : exit
  endif
 next c
endfunction path$

function getfile(file$)
 for c=len(file$) to 1 step -1
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   file$=right$(file$,len(file$)-c) : exit
  endif
 next c
endfunction file$
`
` SUPPORT FUNCTIONS (DUPLICATED IN GUNSYSTEM)
`
function removeedgespaces(text$)
 returntext$=""
 if len(text$)>0
  st=0
  for c=1 to len(text$)
   if asc(mid$(text$,c))>32 then st=c : exit
  next c
  if st=0
   rem all sub-spaces
  else
   for c=len(text$) to 1 step -1
    if asc(mid$(text$,c))>32 then en=c : exit
   next c
   for c=st to en
    returntext$=returntext$+mid$(text$,c)
   next c
  endif
 endif
endfunction returntext$

function minstring(text$,minsize)
 sizegap=minsize-len(text$)
 text$=text$+space$(sizegap)
endfunction text$

`
` FILECOLLECTOR FUNCTIONS
`

function resetfilecollection()
 empty array filecollection$()
endfunction

function addfiletocollection(filename$)
 if segobjusedformapeditor=0 and segobjusedforsegeditor=0
  if len(filename$)>0
   if mid$(filename$,2)=":"
    rem absolute paths not allowed for filenames!
    debugstring(filename$,strarr$(41))
   else
    rem verify file not duplicated
    tokay=1
    for chk=1 to array count(filecollection$())
     if lower$(filecollection$(chk))=lower$(filename$)
      tokay=0
     endif
     if lower$(left$(filecollection$(chk),len(filecollection$(chk))-4))=lower$(left$(filename$,len(filename$)-4))
      rem if have a DDS, and a TGA of the same name, replace it
      if lower$(right$(filecollection$(chk),4))=".tga"
       if lower$(right$(filename$,4))=".dds"
        filecollection$(chk)=filename$
        tokay=0 : exit
       endif
      endif
      rem Scene Commander - memory reduction - if .wav and passing through here, convert - Not all wav's can be converted due to restrctions
      if lower$(right$(filename$,4))=".ogg" or lower$(right$(filename$,4))=".wav"
       sp$=lower$(left$(filecollection$(chk),len(filecollection$(chk))-4))+".ogg"
       if lower$(right$(filecollection$(chk),4))=".wav" and guseoggoff=0
        rem 041212 - Unfortunately OGG sounds cannot be 3D or looped, which means they are only good
        rem for things like sounds you play one-off and are not required to loop, so we create a black list
        rem of folders which contain loopable or 3D sounds below:
        tgamecritical=0
        if left$(filename$,15)="audiobank\music" then tgamecritical=1
        if left$(filename$,15)="audiobank\water" then tgamecritical=1
        if left$(filename$,19)="audiobank\materials" then tgamecritical=1
        if left$(filename$,13)="gamecore\guns" then tgamecritical=1
        if tgamecritical=0
         if file exist(sp$)=0
          a$=filecollection$(chk)
          encode to ogg vorbis a$,sp$
          rem we do not add, we simply replace the WAV that was already here with the OGG
          `filename$=sp$ : tokay=1
          filecollection$(chk)=sp$
          tokay=0 : exit
         endif
        endif
       endif
      endif
      if guseoggoff=1 and lower$(right$(filename$,4))=".wav"
       sp$=lower$(left$(filecollection$(chk),len(filecollection$(chk))-4))+".wav"
       rem we do not add, we simply replace the possible OGG that was already here with the WAV (only if the WAV exists)
       `filename$=sp$ : tokay=1
       if file exist(sp$)=1
        filecollection$(chk)=sp$
        tokay=0 : exit
       endif
      endif
     endif
    next chk
    rem add file to collection
    `041212 - handled above and OGG is produced and assigned
    `twav$=lower$(left$(filename$,len(filename$)-4))+".wav"
    `togg$=lower$(left$(filename$,len(filename$)-4))+".ogg"
    `if file exist(togg$) and filename$=twav$ and left$(twav$,8)<>"gamecore" then filename$=lower$(left$(filename$,len(filename$)-4))+".ogg"
    if tokay=1
     rem file must be completely unique, so add it
     array insert at bottom filecollection$()
     filecollection$()=filename$
     rem FPGC - 220210 - if .WAV, of .OGG assume a LIPSYNC could be with it (even if ultimately not copied)
     if lower$(right$(filename$,4))=".wav" or lower$(right$(filename$,4))=".ogg"
      lipsyncfilename$=left$(filename$,len(filename$)-4)+".lipsync"
      array insert at bottom filecollection$()
      filecollection$()=lipsyncfilename$
     endif
    endif
   endif
  endif
 endif
endfunction

`addallfilestocollection(left$(src$,len(src$)-5))

function addallfilestocollection(folder$)
 storedir$=get dir$()
 set dir folder$
 perform checklist for files
 for c=1 to checklist quantity()
  file$=checklist string$(c)
  if file$<>"." and file$<>".."
   if right$(lower$(file$),4)<>".tga"
    rem all except raw TGA file
    addfiletocollection(folder$+"\"+file$)
   endif
  endif
 next c
 set dir storedir$
endfunction

`
` ASSESS FILE FOR HOW OLD IT IS
`
function getdatevaluefromdatestring(dayofyear$)
   rem get year
   year$=right$(dayofyear$,4)
   dayofyear$=left$(dayofyear$,len(dayofyear$)-5)
   rem eat day
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem find month
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     month$=lower$(left$(dayofyear$,c-1))
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem find date
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     date$=lower$(left$(dayofyear$,c-1))
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem get time
   time$=""
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)<>":"
     time$=time$+mid$(dayofyear$,c)
    endif
   next c
   time$=left$(time$,len(time$)-2)
   if month$="jan" then month=1
   if month$="feb" then month=2
   if month$="mar" then month=3
   if month$="apr" then month=4
   if month$="may" then month=5
   if month$="jun" then month=6
   if month$="jul" then month=7
   if month$="aug" then month=8
   if month$="sep" then month=9
   if month$="oct" then month=10
   if month$="nov" then month=11
   if month$="dec" then month=12
   filedatevalue=((val(year$)-2004)*12*32*2500)+(month*32*2500)+(val(date$)*2500)+val(time$)
endfunction filedatevalue

function isbinaryfileolderthantxtfile(binaryfilefull$,textfilefull$)
 result=0
 if file exist(binaryfilefull$)=1
  stdir$=get dir$()
  binaryfile$=getfile(binaryfilefull$)
  textfile$=getfile(textfilefull$)
  set dir getpath(binaryfilefull$)
  filedatevalueB=0
  filedatevalueT=0
  find first
  while get file type()<>-1
   if get file type()=0
    if lower$(get file name$())=lower$(binaryfile$)
     this$=get file date$()
     dayofyearB$=this$
     filedatevalueB=getdatevaluefromdatestring(dayofyearB$)
    else
     if lower$(get file name$())=lower$(textfile$)
      this$=get file date$()
      dayofyearT$=this$
      filedatevalueT=getdatevaluefromdatestring(dayofyearT$)
     endif
    endif
    if filedatevalueB<>0 and filedatevalueT<>0 then exit
   endif
   find next
  endwhile
  if filedatevalueB<>0 and filedatevalueT<>0
   if filedatevalueB<filedatevalueT
    result=1
   endif
  endif
  set dir stdir$
 endif
endfunction result

function isbinaryfileolderthantxtfileforseg(binaryfilefull$,textfilefull$)
 rem segment BIN files have version number signalled with a -1 in the first field
 result=0
 if file exist(binaryfilefull$)=1
  stdir$=get dir$()
  binaryfile$=getfile(binaryfilefull$)
  textfile$=getfile(textfilefull$)
  set dir getpath(binaryfilefull$)
  filedatevalueB=0
  filedatevalueT=0
  find first
  while get file type()<>-1
   if get file type()=0
    if lower$(get file name$())=lower$(binaryfile$)
     this$=get file date$()
     dayofyearB$=this$
     filedatevalueB=getdatevaluefromdatestring(dayofyearB$)
    else
     if lower$(get file name$())=lower$(textfile$)
      this$=get file date$()
      dayofyearT$=this$
      filedatevalueT=getdatevaluefromdatestring(dayofyearT$)
     endif
    endif
    if filedatevalueB<>0 and filedatevalueT<>0 then exit
   endif
   find next
  endwhile
  if filedatevalueB<>0 and filedatevalueT<>0
   if filedatevalueB<filedatevalueT
    result=1
   endif
  endif
  set dir stdir$
  if result=0
   rem V110 - 160508 - added extra code to hold new version number in segment BIN file
   open to read 3,binaryfilefull$
    read file 3,tval
    if tval=-1
     read file 3,tversion
     rem if BIN created with older version, trigger delete BIN file
     if tversion<gversion then result=1
    else
     rem if an old BIN, also delete it
     result=1
    endif
   close file 3
  endif
 endif
endfunction result

function isbinaryfileolderthantxtfileforent(binaryfilefull$,textfilefull$)
 rem entity BIN files have version number signalled with a "version" string lanel, then the integer version number
 result=0
 if file exist(binaryfilefull$)=1
  stdir$=get dir$()
  binaryfile$=getfile(binaryfilefull$)
  textfile$=getfile(textfilefull$)
  set dir getpath(binaryfilefull$)
  filedatevalueB=0
  filedatevalueT=0
  find first
  while get file type()<>-1
   if get file type()=0
    if lower$(get file name$())=lower$(binaryfile$)
     this$=get file date$()
     dayofyearB$=this$
     filedatevalueB=getdatevaluefromdatestring(dayofyearB$)
    else
     if lower$(get file name$())=lower$(textfile$)
      this$=get file date$()
      dayofyearT$=this$
      filedatevalueT=getdatevaluefromdatestring(dayofyearT$)
     endif
    endif
    if filedatevalueB<>0 and filedatevalueT<>0 then exit
   endif
   find next
  endwhile
  if filedatevalueB<>0 and filedatevalueT<>0
   if filedatevalueB<filedatevalueT
    result=1
   endif
  endif
  set dir stdir$
  if result=0
   open to read 3,binaryfilefull$
    read string 3,tval$
    if lower$(tval$)="version"
     read file 3,tversion
     rem if BIN created with older version, trigger delete BIN file
     if tversion<gversion then result=1
    else
     rem if an old BIN, also delete it
     result=1
    endif
   close file 3
  endif
 endif
endfunction result


rem
rem GAME PLAYER
rem

`
` Player Core Subroutines (for human and NPC players)
`

_player_resetmaterialsused:
 `
 rem V109 BETA5 - 250408 - clear usage flags, and set them when entity/segment uses that material
 for mi=0 to gmaterialmax
  material(mi).usedinlevel=0
 next mi
 for di=0 to 8
  debrisshapeindexused(di)=0
 next di
 `
return

_player_savematerialsused:
 `
 rem V118 - 060211 - with the introduction of water, some materials are ALWAYS used
 if gmaterialmax<18
  rem V118 - BETA11 - fixes crash if OLD materialindex file used!
  gmaterialmax=18
  dim material(gmaterialmax) as materialsettingstype
 endif
 material(17).usedinlevel=1
 material(18).usedinlevel=1
 `
 rem V109 BETA5 - 250408 - uses that material
 tmaterialfile$="audiobank\materials\materialsused.bin"
 if file exist(tmaterialfile$)=1 then delete file tmaterialfile$
 open to write 1,tmaterialfile$
  tversionnum=101
  write file 1,tversionnum
  if tversionnum>=100
   for mi=0 to gmaterialmax
    write file 1,material(mi).usedinlevel
   next mi
   for di=0 to 8
    write file 1,debrisshapeindexused(di)
   next di
  endif
  if tversionnum>=101
   for fi=0 to flakmax
    write file 1,flak(fi).usedinlevel
   next fi
  endif
 close file 1
 addfiletocollection(tmaterialfile$)
 `
return

_player_loadmaterialsused:
 `
 rem V109 BETA5 - 250408 - uses that material
 tmaterialfile$="audiobank\materials\materialsused.bin"
 if file exist(tmaterialfile$)=1
  open to read 1,tmaterialfile$
   read file 1,tversionnum
   if tversionnum>=100
    for mi=0 to gmaterialmax
     read file 1,a : material(mi).usedinlevel=a
    next mi
    for di=0 to 8
     read file 1,a : debrisshapeindexused(di)=a
    next di
   endif
   if tversionnum>=101
    for fi=0 to flakmax
     read file 1,a : flak(fi).usedinlevel=a
    next fi
   endif
  close file 1
 endif
 `
return

_player_init:

rem FPGC - 020909 - why enemies have 3D sounds hardly used
if gmultiplayergame=1
 tusefullsounds=1
else
 tusefullsounds=0
endif

rem For all players
for plrid=1 to playermax
 `
 rem Player or NPCs
 if plrid=1 then t3d=0 else t3d=1
 `
 rem Sounds 0-9 reserved
 `
 rem can soundsets be stored in a list, and referenced by index
 tsoundset$=playersoundset$(plrid) : gosub _player_submitsoundsettolist
 tsoundsetindex=0 : gosub _player_getsoundsetlistindex : rem returns tsoundsetindex
 playersoundsetindex(plrid)=tsoundsetindex
 soundsetlist(tsoundsetindex)=soundsetlist(tsoundsetindex)+1
 `
 rem Load player grunt sounds
 tsoundset$=playersoundset$(plrid)
 if tsoundset$<>"" and right$(tsoundset$,1)<>"\" then tsoundset$=tsoundset$+"\"
 if tusefullsounds=1 or plrid=1
  snd$="audiobank\voices\"+tsoundset$+"leap.wav"
  playersound(plrid,10)=loadinternalsoundcore(snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"land.wav"
  playersound(plrid,11)=loadinternalsoundcore(snd$,t3d)
 endif
 if tusefullsounds=1 or soundsetlist(tsoundsetindex)<3
  snd$="audiobank\voices\"+tsoundset$+"hurt1.wav"
  playersound(plrid,12)=loadinternalsoundcore(snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"hurt2.wav"
  playersound(plrid,13)=loadinternalsoundcore(snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"hurt3.wav"
  playersound(plrid,14)=loadinternalsoundcore(snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"finalmoan.wav"
  playersound(plrid,15)=loadinternalsoundcore(snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"spawn.wav"
  playersound(plrid,16)=loadinternalsoundcore(snd$,t3d)
 endif
 `
 rem Additional WATER sound for main player
 if plrid=1
  tsndid=17 : snd$="audiobank\water\WaterIn.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
  tsndid=18 : snd$="audiobank\water\WaterOut.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
  tsndid=19 : snd$="audiobank\water\Drown.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
  tsndid=20 : snd$="audiobank\water\GaspForAir.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
 endif
 `
 rem Load tred sounds from material list plrid of 2,3,4 used by entities)
 if tusefullsounds=1 or plrid<=4
  for mi=0 to gmaterialmax
   for titer=0 to 3
    playersound(plrid,21+(mi*4)+titer)=0
    rem V109 BETA8 - 060508 - material used or all if test game
    tloadthismaterialsound=0
    if gtestgamemodefromeditor=1 then tloadthismaterialsound=1
    if material(mi).usedinlevel=1 then tloadthismaterialsound=1
    if material(mi).name$<>"" and tloadthismaterialsound=1
     if titer=0 then snd$=material(mi).tred0$
     if titer=1 then snd$=material(mi).tred1$
     if titer=2 then snd$=material(mi).tred2$
     if titer=3 then snd$=material(mi).tred3$
     playersound(plrid,21+(mi*4)+titer)=loadinternalsoundcore(snd$,t3d)
    endif
   next titer
  next mi
 endif
 `
 rem Setup player default start values (before startpos fills with real ones)
 if plrid=1
  checkpointentity=-1
  gosub _entity_findplayerstartposition : rem gets 'playerstartlives'
  player(plrid).lives=playerstartlives
 else
  player(plrid).lives=1
 endif
 player(plrid).recovershield=0
 player(plrid).health=100
 `
 rem test game gives player 99 lives (but regular health to test logic)
 if gtestgamemodefromeditor=1 and playerstartlives>0 then player(plrid).lives=99
 `
next plrid

Rem Load underwater sound for players built-in atmos
snd$="audiobank\atmos\underwater.wav"
waterunderwatersoundid=loadinternalsound(rootdir$+snd$)

rem place listener far away at start
position listener -999999,-999999,-999999
rotate listener 90,0,0
scale listener 0.02

rem reset extra vars
camerastoodonphyobj=0

return

_player_submitsoundsettolist:
 rem in: tsoundset$
 tsoundsetindex=0
 if soundsetlistmax>0
  for t=1 to soundsetlistmax
   if lower$(soundsetlist$(t))=lower$(tsoundset$)
    tsoundsetindex=t : t=soundsetlistmax
   endif
  next t
 endif
 if tsoundsetindex=0
  rem new soundset entry
  inc soundsetlistmax
  dim soundsetlist$(soundsetlistmax)
  dim soundsetlist(soundsetlistmax)
  soundsetlist$(soundsetlistmax)=tsoundset$
  soundsetlist(tsoundsetindex)=0
 endif
return

_player_getsoundsetlistindex:
 tsoundsetindex=0
 if soundsetlistmax>0
  for t=1 to soundsetlistmax
   if lower$(soundsetlist$(t))=lower$(tsoundset$)
    tsoundsetindex=t : t=soundsetlistmax
   endif
  next t
 endif
return

_player_free:

rem As sounds are unique, free them before re-creating players
for plrid=1 to playermax
 for tt=0 to 520
  tsnd=playersound(plrid,tt)
  if tsnd>0
   if sound exist(tsnd)=1 then delete sound tsnd
  endif
 next tt
next plrid

return

_player_startgun:

rem Get player start data
gosub _entity_findplayerstartposition
if playerstarthasweapon>0
 rem only if not got gun in slot already
 for tww=1 to 10
  if weaponslot(tww).pref>0
   if weaponslot(tww).pref=playerstarthasweapon then exit
  endif
 next tww
 if tww<10
  rem FPGC - 160710 - in standalone game, starting gun did not get added to GOT slot
  weaponslot(tww).got=playerstarthasweapon
  weaponhud(tww)=gun(playerstarthasweapon).hudimage
 else
  for tww=1 to 10
   if weaponslot(tww).pref=0
    weaponslot(tww).pref=playerstarthasweapon
    weaponslot(tww).got=playerstarthasweapon
    weaponhud(tww)=gun(playerstarthasweapon).hudimage
    tww=11 : exit
   endif
  next tww
 endif
 gun(playerstarthasweapon).activeingame=1
endif

return

_player_setstartposonly:
 `
 rem Find player start location
 gosub _entity_findplayerstartposition
 if playerstartx#=0
  rem look for first filled map piece
  for lay=0 to 19
   for x=0 to maxx-1
    for y=0 to maxy-1
     if map(lay,x,y)<>0
      playerstartx#=(x*100)+50
      playerstarty#=(lay*100)
      playerstartz#=(y*-100)-50
      playerstartrx#=0
      playerstartry#=135
      x=maxx : y=maxy : lay=20
      exit
     endif
    next y
   next x
  next lay
 endif
 `
return

_player_startpos:
 `
 rem clear weaponammoindex (startpostion routine can fill this var)
 weaponammoindex=0
 `
 rem Find player start location
 gosub _player_setstartposonly
 `
 rem Setup player default start values
 player(1).health=playerstartstrength
 if level>1
  rem FPSCV10X - carried from previous level (no longer writes over MAX)
  player(1).health=saveplayerstate.health
 endif
 `
 rem restart basic player vars
 gosub _player_restart
 `
return

_player_restart:
 `
 rem uses playerstartxyz#
 rem Ensure player start height avoids stairs and other ground obstacles
 pttry=0
 while pttry<500
  if static volume(playerstartx#,playerstarty#+1.0,playerstartz#,playerstartx#,playerstarty#,playerstartz#,1.0)=0 then exit
  playerstarty#=playerstarty#+1.0
  inc pttry
 endwhile
 `
 rem sort out camera default rotation at start
 yrotate camera playerstartry#
 xrotate camera playerstartrx#
 zrotate camera 0
 `
 rem start with a jump
 grav#=-1.0 : jumpaction=0  : jumpspeed#=0.0 : jumpangle#=camera angle y(0) : gravlasty#=mey#`sizechange=1:firstturnjump=0
 camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
 camforcex#=0 : camforcey#=0 : camforcez#=0
 `
 rem crouch state
 crouchmode=0
 tcamerasize#=1.0
 ellipsevolumesize#=1.0
 `
 rem recover shield
 player(1).recovershield=0`
 `
 rem Me-vars
 meridingtransporter=0
 meridinglift=0
 mefrozentype=0
 mefrozen=0
 `
rem Player Weapon default
 if gmultiplayergame=0  rem fixes ww2 default weapon showing in MP
 if gunzoommode=10 then gunzoommode=11
 autoloadgun=playerstarthasweapon
 endif

rem if weapon, add bullets if any moved to fix weapon not starting
 if playerstarthasweapon>0 and level=1
  for tww=1 to 10
   if weaponslot(tww).pref=playerstarthasweapon
    tqty=firemode(playerstarthasweapon,0).settings.reloadqty
    if playerstarthasweaponqty>=1
     weaponammo(tww)=tqty
     weaponammo(tww+10)=firemode(playerstarthasweapon,1).settings.reloadqty
     if playerstarthasweaponqty>1
      `weaponclipammo(tww)=(playerstarthasweaponqty-1)*tqty
      `weaponclipammo(tww+10)=gun(playerstarthasweapon).settings.altreloadqty*(playerstarthasweaponqty-1)
      tpool=firemode(playerstarthasweapon,0).settings.poolindex : altpool=firemode(playerstarthasweapon,1).settings.poolindex
      if tpool=0 then weaponclipammo(tww)=(playerstarthasweaponqty-1)*tqty else ammopool(tpool).ammo=ammopool(tpool).ammo+(playerstarthasweaponqty-1)*tqty
      if altpool=0 then weaponclipammo(tww+10)=firemode(playerstarthasweapon,1).settings.reloadqty*(playerstarthasweaponqty-1) else ammopool(altpool).ammo=ammopool(altpool).ammo+firemode(playerstarthasweapon,1).settings.reloadqty*(playerstarthasweaponqty-1)
     endif
    endif
    tww=11 : exit
   endif
  next tww
 endif

 playerstarthasweapon=1

 rem Default position in center (borble uses this xyz for its position, then camera adjustment later)
 tvalueheight=11 : rem height from base of player start value to center of borble
 lastcamx#=playerstartx# : lastcamy#=playerstarty#+tvalueheight : lastcamz#=playerstartz#
 phystood#=40.0 : phyeyeheight#=phystood#
 camerapositionx=lastcamx#
 camerapositiony=lastcamy#+phyeyeheight#
 camerapositionz=lastcamz#
 mex#=camerapositionx : mey#=camerapositiony : mez#=camerapositionz
 cx#=camerapositionx : cy#=camerapositiony : cz#=camerapositionz
 `
 rem Activate player borble (uses plrpos)
 gosub _ode_playerborble
 `
 rem Can be called within before_and_after move, so ensure vars are set
 ctox#=ctx# : ctoy#=cty# : ctoz#=ctz#
 if object exist(physicsplayerborble)=1
  camerapositionx=object position x(physicsplayerborble)
  camerapositiony=object position y(physicsplayerborble)+phyeyeheight#
  camerapositionz=object position z(physicsplayerborble)

  position camera camerapositionx+newcamoffsetx,camerapositiony+newcamoffsety,camerapositionz+newcamoffsetz
 endif
 realcx#=camerapositionx : realcy#=camerapositiony : realcz#=camerapositionz
 `
return

_player_savestate:

rem Record players leaving level state
saveplayerstate.lives=player(1).lives
saveplayerstate.health=player(1).health
saveplayerstate.weaponindexholding=weaponammoindex

return

_player_setup:
 `
 rem Setup camera
 position camera 0,52,0
 point camera 0,52,0
 set light range 0,10000
 `
 rem start camera for player
 plrzoominchange=0 : plrzoomin#=0.0
 realfov#=75.0 : set camera fov realfov#
 `
 rem Find player start location
 gosub _player_startpos
 `
 `
 rem Reset some plater related states when restart
 gosub _player_resettrail
 trailx#=mex# : traily#=mey#-52 : trailz#=mez#
 inc playertrailmax
 playertrial(playertrailmax).time=timer()
 playertrial(playertrailmax).x=trailx#
 playertrial(playertrailmax).y=traily#
 playertrial(playertrailmax).z=trailz#
 `
 rem restore player camera states
 phyeyeheight#=phystood#
 tcamerasize#=1.0
 grav#=0
 cameraspeed=0
 cameraholding=0
 camerapickupkeyrelease=0
 camerareach#=0
 camerapicked=0
 cameradampen#=1.0
 `
return

_player_playfootfall:

sndid=0
if colmaterialtype>=0
  if colmaterialtype>=100 then colmaterialtype=colmaterialtype-(int(colmaterialtype/100)*100)
  if colmaterialtype>=0 and colmaterialtype<100
  rem Change the material sound if near or under water
  if plrid>1
   footaty#=entityelement(e).y
   playinternal3dsoundfactor(sndid,entityelement(e).x,entityelement(e).y,entityelement(e).z,1.0)
  else
   footaty#=camera position y()-(phyeyeheight#+15) : rem was 18
  endif
  if footaty#<waterheight# and wateron=1
   if footaty#<waterheight#-50
    rem underwater
    if plrid=1
     rem extra code to handle swimming sound along surface of water
     tnearsurfaceofwater=abs(camera position y()-waterheight#)
     if playerunderwater=0 and tnearsurfaceofwater<15
      colmaterialtype=17
     else
      colmaterialtype=18
     endif
    else
     colmaterialtype=18
    endif
   else
    rem in shallow water
    if waterdecalripple<>0
     rem and only if water does ripple
     colmaterialtype=17
    endif
   endif
  endif
  tt=21+(colmaterialtype*4)
  tplrid=plrid
  for titer=0 to 3
   ttrr=rnd(3)
   tplrid=changeplrforsound(tplrid,tt+ttrr)
   sndid=playersound(tplrid,tt+ttrr)
   if sndid>0
    if sound playing(sndid)=1 then sndid=0
   endif
   if sndid<>0 then playersoundtimeused(tplrid,tt+ttrr)=perftimer() : exit
  next titer
  if sndid=0
   titerdw as DWORD
   tdwsmalltest as DWORD
   bestsndid=0
   for titer=0 to 3
    titerdw=playersoundtimeused(plrid,tt+titer)
    if titer=0 then tdwsmalltest=titerdw
    sndid=playersound(tplrid,tt+titer)
    if sndid>0
     if titerdw<=tdwsmalltest
      tdwsmalltest=titerdw : bestsndid=sndid
     endif
    endif
   next titer
   sndid=bestsndid
  endif
 endif
 if sndid>0
  if (movement<>0 and jumpaction=0) or leapedlanded=1 or plrid>1
   `
   if manuallycontrolledfootfallframe>0 and plrid>1
    rem manually controlled footfall (entities only)
    if manuallycontrolledfootfallframe<>playermovementstep(plrid) or leapedlanded=1
     playermovementstep(plrid)=manuallycontrolledfootfallframe : leapedlanded=0
     playinternal3dsoundfactor(sndid,entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
    endif
   else
    rem if in water, footfall sound must be immediate from static pose
    if plrid=1
     if colmaterialtype=17 or colmaterialtype=18 : rem V109 - 110209 - replaces colmaterialtype=11
      if playermovingfromastandingposture=0
       playermovementstep(plrid)=9999.9
       playermovingfromastandingposture=1
      endif
     endif
    endif
    rem default timer based footfall
    playermovementstep(plrid)=playermovementstep(plrid)+timeelapsed#
    `if movement=2 then tfootspeed#=2.0 else tfootspeed#=1.0
    rem AirMod - Line Modified for Simple Zoom
    if movement=2 or (gunzoommode <> 0) then tfootspeed#=1.0 +(1.0*firemode(gunid,firemode).settings.zoomwalkspeed) else tfootspeed#=1.0
    if plrid=1
    if basespeed#<=40.0 then tsteppingsound#=6.0*tfootspeed#
    if basespeed#>40.0 then tsteppingsound#=5.0*tfootspeed#
   else
    if basespeed#<=40.0 then tsteppingsound#=11.0*tfootspeed#
    if basespeed#>40.0 then tsteppingsound#=7.0*tfootspeed#
   endif
   if plrid=1 then tsteppingsound#=tsteppingsound#/playerspeedratio#
   rem water footfalls take longer and are spaced out (wading)
   if colmaterialtype=9 then tsteppingsound#=tsteppingsound#*1.25
    if playermovementstep(plrid)>tsteppingsound# or leapedlanded=1
     leapedlanded=0 : playermovementstep(plrid)=0.0
     if plrid>1
      rem FPGC - 231109 - do not play footfall sounds if footfall further than 500 units
      ffdx#=entityelement(e).x-camera position x()
      ffdz#=entityelement(e).z-camera position z()
      ffdd#=sqrt(abs(ffdx#*ffdx#)+abs(ffdz#*ffdz#))
      if ffdd#<500
       playinternal3dsoundfactor(sndid,entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
      endif
     else
      rem FPGC - 280809 - tone player footfalls RIGHT DOWN as they are halllmark annoyances from FPSC!!)
      broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0,-1)
      set sound volume sndid,88-rnd(5) : rem VERY SUBTLE AS IT SHOULD HAVE BEEN ALL ALONG (AND VOLUME VARIETY)
     if plrfootfall=1 then play sound sndid
     endif
     if colmaterialtype=9
      rem X10 water noise related to intensity
      if basespeed#>50.0 or leapedlanded=1
       tsndvolume#=95+rnd(5)
      else
       tsndvolume#=85+rnd(5)
      endif
      tsndvolume#=(tsndvolume#/100.0)*soundvolumes(0)
      tvol=tsndvolume#-10 : if tvol<0 then tvol=0
      if tvol>100 then tvol=100
      set sound volume sndid,tvol
     endif

    endif
   endif
   `
  endif
 endif
endif

return

_player_resetobjectives:

rem Set mission after 100 cycle void, for now reset objectives
for mi=1 to 99 : playerobjective(mi)=0 : next mi
newlevelobjectivevoid=10
triggergameexitfade=0
missiongoaltotal=0

return

_player_mission:

rem For player one only
plrid=1

rem Only if game in ful swing
if newlevelobjectivevoid>0
 `
 rem Ensure objective cannot be met for 100 cycles at start of level
 dec newlevelobjectivevoid
 if newlevelobjectivevoid<=0
  rem Set mission through entity objective flags
  for mi=1 to 99 : playerobjective(mi)=0 : next mi
  gosub _entity_calculateobjectivestotal
  newlevelobjectivevoid=0
  triggergameexitfade=0
  rem FPSCV104RC4 - if just loaded a game, refresh objectives from savedata
  if gsaveloadobjectivesloaded=1
   for mi=0 to 99
    playerobjective(mi)=saveloadgamepositionplayerobjective(mi)
   next mi
   gsaveloadobjectivesloaded=0
  endif
 endif
 `
else
 `
 rem Decide when player wins/loses
 if player(plrid).lives=0 and playerstartlives>0 and ((player(plrid).health=0 and playerstartstrength>0) or playerstartstrength=0)
  `
  rem Never lose if in arena mode (other players you see)
  if gmultiplayergame=1
   rem simply skip
  else
   rem LOST
   if triggergameexitfade=0
    triggergameexitfade=1 : levelwon=0
   endif
  endif
  `
 else
  `
  rem only if objectives in this level
  if missiongoaltotal>0
   `
   rem default is mission COMPLETE
   objectivesmet=1
   `
   rem All active objectives must be met, else mission not complete
   for mi=1 to missiongoaltotal
    if playerobjective(mi)=0 then objectivesmet=0
   next mi
   `
   rem Objective never met if arena game not objective based
   if gmultiplayergame=1
    if ggameobjectivetype<>1 then objectivesmet=0
   endif
   `
   rem If all objectives met, player wins level
   if objectivesmet=1
    `
    rem WON
    if triggergameexitfade=0
     triggergameexitfade=1 : levelwon=1
    endif
    `
   endif
   `
  endif
  `
 endif
 `
endif

rem GUI-X9 (knxrb) Fade Out Screen
if guiUsed = 0
    rem Fading system prior to WIN/LOSE logic escape
    if triggergameexitfade>0
     `
     rem Fade out screen
     inc triggergameexitfade,4
     if triggergameexitfade>255
      triggergameexitfade=255
     endif
     `
     rem apply fade to hud
     if internalfaderhud>0
      hudid=internalfaderhud : hud(hudid).hide=0
      set sprite alpha hudid,triggergameexitfade
     endif
     `
     rem When fade complete, can continue win/lose triggers
     if triggergameexitfade=255
      rem can switch from WIN to LOSE if no health by time fade done
      if player(1).health<=0 and playerstartstrength>0 then levelwon=0
      rem complete game session
      if gmultiplayergame=1
       rem allow multi code to determine conclusion actions (multiplayer)
       gosub _multi_missioncomplete
      else
       rem exit level (single player)
       continueokay=1
      endif
      rem reset fader
      triggergameexitfade=0
     endif
     `
    endif
else
    if triggergameexitfade > 0
        if guifaderhud > -1
            inc guifaderalpha,guifaderspeed
            if guifaderalpha > 255 then guifaderalpha = 255
            gosub _gui_run
            if guifaderalpha=255
                if player(1).health<=0 and playerstartstrength>0 then levelwon=0
                if gmultiplayergame=1
                    gosub _multi_missioncomplete
                else
                    continueokay=1
                endif
                guifaderalpha=0
                triggergameexitfade=0
            endif
        endif
    endif
endif

return

_player_manager:

rem For all players
for plrid=1 to playermax
 `
 rem Player commands received
 dropitem=player(plrid).command.drop
 if dropitem>0
  playerinventory(plrid,dropitem).drop=1
  player(plrid).command.drop=0
 endif
 `
next plrid

return

_player_obtainaweapon:
 `
 rem uses weaponindex,tqty
 if weaponindex>0
  rem adds the weapon

rem Scene Commander force to slot
if forcedslot > 0
 weaponinvposition=forcedslot : tgunid=weaponindex
else
  weaponinvposition=pint : tgunid=weaponindex
  endif
  if gun(tgunid).settings.weaponisammo=0 and tqty=0 then tqty=1
  tentqty=tqty
  tqty=tqty*firemode(tgunid,0).settings.reloadqty
  gosub _player_addweapon
 endif
 `
return

_player_itemmanager:

rem For all players
for plrid=1 to playermax
 `
 rem Check inventory for any new items added
 for pint=1 to player(plrid).inventorymax
  if playerinventory(plrid,pint).new=1
   `
   rem Item checked in
   playerinventory(plrid,pint).new=0
   `
   rem Entity ID
   e=playerinventory(plrid,pint).index
   entid=entityelement(e).bankindex
   `
   rem If main player, handle internal resources
   if plrid=1
    `
    rem Entities record when they have been collected
    entityelement(e).collected=1
    `
    rem Respond to presence of WEAPON
    weaponindex=entityprofile(entid).isweapon
    tqty=entityelement(e).eleprof.quantity
    autoentityusedtoholdweapon=e
    gosub _player_obtainaweapon
    `
    rem Respond to presence of AMMO
    ammoindex=entityprofile(entid).isammo
    if ammoindex>0
     tnogunforammo=1
     for ws=1 to 10
      tgunid=weaponslot(ws).pref
      if tgunid=entityprofile(entid).hasweapon
       tnogunforammo=0
       tqty=entityelement(e).eleprof.quantity*firemode(tgunid,0).settings.reloadqty
       tpool=firemode(tgunid,0).settings.poolindex
       altpool=firemode(tgunid,1).settings.poolindex
       if gun(tgunid).settings.weaponisammo=1
        `if tpool=0 then weaponammo(ws)=weaponammo(ws)+tqty else ammopool(tpool).ammo=ammopool(tpool).ammo+tqty
         weaponammo(ws)=weaponammo(ws)+tqty
       else
        rem AirMod - Added for Alt Ammo >>>
        if entityelement(e).isaltammo = 1
         tqty=entityelement(e).eleprof.quantity*firemode(tgunid,1).settings.reloadqty
         `weaponclipammo(ws+10)=weaponclipammo(ws+10)+tqty
         if altpool=0 then weaponclipammo(ws+10)=weaponclipammo(ws+10)+tqty else ammopool(altpool).ammo=ammopool(altpool).ammo+tqty
        else
         if tpool=0 then weaponclipammo(ws)=weaponclipammo(ws)+tqty else ammopool(tpool).ammo=ammopool(tpool).ammo+tqty
        endif
       rem AirMod - Done <<<
       endif
       exit
      endif
     next ws
     if tnogunforammo=1
      rem create a gun slot for it, and fill with ready ammo
      for ws=1 to 10
       if weaponslot(ws).pref=0
        tgunid=entityprofile(entid).hasweapon
        weaponslot(ws).pref=tgunid
        weaponhud(ws)=gun(tgunid).hudimage
        if entityelement(e).isaltammo=0
         tqty=entityelement(e).eleprof.quantity*firemode(tgunid,0).settings.reloadqty
         tpool=firemode(tgunid,0).settings.poolindex
         if tpool=0 then weaponclipammo(ws)=tqty else ammopool(tpool).ammo=ammopool(tpool).ammo+tqty
        else
         tqty=entityelement(e).eleprof.quantity*firemode(tgunid,1).settings.reloadqty
         altpool=firemode(tgunid,1).settings.poolindex
         if altpool=0 then weaponclipammo(ws+10)=tqty else ammopool(altpool).ammo=ammopool(altpool).ammo+tqty
        endif
        exit
       endif
      next ws
     endif
    endif
    `
   else
    `
    rem any maintenance the NPC needs to do when it gets an item
    `
   endif
   `
  endif
 next pint
 `
 rem Check inventory for any items we need to drop
 for pint=1 to player(plrid).inventorymax
  if playerinventory(plrid,pint).drop=1
   `
   rem Entity ID
   e=playerinventory(plrid,pint).index
   entid=entityelement(e).bankindex
   `
   rem Item Entities expect a state incrememt if player drops after pickup
   entityelement(e).ai.state$=str$(val(entityelement(e).ai.state$)+1) rem GUI-X9 (String States)
   `
   rem Handle main player internal resources
   if plrid=1
    `
    rem Entities record when they have been dropped
    entityelement(e).collected=0
    `
    rem Respond to removal of item from inventory
    weaponindex=entityprofile(entid).isweapon
    if weaponindex>0 then gosub _player_removeweapon
    `
   else
    `
    rem any maintenance the NPC needs to do when it drops an item
    `
   endif
   `
   rem Item checked out
   playerinventory(plrid,pint).drop=0
   playerinventory(plrid,pint).index=0
   `
  endif
 next pint
 `
next plrid

return

`
` Main Player Subroutines Only
`

_player_input:

rem Input relates to PLAYER ONE ONLY (main controller of this app)
plrid=1

rem Gather input data
k$=lower$(inkey$())

rem Invincibe Mode - God Mode
if ggodmodestate=1 or gtestgamemodefromeditor=1
 if k$="i" then player(1).health=9999
endif

rem Use Action
tdisablepickupdropthiscycle=0
if (plrkeyRETURN)=1
 player(plrid).usingaction=1
else
 player(plrid).usingaction=0
 if fpgcgenre=0
  rem FPGC - 150310 - game creator is non-shooting, so LEFT click is also USE(ENTER)
  rem uses a global which instructs this code whther LEFT = USE rather than DROP
  if control_mouseclick_mode(1)=2 and gplayercanpressenterhere=1
   tdisablepickupdropthiscycle=1
   player(plrid).usingaction=1
  endif
 endif
endif

rem Mouseclick (mode 1-ignore A,C,D buttons of controller)
tmouseclick=control_mouseclick_mode(1)
if tdisablepickupdropthiscycle=1 and tmouseclick=2 then tmouseclick=0
if showgamemenu=1 then tmouseclick=0
`
rem FPGC - 180610 - FPGC variant treats tmouseclick=1 as =2 (so if using equipment, revert to =1)
if fpgcgenre=0 or firemode(gunid,firemode).settings.gravitygun<>0
 if currentgunobj>0
  if tmouseclick=2 then tmouseclick=1
 endif
endif
`
rem Mouse
player(plrid).state.firingmode=0
rem AirMod - Prevent any blocking bugs to occur when using non-blocking weapons >>>
if firemode(gunid,firemode).action.block.s = 0
 player(plrid).state.blockingaction=0
else
 if player(plrid).state.blockingaction = 2 and tmouseclick=0
  player(plrid).state.blockingaction = 0
 endif
endif
rem AirMod - Done <<<
if player(plrid).health>0 or playerstartstrength=0
 `if tmouseclick=1 then player(plrid).state.firingmode=1
 rem AirMod - Line changed to include blocking action
 if tmouseheld=1
  if mouseclick()<>1 or weaponammo(weaponammoindex+ammooffset)>0 then tmouseheld=0
 endif
 Rem Hockeykid - 030810 - Melee with a key press
 if gun(gunid).settings.meleekey>0
  if keystate(gun(gunid).settings.meleekey) and meleekeynotfree=0 and gun(gunid).settings.ismelee=0 then gun(gunid).settings.ismelee=1 : meleekeynotfree=1
  if meleekeynotfree=1 and keystate(gun(gunid).settings.meleekey)=0 then meleekeynotfree=0
 else
  meleekeynotfree=0
 endif
 if weaponammo(weaponammoindex+ammooffset)>0 or firemode(gunid,firemode).settings.reloadqty=0
  if tmouseclick=1 and player(plrid).state.blockingaction=0 and gun(gunid).settings.ismelee=0 then player(plrid).state.firingmode=1
  if firemode(gunid,firemode).settings.isempty>0

   if gunmode<>7031 and gunmode<>7041
    if gunmode<123 or gunmode>124
     if gunmode<700 or gunmode>707 then firemode(gunid,firemode).settings.isempty=0
    endif
   endif
  endif
 else
  if firemode(gunid,firemode).settings.isempty=0 and firemode(gunid,firemode).settings.hasempty=1 then firemode(gunid,firemode).settings.isempty=1
  if tmouseclick=1 and tmouseheld=0 and player(plrid).state.blockingaction=0 and gun(gunid).settings.ismelee=0 then gunshootnoammo=1
 endif
 rem v118 - 110511 - cinematic hands (terry cox) >>>>
 ` this will prevent the player from firing the weapon if set to 1
    if tmouseclick=1

        if disablefirebutton = 1
        player(plrid).state.firingmode=0
        else
        player(plrid).state.firingmode=1
        lastfired=gunid
        lastfiredtime=timer()
        endif
    endif

    if tmouseclick=1
       if lmbheld=0
       jamadjust=0
       lmbheld=1
       lmbheldtime=timer()
       endif
    endif

Rem Scene commander - track mouse held times
    if tmouseclick=2
      if rmbheld=0
      rmbheld=1
      rmbheldtime=timer()
      endif
      endif

    if tmouseclick<>1
    lmbheld=0
    lmbheldtime=0
    jamadjust=0
    endif

   if tmouseclick<>2
    rmbheld=0
    rmbheldtime=0
    endif


Rem Scene Commander - weapon jammed

if firemode(gunid,firemode).settings.jamchance<>0
Rem Scene Commander, added new gun spec to set the amount of minimum delay before jamming can occour.

if firemode(gunid,firemode).settings.mintimer<>0
mintimer=firemode(gunid,firemode).settings.mintimer
else
mintimer=500
endif

rem scene commander - increase jam change as barrels overheat.
      if lmbheld<>0
         if aaa=(timer()-lmbheldtime)/100>int((timer()-lmbheldtime)/100)
         jamadjust=jamadjust+5
         endif
      endif

if (player(plrid).state.firingmode=1 or gunmode=105) and (timer()-firemode(gunid,firemode).settings.addtimer)>(mintimer-jamadjust)
inc firemode(gunid,firemode).settings.shotsfired,1
firemode(gunid,firemode).settings.cooltimer=timer()
firemode(gunid,firemode).settings.addtimer=timer()
endif


   if player(plrid).state.firingmode=1 and firemode(gunid,firemode).settings.jammed=0
      jamtemp=100-firemode(gunid,firemode).settings.jamchance
      randomize timer()


      `text 200,200,str$(jamadjust)
      chance=firemode(gunid,firemode).settings.shotsbeforejam+(rnd(jamtemp))

      if firemode(gunid,firemode).settings.shotsfired>chance and weaponammo(weaponammoindex)>1
         firemode(gunid,firemode).settings.jammed=1
         rem Scene Commander, ensure weapon jams affect both modes if sharing ammo
          if gun(gunid).settings.modessharemags=1
          firemode(gunid,0).settings.jammed=1
          firemode(gunid,1).settings.jammed=1
          endif
            if gun(gunid).settings.alternate=0
            sndid=gunsound(gunid,3).soundid
            else
            sndid=gunsound(gunid,3).altsoundid
            endif
            if sndid>0
               if sound exist(sndid)
               play sound sndid
               endif
         endif
            endif
      endif

if firemode(gunid,firemode).settings.jammed=1
   player(plrid).state.firingmode=0
   firemode(gunid,firemode).settings.shotsfired=0
endif

Rem Scene Commander - cool down?
if firemode(gunid,firemode).settings.cooldown<>0
   tempcool=timer()-firemode(gunid,firemode).settings.cooltimer
   if tempcool>firemode(gunid,firemode).settings.cooldown
   firemode(gunid,firemode).settings.shotsfired=0
   endif
endif

endif

if firemode(gunid,firemode).settings.nosubmergedfire=1 and playerunderwater=1
   player(plrid).state.firingmode=0
endif


 rem cinematic hands <<<<
 rem AirMod - Blocking Move >>>
 rem v118 - 110511 - cinematic hands (terry cox) >>>>
 `this will check to see if it is a cinematic hand to start the blocking animations for the hand
     if startcinematichands = 1 and firemode(gunid,firemode).action.block.s <> 0 and player(plrid).state.blockingaction = 0 and gun(gunid).settings.ismelee=0
        player(plrid).state.blockingaction=1 : blocking=1
    else
        if tmouseclick=2 and firemode(gunid,firemode).action.block.s <> 0 and player(plrid).state.blockingaction = 0 and gun(gunid).settings.ismelee=0 and disableblockingbutton=0
            player(plrid).state.blockingaction=1 : blocking=1
        endif
    endif
rem cinematic hands <<<<
 `if tmouseclick=2 and firemode(gunid,firemode).action.block.s <> 0 and player(plrid).state.blockingaction = 0 and gun(gunid).settings.ismelee=0
 ` player(plrid).state.blockingaction=1 : blocking=1
 `endif
 `else
 `  player(plrid).state.blockingaction=0
 `endif
 rem AirMod - Done<<<
 rem AirMod - No Zoom in When Reloading or firing in simple zoom
 if tmouseclick=2 and (gunmode<=100 or firemode(gunid,firemode).settings.simplezoom=0) and (firemode(gunid,firemode).settings.forcezoomout=0 or gunmode <= 100)
  rem AirMod - Modified for Simple Zoom
  if gunzoommode=0 and (firemode(gunid,firemode).settings.zoommode<>0 or firemode(gunid,firemode).settings.simplezoom<>0) and firemode(gunid,firemode).settings.isempty=0
   gunzoommode=1 : gunzoommag#=1.0
   rem AirMod - Added for Simple Zoom
   if firemode(gunid,firemode).settings.simplezoomanim<>0 and firemode(gunid,firemode).settings.simplezoom<>0 then gunmode=2001
   rem play sound of gun select-zoom
   if gun(gunid).settings.alternate=0 then sndid=gunsound(gunid,4).soundid else sndid=gunsound(gunid,4).altsoundid
   if sndid>0
    if sound exist(sndid)=1
     if sound playing(sndid)=0
      playinternalBC3dsound(sndid,camera position x(),camera position y(),camera position z(),1)
     endif
    endif
   endif
  endif
  `if gunzoommode=10 then gunzoommode=11
  rem AirMod - Modified for Simple Zoom >>>
  if gunzoommode=10
   gunzoommode=11
   if firemode(gunid,firemode).settings.simplezoomanim<>0 and firemode(gunid,firemode).settings.simplezoom<>0 then gunmode = 2003
  endif
  rem AirMod - Done <<
 else
  if gunzoommode=9 then gunzoommode=10
  if gunzoommode=20 then gunzoommode=0
 endif
 Rem Reload key
 if plrkeyRheld=1 and plrkeyR=0 then plrkeyRheld=0

 tpool=firemode(gunid,firemode).settings.poolindex
 if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo

 if ammo=0 or firemode(gunid,firemode).settings.reloadqty=0  `or gun(gunid).settings.weaponisammo=1
  if (plrkeyR)=1 and plrkeyRheld=0 then gunreloadnoammo=1  : plrkeyRheld=1
 else
  if (plrkeyR)=1 and gun(gunid).settings.ismelee<>2
   player(plrid).state.firingmode=2
   plrreloading=1
   if gun(gunid).settings.ismelee=1 then gun(gunid).settings.ismelee=0
  endif
 endif
endif

rem scene commander - ensure weapon unjam if jammed
if gunzoommode<>0
plrkeyR=0
endif

if firemode(gunid,firemode).settings.jammed=1 and (plrkeyR)=1 and gun(gunid).settings.ismelee<>2 and firemode(gunid,firemode).settings.simplezoomanim=0 and firemode(gunid,firemode).settings.simplezoom=0
player(plrid).state.firingmode=2
endif

rem U71 - Contoller
if gxbox=1 : rem define in a config later
 if joystick hat angle(0)=18000 then k$="0"
 if joystick hat angle(0)=0 then k$=str$(weaponkeyselection)
endif

selkeystate=0
if spareselectkey>0
selkeystate=spareselectkey+1
spareselectkey=0
endif

if selkeystate=0
for i=2 to 11
 if keystate(i) then selkeystate=i : exit
next i
endif
`
rem Keyboard
altswapkeycalled=0
if gun(gunid).settings.altswapkey1>-1 and keystate(gun(gunid).settings.altswapkey1) and gunzoommode=0 or forcealtswap=1 then altswapkeycalled=1:forcealtswap=0
if selkeystate>0 and gunzoommode=0 or altswapkeycalled=1
 if altswapkeycalled=1 and gun(gunid).settings.altswapkey2>-1 and keystate(gun(gunid).settings.altswapkey2) or altswapkeycalled=1 and gun(gunid).settings.altswapkey2=-1 or altswapkeycalled=0
  if keyboardpress=0
   `
   rem Change weapon
    rem v118 - 110511 - cinematic hands (terry cox) - prevent plr selecting gun>>>>
    if (player(plrid).health>0 or playerstartstrength=0) and preventplrselectinggun = 0
    rem cinematic hands <<<<
    `if player(plrid).health>0 or playerstartstrength=0
    `
    rem Weapon select
    wepsel=0



    rem Keyboard input
    `if (k$>="1" and k$<="9") and altswapkeycalled=0
     `sel=(asc(k$)-asc("1")) : wepsel=1+sel
    `endif
    `if k$="0" then wepsel=-1
    `
    rem Hockeykid - 080611 - Allow moving and switching
    wepsel=selkeystate-1

    rem Cannot keypress until release
    keyboardpress=selkeystate
    if selkeystate=11 then wepsel=-1
    if altswapkeycalled=1 then keyboardpress=-2 : wepsel=-2

    rem Actual weapon change
    if altswapkeycalled=0

     if wepsel>0
      weaponkeyselection=wepsel
         rem scene commander - prevent selection if slot locked out.
         if weaponkeyselection>0
            if weaponslot(weaponkeyselection).noselect=0
               weaponindex=weaponslot(weaponkeyselection).got
               if weaponindex>0 then player(plrid).command.newweapon=weaponindex
            endif
         endif
      endif

     rem V118 - 180211 - ensure can only put weapon away when in idle mode
     if wepsel=-1 `and gunmode<=10
      if gunmode<31 or gunmode>35
       if gunid<>0
        gunmode=31 : gunselectionafterhide=0
       endif
      endif
     endif
    endif
    if altswapkeycalled=1 and weaponslot(weaponkeyselection).noselect=0
     if gunid<>0
      if (gun(gunid).settings.alternateisflak = 1 or gun(gunid).settings.alternateisray = 1) and gunmode <= 100
       Rem Hockeykid 150212 - reset gunburst variable so burst doesn't get confused when switching gunmodes
       if gun(gunid).settings.alternate = 1 then gunmode=2009 : gun(gunid).settings.alternate = 0 : gunburst=0 : else : gunmode=2007 : gun(gunid).settings.alternate = 1 : gunburst=0
      endif
     endif
    endif
    `
   endif
   `
   rem Restart if in recovermode, early start
   if player(plrid).recovershield>0 and player(plrid).recovershield<50 and k$=" "
    player(plrid).recovershield=1
   endif
   `
   altswapkeycalled=0
  endif
 endif
endif
if keyboardpress>0
 if keystate(keyboardpress)=0 then keyboardpress=0
endif
if keyboardpress=-2 and altswapkeycalled=0 then keyboardpress=0

rem Mouse Wheel scrolls weapons
tmz=mousemovez()

rem U71 - Contoller
if gxbox=1 : rem define in a config later
 if joystick hat angle(0)=9000 then tmz=10
 if joystick hat angle(0)=27000 then tmz=-10
endif

rem Change weapon
if gunselectionlockdown=0 and gunzoommode=0 and gun(gunid).settings.ismelee=0
 `if tmz<>0
 rem v118 - 110511 - cinematic hands (terry cox) - prevent player changing guns with joystick>>>>
 if tmz<>0 and preventplrselectinggun = 0
 rem cinematic hands <<<<
  tokay=0 : ttries=10

   while tokay=0 and ttries>0
   if tmz<0 then weaponkeyselection=weaponkeyselection-1
   if tmz>0 then weaponkeyselection=weaponkeyselection+1
   if weaponkeyselection>10 then weaponkeyselection=1
   if weaponkeyselection<1 then weaponkeyselection=10
   if weaponslot(weaponkeyselection).noselect=0 then tweaponindex=weaponslot(weaponkeyselection).got
   if tweaponindex>0 then tokay=1
   dec ttries
   endwhile

  if tokay=1
   rem change up or down
   weaponindex=weaponslot(weaponkeyselection).got
   if weaponindex>0 then player(plrid).command.newweapon=weaponindex
  endif
 endif
else
 rem zoom magnification wheel
 if tmz<>0
  tmz#=tmz : gunzoommag#=gunzoommag#+(tmz#/100.0)
  if gunzoommag#<1.0 then gunzoommag#=1.0
  if gunzoommag#>10.0 then gunzoommag#=10.0
  plrzoominchange=1
 endif
endif

rem Recover mode progress (RESTART PLAYER NEW LIFE)
tsetplayereyehud=0
if player(plrid).recovershield>0
 if player(plrid).lives>0 or playerstartlives=0
  player(plrid).recovershield=player(plrid).recovershield-1
  if player(plrid).recovershield>0
   tsetplayereyehud=1
  else
   rem recover player
   player(plrid).recovershield=0
   player(plrid).health=playerstartstrength
   rem restart player at spawn point
   gosub _player_unmark
   gosub _player_startpos
   rem reset entities to make distant ones dormant again
   gosub _entity_resetentitiesifplrleaps
  endif
 endif
endif
if player(plrid).lives=0 and player(plrid).health<=0 and playerstartlives>0
 tsetplayereyehud=1
endif
if tsetplayereyehud=1
 rem GUI-X9 (knxrb) Eyehud
 if guiUsed = 0
     rem update sprite used for screen fade
     if internaleyehud>0
      hudid=internaleyehud : hud(hudid).hide=0
      hud(hudid).hidedelay=5
     endif
 else
     if guieyehud > -1
        guieyetimer = guihurttime+400
        gosub _gui_run
     endif
 endif
endif

return

_player_addweapon:

rem check all weapon slots
gotweapon=0
for ws=1 to 10
 if weaponslot(ws).got=weaponindex then gotweapon=ws
next ws
if gotweapon=0
 rem check if we have a slot preference
 gotweaponpref=0
 for ws=1 to 10
  if weaponslot(ws).pref=weaponindex then gotweaponpref=ws
 next ws
 rem add weapon
 if gotweaponpref=0
  rem find free slot
  for ws=1 to 10
   if weaponslot(ws).pref=0 then exit
  next ws
   Rem Scene Commander change
  if forcedslot<>0 then ws=forcedslot:gotweaponpref=ws:forcedslot=0
  Rem Scene Commander, count weapons for maximum slots. If exceeded, prevent pick up.
  weaps=0
  For count=1 to 10
  if weaponslot(count).pref<>0 then inc weaps,1
  next count
  if weaps>=maxslots then ws=100
  if ws<=10
   rem add weapon into free slot and create pref for it
   weaponslot(ws).pref=weaponindex
   weaponhud(ws)=gun(weaponindex).hudimage
   rem FPGC - mark weapon with 'possible' entity that held this weapon (for equipment activation)
   firemode(weaponindex,0).settings.equipmententityelementindex=autoentityusedtoholdweapon
  else
   rem no room for weapon in available slots
   ws=0
  endif
 else
  ws=gotweaponpref
 endif

 rem switch to collected weapon
 if autoswap=1 and ws>0
  rem insert as slot weapon
  weaponslot(ws).got=weaponindex
  weaponslot(ws).invpos=weaponinvposition
  autoloadgun=weaponindex
  weaponkeyselection=ws
  gotweapon=ws
 endif

 rem place details of weapon in slot
 if ws>0
  rem insert as slot weapon
  weaponslot(ws).got=weaponindex
  weaponslot(ws).invpos=weaponinvposition
  gotweapon=ws
  if gunid=0
   rem if no gun held, auto select collected
   autoloadgun=weaponindex
   weaponkeyselection=ws
  endif
 endif
endif
`
rem weapons start with some ammo
if gotweapon>0
 tgunid=weaponslot(gotweapon).pref
 if gun(tgunid).settings.weaponisammo=0
  if tqty=0 then tqty=1
  if weaponammo(gotweapon)=0
   taltqty=tentqty*firemode(tgunid,1).settings.reloadqty
   if taltqty>firemode(tgunid,1).settings.reloadqty
    altpool=firemode(tgunid,1).settings.poolindex
    weaponammo(gotweapon+10)=firemode(tgunid,1).settings.reloadqty
    if altpool>0 then ammopool(altpool).ammo=ammopool(altpool).ammo+(taltqty-firemode(tgunid,1).settings.reloadqty) else weaponclipammo(gotweapon+10)=taltqty-firemode(tgunid,1).settings.reloadqty
   else
    if gun(tgunid).settings.addtospare=0
      weaponammo(gotweapon+10)=taltaty
    else
     if gun(tgunid).settings.canaddtospare=1
      altpool=firemode(tgunid,1).settings.poolindex
      if altpool=0 then weaponclipammo(gotweapon+10)=weaponclipammo(gotweapon+10)+taltqty else ammopool(altpool).ammo=ammopool(altpool).ammo+taltqty
     endif
     if gun(tgunid).settings.canaddtospare=0 then weaponammo(gotweapon+10)=taltqty
    endif
   endif
   if tqty>firemode(tgunid,0).settings.reloadqty
    rem FPGC - 080710 - gun has MAX slots of ammo, cannot exceed this!
    tpool=firemode(tgunid,0).settings.poolindex
    weaponammo(gotweapon)=firemode(tgunid,0).settings.reloadqty
    if tpool>0 then ammopool(tpool).ammo=ammopool(tpool).ammo+(tqty-firemode(tgunid,0).settings.reloadqty) else weaponclipammo(gotweapon)=tqty-firemode(tgunid,0).settings.reloadqty
   else
    if gun(tgunid).settings.addtospare=0
      weaponammo(gotweapon)=tqty
    else
     Rem new gunspec addition "addtospare" This will allow it so picking up ammo with an empty weapon won't add the ammo directly into the clip
     if gun(tgunid).settings.canaddtospare=1
      `weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
      tpool=firemode(tgunid,0).settings.poolindex
      if tpool=0 then weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty else ammopool(tpool).ammo=ammopool(tpool).ammo+tqty
     endif
     if gun(tgunid).settings.canaddtospare=0 then weaponammo(gotweapon)=tqty : gun(tgunid).settings.canaddtospare=1
    endif
   endif
  else
   if newweapon=0
    tpool=firemode(tgunid,0).settings.poolindex
    altpool=firemode(tgunid,1).settings.poolindex
    if tpool=0 then weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty else ammopool(tpool).ammo=ammopool(tpool).ammo+tqty
    if altpool=0 then weaponclipammo(gotweapon+10)=weaponclipammo(gotweapon+10)+taltqty else ammopool(altpool).ammo=ammopool(altpool).ammo+taltqty
   endif
   newweapon=0
  endif
 endif
endif

return

_player_removeweapon:

rem check all weapon slots
for ws=1 to 10
 if weaponslot(ws).got=weaponindex then exit
next ws
if ws<=10
 `
 rem Ensure gun is removed (if applicable)
 if gunid>0 and weaponslot(ws).got=gunid
  autoloadgun=0
 endif
 `
 rem drop weapon from slot
 weaponslot(ws).got=0
 weaponslot(ws).invpos=0
 `
endif

return

`
` Player Movement Related
`

_player_unmark:
 gosub _ode_unmark
return

_player_mark:
 gosub _ode_mark
return

_player_camera:
 plrid=1 : gosub _ode_playercamera
 basespeed#=plrbasespeed# : gosub _player_playfootfall
 if cty#<=-100 then tdamage=65535 : gosub _player_takedamage
return

_player_listener:
 gosub _ode_listener
return

`
` Player Gun Functions (should they be here)
`

function loadgun(tfile$)
 index=0
 if gunbankmax>0
  for t=1 to gunbankmax
   if tfile$=gunbank$(t) then index=gunbankoffset+t : exit
  next t
 else
  t=gunbankmax+1
 endif
 if t>gunbankmax
  inc gunbankmax
  `
  rem V109 BETA8 - some models do not re-load as HUD DBO correctly, so exclude them here:
  legacyhudmode=0
  if lower$(right$(tfile$,10))="ak47\hud.x" then legacyhudmode=1
  `
  rem V109 BETA6 - replaced X file load with optional DBO convert/load for HUD.X
  if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
  if legacyhudmode=1 then tdbofile$=""
  if file exist(tfile$)=1 or file exist(tdbofile$)=1
   index=gunbankoffset+gunbankmax
   gunbank$(gunbankmax)=tfile$
   rem V109 BETA6 - replaced X file load with optional DBO convert/load for HUD.X
   if file exist(tdbofile$)=1
    tfile$=tdbofile$
    tdbofile$=""
   else
    rem allowed to save DBO (once only)
   endif
   load object tfile$,index
   if len(tdbofile$)>1
    save object tdbofile$,index
    if file exist(tdbofile$)=1
     delete object index
     load object tdbofile$,index
     tfile$=tdbofile$
    endif
   endif
   addfiletocollection(tfile$)
   `
   set object collision off index
   set object interpolation index,100
   set object frame index,firemode(gunbankmax,0).action.show.s
   hide object index
   `
  endif
 endif
endfunction index

function createsecondgun()
 inc gunbankmax
 gunbank$(gunbankmax)="second"
 index=gunbankoffset+gunbankmax
endfunction index

function loadbrass(tfile$)
 index=0
 if brassbankmax>0
  for t=1 to brassbankmax
   if tfile$=brassbank$(t) then index=brassbankoffset+t : exit
  next t
 else
  t=brassbankmax+1
 endif
 if t>brassbankmax
  inc brassbankmax
  `
  rem V109 BETA6 - replaced X file load with optional DBO convert/load for HUD.X
  `load object tfile$,index
  `addfiletocollection(tfile$)
  if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
  if file exist(tfile$)=1 or file exist(tdbofile$)=1
   index=brassbankoffset+brassbankmax
   brassbank$(brassbankmax)=tfile$
   rem V109 BETA6 - replaced X file load with optional DBO convert/load for HUD.X
   if file exist(tdbofile$)=1
    tfile$=tdbofile$
    tdbofile$=""
   else
    rem allowed to save DBO (once only)
   endif
   load object tfile$,index
   if len(tdbofile$)>1
    save object tdbofile$,index
    if file exist(tdbofile$)=1
     delete object index
     load object tdbofile$,index
     tfile$=tdbofile$
    endif
   endif
   addfiletocollection(tfile$)
   `
   set object collision off index
   disable object zdepth index
   set object transparency index,1
   set object specular index,15
   set object fov index,45
  endif
 endif
endfunction index

function loadmuzzle(tfile$)
 index=0
 if muzzlebankmax>0
  for t=1 to muzzlebankmax
   if tfile$=muzzlebank$(t) then index=muzzlebankoffset+t : exit
  next t
 else
  t=muzzlebankmax+1
 endif
 if t>muzzlebankmax
  inc muzzlebankmax
  muzzlebank$(muzzlebankmax)=tfile$
  index=muzzlebankoffset+muzzlebankmax
  loadinternalimageexcompress(tfile$,index,5)
 endif
endfunction index

function loadsmoke(tfile$)
 index=0
 if smokebankmax>0
  for t=1 to smokebankmax
   if tfile$=smokebank$(t) then index=smokebankoffset+t : exit
  next t
 else
  t=smokebankmax+1
 endif
 if t>smokebankmax
  inc smokebankmax
  smokebank$(smokebankmax)=tfile$
  index=smokebankoffset+smokebankmax
  loadinternalimageexcompress(tfile$,index,5)
 endif
endfunction index


rem
rem GUN CORE
rem


_gun_init:

rem Load all guns into memory
gosub _gun_scaninall_ref

rem Force all weapons into weapon slots (initial default start)
if level=1 then gosub _gun_gatherslotorder

rem No gun to start with
weaponammoindex=0
autoloadgun=-1
gunid=0

rem V114 - 021208 - trigger weapon one automatically if exists
triggerweapononeifexists=1

rem V111 - 140608 - modifier to adjust gun animation speed based on change from 32fps to 38fps cap
`100   +1.0      32fps   32.0
`84.2  +0.842    38fps   32.0  SO (75.0*0.842) and (125.0*0.842)

return

_gun_decaldetails:
 for i=1 to gunmax
  for y=0 to 1
   if firemode(i,y).particle.decal$>""
    decal$=firemode(i,y).particle.decal$
    Gosub _decal_find
    if decalid<>-1
     firemode(i,y).particle.id=decalid
    else
     firemode(i,y).particle.decal$=""
    endif
   endif
  next y
 next i
Return

_gun_loadonlypresent:
 `
 rem Load only active guns from slots (and from playerstartentry)
 for tww=1 to 10
  gunid=weaponslot(tww).pref
  if gunid>0 then gun(gunid).activeingame=1
 next tww
 `
 rem load in any guns that entities specify
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  gunid=entityprofile(entid).hasweapon
  if gunid>0 then gun(gunid).activeingame=1
  gunid=entityprofile(entid).isweapon
  if gunid>0 then gun(gunid).activeingame=1
 next e
 `
 rem Load all guns that have been activated
 for gunid=1 to gunmax
  if gun(gunid).activeingame=1
   gun$=gun(gunid).name$ : gosub _gun_load
  endif
 next gunid
 `
 rem And now fill in player weapon details
 for tww=1 to 10
  gunid=weaponslot(tww).pref
  if gunid>0
   if gun(gunid).activeingame=1
    weaponhud(tww)=gun(gunid).hudimage
   endif
  endif
 next tww
 `
 rem Ensure gun vars are reset
 gunid=0
 `
return

_gun_resetgunsettings:
 `
 rem Reset weapons (1=restart)
 if tcopyorrestart=0
  rem copy
  dim copyweaponslot(10) as weaponslottype
  rem AirMod - Next 2 Lines modified for Alt Fire
  dim copyweaponammo(20) as integer
  dim copyweaponclipammo(20) as integer
  `dim copyweaponammo(10) as integer
  `dim copyweaponclipammo(10) as integer
  dim copyweaponhud(10) as integer
  for ws=1 to 20
   rem AirMod - Line Modified for Alt Fire
   if ws < 11 then copyweaponslot(ws)=weaponslot(ws)
   copyweaponammo(ws)=weaponammo(ws)
   copyweaponclipammo(ws)=weaponclipammo(ws)
   rem AirMod - Line Modified for Alt Fire
   if ws < 11 then copyweaponhud(ws)=weaponhud(ws)
  next ws
 else
  rem restore
  rem AirMod - Line Modified for alt Fire
  for ws=1 to 20
   rem AirMod - Line Modified for Alt Fire
   if ws < 11 then weaponslot(ws)=copyweaponslot(ws)
   weaponammo(ws)=copyweaponammo(ws)
   weaponclipammo(ws)=copyweaponclipammo(ws)
   rem AirMod - Line Modified for Alt Fire
   if ws < 11 then weaponhud(ws)=copyweaponhud(ws)
  next ws
 endif
 `
return

_gun_manager:

rem V110 - new freeze mode (PLRDISABLE) which stops player attacking
gunclick=player(1).state.firingmode
if mefrozen>0 and mefrozentype=2 then gunclick=0
if gunclick=1 and firemode(gunid,firemode).settings.disablerunandshoot=1 and isrunning=1 and player(1).state.moving=1 then gunclick=0

rem Gun controls
if gunmode<100
 rem Gun Firing
 if gunclick<>1 then gunmustreleasefirst=0
 if gunclick<>0
  if gunclick=1 and gunmustreleasefirst=0 and gunmode >=5 and gunmode <=26 then gunmode=101
  rem V109 BETA10 - 120508 - can only reload when gun idle (stops gun freeze when do change then reload quickly)
  `if gunmode<11
  rem AirMod - No Full Reload Feature
  gunfull=1
  if (weaponammo(weaponammoindex+ammooffset) < firemode(gunid,firemode).settings.reloadqty+1 and firemode(gunid,firemode).settings.chamberedround > 0) then gunfull = 0
  if (weaponammo(weaponammoindex+ammooffset) < firemode(gunid,firemode).settings.reloadqty and firemode(gunid,firemode).settings.chamberedround=0) then gunfull = 0
  Rem Scene Commander
  if (weaponammo(weaponammoindex+ammooffset)>0 and firemode(gunid,firemode).settings.emptyreloadonly = 1) then gunfull=1
  if gunfull=1 then plrreloading=0
  rem V110 - 220508 - and also for when walking/running
  if gunmode<30
   `if gunclick=2 then gunmode=121
   if gunclick=2 and (gunfull=0 or firemode(gunid,firemode).settings.nofullreload = 0) then gunmode=121
  endif
 else
  rem Gun Movement
  if gunmode<21 or gunmode>39
   `if player(1).state.moving=1 then gunmode=21
   rem AirMod - Enable MOVE animation in crouch
   if player(1).state.moving<>0 then gunmode=21
  endif
 endif
endif
`
rem AirMod - Gun Blocking >>>
block = player(1).state.blockingaction
if block = 1 and gunmode<100
 gunmode=1001
else
 if block <> 2 then player(1).state.blockingaction = 0
endif
rem AirMod - Done <<<

if gun(gunid).settings.ismelee>0 and gunmode<100
 if firemode(gunid,firemode).meleeaction.start.s>0
  if gunzoommode=10 then gunzoommode=11
  if gun(gunid).settings.ismelee=2 then gunmode=1020
  if firemode(gunid,firemode).settings.simplezoom <> 0 and firemode(gunid,firemode).settings.simplezoomanim<>0 and gunzoommode<>0
   gunmode=2003
  else
   gun(gunid).settings.ismelee=2
  endif
 else
  gun(gunid).settings.ismelee=0
 endif
endif
`
texture object hudbankoffset+5,firemode(gunid,firemode).settings.flashimg
`
rem Gun Selection
rem V118 - 180211 - ensure you can only command a weapon change when not putting weapon away or no gun (i.e. don't interupt the weapon put-away anim with weapon change)
rem V119 - Hockeykid - 080611 - Make sure we can still switch while doing everything other than switching weapons
if gunmode<31 or gunmode>35
 if gunselectionlockdown=0 or gunid=0
  if player(1).command.newweapon>0
   sel=player(1).command.newweapon
   player(1).command.newweapon=0
   if weaponammoindex>0
    rem only if 'different weapon'
    if weaponslot(weaponammoindex).pref<>sel
     gunmode=31 : gunselectionafterhide=sel
     tmouseheld=0
     rem AirMod - Alternate Fire >>>
    else
     `gunzoommode = 0 and
     if gun(gunid).settings.altswapkey1=-1
      if (gun(gunid).settings.alternateisflak = 1 or gun(gunid).settings.alternateisray = 1) and gunmode <= 100
       if gun(gunid).settings.alternate = 1 then gunmode=2009 : gun(gunid).settings.alternate = 0 : else : gunmode=2007 : gun(gunid).settings.alternate = 1
      endif
     endif
     rem AirMod - Done <<<<
    endif
   else
    gunmode=131 : autoloadgun=sel
    if autoloadgun<>gunid then tmouseheld=0
   endif
  endif
 endif
endif

rem Change weapon
gosub _gun_change

rem Need to update hud object for gun here (and again after SYNC)
gosub _gun_update_hud

rem Gun control
if gunid>0
 if object exist(currentgunobj)=1
  firemode=gun(gunid).settings.alternate
  ammooffset=firemode*10
  rem Hockeykid 140212 - Primary and alt modes can share a mag
  if gun(gunid).settings.modessharemags=1 then ammooffset=0
  `
  if gun(gunid).settings.bulletmod=1
   if object frame(currentgunobj)>=gun(gunid).settings.bulletreset and object frame(currentgunobj)<=gun(gunid).settings.bulletreset+5
    for p=gun(gunid).settings.bulletlimbstart to gun(gunid).settings.bulletlimbend
     limbnumber=bulletlimbs(p)
     scale limb currentgunobj,limbnumber,100,100,100
    next p
   endif
  endif
  `
  gosub _gun_control
  gosub _gun_shoot
  if gun(gunid).settings.flashlimb>=0 then gosub _gun_flash
  if gun(gunid).settings.brasslimb>=0 then gosub _gun_brass
  if gun(gunid).settings.smokelimb>=0 then gosub _gun_smoke
  gosub _gun_soundcontrol
 endif
endif

rem Independent handling (no matter which guns is selected)
gosub _gun_brass_indi

return

_gun_change:

rem V114 - 021208 - at start of level, this is set to one
if triggerweapononeifexists>0
 triggerweapononeifexists=0
 tgunid=weaponslot(1).got
 if tgunid>0
  if len(gun(tgunid).name$)>1
   autoloadgun=tgunid
  endif
 endif
endif

if autoloadgun<>-1
 `
 rem Free the old gun
 gosub _gun_free
 `
 rem Gun selection
 gunid=autoloadgun
 gun$=gun(gunid).name$
 autoloadgun=-1
 `
 rem If gun selection valid, load it
 if gun$<>""
   firemode=0
   gosub _gun_selectandorload
 endif

 rem cause gun lighting to reset
 currentguncolr=-1 : gosub _lighting_applyplayerlighting

 rem Show gun as active
 currentgunobj=gun(gunid).obj
 if currentgunobj>0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,firemode(gunid,0).action.show.s
  show object currentgunobj
 else
  gunid=0
 endif

 rem Default gun action is to SHOW and reveal gun (then goes to gunmode=5 idle)
 gunmode=131 : keyboardpress=0

 rem locate slot for ammo usage
 weaponammoindex=0
 if gunid>0
  for ws=1 to 10
   if weaponslot(ws).pref=gunid
    weaponammoindex=ws : exit
   endif
  next ws
 endif

endif

return

_gun_update_hud:

rem HUD marker update
if object exist(hudbankoffset+2)=1
 tsimwoddle#=0
 gunax#=camera angle x() : gunay#=camera angle y()
 rotate object hudbankoffset+2,gunax#,gunay#,0
 if currentgunobj>0
  if object exist(currentgunobj)=1
   if player(1).health>0 or playerstartstrength=0
    show object currentgunobj
   else
    hide object currentgunobj
   endif
   rem FPGC - if not animation in HUD, simulate if movement
   if movement<>0
    if total object frames(currentgunobj)=0
     gfakewoddle#=wrapvalue(gfakewoddle#+4)
     tsimwoddle#=curvevalue(cos(gfakewoddle#)*2,tsimwoddle#,15)
    endif
   else
    tsimwoddle#=curvevalue(0,tsimwoddle#,15)
   endif
  endif
 endif
 position object hudbankoffset+2,camera position x(),camera position y()+tsimwoddle#,camera position z()
endif

return

_gun_update_overlay:
return

_gun_control:

if gunmode=9998
   gunmode=9999
   show object currentgunobj
   set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
   set object interpolation currentgunobj,100
   play object currentgunobj,custstart,custend

endif

if gunmode=9999
   if object frame(currentgunobj)>=custend then gunmode=5
endif


rem AirMod - Gun Lag :D >>>
if gunzoommode <> 0
 gunlagspeed# = firemode(gunid,firemode).settings.zoomgunlagSpeed
 gunlagxmax# = firemode(gunid,firemode).settings.zoomgunlagxmax
 gunlagymax# = firemode(gunid,firemode).settings.zoomgunlagymax
else
 gunlagspeed# = firemode(gunid,firemode).settings.gunlagSpeed
 gunlagxmax# = firemode(gunid,firemode).settings.gunlagxmax
 gunlagymax# = firemode(gunid,firemode).settings.gunlagymax
endif
gunlagX# = curvevalue(gunlagX#-(cammovex#)*0.01,gunlagX#,gunlagspeed#)
gunlagY# = curvevalue(gunlagY#+(cammovey#)*0.01,gunlagY#,gunlagspeed#)

if gunlagX# < - gunlagxmax# then gunlagX# = -gunlagxmax#
if gunlagY# < - gunlagymax# then gunlagY# = -gunlagymax#
if gunlagX# >  gunlagxmax# then gunlagX# = gunlagxmax#
if gunlagY# >  gunlagymax# then gunlagY# = gunlagymax#

gunlagX# = curvevalue(0,gunlagX#,gunlagspeed#*1.2)
gunlagY# = curvevalue(0,gunlagY#,gunlagspeed#*1.2)

if gunzoommode <> 0 and gunzoommode < 11 and firemode(gunid,firemode).settings.simplezoom <> 0
 gunOffsetX# = curvevalue(firemode(gunid,firemode).settings.simplezoomx#,gunOffsetX#,firemode(gunid,firemode).settings.simplezoomspeed)
 gunOffsetY# = curvevalue(firemode(gunid,firemode).settings.simplezoomy#,gunOffsetY#,firemode(gunid,firemode).settings.simplezoomspeed)
else
 tx# = 0
 ty# = 0
 if (plrkeySHIFT)=1 and movement<>0 then tx# = firemode(gunid,firemode).settings.runx# : ty# = firemode(gunid,firemode).settings.runy#
 gunOffsetX# = curvevalue(tx#,gunOffsetX#,firemode(gunid,firemode).settings.simplezoomspeed)
 gunOffsetY# = curvevalue(ty#,gunOffsetY#,firemode(gunid,firemode).settings.simplezoomspeed)
endif
rem AirMod - Done <<<

rem gun position offset and rotation
if plrzoomin#<>0.0
 plrzoomaccuracy#=firemode(gunid,firemode).settings.zoomaccuracy/100.0
 if firemode(gunid,firemode).settings.simplezoom <> 0
  if firemode(gunid,firemode).settings.simplezoommod = 0
   position object currentgunobj,firemode(gunid,firemode).horiz#+gunlagx#+gunOffsetX#,firemode(gunid,firemode).vert#+gunlagy#+gunOffsetY#,firemode(gunid,firemode).forward#
  else
   position object currentgunobj,firemode(gunid,firemode).horiz#+gunlagx#+gunOffsetX#,firemode(gunid,firemode).vert#+gunlagy#+gunOffsetY#,firemode(gunid,firemode).forward#-(plrzoomin#/firemode(gunid,firemode).settings.simplezoommod)
  endif
 else
  position object currentgunobj,firemode(gunid,firemode).horiz#,firemode(gunid,firemode).vert#,firemode(gunid,firemode).forward#-(plrzoomin#*10.0)
 endif
else
 `position object currentgunobj,gun(gunid).horiz#,gun(gunid).vert#,gun(gunid).forward#
 rem AirMod - New Gun Lag Feature
 position object currentgunobj,firemode(gunid,firemode).horiz#+gunlagx#+gunOffsetX#,firemode(gunid,firemode).vert#+gunlagy#+gunOffsetY#,firemode(gunid,firemode).forward#
endif
rotate object currentgunobj,0,180,0

rem hide the object if weapon-ammo and no qty left
if gun(gunid).settings.weaponisammo=1
 if weaponammo(weaponammoindex)=0
  hide object currentgunobj
 else
  show object currentgunobj
 endif
endif

rem FPGC - 090710 - generic speed of gun animations (to match legacy sound-sensitive gun anims from < V116)
`genericgunanimspeed#=100.0
genericgunanimspeed#=130.0

rem AirMod - Zoom To/From Animations >>>> (show/hide)
if gunmode >= 2001 and gunmode <= 2010
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
endif
if gunmode = 2001
 set object interpolation currentgunobj,100
 gunmode = 2002
 play object currentgunobj,firemode(gunid,firemode).zoomaction.show.s,firemode(gunid,firemode).zoomaction.show.e
endif
if gunmode = 2002
 if object frame(currentgunobj)>=firemode(gunid,firemode).zoomaction.show.e then gunmode=5
endif

if gunmode = 2003
 set object interpolation currentgunobj,100
 gunmode = 2004
 play object currentgunobj,firemode(gunid,firemode).zoomaction.hide.s,firemode(gunid,firemode).zoomaction.hide.e
endif
if gunmode = 2004
 if object frame(currentgunobj)>=firemode(gunid,firemode).zoomaction.hide.e and gunzoommode=0 then gunmode=5
endif

if gunmode = 2005
 set object interpolation currentgunobj,100
 gunmode = 2006
 play object currentgunobj,firemode(gunid,firemode).zoomaction.hide.s,firemode(gunid,firemode).zoomaction.hide.e
endif
if gunmode = 2006
 if object frame(currentgunobj)>=firemode(gunid,firemode).zoomaction.hide.e and gunzoommode=0 then gunmode=121
endif

if gunmode = 2007
 set object interpolation currentgunobj,100
 gunmode = 2008
 play object currentgunobj,gun(gunid).altaction.to.s,gun(gunid).altaction.to.e
 texture object hudbankoffset+5,firemode(gunid,1).settings.flashimg
endif
if gunmode = 2008
 if object frame(currentgunobj)>=gun(gunid).altaction.to.e then gunmode=5
endif

if gunmode = 2009
 set object interpolation currentgunobj,100
 gunmode = 2010
 play object currentgunobj,gun(gunid).altaction.from.s,gun(gunid).altaction.from.e
 texture object hudbankoffset+5,firemode(gunid,0).settings.flashimg
endif
if gunmode = 2010
 if object frame(currentgunobj)>=gun(gunid).altaction.from.e then gunmode=5
endif

rem AirMod - Done <<<


gshow as gunanimtype
gidle as gunanimtype
gmove as gunanimtype
gstart as gunanimtype
gautomatic as gunanimtype
gfinish as gunanimtype
gstartreload as gunanimtype
greloadloop as gunanimtype
gendreload as gunanimtype
gcock as gunanimtype
ghide as gunanimtype
gblock as gunanimtype
`
`if gunmode<21 or gunmode>26 then usingrun=0
if firemode(gunid,firemode).settings.hasempty=1 and firemode(gunid,firemode).settings.isempty=1
 if gunzoommode=10 and firemode(gunid,firemode).settings.simplezoom <> 0
  if firemode(gunid,firemode).settings.simplezoomanim <> 0
   Rem Zoom out once we finish off the last of our shooting gunmode
   if gunmode<101 or gunmode>107 then gunzoommode=11 : gunmode = 2003
   gstart=firemode(gunid,firemode).zoomaction.start
   gfinish=firemode(gunid,firemode).zoomaction.finish
   gautomatic=firemode(gunid,firemode).zoomaction.automatic
  else
   gunzoommode=11
   gstart=firemode(gunid,firemode).action.start
   gfinish=firemode(gunid,firemode).action.finish
   gautomatic=firemode(gunid,firemode).action.automatic
  endif
 else
  gstart=firemode(gunid,firemode).action.start
  gfinish=firemode(gunid,firemode).action.finish
  gautomatic=firemode(gunid,firemode).action.automatic
 endif
 gshow=firemode(gunid,firemode).emptyaction.show
 gidle=firemode(gunid,firemode).emptyaction.idle
 if isrunning=0 and usingrun<>-1
  gmove=firemode(gunid,firemode).emptyaction.move : usingrun=-1
  if gunmode>=21 and gunmode<=26 then gunmode=21
 endif
 if isrunning=1 and usingrun<>1
  gmove=firemode(gunid,firemode).emptyaction.run : usingrun=1
  if gunmode>=21 and gunmode<=26 then gunmode=21
 endif
 if usingrun=-1 then gmove=firemode(gunid,firemode).emptyaction.move
 if usingrun=1 then gmove=firemode(gunid,firemode).emptyaction.run
 gstartreload=firemode(gunid,firemode).emptyaction.startreload
 greloadloop=firemode(gunid,firemode).emptyaction.reloadloop
 gendreload=firemode(gunid,firemode).emptyaction.endreload
 gcock=firemode(gunid,firemode).emptyaction.cock
 ghide=firemode(gunid,firemode).emptyaction.hide
else
 gshow=firemode(gunid,firemode).action.show
 gidle=firemode(gunid,firemode).action.idle
 if isrunning=0 and usingrun<>-1
  gmove=firemode(gunid,firemode).action.move : usingrun=-1
  if gunmode>=21 and gunmode<=26 then gunmode=21
 endif
 if isrunning=1 and usingrun<>1
  gmove=firemode(gunid,firemode).action.run : usingrun=1
  if gunmode>=21 and gunmode<=26 then gunmode=21
 endif
 if usingrun=-1 then gmove=firemode(gunid,firemode).action.move
 if usingrun=1 then gmove=firemode(gunid,firemode).action.run
 gautomatic=firemode(gunid,firemode).action.automatic
 gstartreload=firemode(gunid,firemode).action.startreload
 greloadloop=firemode(gunid,firemode).action.reloadloop
 gendreload=firemode(gunid,firemode).action.endreload
 gcock=firemode(gunid,firemode).action.cock
 ghide=firemode(gunid,firemode).action.hide
 if tfireanim=0
  gstart=firemode(gunid,firemode).action.start
  gfinish=firemode(gunid,firemode).action.finish
  tempani=1
  if firemode(gunid,firemode).action.start2.s > 0 and rnd(2)=0
   gstart=firemode(gunid,firemode).action.start2
   gfinish=firemode(gunid,firemode).action.finish2
   tempani=2
  endif
  if firemode(gunid,firemode).action.start3.s > 0 and rnd(2)=0
   gstart=firemode(gunid,firemode).action.start3
   gfinish=firemode(gunid,firemode).action.finish3
   tempani=3
  endif
 else
  if tfireanim=1
   gstart=firemode(gunid,firemode).action.start
   gfinish=firemode(gunid,firemode).action.finish
  endif
  if tfireanim=2
   gstart=firemode(gunid,firemode).action.start2
   gfinish=firemode(gunid,firemode).action.finish2
  endif
  if tfireanim=3
   gstart=firemode(gunid,firemode).action.start3
   gfinish=firemode(gunid,firemode).action.finish3
  endif
 endif
 `
endif
if gunzoommode <> 0 and firemode(gunid,firemode).settings.simplezoom <> 0 and firemode(gunid,firemode).settings.simplezoomanim <> 0 and firemode(gunid,firemode).settings.isempty=0
 gshow=firemode(gunid,firemode).zoomaction.show
 gidle=firemode(gunid,firemode).zoomaction.idle
 gmove=firemode(gunid,firemode).zoomaction.move` : usingrun=0
 gstart=firemode(gunid,firemode).zoomaction.start
 gautomatic=firemode(gunid,firemode).zoomaction.automatic
 gfinish=firemode(gunid,firemode).zoomaction.finish
 gstartreload=firemode(gunid,firemode).zoomaction.startreload
 greloadloop=firemode(gunid,firemode).zoomaction.reloadloop
 gendreload=firemode(gunid,firemode).zoomaction.endreload
 gcock=firemode(gunid,firemode).zoomaction.cock
 ghide=firemode(gunid,firemode).zoomaction.hide
endif
if gun(gunid).settings.ismelee=2
 if firemode(gunid,firemode).settings.isempty=0 or firemode(gunid,firemode).emptyaction.start.s=0
  if tmeleeanim=0
   gstart=firemode(gunid,firemode).meleeaction.start
   gfinish=firemode(gunid,firemode).meleeaction.finish
   tempmeani=1
   if firemode(gunid,firemode).meleeaction.start2.s > 0 and rnd(2)=0
    gstart=firemode(gunid,firemode).meleeaction.start2
    gfinish=firemode(gunid,firemode).meleeaction.finish2
    tempmeani=2
   endif
   if firemode(gunid,firemode).meleeaction.start3.s > 0 and rnd(2)=0
    gstart=firemode(gunid,firemode).meleeaction.start3
    gfinish=firemode(gunid,firemode).meleeaction.finish3
    tempmeani=3
   endif
  else
   if tmeleeanim=1
    gstart=firemode(gunid,firemode).meleeaction.start
    gfinish=firemode(gunid,firemode).meleeaction.finish
   endif
   if tmeleeanim=2
    gstart=firemode(gunid,firemode).meleeaction.start2
    gfinish=firemode(gunid,firemode).meleeaction.finish2
   endif
   if tmeleeanim=3
    gstart=firemode(gunid,firemode).meleeaction.start3
    gfinish=firemode(gunid,firemode).meleeaction.finish3
   endif
  endif
 else
  if firemode(gunid,firemode).settings.isempty>0
   if tmeleeanim=0
    gstart=firemode(gunid,firemode).emptyaction.start
    gfinish=firemode(gunid,firemode).emptyaction.finish
    tempmeani=1
    if firemode(gunid,firemode).emptyaction.start2.s > 0 and rnd(2)=0
     gstart=firemode(gunid,firemode).emptyaction.start2
     gfinish=firemode(gunid,firemode).emptyaction.finish2
     tempmeani=2
    endif
    if firemode(gunid,firemode).emptyaction.start3.s > 0 and rnd(2)=0
     gstart=firemode(gunid,firemode).emptyaction.start3
     gfinish=firemode(gunid,firemode).emptyaction.finish3
     tempmeani=3
    endif
   else
    if tmeleeanim=1
     gstart=firemode(gunid,firemode).emptyaction.start
     gfinish=firemode(gunid,firemode).emptyaction.finish
    endif
    if tmeleeanim=2
     gstart=firemode(gunid,firemode).emptyaction.start2
     gfinish=firemode(gunid,firemode).emptyaction.finish2
    endif
    if tmeleeanim=3
     gstart=firemode(gunid,firemode).emptyaction.start3
     gfinish=firemode(gunid,firemode).emptyaction.finish3
    endif
   endif
  endif
 endif
 if tempmeani<>0 then tmeleeanim=tempmeani : tempmeani=0
endif

gblock = firemode(gunid,firemode).action.block
rem AirMod - Added for Burst
if gunburst<=0
 gunburst = firemode(gunid,firemode).settings.burst
endif
`
rem gun idle control ((4*0.75)=3.0)

if gunmode=5
 gunmode=6
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gidle.s+3.0
endif
if gunmode=6
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gidle.s+3.0
  gunmode=7
 endif
endif
if gunmode=7
 gunmode=8
 play object currentgunobj,gidle.s+3.0,gidle.e
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
endif
if gunmode=8
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=gidle.e then gunmode=9
endif
if gunmode=9
 gunmode=10
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gidle.s+3.0
endif
if gunmode=10
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gidle.s+3.0
  gunmode=7
 endif
endif

rem gun movment control ((4*0.75)=3.0
if gunmode=21
 gunmode=22
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gmove.s+3.0
endif
if gunmode=22
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gmove.s+3.0
  gunmode=23
 endif
endif
if gunmode>=23 and gunmode<=26
 if movement=0 then gunmode=5
endif
if gunmode=23
 gunmode=24
 play object currentgunobj,gmove.s+3.0,gmove.e
 rem AirMod - for Move animation speed modifier
 if firemode(gunid,firemode).settings.movespeedmod = 0
  set object speed currentgunobj,timeelapsed#*((basespeed#/35)*genericgunanimspeed#)
 else
  set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 endif
endif
if gunmode=24
 rem AirMod - for Move animation speed modifier
 if firemode(gunid,firemode).settings.movespeedmod = 0
  set object speed currentgunobj,timeelapsed#*((basespeed#/35)*genericgunanimspeed#)
 else
  set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 endif
 if object frame(currentgunobj)>=gmove.e then gunmode=25
endif
if gunmode=25
 gunmode=26
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gmove.s+3.0
endif
if gunmode=26
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gmove.s+3.0
  gunmode=23
 endif
endif

rem gun put away and hide control
if gunmode=31 and noholster=1
Rem Scene Commander, clear fired count if holstering
lastfiredtime=0
 gunmode=32
 guninterp=4
 gunselectionlockdown=1
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,ghide.s
 rem play sound of gun select-change
 if gun(gunid).settings.alternate=0 then sndid=gunsound(gunid,4).soundid else sndid=gunsound(gunid,4).altsoundid
 if sndid>0
  if sound exist(sndid)=1
   if sound playing(sndid)=0
    playinternalBC3dsound(sndid,camera position x(),camera position y(),camera position z(),1)
   endif
  endif
 endif
endif
if gunmode=32
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,ghide.s
  rem V111 - 140608 - modifier to adjust gun animation speed based on change from 32fps to 38fps cap
  `set object speed currentgunobj,timeelapsed#*(125.0*0.842)
  set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
  gunmode=33
 endif
endif
if gunmode=33
 gunmode=34
 set object interpolation currentgunobj,100
 play object currentgunobj,ghide.s,ghide.e
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
endif
if gunmode=34
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=ghide.e then gunmode=35
endif
if gunmode=35
 rem V111 - 140608 - modifier to adjust gun animation speed based on change from 32fps to 38fps cap
 `set object speed currentgunobj,timeelapsed#*(75.0*0.842)
 set object speed currentgunobj,timeelapsed#*(genericgunanimspeed#*0.75)
 autoloadgun=gunselectionafterhide
 gunselectionlockdown=0
 gunmode=5
 Rem Scene commander
 if runwhenaway=1
   runwhenaway=2
 endif

endif

rem gun blocking control
if gunmode=1001
 gunmode=1002
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 set object interpolation currentgunobj,100
 play object currentgunobj,gblock.s,gblock.e
 rem v118 - 110511 - cinematic hands (terry cox) >>>>
 `here we check how many times the cinematic hands went through its animation
 `when is through looping then everything necessary is reset
 if cinematichandsloop > 0
     if trackingcinematichandsloop < cinematichandsloop
         trackingcinematichandsloop = trackingcinematichandsloop + 1
     else
         trackingcinematichandsloop = 1 : startcinematichands = 0 : cinematichandsloop = 0
     endif
 endif
 rem cinematic hands <<<<
endif

if gunmode=1002
 if object frame(currentgunobj)>=gblock.e then gunmode=1003
endif
if gunmode=1003
 gunmode=5
 player(1).state.blockingaction=2 `Reset Block
endif

rem melee gun modes
if gunmode=1020
 gunmode=1021
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 set object interpolation currentgunobj,100
 play object currentgunobj,gstart.s,gstart.e
endif
if gunmode=1021
 if object frame(currentgunobj)>=gstart.e then gunmode=1022
endif
if gunmode=1022
 gunmode=1023
 play object currentgunobj,gfinish.s,gfinish.e : gunshoot=1
endif
if gunmode=1023
 if object frame(currentgunobj)>=gfinish.e then gun(gunid).settings.ismelee=0 : gunmode=5 : tmeleeanim=0
endif


Rem Player presses mouse button but has no ammo (avoid model animation freezing)
if gunshootnoammo=1
 if weaponammo(weaponammoindex+ammooffset)>0

 else
  tmouseheld=1
  if gunclick<>1
   if gun(gunid).settings.alternate=0 then sndid=gunsound(gunid,3).soundid else sndid=gunsound(gunid,3).altsoundid
   if sndid>0
    if sound exist(sndid)=1
     if sound playing(sndid)=0
      if firemode(gunid,firemode).settings.equipment=0
       playinternalBC3dsound(sndid,camera position x(),camera position y(),camera position z(),50)
      endif
     endif
    endif
   endif
  endif
  `
 endif
 gunshootnoammo=0
endif
Rem Player presses reload button but has no ammo (avoid model animation freezing)
if gunreloadnoammo=1
   plrreloading=0
 tpool=firemode(gunid,firemode).settings.poolindex
 if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo
 if ammo=0 or gun(gunid).settings.weaponisammo=1
  if gun(gunid).settings.weaponisammo=0
   if gun(gunid).settings.alternate=0 then sndid=gunsound(gunid,3).soundid else sndid=gunsound(gunid,3).altsoundid
   if sndid>0
    if sound exist(sndid)=1
     if sound playing(sndid)=0
      `playinternalBC3dsound(gunsound(gunid,3).soundid,camera position x(),camera position y(),camera position z(),50)
      rem AirMod - Line Modified for Sound Strength
      playinternalBC3dsound(sndid,camera position x(),camera position y(),camera position z(),firemode(gunid,firemode).settings.soundstrength/2)
     endif
    endif
   endif
  endif
 endif
 gunreloadnoammo=0
endif

rem gun firing control (or activate with equipment)
tgunactivateequipment=0
if gunmode=101
 if firemode(gunid,firemode).settings.reloadqty=0 then weaponammo(weaponammoindex+ammooffset)=99999
 rem AirMod - Line Modified for alt Fire
 if weaponammo(weaponammoindex+ammooffset)>0
  gunmode=102
  set object interpolation currentgunobj,100
  tfireanim=tempani
  play object currentgunobj,gstart.s,gstart.e
  set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 else
  if gunclick<>1
   if gun(gunid).settings.alternate=0 then sndid=gunsound(gunid,3).soundid else sndid=gunsound(gunid,3).altsoundid
   if sndid>0
    if sound exist(sndid)=1
     if sound playing(sndid)=0
      if firemode(gunid,firemode).settings.equipment=0
       playinternalBC3dsound(sndid,camera position x(),camera position y(),camera position z(),50)
      endif
     endif
    endif
   endif
   gunmode=107
  endif
 endif
endif
if gunmode=102
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=gstart.e then gunmode=103
endif
if gunmode=103
 gunmode=104
 if firemode(gunid,firemode).settings.equipment=1
  if total object frames(currentgunobj)=0 then tgunactivateequipment=1
 else
  gunflash=1
  gunshoot=1
  guntimercount=firemode(gunid,firemode).settings.firerate/2
 endif
 rem AirMod - Modified for Alt Fire
 weaponammo(weaponammoindex+ammooffset)=weaponammo(weaponammoindex+ammooffset)-1

 rem AirMod - Added for Burst
 dec gunburst,1
 if gun(gunid).settings.brasslimb<>-1 then gunbrass=1 : gunbrasscount=firemode(gunid,firemode).settings.firerate/2 : rem V113 AIRSLIDE 5/8/8 guntimercount=6
 if gun(gunid).settings.smokelimb<>-1 then gunsmoke=1 : gunsmokecount=firemode(gunid,firemode).settings.firerate/2 : rem V113 AIRSLIDE 5/8/8 guntimercount=6

 if firemode(gunid,firemode).settings.equipment=0
  fireloopend=firemode(gunid,firemode).sound.fireloopend
  if gun(gunid).settings.alternate=0
   sndid=gunsound(gunid,1).soundid
  else
   sndid=gunsound(gunid,1).altsoundid
  endif
  if sndid>0
   if sound exist(sndid)=1
    if gautomatic.s>0 and gun(gunid).settings.alternate=0 or gautomatic.s>0 and gun(gunid).settings.alternate=1 and gun(gunid).settings.alternateisray=1
     loop object currentgunobj,gautomatic.s,gautomatic.e
     set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
     play sound sndid,fireloopend : rem some sound bug
     loop sound sndid,0,fireloopend
     gunmodeloopsnd=sndid : gunmodeloopstarted=timer()
     gunmodeloopvolume=100 : set sound volume gunmodeloopsnd,gunmodeloopvolume
    endif
   endif
  endif
 endif
endif
if gunmode=104
 `if weaponammo(weaponammoindex)>0
  `
 Rem create decal particles
 if firemode(gunid,firemode).particle.decal$>""
  if firemode(gunid,firemode).settings.simplezoom <> 0 and gunzoommode <> 0 and firemode(gunid,firemode).settings.simplezoomflash = 1
   x1#=object position x(currentgunobj)+firemode(gunid,firemode).settings.zoommuzzlex#
   y1#=object position y(currentgunobj)+firemode(gunid,firemode).settings.zoommuzzley#
   z1#=object position z(currentgunobj)+firemode(gunid,firemode).settings.zoommuzzlez#
  else
   x1#=object position x(currentgunobj)+firemode(gunid,firemode).settings.muzzlex#
   y1#=object position y(currentgunobj)+firemode(gunid,firemode).settings.muzzley#
   z1#=object position z(currentgunobj)+firemode(gunid,firemode).settings.muzzlez#
  endif
  decalid=firemode(gunid,firemode).particle.id
  `Print firemode(gunid,firemode).particle.id
  `Print x1# : Print y1# : Print z1#
  decalorient=2
  decalx=x1#
  decaly=y1#
  decalz=z1#
  decalscalemodx=100 : decalscalemody=decalscalemodx
  originatore=0 : gosub _decalelement_create
 endif
 if weaponammo(weaponammoindex+ammooffset)>0
  `
  rem lee - 140310 - timer based deductions
  dec gunbrasscount,timeelapsed#
  dec gunsmokecount,timeelapsed#
  dec guntimercount,timeelapsed#
  if gunbrasscount<=0 and gun(gunid).settings.brasslimb<>-1 then gunbrass=1 : gunbrasscount=firemode(gunid,firemode).settings.firerate/2 : rem V113 AIRSLIDE 5/8/8 guntimercount=6
  if gunsmokecount<=0 and gun(gunid).settings.smokelimb<>-1 then gunsmoke=1 : gunsmokecount=firemode(gunid,firemode).settings.firerate/2 : rem V113 AIRSLIDE 5/8/8 guntimercount=6
  if firemode(gunid,firemode).settings.equipment=0
   if gunflash=0 then gunflash=1
   if guntimercount<=0 then gunshoot=1 : guntimercount=firemode(gunid,firemode).settings.firerate/2 : weaponammo(weaponammoindex+ammooffset)=weaponammo(weaponammoindex+ammooffset)-1 : dec gunburst,1 rem rem V113 AIRSLIDE 5/8/8
  endif
  if gautomatic.s=0 or gun(gunid).settings.alternate=1 and gun(gunid).settings.alternateisflak=1 then gunmode=105
  if gunclick<>1 and firemode(gunid,firemode).settings.burst < 1 then gunmode=105
  rem AirMod - Added for Burst
  if gunburst < 1 and firemode(gunid,firemode).settings.burst > 0 then gunmode=105
  if firemode(gunid,firemode).settings.equipment=0
   `sndid=gunsound(gunid,1).soundid
   if gun(gunid).settings.alternate=0 then sndid=gunsound(gunid,1).soundid else sndid=gunsound(gunid,1).altsoundid
   if sndid>0
    if sound exist(sndid)=1
     position sound sndid,camera position x()/10.0,camera position y()/3.0,camera position z()/10.0
     rem AirMod - Line Modified for Sound Strength Modifier
     broadcast3dsound(camera position x(),camera position y(),camera position z(),firemode(gunid,firemode).settings.soundstrength,-1)
    endif
   endif
  endif
 else
  gunmode=105
  Rem Hockeykid 150212 - reset variable so burst won't attempt to finish upon reloading
  Rem should also stop alt mode from retaining primary burst mode settings
  gunburst=0
 endif
endif
if gunmode=105
 Rem Hockeykid 140212 - Should also work with altisray
 if gautomatic.s>0 and firemode(gunid,firemode).settings.burst < 1 `and gun(gunid).settings.alternate = 0
  rem automatic weapons cannot resume firing right away
 else
  gunmustreleasefirst=1
 endif

 if gfinish.s>0
  gunmode=106
  play object currentgunobj,gfinish.s,gfinish.e
  set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
  if firemode(gunid,firemode).settings.equipment=0
   `sndid=gunsound(gunid,1).soundid
   fireloopend=firemode(gunid,firemode).sound.fireloopend
   if gun(gunid).settings.alternate=0
    sndid=gunsound(gunid,1).soundid
   else
    sndid=gunsound(gunid,1).altsoundid
   endif
   if sndid>0
    if sound exist(sndid)=1
     position sound sndid,camera position x()/10.0,camera position y()/3.0,camera position z()/10.0
     play sound sndid,fireloopend
    endif
   endif
   rem AirMod - Line Modified for Sound Strength Modifier
   broadcast3dsound(camera position x(),camera position y(),camera position z(),firemode(gunid,firemode).settings.soundstrength/2,-1)
  endif
 else
  gunmode=107
 endif
endif
if gunmode=106
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=gfinish.e then gunmode=107
 rem FPGC - detect sound slot 1 triggers, as these are USE actions and should ACTIVATE the equipment
 if firemode(gunid,firemode).settings.equipment=1 and total object frames(currentgunobj)>0
  if gun(gunid).sound.soundframes>0
   for p=0 to gun(gunid).sound.soundframes : rem FPGC - 110809 - was -1
    if gunsounditem(gunid,p).playsound=1
     sndid=gunsound(gunid,gunsounditem(gunid,p).playsound).soundid
     if sndid>0
      if int(gunsounditem(gunid,p).keyframe)=int(object frame(currentgunobj))
       tgunactivateequipment=1
      endif
     endif
    endif
   next p
  endif
 endif
endif

rem scene commander for static weapons
if lockangle<>9999
if camera angle y()<(lockangle-fieldoffire) then rotate camera camera angle x(),(lockangle-fieldoffire),camera angle z()
if camera angle y()>(lockangle+fieldoffire) then rotate camera camera angle x(),(lockangle+fieldoffire),camera angle z()
endif
`
rem FPGC = if equipment being used and LOCKCAMERA flag set, freeze out player
if firemode(gunid,firemode).settings.equipment<>0 and firemode(gunid,firemode).settings.lockcamera=1
 if gunmode>=101 and gunmode<107
  mefrozentype=2 : mefrozen=timer()+100
 endif
endif

`
rem FPSC = focus on entity being activated, or quit the equip-animation early
if firemode(gunid,firemode).settings.equipment<>0 and firemode(gunid,firemode).settings.lockcamera=1
 if gunmode>=101 and gunmode<107
  tstoree=e : tstorete=te
  e=firemode(gunid,firemode).settings.equipmententityelementindex
  if e>0
   tname$=entityelement(e).eleprof.ifused$
   gosub _entity_checkforproximityofactivatename_single
   if foundttte>0
    rem found the entity, so focus camera on it
    precamangx#=camera angle x() : precamangy#=camera angle y()
    point camera entityelement(foundttte).x,entityelement(foundttte).y,entityelement(foundttte).z
    camangx#=camera angle x() : camangy#=camera angle y()
    rotate camera curveangle(camangx#,precamangx#,15.0),curveangle(camangy#,precamangy#,15.0),0
   else
    rem no entity that matches equipment target in proximity, end now
    gunmode=107
   endif
  endif
  e=tstoree : te=tstorete
 endif
endif
`
if gunmode=107
 rem reset to normal
 gunmode=5
 tfireanim=0
 rem auto-reload if no bullets
 `if weaponammo(weaponammoindex)=0
  `if weaponclipammo(weaponammoindex)>0
 tpool=firemode(gunid,firemode).settings.poolindex
 if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo
 if weaponammo(weaponammoindex+ammooffset)=0
  if ammo>0
   rem AirMod - No Auto Reload Feature
   if firemode(gunid,firemode).settings.noautoreload = 0
    gunmode=121
   endif
  endif
 endif
 rem if equipment, reset freeze if any
 if firemode(gunid,firemode).settings.equipment<>0 and firemode(gunid,firemode).settings.lockcamera=1
  mefrozentype=0
 endif
endif
`
rem FPGC = equipment activates item at player position, does not fire a weapon
if tgunactivateequipment=1
 tstoree=e : tstorete=te
 e=firemode(gunid,firemode).settings.equipmententityelementindex
 if e>0
  tname$=entityelement(e).eleprof.ifused$
 else
  rem FPGC - 180610 - if no entity (used player start field), default to 'broken' as the name for entities to be activated
  tname$="broken"
 endif
 tstate=1 : tonlyactivateifnearautotoggle=1 : gosub _entity_activatename
 e=tstoree : te=tstorete
 tgunactivateequipment=0
endif
`
rem V109 BETA10 - 120508 - if gunloop sound continues beyond gunfire loop, end it!
if gunmodeloopsnd>0
 if timer()>gunmodeloopstarted+300
  if gunmode<101 or gunmode>107
   if sound exist(gunmodeloopsnd)=1
    if sound playing(gunmodeloopsnd)=1
      Rem Hockeykid - 260210 - changed line to stop sounds from cutting off
      rem FPGC - 160710 - ah but we WANT to cut off the 'loop sound' if its still playing outside 101-107 (the autobit)
      Rem Hockeykid - 270719 - This does just that and sounds a lot better. (I fixed the issue I was having before ;) )
      pause sound gunmodeloopsnd : resume sound gunmodeloopsnd
      `if gunmodeloopvolume>0
       `dec gunmodeloopvolume,2
       `if gunmodeloopvolume<0 then gunmodeloopvolume=0
       `set sound volume gunmodeloopsnd,gunmodeloopvolume
      `else
       `stop sound gunmodeloopsnd
       gunmodeloopsnd=0 : gunmodeloopstarted=0
      `endif
    endif
   endif
  endif
 endif
endif

rem gun reload and cock control
if gunmode=121
 Rem AirMod - Chambered Round >>>
 plrreloading=0
 gunchamber = 0
 if firemode(gunid,firemode).settings.chamberedround>0 then gunchamber = 1
 if weaponammo(weaponammoindex+ammooffset) = 0 then gunchamber = 0
 rem AirMod - Done <<<
 rem AirMod - Disable Simple Zoom on Reload
 if firemode(gunid,firemode).settings.simplezoom <> 0 and gunzoommode <> 0
  if gunzoommode=10 then gunzoommode=11
  if firemode(gunid,firemode).settings.simplezoomanim <> 0 then gunmode = 2005 : goto _gunmode121_cancel
 endif
 if firemode(gunid,firemode).settings.forcezoomout=1 and gunzoommode <> 0 and firemode(gunid,firemode).settings.simplezoom = 0
  if gunzoommode=10 then gunzoommode=11
 endif
 `if weaponclipammo(weaponammoindex)=0 or gun(gunid).settings.weaponisammo=1
 tpool=firemode(gunid,firemode).settings.poolindex
 if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo
 if ammo=0 or gun(gunid).settings.weaponisammo=1
  if gun(gunid).settings.weaponisammo=0
   if gun(gunid).settings.alternate=0 then sndid=gunsound(gunid,3).soundid else sndid=gunsound(gunid,3).altsoundid
   if sndid>0
    if sound exist(sndid)=1
     if sound playing(sndid)=0
      `playinternalBC3dsound(gunsound(gunid,3).soundid,camera position x(),camera position y(),camera position z(),50)
      rem AirMod - Line Modified for Sound Strength
      playinternalBC3dsound(sndid,camera position x(),camera position y(),camera position z(),firemode(gunid,firemode).settings.soundstrength/2)
     endif
    endif
   endif
  endif
  gunmode=5
 else
  gunmode=122
  guninterp=4
  stop object currentgunobj
  set object interpolation currentgunobj,25
  set object frame currentgunobj,gstartreload.s
 endif
endif
rem AirMod - Added for Reload Cancel
_gunmode121_cancel:
if gunmode=122
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gstartreload.s
  `gunmode=123 : rem V113 AIRSLIDE 5/8/8 : shotgun
  if firemode(gunid,firemode).settings.shotgun=1 and firemode(gunid,firemode).settings.isempty=0 or firemode(gunid,firemode).settings.isempty=1 and firemode(gunid,firemode).settings.emptyshotgun=1
   gunmode=700
  else
   gunmode=123
  endif
 endif
endif
`
rem AIRSLIDE SHOTGUN CODE BEGIN
if gunmode = 700
 gunmode = 701
 set object interpolation currentgunobj,100
 play object currentgunobj,gstartreload.s,gstartreload.e
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
endif
if gunmode=701
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
   if object frame(currentgunobj)>=gstartreload.e
   gunmode=703
   endif
endif
if gunmode=703
 play object currentgunobj,greloadloop.s,greloadloop.e
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 gunmode = 7031
endif
if gunmode=7031
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=greloadloop.e then gunmode=702
endif
if gunmode=702 `and object frame(currentgunobj)>=gun(gunid).action.reloadloop.e
 rem actual reload
   plrreloading=0
 tneedfromclip=firemode(gunid,firemode).settings.reloadqty+gunchamber-weaponammo(weaponammoindex+ammooffset)
 if tneedfromclip > 1 then tneedfromclip = 1
 tpool=firemode(gunid,firemode).settings.poolindex
 if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo

 if tneedfromclip>ammo then tneedfromclip=ammo
 if tneedfromclip>0
  weaponammo(weaponammoindex+ammooffset)=weaponammo(weaponammoindex+ammooffset)+tneedfromclip
  if tpool=0 then weaponclipammo(weaponammoindex+ammooffset)=weaponclipammo(weaponammoindex+ammooffset)-tneedfromclip else ammopool(tpool).ammo=ammopool(tpool).ammo-tneedfromclip
  gunmode = 703
  if firemode(gunid,firemode).settings.reloadqty+gunchamber-weaponammo(weaponammoindex+ammooffset) < 1 then gunmode = 7041
  if player(plrid).state.firingmode = 1 then gunmode = 7041
 else
  gunmode = 7041
 endif
 if gunsound(gunid,2).soundid>0
  if sound exist(gunsound(gunid,2).soundid)=1
   position sound gunsound(gunid,2).soundid,camera position x()/10.0,camera position y()/3.0,camera position z()/10.0
  endif
 endif
endif
if gunmode = 7041
 if gunchamber > 0
  gunmode = 706
  else
   gunmode = 704
  endif
endif
if gunmode = 704
 play object currentgunobj,gendreload.s,gcock.e
 gunmode = 705
endif
if gunmode=705
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=gcock.e then gunmode=5:plrreloading=0
endif
if gunmode = 706
 play object currentgunobj,gendreload.s,gendreload.e
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 gunmode = 707
endif
if gunmode=707
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=gendreload.e then gunmode=5 : gun(gunid).settings.ismelee=0
endif
rem AIRSLIDE SHOTGUN CODE END
`
if gunmode=123
 gunmode=124
 set object interpolation currentgunobj,100
 play object currentgunobj,gstartreload.s,gcock.e
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if gunsound(gunid,2).soundid>0
  if sound exist(gunsound(gunid,2).soundid)=1
   position sound gunsound(gunid,2).soundid,camera position x()/10.0,camera position y()/3.0,camera position z()/10.0
  endif
 endif
endif
if gunmode=124
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=gcock.e then gunmode=125
endif
if gunmode=125
 rem actual reload
   plrreloading=0
 tneedfromclip=firemode(gunid,firemode).settings.reloadqty-weaponammo(weaponammoindex+ammooffset)
 if gunchamber = 1 then tneedfromclip = tneedfromclip + 1
 tpool=firemode(gunid,firemode).settings.poolindex
 if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo
 if tneedfromclip>ammo then tneedfromclip=ammo
 if tneedfromclip>0
  weaponammo(weaponammoindex+ammooffset)=weaponammo(weaponammoindex+ammooffset)+tneedfromclip
  if tpool=0 then weaponclipammo(weaponammoindex+ammooffset)=weaponclipammo(weaponammoindex+ammooffset)-tneedfromclip else ammopool(tpool).ammo=ammopool(tpool).ammo-tneedfromclip
 endif
 gun(gunid).settings.ismelee=0
 gunmode=5
endif

rem gun reveal
if gunmode=131
 set object interpolation currentgunobj,100
 set object frame currentgunobj,gshow.s
 play object currentgunobj,gshow.s,gshow.e
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if gunsound(gunid,2).soundid>0
  if sound exist(gunsound(gunid,2).soundid)=1
   position sound gunsound(gunid,2).soundid,camera position x()/10.0,camera position y()/3.0,camera position z()/10.0
  endif
 endif
 gunmode=132
endif
if gunmode=132
 set object speed currentgunobj,timeelapsed#*genericgunanimspeed#
 if object frame(currentgunobj)>=gshow.e then gunmode=5
endif

return

_gun_flash:

if plrzoomin#<>0.0 and firemode(gunid,firemode).settings.simplezoom = 0
 gunflash=0
 rem V109 BETA10 - 120508 - hide muzzle if still visible (quick shot then zoom bug)
 if object visible(hudbankoffset+5)=1 then hide object hudbankoffset+5
 if object visible(hudbankoffset+32)=1 then hide object hudbankoffset+32
endif
rem AirMod - Allow MuzzleFlash to work in Simple Zoom, though should be tweaked later
`if plrzoomin#<>0.0 and gun(gunid).settings.simplezoom = 0 then gunflash=0
if firemode(gunid,firemode).settings.simplezoom <> 0 and gunzoommode <> 0 and firemode(gunid,firemode).settings.simplezoomflash = 1
 position object hudbankoffset+5,firemode(gunid,firemode).settings.zoommuzzlex#+gunlagX#+gunOffsetX#,firemode(gunid,firemode).settings.zoommuzzley#+gunlagY#+gunOffsetY#,firemode(gunid,firemode).settings.zoommuzzlez#
else
 position object hudbankoffset+5,firemode(gunid,firemode).settings.muzzlex#+gunlagX#+gunOffsetX#,firemode(gunid,firemode).settings.muzzley#+gunlagY#+gunOffsetY#,firemode(gunid,firemode).settings.muzzlez#
endif
if gunflash=1
 `
 rem fire flash init
 gunflash=2
 gunflashcount=firemode(gunid,firemode).settings.firerate/2 : rem V113 AIRSLIDE 5/8/8 gunflashcount=6
 rotate object hudbankoffset+5,0,0,rnd(360)
 show object hudbankoffset+5
 if gun(gunid).settings.flashlimb2<>-1
  rotate object hudbankoffset+32,0,0,rnd(360)
  show object hudbankoffset+32
 endif
 `
 rem light flash init
 spotflash=100
 tx#=camera position x()
 ty#=camera position y()
 tz#=camera position z()
 tcolr=firemode(gunid,firemode).settings.muzzlecolorr
 tcolg=firemode(gunid,firemode).settings.muzzlecolorg
 tcolb=firemode(gunid,firemode).settings.muzzlecolorb
 gosub _lighting_spotflash
 `
endif
if gunflash=2
 rem lee - 140310 - timer based deduction
 `if gunflashcount<=4
 firerate=firemode(gunid,firemode).settings.firerate/2
 if gunflashcount<=(firerate)-(timeelapsed#*2) : rem V113 AIRSLIDE 5/8/8 (<=4)
  rem hide early
  hide object hudbankoffset+5
  hide object hudbankoffset+32
 endif
 dec gunflashcount,timeelapsed#
 if gunflashcount<=0
  gunflash=3
 endif
endif
if gunflash=3
 gunflash=0
 gunflashcount=0
 rem final hide
 hide object hudbankoffset+5
 hide object hudbankoffset+32
endif

return

_gun_brass:

rem FPSCV104RC5-twingun
gunbrass2=0 : if gunbrass=1 and gun(gunid).settings.flashlimb2<>-1 then gunbrass2=1

rem find free shell and expell
for o=6 to 20
 obj=hudbankoffset+o
 if object visible(obj)=0 and gunbrass=1
  lx#=limb position x(currentgunobj,gun(gunid).settings.brasslimb)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,gun(gunid).settings.brasslimb)
  lz#=limb position z(currentgunobj,gun(gunid).settings.brasslimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  rotate object obj,0,camera angle y(),0
  `set object to object orientation obj,hudbankoffset+2
  `roll object left obj,25+rnd(10) ` FPGC - 080710 - simplify expelled brass
  `brassfallcount(o)=15
  brassfallcount(o)=0
  show object obj
  gunbrass=0
 endif
 if object visible(obj)=0 and gunbrass=0 and gunbrass2=1
  lx#=limb position x(currentgunobj,gun(gunid).settings.brasslimb2)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,gun(gunid).settings.brasslimb2)
  lz#=limb position z(currentgunobj,gun(gunid).settings.brasslimb2)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  rotate object obj,0,camera angle y(),0
  `set object to object orientation obj,hudbankoffset+2
  `roll object left obj,25+rnd(10) ` FPGC - 080710 - simplify expelled brass
  `brassfallcount(o)=15
  brassfallcount(o)=0
  show object obj
  gunbrass2=0
 endif
next o

return

_gun_brass_indi:
 for o=6 to 20
  obj=hudbankoffset+o
  if object visible(obj)=1
   rem FPGC - 080710 - simplify expelled brass
   brassfallcount(o)=brassfallcount(o)+1
   `if brassfallcount(o)>5
   ` eject#=1.0
   `else
   ` eject#=brassfallcount(o)/5.0
   `endif
   `move object right obj,1.0
   `if object position y(obj)>object position y(hudbankoffset+2)-20
   ` if brassfallcount(o)>0
   `  brassfallcount(o)=brassfallcount(o)-1
   `  roll object right obj,4.0
   ` endif
   `endif
   `position object obj,object position x(obj),object position y(obj)-((1.0-eject#)*1.0),object position z(obj)
   position object obj,object position x(obj),object position y(obj)-((brassfallcount(o)+0.1)/10.0),object position z(obj)
   if object position y(obj)<object position y(hudbankoffset+2)-50 or object in screen(obj)=0
    hide object obj
   endif
  endif
 next o
return

_gun_smoke:

rem FPSCV104RC5-twingun
gunsmoke2=0 : if gunsmoke=1 and gun(gunid).settings.flashlimb2<>-1 then gunsmoke2=1

rem find free smoke and puff
for o=21 to 30
 obj=hudbankoffset+o
 if object visible(obj)=0 and gunsmoke=1
  ttsmokelimb=gun(gunid).settings.smokelimb
  if ttsmokelimb<=0 then ttsmokelimb=gun(gunid).settings.brasslimb
  lx#=limb position x(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)+gunRecoilX#
  smokely#(o)=limb position y(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)+gunRecoilY#`+10.0 : rem V118 - 210211 - compensate for kick-back
  lz#=limb position z(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,smokely#(o),lz#
  show object obj
  gunsmoke=0 : smokeframe=0
 endif
 if object visible(obj)=0 and gunsmoke=0 and gunsmoke2=1
  ttsmokelimb=gun(gunid).settings.smokelimb2
  if ttsmokelimb<=0 then ttsmokelimb=gun(gunid).settings.brasslimb
  lx#=limb position x(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  smokely#(o)=limb position y(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  lz#=limb position z(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,smokely#(o),lz#
  show object obj
  gunsmoke2=0 : smokeframe=0
 endif
 if object visible(obj)=1
  point object obj,camera position x(),camera position y(),camera position z()
  smokerisespeed#=firemode(gunid,firemode).settings.smokespeed/100.0
  position object obj,object position x(obj),object position y(obj)+smokerisespeed#,object position z(obj)
  smokeframe=(object position y(obj)-smokely#(o))/0.75
  if object in screen(obj)=1 and smokeframe<=15
   ty=smokeframe/4
   tx=smokeframe-(ty*4)
   q#=1.0/4.0 : tx#=tx*q# : ty#=ty*q#
   rem vertex data lock mode of 1=update (faster method if mesh size unchanged)
   lock vertexdata for limb obj,0,1
   set vertexdata uv 0,tx#+q#,ty#
   set vertexdata uv 1,tx#,ty#
   set vertexdata uv 2,tx#+q#,ty#+q#
   set vertexdata uv 3,tx#,ty#
   set vertexdata uv 4,tx#,ty#+q#
   set vertexdata uv 5,tx#+q#,ty#+q#
   unlock vertexdata
  else
   hide object obj
  endif
 endif
next o

return

_gun_shoot:

rem when fire line active
if gunshoot=1
 rem AirMod - Recoil
 if gunzoommode <> 0
  xprect# = firemode(gunid,firemode).settings.zoomrecoilxcorrect#/100
  yprect# = firemode(gunid,firemode).settings.zoomrecoilycorrect#/100
 else
  xprect# = firemode(gunid,firemode).settings.recoilxcorrect#/100
  yprect# = firemode(gunid,firemode).settings.recoilycorrect#/100
 endif

 dec xprect#,0.25
 dec yprect#,0.25

 if gunzoommode<>0
  gunRecoilY# = gunRecoilY# + (firemode(gunid,firemode).settings.zoomrecoily#/5) : gunRecoilCorrectY# = gunRecoilCorrectY# + ((firemode(gunid,firemode).settings.zoomrecoily#/5)*(yprect#))
  if rnd(1) = 1
   gunRecoilX# = gunRecoilX# + (firemode(gunid,firemode).settings.zoomrecoilx#/5) : gunRecoilCorrectX# = gunRecoilCorrectX# + ((firemode(gunid,firemode).settings.zoomrecoilx#/5)*(xprect#))
  else
   gunRecoilX# = gunRecoilX# - (firemode(gunid,firemode).settings.zoomrecoilx#/5) : gunRecoilCorrectX# = gunRecoilCorrectX# - ((firemode(gunid,firemode).settings.zoomrecoilx#/5)*(xprect#))
  endif
 else
  gunRecoilY# = gunRecoilY# + (firemode(gunid,firemode).settings.recoily#/5)  : gunRecoilCorrectY# = gunRecoilCorrectY# + ((firemode(gunid,firemode).settings.recoily#/5)*(yprect#))
  if rnd(1) = 1
   gunRecoilX# = gunRecoilX# + (firemode(gunid,firemode).settings.recoilx#/5) : gunRecoilCorrectX# = gunRecoilCorrectX# + ((firemode(gunid,firemode).settings.recoilx#/5)*(xprect#))
  else
   gunRecoilX# = gunRecoilX# - (firemode(gunid,firemode).settings.recoilx#/5) : gunRecoilCorrectX# = gunRecoilCorrectX# - ((firemode(gunid,firemode).settings.recoilx#/5)*(xprect#))
  endif
 endif
 rem AirMod - Line Modified for Alternate Fire
 if firemode(gunid,firemode).settings.flakindex=0 or ((gun(gunid).settings.alternateisflak = 1) and gun(gunid).settings.alternate = 0) or ((gun(gunid).settings.alternateisray = 1) and gun(gunid).settings.alternate = 1) or gun(gunid).settings.ismelee=2

  `
  rem BULLET
  rem gun data controls iterations and accuracy
  trayiter=1+firemode(gunid,firemode).settings.iterate
  Rem Hockeykid - 010410 - Swapped to a float to work better with Plystire's accuracy system
  `trayaccuracy=gun(gunid).settings.accuracytempacc#=playeraccmult#
  tempacc#=playeraccmult#
  rem AirMod - Make gun more accurate so bullets don't fly to mars - EDIT: Additionally use simple zoom accuracy if selected
  if gunzoommode<>0 and firemode(gunid,firemode).settings.simplezoom <>0
  `Rem Scene Commander adjusted for player accuracy modification

   trayaccuracy#=firemode(gunid,firemode).settings.simplezoomacc*tempacc#
  else
   if (plrkeySHIFT)=1 and movement<>0 and firemode(gunid,firemode).settings.runaccuracy <> - 1
    trayaccuracy#=firemode(gunid,firemode).settings.runaccuracy*tempacc#
   else
    trayaccuracy#=firemode(gunid,firemode).settings.accuracy*tempacc#
   endif
  endif
  bulletdamage=firemode(gunid,firemode).settings.damage
  if gun(gunid).settings.ismelee=2 then bulletdamage=firemode(gunid,firemode).settings.meleedamage : trayiter=1
  `
  rem Special ZOOMODE kill in multiplayer
  if gmultiplayergame=1
   Rem don't allow a gun using iron sights to use the one shot kill
   if gunzoommode<>0 and firemode(gunid,firemode).settings.simplezoom=0
    bulletdamage=65500
   endif
  endif
  `
  if firemode=0
   if gun(gunid).settings.bulletmod=1 and weaponammo(weaponammoindex)<gun(gunid).settings.bulletamount `and weaponammo(weaponammoindex)>0
    limbnum=bulletlimbs(gun(gunid).settings.bulletlimbstart+weaponammo(weaponammoindex))
    if limbnum>0
     if limb exist(currentgunobj,limbnum)
      for p=0 to weaponammo(weaponammoindex)
       if limb scale x(currentgunobj,limbnum)<>1 then scale limb currentgunobj,limbnum,1,1,1
       show limb currentgunobj,bulletlimbs(gun(gunid).settings.bulletlimbstart+p)
      next p
     endif
    endif
   endif
  endif
  `
  rem for some weapons, blunderbus style five-ray shot
  multiplayerdamagecollected=0

  for traycount=1 to trayiter
   `
   range#=firemode(gunid,firemode).settings.range
   if gun(gunid).settings.ismelee=2 then range#=firemode(gunid,firemode).settings.meleerange
   `
   rem project gun-line-for-shot
   Rem Hockeykid - 010410 - Replaced old accuracy sytem with Plystire's
   x1#=camera position x()
   y1#=camera position y()
   z1#=camera position z()
   position object hudbankoffset+3,x1#,y1#,z1#
   tca#=rnd(360000.0)/1000.0
   tcx#=cos(tca#) : tcy#=sin(tca#)
   tcm#=rnd(trayaccuracy#*1000.0)/1000.0 : tcx#=tcx#*tcm# : tcy#=tcy#*tcm#
   rotate object hudbankoffset+3, camera angle x()+tcy#,camera angle y()+tcx#,camera angle z()
   `move object hudbankoffset+3,gun(gunid).settings.range
   move object hudbankoffset+3,range#
   disable object zdepth hudbankoffset+3
   x2#=object position x(hudbankoffset+3)
   y2#=object position y(hudbankoffset+3)
   z2#=object position z(hudbankoffset+3)
   `
   rem reset bullethit vars
   bullethit=0 : bullethitstatic=0
   tbullethitmaterial=0 : tbullethitflesh=0
   bulletraytype=firemode(gunid,firemode).settings.damagetype
   gunrange#=range#`firemode(gunid,firemode).settings.range
   `
   rem raycastto entity
   gosub _entity_hasbulletrayhit
   `
   rem raycast to surface (bullets path)
   dstwallhit#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
   if dstwallhit#>0
    wallhitx#=checklist fvalue a(6)
    wallhity#=checklist fvalue b(6)
    wallhitz#=checklist fvalue c(6)
    wallhitmaterial=get static collision value()-1
   endif
   `
   rem has bullet hit any entity
   if tcloseste>0 and (dstwallhit#=0 or dstwallhit#>tclosestdist#)

    rem complete rayhit if wall not in way (must come right after _entity_hasbulletrayhit)
    gosub _entity_completerayhit
    `
    rem bulletraytype (1-pierce, 2-shotgun)
    tix#=x#-x1# : tiy#=y#-y1# : tiz#=z#-z1#
    tnorm#=(abs(tix#)+abs(tiy#)+abs(tiz#))/3.0
    tix#=tix#/tnorm# : tiy#=tiy#/tnorm# : tiz#=tiz#/tnorm#
    `
    rem move entity by that direction with some force (non-multiplayer)
    e=bulletrayhit
    if ai entity exist(entityelement(e).obj)
     entityelement(e).darkai.ehit=-1
    endif
    tentid=entityelement(e).bankindex
    if gmultiplayergame=0
     if bulletraytype=2
      tforce#=firemode(gunid,firemode).settings.damage/5.0
     else
      tforce#=firemode(gunid,firemode).settings.damage/30.0
     endif
     rem entity prone to force
     rem V119 - Hockeykid - 090611 - DAI entities should not get forced back when shot
     rem can cause them to get shot over their boundaries
     if entityelement(e).eleprof.isimmobile=0 and ai entity exist(entityelement(e).obj)=0
      rem apply force
      if entityelement(e).eleprof.physics=1
       rem using advanced physics (force is soft if entity destroyed in hit)
       todee=e : tdx#=tix# : tdy#=tiy# : tdz#=tiz# : todefalloff#=0.0
       if entityelement(e).health>0 then todeforce#=tforce#*10.0 else todeforce#=tforce#/10.0
       tpx#=x# : tpy#=y# : tpz#=z# : gosub _ode_applypointforce
      else
       rem using regular force calc
       entityelement(e).force.active=1
       entityelement(e).force.ix=tix#*tforce#
       entityelement(e).force.iy=tiy#*tforce#
       entityelement(e).force.iz=tiz#*tforce#
      endif
     endif
    endif
    if entityprofile(tentid).ischaracter=1
     rem only if character full of red blood (and had health)!
     tbullethitflesh=entityprofile(tentid).bloodscorch
    endif
    bullethit=1
    `
   else
    `
    rem has bullet hit some debris between gun and wall
    if dstwallhit#>0
     tforce#=firemode(gunid,firemode).settings.damage/5.0
     gosub _part_movedebrisifinray
    endif
    `
   endif
   `
   rem had bulletray hit anything solid
   if bulletrayhit>0
    if tbullethitflesh=0
     if bulletrayhitdist#<dstwallhit# then dstwallhit#=0.0
    else
     rem work out size of blood splat based on distance from flesh to surface (0-100)
     t#=abs(dstwallhit#-bulletrayhitdist#)
     if t#<200
      tbullethitflesh=t#/2.0
     else
      dstwallhit#=0.0
     endif
    endif
   endif
   `
   rem wallhit?
   tsoundtrigger=0 : tsoundmaterial=0
   if dstwallhit#>0
    rem flag the creation of a scorch for the solid surface
    x#=wallhitx# : y#=wallhity# : z#=wallhitz#
    `if wallhitmaterial>=1 and wallhitmaterial<=4 then tbullethitmaterial=wallhitmaterial : rem FPSCV101 - fix
    if wallhitmaterial>=1 then tbullethitmaterial=wallhitmaterial
    bullethitstatic=1 : bullethit=1
    rem trigger a sound for this material type (1-stone/4-glass)
    if wallhitmaterial>=0
     tmatindex=wallhitmaterial
     `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
     if tmatindex>=0 and tmatindex<=gmaterialmax
      tsoundmaterial=1+tmatindex
      tsoundtrigger=material(tmatindex).impactid
      tsx#=wallhitx# : tsy#=wallhity# : tsz#=wallhitz#
      tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
     endif
    endif
   endif
   `
   rem if material sound triggered
   gosub _ode_triggermaterialsound
   gosub _decal_triggermaterialdebris
   `
   rem bullet result
   if bullethit=1
    `
    rem trigger decal for blood splat/whatever effect
    if bulletrayhit>0
     e=bulletrayhit
     tentid=entityelement(e).bankindex
     decalid=entitydecal(tentid,1)
     rem FPSCV101 - decal effect already used
     `rem if no built-in decal, use material of entity
     `if decalid=0
      `if entityprofile(tentid).ischaracter=0
      ` if entityprofile(tentid).materialindex>0
        `tmatindex=entityprofile(tentid).materialindex : rem FPSCV101 - fix
        `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
      `  tmatindex=entityprofile(tentid).materialindex-1
      `  if tmatindex>=0 and tmatindex<=gmaterialmax
      `   decalid=material(tmatindex).decalid
      `  endif
      ` endif
      `endif
     `endif
     if decalid>0
      rem direction from player to entity
      tix#=x2#-x1# : tiy#=y2#-y1# : tiz#=z2#-z1#
      tdd#=sqrt(abs(tix#*tix#)+abs(tiy#*tiy#)+abs(tiz#*tiz#))
      tix#=tix#/tdd# : tiy#=tiy#/tdd# : tiz#=tiz#/tdd#
      rem find point of impact
      tix#=tix#*(bulletrayhitdist#-10.0)
      tiy#=tiy#*(bulletrayhitdist#-10.0)
      tiz#=tiz#*(bulletrayhitdist#-10.0)
      rem create a splat decal
      decalscalemodx=0 : rem FPSCV101 - fix
      decalorient=0 : decalx=x1#+tix# : decaly=y1#+tiy# : decalz=z1#+tiz#
      originatore=-1 : gosub _decalelement_create
     endif
    endif
    `
    rem add scorch if hit universe static polygons
    if bullethitstatic=1
     tscorchtype=firemode(gunid,firemode).settings.scorchtype
     gosub _entity_doscorch
    endif
    `
   endif
   `
  rem repeat ray over
  next traycount
  `
  rem after all rays of shot, deal damage OR missed-shot (multiplayer)
  if gmultiplayergame<>0
   rem inform session when make a shot
   gosub _multi_playershoots
   rem deal damage if collected for character hit
   if multiplayerdamagecollected>0
    rem deal damage to entitycharacter (to multiplayerdamagechar)
    tdamage=multiplayerdamagecollected
    e=multiplayerdamagechar : gosub _entity_deducthealth
   endif
  endif
  `
  rem shot over
  gunshoot=0
  `
 else
  `
  rem FLAK
  rem create-projectile-for-shot
  flakid=firemode(gunid,firemode).settings.flakindex
 ` if gun(gunid).settings.alternateisray = 1 and gun(gunid).settings.alternate = 1 then flakid=0
  if flakid>0
   flakangle=camera angle y() : flakpitch=camera angle x() : flakowner=0
   if gun(gunid).settings.flashlimb<>-1
    flakx=limb position x(hudbankoffset+5,0)
    flaky=limb position y(hudbankoffset+5,0)
    flakz=limb position z(hudbankoffset+5,0)
   else
    flakx=camera position x()+newxvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
    flaky=camera position y()+flak(flakid).throwheight
    flakz=camera position z()+newzvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
    flaky=flaky-(sin(flakpitch)*flak(flakid).throwforward)
   endif
   flakspeed#=1.0
   gosub _flakelement_create
   rem if something blocking launch, explode flak
   texplodeflakinstantly=0
   flakx=flakelement(tf).xpos
   flaky=flakelement(tf).ypos
   flakz=flakelement(tf).zpos
   if static raycast(camerapositionx,camerapositiony,camerapositionz,flakx,flaky,flakz)<>0
    texplodeflakinstantly=1
   endif
   rem intensive scan for solid entity obstacles
   for te=1 to entityelementlist
    if entityelement(te).active=1
     if entityelement(te).obj>0 and entityelement(te).collisionactive=1
      tentid=entityelement(te).bankindex
      if intersect object(entityelement(te).obj,camerapositionx,camerapositiony,camerapositionz,flakx,flaky,flakz)<>0
       texplodeflakinstantly=1 : exit
      endif
     endif
    endif
   next te
   if texplodeflakinstantly=1
    flakelement(tf).profile.weight=0
    flakelement(tf).profile.xinc=0
    flakelement(tf).profile.yinc=0
    flakelement(tf).profile.zinc=0
    flakelement(tf).xpos=camerapositionx
    flakelement(tf).ypos=camerapositiony
    flakelement(tf).zpos=camerapositionz
    gosub _flakelement_explodeinstantly
   endif
  endif
  `
  rem shot over
  gunshoot=0
  `
 endif
endif

return

_gun_soundcontrol:

rem Play sound frames when object frame matches
if gun(gunid).sound.soundframes>0
 for p=0 to gun(gunid).sound.soundframes : rem FPGC - 110809 - was -1
  sndid=gunsound(gunid,gunsounditem(gunid,p).playsound).soundid
  if (gun(gunid).action.automatic.s>0 and gun(gunid).settings.alternate = 0) and p=0 or gun(gunid).altaction.automatic.s>0 and gun(gunid).settings.alternate = 1 and gun(gunid).settings.alternateisray = 1 and p=0 then sndid=0
  if sndid>0
   if int(gunsounditem(gunid,p).keyframe)=int(object frame(currentgunobj))
    if gunsounditem(gunid,p).lastplay=0
     gunsounditem(gunid,p).lastplay=1
     broadcast3dsound(camera position x(),camera position y(),camera position z(),50,-1)
     if sound exist(sndid)=1
      play sound sndid
     endif
    endif
   else
    gunsounditem(gunid,p).lastplay=0
   endif
  endif
 next p
endif

return

`
` Gun Resources
`

_gun_create_hud:

rem Setup HUD Center Marker
make object box hudbankoffset+2,30,100,30
set object collision off hudbankoffset+2
hide object hudbankoffset+2

rem Setup HUD Gun-line Marker (shows impact coord)
make object cube hudbankoffset+3,5
set object collision off hudbankoffset+3
hide object hudbankoffset+3

rem Muzzle Flash(es)
for t=0 to 1
 if t=0 then tobj=hudbankoffset+5
 if t=1 then tobj=hudbankoffset+32
 make object plain tobj,25,25
 set object collision off tobj
 set object transparency tobj,1
 disable object zdepth tobj
 set object ambient tobj,0
 set object light tobj,0
 set object fov tobj,45
 hide object tobj
next t

rem Brass
for o=6 to 20
 obj=hudbankoffset+o
 make object sphere obj,5
 set object collision off obj
 disable object zdepth obj
 hide object obj
next o

rem Smoke
for o=21 to 30
 obj=hudbankoffset+o
 `make object plain obj,20,20 : rem V118 - 210211 - make smoke larger
 make object plain obj,50,50
 set object collision off obj
 disable object zdepth obj
 disable object zwrite obj
 set object transparency obj,1
 set object ambient obj,0
 set object light obj,0
 set object fov obj,45
 hide object obj
next obj

rem crosshair hud object
if gdepthcameraid>0
 rem FPGC - 070710 - replace cross hair with sprite
else
 obj=hudbankoffset+31
 make object cube obj,25
 set object collision off obj
 disable object zdepth obj
 disable object zwrite obj
 lock object on obj
 position object obj,0,0,400
 ghost object on obj
 set object ambient obj,0
 set object light obj,0
 hide object obj
endif

return

_gun_setup:

rem Create common resources for gun
gosub _gun_create_hud

rem Debris
img$="gamecore\debris\debris1.tga"
imgid=loadinternalimage(img$)
for p=1 to 32
 make particles p,imgid,2,20.0
 set particle life p,12.0
 set particle speed p,0.04
 set particle velocity p,5.0
 ghost particles on p,5
 hide particles p
next p

return

_gun_gatherslotorder:

tslotmax=0
gunslotmax=0
dim data$(100)
filename$="..\"+setupfilename$
if file exist(filename$)=0 then debugstring(strarr$(375),filename$)
load array filename$,data$()
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem gather gun type from slot
   for tww=1 to 9
    tryfield$="slot"+str$(tww)
    if field$=tryfield$
     rem find gun id from name
     findgun$=value$
     gosub _gun_findweaponindexbyname
     weaponslot(tww).pref=foundgunid
     if foundgunid>0 then gunslotmax=tww
    endif
   next tww
   `
  endif
 endif
next l
undim data$()

return

_gun_loaddata:

for i=0 to 1
 rem AirMod - Default Zoom Walk & Turn
 firemode(gunid,i).settings.zoomwalkspeed=0.5
 firemode(gunid,i).settings.zoomturnspeed=0.2
 `
 rem AirMod - Default Run Accuracy (No diff)
 firemode(gunid,i).settings.runaccuracy = -1
 rem AirMod - Default Sound Strength
 firemode(gunid,i).settings.soundstrength=100
 `
 Rem Default equipment settings
 firemode(gunid,i).settings.equipment=0
 firemode(gunid,i).settings.equipmententityelementindex=0
 firemode(gunid,i).settings.lockcamera=0
 `
 rem FPGC - reset in case
 firemode(gunid,i).settings.rotx#=0
 firemode(gunid,i).settings.roty#=0
 firemode(gunid,i).settings.rotz#=0
 `
next i
`
gun(gunid).settings.altswapkey1=-1 : gun(gunid).settings.altswapkey2=-1
`
rem AirMod - Extend the Length of Gunspecs to 300
dim data$(300)
filename$="gamecore\"+fpgchuds$+"\"+gun$+"\gunspec.txt"
if file exist(filename$)=0
 rem fpgc - sanitized naming of equipment specification text file
 filename$="gamecore\"+fpgchuds$+"\"+gun$+"\spec.txt"
endif
if file exist(filename$)=1
load array filename$,data$()
addfiletocollection(filename$)
for l=0 to 299
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem GUN SETTINGS

   if field$="weaponisammo" then gun(gunid).settings.weaponisammo=value1
   if field$="melee key" then gun(gunid).settings.meleekey=value1
   Rem This whole section is to easily allow alternate fire mode to use these commands
   for i=0 to 2
    if i=0 then alt$=""
    if i=1 then alt$="alt "
    Rem Allow for no space between "alt" and the rest of the string for backward compatibility with Airmod's old command names
    if i=2 then alt$="alt"
    if i<>2 then x=i else x=1
    rem GUN SETTINGS
      Rem Scene Commander
      if field$=alt$+"gravitygun" then firemode(gunid,x).settings.gravitygun=value1
      if field$=alt$+"magnet" then firemode(gunid,x).settings.magnet=value1
      if field$=alt$+"magnetstrength" then firemode(gunid,x).settings.magnetstrength=value1
      if field$=alt$+"gravitystrength" then firemode(gunid,x).settings.gravitystrength=value1

      if field$=alt$+"emptyreloadonly" then firemode(gunid,x).settings.emptyreloadonly=value1
      if field$=alt$+"jamchance" then firemode(gunid,x).settings.jamchance=value1
      if field$=alt$+"overheatafter" then firemode(gunid,x).settings.shotsbeforejam=value1
      if field$=alt$+"cooldown" then firemode(gunid,x).settings.cooldown=value1
      if field$=alt$+"jamtimer" then firemode(gunid,x).settings.mintimer=value1
      if field$=alt$+"nosubmergedfire" then firemode(gunid,x).settings.nosubmergedfire=value1

      rem Scene Commander end.

    if field$=alt$+"muzzlesize" then firemode(gunid,x).settings.muzzlesize#=value1
    if field$=alt$+"muzzlecolorr" then firemode(gunid,x).settings.muzzlecolorr=value1
    if field$=alt$+"muzzlecolorg" then firemode(gunid,x).settings.muzzlecolorg=value1
    if field$=alt$+"muzzlecolorb" then firemode(gunid,x).settings.muzzlecolorb=value1
    if field$=alt$+"brass" then firemode(gunid,x).settings.brass=value1
    if field$=alt$+"smoke" then firemode(gunid,x).settings.smoke=value1
    if field$=alt$+"smokespeed" then firemode(gunid,x).settings.smokespeed=value1
    if field$=alt$+"smokedecal" then firemode(gunid,x).settings.smokedecal$=value$
    if field$=alt$+"flak" then firemode(gunid,x).settings.flakname$=value$
    if field$=alt$+"reloadqty" then firemode(gunid,x).settings.reloadqty=value1
    if field$=alt$+"iterate" then firemode(gunid,x).settings.iterate=value1
    if field$=alt$+"range" then firemode(gunid,x).settings.range=value1
    if field$=alt$+"accuracy" then firemode(gunid,x).settings.accuracy=value1
    if field$=alt$+"damage" then firemode(gunid,x).settings.damage=value1
    if field$=alt$+"muzzleflash" then firemode(gunid,x).settings.muzzleflash=value1
    if field$=alt$+"firerate" then firemode(gunid,x).settings.firerate=value1
    if field$=alt$+"zoommode" then firemode(gunid,x).settings.zoommode=value1
    if field$=alt$+"zoomaccuracy" then firemode(gunid,x).settings.zoomaccuracy=value1
    if field$=alt$+"zoomscope" then firemode(gunid,x).zoomscope$=value$
    if field$=alt$+"second" then firemode(gunid,x).settings.seconduse=value1
    if field$=alt$+"damagetype" then firemode(gunid,x).settings.damagetype=value1
    if field$=alt$+"scorchtype" then firemode(gunid,x).settings.scorchtype=value1
    if field$=alt$+"melee damage" then firemode(gunid,x).settings.meleedamage=value1
    if field$=alt$+"melee range" then firemode(gunid,x).settings.meleerange=value1
    if field$=alt$+"decal" then firemode(gunid,x).decal$=value$
    if field$=alt$+"shotgun" then firemode(gunid,x).settings.shotgun=value1
    if field$=alt$+"disablerunandshoot" then firemode(gunid,x).settings.disablerunandshoot=value1
    rem AirMod - Burst Fire
    if field$=alt$+"burst" then firemode(gunid,x).settings.burst=value1
    rem AirMod - Move Animation Speed Mod (Default on)
    if field$=alt$+"disablemovespeedmod" then firemode(gunid,x).settings.movespeedmod=value1
    rem AirMod - Chambered Round
    if field$=alt$+"chamberedround" then firemode(gunid,x).settings.chamberedround=value1
    rem AirMod - Auto and Full Reload
    if field$=alt$+"noautoreload" then firemode(gunid,x).settings.noautoreload=value1
    if field$=alt$+"nofullreload" then firemode(gunid,x).settings.nofullreload=value1
    rem AirMod - Run Positioning
    if field$=alt$+"runx" then firemode(gunid,x).settings.runx#=value1
    if field$=alt$+"runy" then firemode(gunid,x).settings.runy#=value1
    if field$=alt$+"runacc" then firemode(gunid,x).settings.runaccuracy=value1
    rem AirMod - No Scorch
    if field$=alt$+"noscorch" then firemode(gunid,x).settings.noscorch=value1
    if field$=alt$+"melee noscorch" then firemode(gunid,x).settings.meleenoscorch=value1
    rem AirMod - Simple Zoom
    if field$=alt$+"simplezoom" then firemode(gunid,x).settings.simplezoom=value1
    if field$=alt$+"simplezoomx" then firemode(gunid,x).settings.simplezoomx#=value1
    if field$=alt$+"simplezoomy" then firemode(gunid,x).settings.simplezoomy#=value1
    if field$=alt$+"simplezoommod" then firemode(gunid,x).settings.simplezoommod=value1
    if field$=alt$+"simplezoomacc" then firemode(gunid,x).settings.simplezoomacc=value1
    if field$=alt$+"simplezoomspeed" then firemode(gunid,x).settings.simplezoomspeed=value1
    if field$=alt$+"simplezoomflash" then firemode(gunid,x).settings.simplezoomflash=value1
    if field$=alt$+"simplezoomanim" then firemode(gunid,x).settings.simplezoomanim=value1
    rem AirMod - Gun Lag
    if field$=alt$+"gunlagspeed" then firemode(gunid,x).settings.gunlagSpeed=value1
    if field$=alt$+"gunlagxmax" then firemode(gunid,x).settings.gunlagXmax=value1
    if field$=alt$+"gunlagymax" then firemode(gunid,x).settings.gunlagYmax=value1
    rem AirMod - Zoom Gun Lag
    if field$=alt$+"zoomgunlagspeed" then firemode(gunid,x).settings.zoomgunlagSpeed=value1
    if field$=alt$+"zoomgunlagxmax" then firemode(gunid,x).settings.zoomgunlagXmax=value1
    if field$=alt$+"zoomgunlagymax" then firemode(gunid,x).settings.zoomgunlagYmax=value1
    rem AirMod - Zoom Walk and Turn Speed
    if field$=alt$+"zoomwalkspeed" then firemode(gunid,x).settings.zoomwalkspeed=value1
    if field$=alt$+"zoomturnspeed" then firemode(gunid,x).settings.zoomturnspeed=value1
    rem AirMod - Sound Strength
    if field$=alt$+"soundstrength" then firemode(gunid,x).settings.soundstrength=value1
    rem AirMod - Gun Recoil
    if field$=alt$+"recoily" then firemode(gunid,x).settings.recoily#=value1
    if field$=alt$+"recoilx" then firemode(gunid,x).settings.recoilx#=value1
    if field$=alt$+"recoilyreturn" then firemode(gunid,x).settings.recoilycorrect#=value1
    if field$=alt$+"recoilxreturn" then firemode(gunid,x).settings.recoilxcorrect#=value1
    rem AirMod - Gun Zoom Recoil
    if field$=alt$+"zoomrecoily" then firemode(gunid,x).settings.zoomrecoily#=value1
    if field$=alt$+"zoomrecoilx" then firemode(gunid,x).settings.zoomrecoilx#=value1
    if field$=alt$+"zoomrecoilyreturn" then firemode(gunid,x).settings.zoomrecoilycorrect#=value1
    if field$=alt$+"zoomrecoilxreturn" then firemode(gunid,x).settings.zoomrecoilxcorrect#=value1
    rem AirMod - Force Zoomout on Reload
    if field$=alt$+"forcezoomout" then firemode(gunid,x).settings.forcezoomout=value1
    Rem AirMod - Maximum Extra Ammo
    if field$=alt$+"ammomax" then firemode(gunid,x).settings.ammomax=value1
    if field$=alt$+"equipment" then firemode(gunid,x).settings.equipment=value1 : rem V115 FPGC 10/6/9
    if field$=alt$+"lockcamera" then firemode(gunid,x).settings.lockcamera=value1 : rem V115 FPGC 10/6/9
    `
    Rem GUN ANIMATIONS
    if field$=alt$+"keyframe ratio"
     if i=0 then keyframeratio=value1 else altkeyframeratio=value1
    endif
      rem Scene Commander animations (based on Cyborg Arts animations)
      if field$=alt$+"fix jam" then firemode(gunid,x).action2.clearjam.s=value1 : firemode(gunid,x).action2.clearjam.e=value2
      if field$=alt$+"hand push" then firemode(gunid,x).action2.handpush.s=value1 : firemode(gunid,x).action2.handpush.e=value2
      if field$=alt$+"hand dead" then firemode(gunid,x).action2.handdead.s=value1 : firemode(gunid,x).action2.handdead.e=value2
      if field$=alt$+"jammed" then firemode(gunid,x).action2.jammed.s=value1 : firemode(gunid,x).action2.jammed.e=value2
      if field$=alt$+"change firemode" then firemode(gunid,x).action2.swaptoalt.s=value1 : firemode(gunid,x).action2.swaptoalt.e=value2
      if field$=alt$+"hand button" then firemode(gunid,x).action2.handbutton.s=value1 : firemode(gunid,x).action2.handbutton.e=value2
      if field$=alt$+"hand take" then firemode(gunid,x).action2.handtake.s=value1 : firemode(gunid,x).action2.handtake.e=value2
      if field$=alt$+"pull up" then firemode(gunid,x).action2.pullup.s=value1 : firemode(gunid,x).action2.pullup.e=value2
      if field$=alt$+"pull down" then firemode(gunid,x).action2.pulldown.s=value1 : firemode(gunid,x).action2.pulldown.e=value2
      if field$=alt$+"pull left" then firemode(gunid,x).action2.pullleft.s=value1 : firemode(gunid,x).action2.pullleft.e=value2
      if field$=alt$+"pull right" then firemode(gunid,x).action2.pullright.s=value1 : firemode(gunid,x).action2.pullright.e=value2
    Rem Normal Animations
    if field$=alt$+"select" then firemode(gunid,x).action.show.s=value1 : firemode(gunid,x).action.show.e=value2
    if field$=alt$+"idle" then firemode(gunid,x).action.idle.s=value1 : firemode(gunid,x).action.idle.e=value2
    if field$=alt$+"move" then firemode(gunid,x).action.move.s=value1 : firemode(gunid,x).action.move.e=value2
    if field$=alt$+"run" then firemode(gunid,x).action.run.s=value1 : firemode(gunid,x).action.run.e=value2
    if field$=alt$+"fire" then firemode(gunid,x).action.start.s=value1 : firemode(gunid,x).action.start.e=value1 : firemode(gunid,x).action.finish.s=value1 : firemode(gunid,x).action.finish.e=value2
    if field$=alt$+"use" then firemode(gunid,x).action.start.s=value1 : firemode(gunid,x).action.start.e=value1 : firemode(gunid,x).action.finish.s=value1 : firemode(gunid,x).action.finish.e=value2
    if field$=alt$+"start fire" then firemode(gunid,x).action.start.s=value1 : firemode(gunid,x).action.start.e=value2
    if field$=alt$+"automatic fire" then firemode(gunid,x).action.automatic.s=value1 : firemode(gunid,x).action.automatic.e=value2
    if field$=alt$+"end fire" then firemode(gunid,x).action.finish.s=value1 : firemode(gunid,x).action.finish.e=value2
    if field$=alt$+"reload"
     firemode(gunid,x).action.startreload.s=value1 : firemode(gunid,x).action.startreload.e=value2
     firemode(gunid,x).action.reloadloop.s=value2 : firemode(gunid,x).action.reloadloop.e=value2
     firemode(gunid,x).action.endreload.s=value2 : firemode(gunid,x).action.endreload.e=value2
    endif
    if field$=alt$+"start reload" then firemode(gunid,x).action.startreload.s=value1 : firemode(gunid,x).action.startreload.e=value2
    if field$=alt$+"reload loop" then firemode(gunid,x).action.reloadloop.s=value1 : firemode(gunid,x).action.reloadloop.e=value2
    if field$=alt$+"end reload" then firemode(gunid,x).action.endreload.s=value1 : firemode(gunid,x).action.endreload.e=value2
    if field$=alt$+"cock" then firemode(gunid,x).action.cock.s=value1 : firemode(gunid,x).action.cock.e=value2
    if field$=alt$+"putaway" then firemode(gunid,x).action.hide.s=value1 : firemode(gunid,x).action.hide.e=value2
    if field$=alt$+"start fire 2" then firemode(gunid,x).action.start2.s=value1 : firemode(gunid,x).action.start2.e=value2
    if field$=alt$+"end fire 2" then firemode(gunid,x).action.finish2.s=value1 : firemode(gunid,x).action.finish2.e=value2
    if field$=alt$+"start fire 3" then firemode(gunid,x).action.start3.s=value1 : firemode(gunid,x).action.start3.e=value2
    if field$=alt$+"end fire 3" then firemode(gunid,x).action.finish3.s=value1 : firemode(gunid,x).action.finish3.e=value2
    Rem Empty Animations
    if field$=alt$+"useempty" then firemode(gunid,x).settings.hasempty=value1
    if field$=alt$+"empty shotgun" then firemode(gunid,x).settings.emptyshotgun=value1
    if field$=alt$+"empty putaway" then firemode(gunid,x).emptyaction.hide.s=value1 : firemode(gunid,x).emptyaction.hide.e=value2
    if field$=alt$+"empty select" then firemode(gunid,x).emptyaction.show.s=value1 : firemode(gunid,x).emptyaction.show.e=value2
    if field$=alt$+"empty idle" then firemode(gunid,x).emptyaction.idle.s=value1 : firemode(gunid,x).emptyaction.idle.e=value2
    if field$=alt$+"empty move" then firemode(gunid,x).emptyaction.move.s=value1 : firemode(gunid,x).emptyaction.move.e=value2
    if field$=alt$+"empty run" then firemode(gunid,x).emptyaction.run.s=value1 : firemode(gunid,x).emptyaction.run.e=value2
    if field$=alt$+"empty start reload" then firemode(gunid,x).emptyaction.startreload.s=value1 : firemode(gunid,x).emptyaction.startreload.e=value2
    if field$=alt$+"empty reload loop" then firemode(gunid,x).emptyaction.reloadloop.s=value1 : firemode(gunid,x).emptyaction.reloadloop.e=value2
    if field$=alt$+"empty end reload" then firemode(gunid,x).emptyaction.endreload.s=value1 : firemode(gunid,x).emptyaction.endreload.e=value2
    if field$=alt$+"empty cock" then firemode(gunid,x).emptyaction.cock.s=value1 : firemode(gunid,x).emptyaction.cock.e=value2
    if field$=alt$+"empty reload"
     firemode(gunid,x).emptyaction.startreload.s=value1 : firemode(gunid,x).emptyaction.startreload.e=value2
     firemode(gunid,x).emptyaction.reloadloop.s=value2 : firemode(gunid,x).emptyaction.reloadloop.e=value2
     firemode(gunid,x).emptyaction.endreload.s=value2 : firemode(gunid,x).emptyaction.endreload.e=value2
    endif
    `
    Rem Melee Animations
    if field$=alt$+"melee start" then firemode(gunid,x).meleeaction.start.s=value1 : firemode(gunid,x).meleeaction.start.e=value2
    if field$=alt$+"melee start 2" then firemode(gunid,x).meleeaction.start2.s=value1 : firemode(gunid,x).meleeaction.start2.e=value2
    if field$=alt$+"melee start 3" then firemode(gunid,x).meleeaction.start3.s=value1 : firemode(gunid,x).meleeaction.start3.e=value2
    if field$=alt$+"melee end" then firemode(gunid,x).meleeaction.finish.s=value1 : firemode(gunid,x).meleeaction.finish.e=value2
    if field$=alt$+"melee end 2" then firemode(gunid,x).meleeaction.finish2.s=value1 : firemode(gunid,x).meleeaction.finish2.e=value2
    if field$=alt$+"melee end 3" then firemode(gunid,x).meleeaction.finish3.s=value1 : firemode(gunid,x).meleeaction.finish3.e=value2
    `
    if field$=alt$+"empty melee start" then firemode(gunid,x).emptyaction.start.s=value1 : firemode(gunid,x).emptyaction.start.e=value2
    if field$=alt$+"empty melee start 2" then firemode(gunid,x).emptyaction.start2.s=value1 : firemode(gunid,x).emptyaction.start2.e=value2
    if field$=alt$+"empty melee start 3" then firemode(gunid,x).emptyaction.start3.s=value1 : firemode(gunid,x).emptyaction.start3.e=value2
    if field$=alt$+"empty melee end" then firemode(gunid,x).emptyaction.finish.s=value1 : firemode(gunid,x).emptyaction.finish.e=value2
    if field$=alt$+"empty melee end 2" then firemode(gunid,x).emptyaction.finish2.s=value1 : firemode(gunid,x).emptyaction.finish2.e=value2
    if field$=alt$+"empty melee end 3" then firemode(gunid,x).emptyaction.finish3.s=value1 : firemode(gunid,x).emptyaction.finish3.e=value2
    `
    rem AirMod - Melee Block Move
    if field$="block" then firemode(gunid,x).action.block.s=value1 : firemode(gunid,x).action.block.e=value2
    Rem Zoom Animations
    if field$=alt$+"zoomto" then firemode(gunid,x).zoomaction.show.s=value1 : firemode(gunid,x).zoomaction.show.e=value2
    if field$=alt$+"zoomfrom" then firemode(gunid,x).zoomaction.hide.s=value1 : firemode(gunid,x).zoomaction.hide.e=value2
    if field$=alt$+"zoom start fire" then firemode(gunid,x).zoomaction.start.s=value1 : firemode(gunid,x).zoomaction.start.e=value2
    if field$=alt$+"zoom automatic fire" then firemode(gunid,x).zoomaction.automatic.s=value1 : firemode(gunid,x).zoomaction.automatic.e=value2
    if field$=alt$+"zoom end fire" then firemode(gunid,x).zoomaction.finish.s=value1 : firemode(gunid,x).zoomaction.finish.e=value2
    if field$=alt$+"zoom idle" then firemode(gunid,x).zoomaction.idle.s=value1 : firemode(gunid,x).zoomaction.idle.e=value2
    if field$=alt$+"zoom move" then firemode(gunid,x).zoomaction.move.s=value1 : firemode(gunid,x).zoomaction.move.e=value2
    `
    rem GUN SOUNDS
    if field$=alt$+"fireloop" then firemode(gunid,x).sound.fireloopend=value1
    `
    rem GUN AND MUZZLE ALIGNMENT
    if field$=alt$+"horiz" then firemode(gunid,x).horiz#=value1
    if field$=alt$+"vert" then firemode(gunid,x).vert#=value1
    if field$=alt$+"forward" then firemode(gunid,x).forward#=value1
    if field$=alt$+"alignx" then firemode(gunid,x).settings.muzzlex#=value1
    if field$=alt$+"aligny" then firemode(gunid,x).settings.muzzley#=value1
    if field$=alt$+"alignz" then firemode(gunid,x).settings.muzzlez#=value1
    if field$=alt$+"zoomalignx" then firemode(gunid,x).settings.zoommuzzlex#=value1
    if field$=alt$+"zoomaligny" then firemode(gunid,x).settings.zoommuzzley#=value1
    if field$=alt$+"zoomalignz" then firemode(gunid,x).settings.zoommuzzlez#=value1
    `
    rem FPGC - rotate locally
    if field$=alt$+"rotx" then firemode(gunid,x).settings.rotx#=value1
    if field$=alt$+"roty" then firemode(gunid,x).settings.roty#=value1
    if field$=alt$+"rotz" then firemode(gunid,x).settings.rotz#=value1
    `
    Rem GUN PARTICLES
    if field$=alt$+"particledecal" then firemode(gunid,x).particle.decal$=value$
    if field$=alt$+"particlespeed" then firemode(gunid,x).particle.velocity=value1
    `
    Rem GUN AMMO POOLING
    if field$=alt$+"poolammo"
     if value$<>""
      poolindex=0 : emptyindex=0
      for y=1 to 100
       if ammopool(y).name$=value$ then poolindex=y : exit
       if ammopool(y).used=0 and emptyindex=0 then emptyindex=y
      next i
      if poolindex=0 then poolindex=emptyindex
      if poolindex>0
       firemode(gunid,x).settings.poolindex=poolindex
       ammopool(poolindex).used=1 : ammopool(poolindex).name$=value$
      endif
     endif
    endif
   next i
   `
   rem AirMod - Alternate Fire
   if field$="alternateisflak" then gun(gunid).settings.alternateisflak=value1
   if field$="alternateisray" then gun(gunid).settings.alternateisray=value1
   if field$="altto" or field$="alt to" then gun(gunid).altaction.to.s=value1 : gun(gunid).altaction.to.e=value2
   if field$="altfrom" or field$="alt from" then gun(gunid).altaction.from.s=value1 : gun(gunid).altaction.from.e=value2

   if field$="switchtoalt"
    gun(gunid).settings.altswapkey1=value1 : gun(gunid).settings.altswapkey2=value2
    if value2=0 then gun(gunid).settings.altswapkey2=-1
   endif
   if field$="addtospare" then gun(gunid).settings.addtospare=value1
   if field$="shareloadedammo" then gun(gunid).settings.modessharemags=value1
   `
   if field$="bullethidemod" then gun(gunid).settings.bulletmod=value1
   if field$="bullethidereset" then gun(gunid).settings.bulletreset=value1
   if field$="bulletlimbtotal" then gun(gunid).settings.bulletlimbsmax=value1
   if field$="bullethidestart"
    gun(gunid).settings.bulletamount=value1
    gun(gunid).settings.currentbullet=value1+1
   endif
   `
   rem GUN VISUALS
   tryfield$="textured"
   if field$=tryfield$ then gun(gunid).texd$=value$
   tryfield$="effect"
   if field$=tryfield$ then gun(gunid).effect$=value$
   tryfield$="transparency"
   if field$=tryfield$ then gun(gunid).transparency=value1
   tryfield$="weapontype"
   if field$=tryfield$ then gun(gunid).weapontype=value1
   `
   rem GUN SOUNDS
   rem AirMod - Extended to 15 different sounds
   for p=1 to 14
    tryfield$="sound"+str$(p)
    if field$=tryfield$ then gunsound(gunid,p).name$=value$
   next p
   for p=1 to 4
    tryfield$="altsound"+str$(p) : tryfield2$="alt sound"+str$(p)
    if p<>2
     if field$=tryfield$ or field$=tryfield2$ then gunsound(gunid,p).altname$=value$
    endif
   next p
   `
   rem GUN SOUND FRAMES DATA
   tryfield$="soundframes"
   if field$=tryfield$
    gun(gunid).sound.soundframes=value1
    rem FPGC - 110809 - cap max frames to array size
    Rem Hockeykid - 080710 - No point in capping especially now that we have airmod and requires more sound frames
    `if gun(gunid).sound.soundframes>5 then gun(gunid).sound.soundframes=5
   endif
   if gun(gunid).sound.soundframes>0
    for p=0 to gun(gunid).sound.soundframes
     tryfield$="sframe"+str$(p)
     if field$=tryfield$
      gunsounditem(gunid,p).keyframe=(value1*keyframeratio)
      rem FPGC - 110809 - array limit is five
      Rem Hockeykid - 080710 - No point in capping especially now that we have airmod and requires more sound frames
      `if value2>5 then value2=5
      gunsounditem(gunid,p).playsound=value2
     endif
    next p
   endif
   `
  endif
 endif

next l
undim data$()
endif



Rem No run animations
for i=0 to 1
 if firemode(gunid,i).action.run.e=0 then firemode(gunid,i).action.run=firemode(gunid,i).action.move
 if firemode(gunid,i).zoomaction.run.e=0 then firemode(gunid,i).zoomaction.run=firemode(gunid,i).zoomaction.move
 `
 rem If no COCK animation, fill with end of reload data
 if firemode(gunid,i).action.cock.e=0
  firemode(gunid,i).action.cock.s=firemode(gunid,i).action.endreload.e
  firemode(gunid,i).action.cock.e=firemode(gunid,i).action.endreload.e
 endif
 `
 Rem fill empty animations if no animation found
 if firemode(gunid,i).emptyaction.hide.e=0 then firemode(gunid,i).emptyaction.hide=firemode(gunid,i).action.hide
 if firemode(gunid,i).emptyaction.show.e=0 then firemode(gunid,i).emptyaction.show=firemode(gunid,i).action.show
 if firemode(gunid,i).emptyaction.idle.e=0 then firemode(gunid,i).emptyaction.idle=firemode(gunid,i).action.idle
 if firemode(gunid,i).emptyaction.move.e=0 then firemode(gunid,i).emptyaction.move=firemode(gunid,i).action.move
 if firemode(gunid,i).emptyaction.cock.e=0 and firemode(gunid,i).emptyaction.endreload.e=0 then firemode(gunid,i).emptyaction.cock=firemode(gunid,i).action.cock
 if firemode(gunid,i).emptyaction.startreload.e=0 then firemode(gunid,i).emptyaction.startreload=firemode(gunid,i).action.startreload
 if firemode(gunid,i).emptyaction.reloadloop.e=0 then firemode(gunid,i).emptyaction.reloadloop=firemode(gunid,i).action.reloadloop
 if firemode(gunid,i).emptyaction.endreload.e=0 then firemode(gunid,i).emptyaction.endreload=firemode(gunid,i).action.endreload
 if firemode(gunid,i).emptyaction.run.e=0 then firemode(gunid,i).emptyaction.run=firemode(gunid,i).emptyaction.move

 rem If no COCK animation, fill with end of reload data
 if firemode(gunid,i).emptyaction.cock.e=0 `and gun(gunid).emptyaction.endreload.e>0 and gun(gunid).emptyaction.endreload.e<>gun(gunid).action.endreload.e
  firemode(gunid,i).emptyaction.cock.s=firemode(gunid,i).emptyaction.endreload.e
  firemode(gunid,i).emptyaction.cock.e=firemode(gunid,i).emptyaction.endreload.e
 endif
 `
 rem FPSCV104RC5 if no muzzle colour, go with default
 if firemode(gunid,i).settings.muzzlecolorr=0 and firemode(gunid,i).settings.muzzlecolorg=0 and firemode(gunid,i).settings.muzzlecolorb=0
  firemode(gunid,i).settings.muzzlecolorr=255
  firemode(gunid,i).settings.muzzlecolorg=255
  firemode(gunid,i).settings.muzzlecolorb=0
 endif
 rem FPSCV104RC8 - can set the smoke speed
 if firemode(gunid,i).settings.smokespeed=0
  firemode(gunid,i).settings.smokespeed=25
 endif
 `
 rem V113 AIRSLIDE 5/8/8 : FPSC-AirMod 0.5 - can set rate of fire
 if firemode(gunid,i).settings.firerate=0
  firemode(gunid,i).settings.firerate=12
 endif
 `
 rem FPSCV104RC9
 if firemode(gunid,i).settings.smokedecal$=""
  firemode(gunid,i).settings.smokedecal$="smoke1"
 endif
 `
 rem Find the decal specified
 firemode(gunid,i).decalid=0
 if firemode(gunid,i).decal$<>""
  decal$=firemode(gunid,i).decal$ : gosub _decal_find
  if decalid<0
   decalid=0
  else
   decal(decalid).active=1
   firemode(gunid,i).decalid=decalid
  endif
 endif
 `
 rem Default gun range
 if firemode(gunid,i).settings.range=0 then firemode(gunid,i).settings.range=1000
next i

return

_gun_selectandorload:

rem Load gun if not selected
if gun(gunid).obj=0
 gosub _gun_load
endif

rem Associate gun with player
currentgunobj=gun(gunid).obj

rem Setup gun with muzzle flash image
if gun(gunid).settings.flashlimb<>-1
 texture object hudbankoffset+5,firemode(gunid,0).settings.flashimg
 glue object to limb hudbankoffset+5,hudbankoffset+2,0
 position object hudbankoffset+5,firemode(gunid,0).settings.muzzlex#,firemode(gunid,0).settings.muzzley#,firemode(gunid,0).settings.muzzlez#
 size#=firemode(gunid,0).settings.muzzlesize# : if size#=0.0 then size#=100.0
 scale object hudbankoffset+5,size#,size#,size#
endif
if gun(gunid).settings.flashlimb2<>-1
 texture object hudbankoffset+32,firemode(gunid,0).settings.flashimg
 glue object to limb hudbankoffset+32,hudbankoffset+2,0
 position object hudbankoffset+32,firemode(gunid,0).settings.muzzlex#*-1,firemode(gunid,0).settings.muzzley#,firemode(gunid,0).settings.muzzlez#
 size#=firemode(gunid,0).settings.muzzlesize# : if size#=0.0 then size#=100.0
 scale object hudbankoffset+32,size#,size#,size#
else
 scale object hudbankoffset+32,0,0,0
endif

rem Setup gun with brass models
if gun(gunid).settings.brasslimb<>-1
 for o=6 to 20
  obj=hudbankoffset+o
  if object exist(obj)=1 then delete object obj
  objecteffect(obj)=0
  instance object obj,firemode(gunid,firemode).settings.brassobjmaster
  usingbrass=firemode(gunid,firemode).settings.brass
  set object collision off obj
  disable object zdepth obj
  set object fov obj,45
  hide object obj
 next o
endif

rem Setup gun with smoke images
if gun(gunid).settings.smokelimb<>-1
 for o=21 to 30
  obj=hudbankoffset+o
  texture object obj,firemode(gunid,firemode).settings.smokeimg
  hide object obj
 next o
endif

rem Setup gun with crosshair
if gdepthcameraid>0
 rem FPGC - 070710 - replace cross hair with sprite
 timg=gun(gunid).settings.crosshairimg
 if timg>0
  if image exist(timg)=1
   crosshairx#=(screen width()-image width(timg))/2
   crosshairy#=(screen height()-image height(timg))/2
   set sprite effectmenuimagestart+40,0,2
   sprite effectmenuimagestart+40,crosshairx#,crosshairy#,timg
   ts#=(100.0/147.0)*image width(timg)
   size sprite effectmenuimagestart+40,ts#,ts#
   of#=((image width(timg)-ts#)/2)*-1
   offset sprite effectmenuimagestart+40,of#,of#
  endif
 endif
else
 obj=hudbankoffset+31
 timg=gun(gunid).settings.crosshairimg
 texture object obj,timg
 crosshairx=(screen width()-image width(timg))/2
 crosshairy=(screen height()-image height(timg))/2
 ts#=(100.0/64.0)*image width(timg)
 scale object obj,ts#,ts#,ts#
 show object obj
endif

`rem Second-Handed Weapon Mode
`if gun(gunid).settings.seconduse=1
` currentgunsecondobj=gun(gunid).secondobj
` glue object to limb currentgunsecondobj,hudbankoffset+2,0
` if gun(gunid).settings.flashlimb<>-1
`  texture object hudbankoffset+32,gun(gunid).settings.flashimg
`  glue object to limb hudbankoffset+32,hudbankoffset+2,0
`  position object hudbankoffset+32,gun(gunid).settings.muzzlex#*-1.0,gun(gunid).settings.muzzley#,gun(gunid).settings.muzzlez#
`  size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
`  scale object hudbankoffset+32,size#,size#,size#
` endif
`else
` hide object hudbankoffset+32
`endif

return

_gun_load:

rem Load gun data
gosub _gun_loaddata

rem Load gun models
currentgunobj=loadgun("gamecore\"+fpgchuds$+"\"+gun$+"\HUD.x")
gun(gunid).obj=currentgunobj

rem FPSCV10X - ensure multi-textures in HUD are recorded for final build
nout$=findmaterialtexturesinmodelfile("gamecore\"+fpgchuds$+"\"+gun$+"\HUD.x","gamecore\"+fpgchuds$+"\"+gun$+"\")

rem Set the unique FOV aspect of the gun
set object fov currentgunobj,45

rem Perform scan to determine hotspot markers
flashlimb=-1 : brasslimb=-1 : smokelimb=-1 : handlimb=-1
flashlimb2=-1 : brasslimb2=-1 : smokelimb2=-1

if gun(gunid).settings.bulletmod=1
 gun(gunid).settings.bulletlimbstart=bulletlimbsmax+1
 inc bulletlimbsmax,gun(gunid).settings.bulletlimbsmax
 gun(gunid).settings.bulletlimbend=bulletlimbsmax
 `
 dim bulletlimbs(bulletlimbsmax)
 `
 for p=0 to gun(gunid).settings.bulletlimbsmax
  if gun(gunid).settings.bulletlimbstart+p<=bulletlimbsmax then bulletlimbs(gun(gunid).settings.bulletlimbstart+p)=-1
 next p
endif

perform checklist for object limbs currentgunobj
for c=1 to checklist quantity()
 name$=upper$(checklist string$(c))
 if name$="FIRESPOT" then flashlimb=c-1
 if name$="X3DS_FIRESPOT" then flashlimb=c-1
 if name$="FIRESPOT02" then flashlimb2=c-1
 if name$="BRASS" then brasslimb=c-1
 if name$="X3DS_BRASS" then brasslimb=c-1
 if name$="BRASS02" then brasslimb2=c-1
 if name$="SMOKE" then smokelimb=c-1
 if name$="X3DS_SMOKE" then smokelimb=c-1
 if name$="SMOKE02" then smokelimb2=c-1
 if name$="HAND" then handlimb=c-1
 if name$="X3DS_HAND" then handlimb=c-1
 `
 if gun(gunid).settings.bulletmod=1
  for p=0 to gun(gunid).settings.bulletlimbsmax
   if name$="BULLET"+str$(p) and gun(gunid).settings.bulletlimbstart+p<=bulletlimbsmax then bulletlimbs(gun(gunid).settings.bulletlimbstart+p)=c-1
  next p
 endif
next c

rem Store limbs in limb-data
gun(gunid).settings.flashlimb=flashlimb
gun(gunid).settings.brasslimb=brasslimb
gun(gunid).settings.handlimb=handlimb
rem FPSCV104RC5 - new fields
gun(gunid).settings.smokelimb=smokelimb
gun(gunid).settings.flashlimb2=flashlimb2
gun(gunid).settings.brasslimb2=brasslimb2
gun(gunid).settings.smokelimb2=smokelimb2

rem Determine number of frames per keyframe
if keyframeratio>0
 ratio#=keyframeratio
else
 ratio#=1
endif
rem Determine number of alt frames per keyframe
if altkeyframeratio>0
 altratio#=altkeyframeratio
else
 altratio#=1
endif

rem Adjust animation data based on actual number of keyframes
for i=0 to 1
 if i=1 then ratio#=altratio#
 firemode(gunid,i).action.show.s = firemode(gunid,i).action.show.s * ratio#
 firemode(gunid,i).action.show.e = firemode(gunid,i).action.show.e * ratio#
 firemode(gunid,i).action.idle.s = firemode(gunid,i).action.idle.s * ratio#
 firemode(gunid,i).action.idle.e = firemode(gunid,i).action.idle.e * ratio#
 firemode(gunid,i).action.move.s = firemode(gunid,i).action.move.s * ratio#
 firemode(gunid,i).action.move.e = firemode(gunid,i).action.move.e * ratio#
 firemode(gunid,i).action.start.s = firemode(gunid,i).action.start.s * ratio#
 firemode(gunid,i).action.start.e = firemode(gunid,i).action.start.e * ratio#
 firemode(gunid,i).action.automatic.s = firemode(gunid,i).action.automatic.s * ratio#
 firemode(gunid,i).action.automatic.e = firemode(gunid,i).action.automatic.e * ratio#
 firemode(gunid,i).action.finish.s = firemode(gunid,i).action.finish.s * ratio#
 firemode(gunid,i).action.finish.e = firemode(gunid,i).action.finish.e * ratio#
 firemode(gunid,i).action.startreload.s = firemode(gunid,i).action.startreload.s * ratio#
 firemode(gunid,i).action.startreload.e = firemode(gunid,i).action.startreload.e * ratio#
 firemode(gunid,i).action.reloadloop.s = firemode(gunid,i).action.reloadloop.s * ratio#
 firemode(gunid,i).action.reloadloop.e = firemode(gunid,i).action.reloadloop.e * ratio#
 firemode(gunid,i).action.endreload.s = firemode(gunid,i).action.endreload.s * ratio#
 firemode(gunid,i).action.endreload.e = firemode(gunid,i).action.endreload.e * ratio#
 firemode(gunid,i).action.cock.s = firemode(gunid,i).action.cock.s * ratio#
 firemode(gunid,i).action.cock.e = firemode(gunid,i).action.cock.e * ratio#
 firemode(gunid,i).action.hide.s = firemode(gunid,i).action.hide.s * ratio#
 firemode(gunid,i).action.hide.e = firemode(gunid,i).action.hide.e * ratio#
next i

rem Load Effect (if allowed)
if guseeffectongunsstate=1 and gun(gunid).effect$<>""
 tfile$=gun(gunid).effect$
 debugfilename(tfile$,"effect for gun")
 teffectid=loadinternaleffect(tfile$)
else
 teffectid=0
endif

rem Setup gun model materiual properties
set object diffuse currentgunobj,rgb(255,255,255)
set object ambience currentgunobj,rgb(255,255,255)
set object specular currentgunobj,0
set object emissive currentgunobj,0

rem First Textures are PLATES
if teffectid>0
 `
 rem Load effect textures
 if gun(gunid).transparency>2
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+fpgchud$+"_D.tga" : imgDid=loadinternalimagecompressquality(img$,0,1)
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+fpgchud$+"_N.tga" : imgNid=loadinternalimagecompressquality(img$,0,1)
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+fpgchud$+"_R.tga" : imgRid=loadinternalimagecompressquality(img$,0,1)
 else
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+fpgchud$+"_D.tga" : imgDid=loadinternalimagecompress(img$,5)
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+fpgchud$+"_N.tga" : imgNid=loadinternalimage(img$)
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+fpgchud$+"_R.tga" : imgRid=loadinternalimage(img$)
 endif
 `
 rem Last Texture Image is CUBE
 img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+fpgchud$+"_cube.dds" : imgCUBEid=loadinternalimage(img$)
 if file exist(img$)=1 then load image img$,imgCUBEid,2
 `
 rem Bump Quality
 texture object currentgunobj,0,imgDid
 texture object currentgunobj,1,imgNid
 texture object currentgunobj,2,imgRid
 texture object currentgunobj,3,imgCUBEid
 `
 rem Apply effect to object
 gun(gunid).effectidused=teffectid
 set object effect currentgunobj,teffectid
 objecteffect(currentgunobj)=teffectid
 `
else
 `
 rem Basic Diffuse2 for Gun (and AmmoClip) - if specified in gunspec.txt
 tfile$=gun(gunid).texd$
 if len(tfile$)=0 then tfile$=fpgchud$+"_D2.tga"
 img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 if len(gun(gunid).texd$)>0 and left$(gun(gunid).texd$,1)<>" "
  texture object currentgunobj,imgD2id
 endif
 tfile$="ammo_D2.tga"
 img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 tfile$="scope_D2.tga"
 img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 rem FPSCV104RC10
 tfile$="hand_D2.tga"
 img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 tfile$="supressor_D2.tga"
 img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 `
endif

rem FPGC - 100710 - scan gun folder for extra DDS/JPG/PNG textures and add to files collection
rem for those weapons which specify secondary textures inside the weapon model
tstoreolddir$=get dir$()
set dir "gamecore\"+fpgchuds$+"\"+gun$+"\"
perform checklist for files
for ttc=1 to checklist quantity()
 ttgfile$=lower$(checklist string$(ttc))
 if ttgfile$<>"." and ttgfile$<>".."
  if right$(ttgfile$,4)=".dds" or right$(ttgfile$,4)=".jpg" or right$(ttgfile$,4)=".png"
   addfiletocollection("gamecore\"+fpgchuds$+"\"+gun$+"\"+ttgfile$)
  endif
 endif
next ttc
set dir tstoreolddir$

for i=0 to 1
 rem load in scope if any
 if firemode(gunid,i).zoomscope$<>""
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+firemode(gunid,i).zoomscope$
  firemode(gunid,i).zoomscope=loadinternalimagecompress(img$,5)
  addfiletocollection(img$)
 else
  rem V109 BETA8 - try to load common scope files in case not specified in gunspec
  tzoomscope$="scope_d2.tga"
  img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tzoomscope$
  firemode(gunid,i).zoomscope=loadinternalimagecompress(img$,5)
  if firemode(gunid,i).zoomscope=0
   tzoomscope$="scope.tga"
   img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tzoomscope$
   firemode(gunid,i).zoomscope=loadinternalimagecompress(img$,5)
   if firemode(gunid,i).zoomscope=0
    tzoomscope$="scope1.tga"
    img$="gamecore\"+fpgchuds$+"\"+gun$+"\"+tzoomscope$
    firemode(gunid,i).zoomscope=loadinternalimagecompress(img$,5)
   endif
  endif
 endif
 `
 rem FPGC - rotate gun and fix pivot if GUNSPEC changes it
 if firemode(gunid,i).settings.rotx#<>0 or firemode(gunid,i).settings.roty#<>0 or firemode(gunid,i).settings.rotz#<>0
  set object rotation zyx currentgunobj
  rotate object currentgunobj,firemode(gunid,i).settings.rotx#,firemode(gunid,i).settings.roty#,firemode(gunid,i).settings.rotz#
  fix object pivot currentgunobj
 endif
 `
next i

rem Glue gun to HUD-Gun-Marker
glue object to limb currentgunobj,hudbankoffset+2,0

rem Setup gun for correct visuals (special transparency for after-shadow setting)
if gun(gunid).transparency>2
 set object transparency currentgunobj,gun(gunid).transparency
else
 set object transparency currentgunobj,2
endif
disable object zdepth currentgunobj

rem Setup gun for animation
rem V111 - 140608 - modifier to adjust gun animation speed based on change from 32fps to 38fps cap
`set object speed currentgunobj,(75.0*0.842)
set object speed currentgunobj,timeelapsed#*(genericgunanimspeed#*0.75)
loop object currentgunobj

rem Setup gun with muzzle flash image
for i=0 to 1
 num=firemode(gunid,i).settings.muzzleflash : if num=0 then num=1
 size#=firemode(gunid,i).settings.muzzlesize# : if size#=0.0 then size#=100.0
 muzzleflash$="gamecore\muzzleflash\flash"+str$(num)+".tga"
 imgid=loadmuzzle(muzzleflash$)
 firemode(gunid,i).settings.flashimg=imgid
`
 rem Setup gun with brass models
 num=firemode(gunid,i).settings.brass : if num=0 then num=1
 brass$="gamecore\brass\brass"+str$(num)+"\brass"+str$(num)+".x"
 brassobj=loadbrass(brass$)
 if brassobj=0
  rem leefix - 290308 - v109 - specifying a brass value that does not exist crashes engine
  num=1 : firemode(gunid,i).settings.brass=0
  brass$="gamecore\brass\brass"+str$(num)+"\brass"+str$(num)+".x"
  brassobj=loadbrass(brass$)
 endif
 addfiletocollection("gamecore\brass\brass"+str$(num)+"\brass"+str$(num)+"_D2.dds")
 firemode(gunid,i).settings.brassobjmaster=brassobj

 rem Setup gun with smoke images
 num=firemode(gunid,i).settings.smoke
 if len(firemode(gunid,i).settings.smokedecal$)>0
  smoke$="gamecore\decals\"+firemode(gunid,i).settings.smokedecal$+"\decal.tga"
  imgid=loadsmoke(smoke$)
 else
  if num=0 then num=1
  rem FPSCV04RC9 0- replace smoke1 usage with gunsmoke usage (better visual)
  if num=1
   smoke$="gamecore\decals\gunsmoke\decal.tga"
  else
   smoke$="gamecore\decals\smoke"+str$(num)+"\decal.tga"
  endif
  imgid=loadsmoke(smoke$)
 endif
 firemode(gunid,i).settings.smokeimg=imgid
next i
rem Setup gun with crosshair
crosshair$="gamecore\"+fpgchuds$+"\"+gun$+"\crosshair.tga"
crosshairimage=loadinternalimagecompressquality(crosshair$,5,1)
gun(gunid).settings.crosshairimg=crosshairimage
gun(gunid).secondobj=0

rem Load gun sounds (and companions)
`for p=1 to 5
rem AirMod - Extended to 15
for p=1 to 15
 if gunsound(gunid,p).name$<>""
  rem main sound for player
  snd$="gamecore\"+fpgchuds$+"\"+gun$+"\"+gunsound(gunid,p).name$
  timestampactivity(0,"Loading Sound:"+snd$)
  gunsound(gunid,p).soundid=loadinternalsound(snd$)
  rem FPSCV104RC4 - extra sound value checks in many places
  if gunsound(gunid,p).soundid>0
   if sound exist(gunsound(gunid,p).soundid)=0
    gunsound(gunid,p).soundid=0
   endif
  endif
  rem companion sounds for other weapon sound uses
  if p<=3
   gunsoundcompanion(gunid,p,0).soundid=loadinternalsoundcore(snd$,1)
   gunsoundcompanion(gunid,p,1).soundid=loadinternalsoundcore(snd$,1)
   gunsoundcompanion(gunid,p,2).soundid=loadinternalsoundcore(snd$,1)
  endif
 endif
next p
rem Load gun altsounds
for p=1 to 4
 if p<>2
  snd$="gamecore\"+fpgchuds$+"\"+gun$+"\"+gunsound(gunid,p).altname$
  timestampactivity(0,"Loading Sound:"+snd$)
  gunsound(gunid,p).altsoundid=loadinternalsound(snd$)
  if gunsound(gunid,p).altsoundid>0
   if sound exist(gunsound(gunid,p).altsoundid)=0
    gunsound(gunid,p).altsoundid=0
   endif
  endif
 endif
next p

rem Load HUD image (ammo and weapon selected image)
img$="gamecore\"+fpgchuds$+"\"+gun$+"\hud_icon.tga" : addfiletocollection(img$)
gun(gunid).hudimage=loadinternalimagecompressquality(img$,5,1)

for i=0 to 1
 rem Find and store flak index for later use
 if firemode(gunid,i).settings.flakname$<>""
  flak$=firemode(gunid,i).settings.flakname$ : gosub _flak_findindex
  firemode(gunid,i).settings.flakindex=tindex
  rem V109 BETA10 - 120508 - flag that we are using this flak
  flak(tindex).usedinlevel=1
 endif
next i
return

_gun_freeafterlevel:
 `
 rem Free the old gun
 autoloadgun=0 : gosub _gun_change
 `
return

_gun_scaninall:

rem Scan entire guns folder
gosub _gun_scaninall_ref

rem Load all guns
for gunid=1 to gunmax
 gun$=gun(gunid).name$ : gosub _gun_load
next gunid

return

_gun_scaninall_dataonly:
 for gunid=1 to gunmax
  gun$=gun(gunid).name$ : gosub _gun_loaddata
 next gunid
return


`
` Particles
`


_particles_control:

remstart FPGC - 080701 - never a good idea, removed perminantly
rem Handle any debris
for p=1 to 32
 if debris(p)>0
  if debris(p)<=38 then show particles p
  if debris(p)<=37 then set particle emissions p,0
  debris(p)=debris(p)-1
  if debris(p)=0
   hide particles p
  endif
 endif
next p
remend

return


rem
rem Waypoint Core Functions
rem

`
` Subroutines for waypoint system
`

_waypoint_savedata:

rem Save list
if file exist("mapbank\testmap\map.way")=1 then delete file "mapbank\testmap\map.way"
open to write 1,"mapbank\testmap\map.way"
 rem strands
 write file 1,waypointmax
 if waypointmax>0
  for w=1 to waypointmax
   a=waypoint(w).count : write file 1,a
   a=waypoint(w).start : write file 1,a
   a=waypoint(w).finish : write file 1,a
  next w
 endif
 rem coords
 write file 1,waypointcoordmax
 if waypointcoordmax>0
  for w=1 to waypointcoordmax
   a#=waypointcoord(w).x : write float 1,a#
   a#=waypointcoord(w).y : write float 1,a#
   a#=waypointcoord(w).z : write float 1,a#
   a=waypointcoord(w).link : write file 1,a
   a=waypointcoord(w).index : write file 1,a
  next w
 endif
close file 1

return

_waypoint_loaddata:

rem Free any old
gosub _waypoint_deleteall

rem load list
if file exist(levelmapptah$+"\map.way")=1
 filename$=levelmapptah$+"map.way"
 open to read 1,filename$
  rem strands
  read file 1,waypointmax
  if waypointmax>0
   undim waypoint()
   dim waypoint(waypointmax+1) as waypointtype
   for w=1 to waypointmax
    read file 1,a : waypoint(w).count=a
    read file 1,a : waypoint(w).start=a
    read file 1,a : waypoint(w).finish=a
   next w
  endif
  rem coords
  read file 1,waypointcoordmax
  if waypointcoordmax>0
   undim waypointcoord()
   dim waypointcoord(waypointcoordmax+1) as waypointcoordtype
   for w=1 to waypointcoordmax
    read float 1,a# : waypointcoord(w).x=a#
    read float 1,a# : waypointcoord(w).y=a#
    read float 1,a# : waypointcoord(w).z=a#
    read file 1,a : waypointcoord(w).link=a
    read file 1,a : waypointcoord(w).index=a
   next w
  endif
 close file 1
endif

rem also ensure data is not pointing to larger arrays than we have (old legacy editing rogue data)
if waypointmax>0
 for waypointindex=1 to waypointmax
  if waypoint(waypointindex).count>0
   if waypoint(waypointindex).start>waypointcoordmax or waypoint(waypointindex).finish>waypointcoordmax
    rem waypoint indexes exceed current arrays - diable waypoint
    waypoint(waypointindex).count=0
    waypoint(waypointindex).start=0
    waypoint(waypointindex).finish=0
   endif
  endif
 next waypointindex
 for w=1 to waypointcoordmax
  if waypointcoord(w).link>waypointcoordmax
   waypointcoord(w).link=0
  endif
  if waypointcoord(w).index>waypointmax
   waypointcoord(w).index=0
  endif
 next w
endif

return

_waypoint_recreateobjs:
 for waypointindex=1 to waypointmax
  if waypoint(waypointindex).count>0
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
  endif
 next waypointindex
return

_waypoint_createnew:

rem Create a new waypoint strand (or find empty one)
for tw=1 to waypointmax
 if waypoint(tw).count=0
  waypointindex=tw : exit
 endif
next tw
if tw>waypointmax
 inc waypointmax
 dim waypoint(waypointmax)
 waypointindex=waypointmax
endif
`
rem Do the creatin
waypoint(waypointindex).count=1
inc waypointcoordmax
w=waypointcoordmax
dim waypointcoord(waypointcoordmax)
waypoint(waypointindex).start=w
waypoint(waypointindex).finish=w
waypointcoord(w).x=mx#
waypointcoord(w).y=(gridlayer*100.0)+5
waypointcoord(w).z=mz#
waypointcoord(w).index=waypointindex
`if waypointindex<=10 `odd - 210105
 if gdontcreatewaypointobjects=0
  if waypoint(waypointindex).count>0
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
  endif
 endif
`endif

rem Create highlight sphere for easier selection
if gdontcreatewaypointobjects=0
 if object exist(editorwaypointoffset+0)=0
  make object sphere editorwaypointoffset+0,25
  set object collision off editorwaypointoffset+0
  ghost object on editorwaypointoffset+0
  set object transparency editorwaypointoffset+0,2
  disable object zread editorwaypointoffset+0
  hide object editorwaypointoffset+0
 endif
endif

return

_waypoint_createallobjs:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if gdontcreatewaypointobjects=0
   if waypoint(waypointindex).count>0
    createwaypointobj(obj,waypointindex)
   else
    if object exist(obj)=1 then delete object obj
   endif
  endif
 next waypointindex
return

_waypoint_deleteall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then delete object obj
 next waypointindex
 waypointmax=0
 waypointcoordmax=0
return

_waypoint_hideall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then hide object obj
 next waypointindex
return

_waypoint_showall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then show object obj
 next waypointindex
return

_waypoint_mousemanage:

rem Grid the waypoint coordinate input
mx#=int(mx#/5)*5 : mz#=int(mz#/5)*5

rem Simply find waypoint over cursor
waypointiovercursor=0
waypointindexovercursor=0
for twaypointindex=1 to waypointmax
 if waypoint(twaypointindex).count>0
  tbest#=9999 : tbestwaypointindex=0 : tbestwaypointiovercursor=0
  for w=waypoint(twaypointindex).start to waypoint(twaypointindex).finish
   dx#=abs(mx#-waypointcoord(w).x)
   dz#=abs(mz#-waypointcoord(w).z)
   tdd#=sqrt((dx#*dx#)+(dz#*dz#))
   if tdd#<20 and abs(waypointeditheight#-waypointcoord(w).y)<20
    if tdd#<tbest#
     tbest#=tdd# : tbestwaypointindex=twaypointindex : tbestwaypointiovercursor=w
    endif
   endif
  next w
  if tbest#<9999
   if tbestwaypointiovercursor<>0
    waypointindexovercursor=tbestwaypointindex
    waypointiovercursor=tbestwaypointiovercursor
    exit
   endif
  endif
 endif
next twaypointindex

rem mclickdone is for singlr mouse clicks
mclickdone=0
if mclick=0 then mclickpressed=0
if mclick>0 and mclickpressed=0 then mclickdone=mclick : mclickpressed=1

rem Move existing new waypoint
if mclick>0
 `
 if onedrag=0
  rem Find waypoint
  if waypointiovercursor>0 and waypointindexovercursor>0
   onedrag=waypointiovercursor : onedragmode=mclick : onedragx#=mx# : onedragz#=mz#
   waypointindex=waypointindexovercursor
  endif
 else
  rem Drag waypoint around
  if onedragmode=1 and (mx#<>onedragx# or mz#<>onedragz#)
   w=onedrag
   waypointcoord(w).x=mx#
   waypointcoord(w).y=waypointeditheight#
   waypointcoord(w).z=mz#
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
   rem Drag linked waypoint too
   linkto=waypointcoord(w).link
   if linkto>0
    waypointcoord(linkto).x=mx#
    waypointcoord(linkto).y=waypointeditheight#
    waypointcoord(linkto).z=mz#
    for twayp=1 to waypointmax
     for w=waypoint(twayp).start to waypoint(twayp).finish
      if w=linkto then createwaypointobj(editorwaypointoffset+twayp,twayp)
     next w
    next twayp
   endif
  endif
 endif
else
 rem Release waypoint
 if onedrag>0
  if onedragmode=1
   rem Glue if waypoint is linked to other waypoint
   for twayp=1 to waypointmax
    if twayp<>waypointindex
     for w=waypoint(twayp).start to waypoint(twayp).finish
      clipx1=int(mx#/20)
      clipz1=int(mz#/20)
      clipx2=int(waypointcoord(w).x/20)
      clipz2=int(waypointcoord(w).z/20)
      if clipx1=clipx2 and abs(waypointcoord(w).y-waypointeditheight#)<20 and clipz1=clipz2
       if waypointcoord(w).link=0
        waypointcoord(onedrag).link=w : waypointcoord(w).link=onedrag
        createwaypointobj(editorwaypointoffset+twayp,twayp)
        exit
       endif
      endif
     next w
    endif
   next twayp
  else
   rem Detatch if waypoint is linked
   if waypointcoord(onedrag).link>0
    linkto=waypointcoord(onedrag).link
    waypointcoord(linkto).x=waypointcoord(linkto).x+10
    waypointcoord(linkto).z=waypointcoord(linkto).z+10
    waypointcoord(onedrag).x=waypointcoord(onedrag).x
    waypointcoord(onedrag).z=waypointcoord(onedrag).z
    waypointcoord(onedrag).link=0
    waypointcoord(linkto).link=0
   endif
   for twayp=1 to waypointmax
    for w=waypoint(twayp).start to waypoint(twayp).finish
     if w=onedrag then createwaypointobj(editorwaypointoffset+twayp,twayp) : exit
     if w=linkto then createwaypointobj(editorwaypointoffset+twayp,twayp) : exit
    next w
   next twayp
  endif
 endif
 onedrag=0
endif

rem Delete last waypoint selected
if inputsys.keyshift=1 and mclickdone=2 and waypointiovercursor>0
 rem Delete waypoint
 w=waypointiovercursor
 if w=waypoint(waypointindex).start
  rem delete whole waypoint
  tsize0=0+waypoint(waypointindex).finish-waypoint(waypointindex).start
  tsize1=1+waypoint(waypointindex).finish-waypoint(waypointindex).start
  while w<waypointcoordmax-tsize0
   waypointcoord(w).x=waypointcoord(w+tsize1).x
   waypointcoord(w).y=waypointcoord(w+tsize1).y
   waypointcoord(w).z=waypointcoord(w+tsize1).z
   waypointcoord(w).link=waypointcoord(w+tsize1).link
   waypointcoord(w).index=waypointcoord(w+tsize1).index
   inc w
  endwhile
  for tw=w to w+tsize0
   waypointcoord(tw).x=0
   waypointcoord(tw).y=0
   waypointcoord(tw).z=0
   waypointcoord(tw).link=0
   waypointcoord(tw).index=0
  next tw
  dec waypointcoordmax,tsize1
  w=waypointiovercursor+tsize0
  for twayp=1 to waypointmax
   if twayp<>waypointindex
    if w<waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start-tsize1
    if w<waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish-tsize1
   endif
  next twayp
  rem delete wayppint-sequence itself
  waypoint(waypointindex).count=0
  waypoint(waypointindex).start=0
  waypoint(waypointindex).finish=0
 else
  rem delete node from waypoint
  w=waypointiovercursor
  while w<waypointcoordmax
   waypointcoord(w).x=waypointcoord(w+1).x
   waypointcoord(w).y=waypointcoord(w+1).y
   waypointcoord(w).z=waypointcoord(w+1).z
   waypointcoord(w).link=waypointcoord(w+1).link
   waypointcoord(w).index=waypointcoord(w+1).index
   inc w
  endwhile
  waypointcoord(w).x=0
  waypointcoord(w).y=0
  waypointcoord(w).z=0
  waypointcoord(w).link=0
  waypointcoord(w).index=0
  dec waypointcoordmax
  waypoint(waypointindex).count=waypoint(waypointindex).count-1
  waypoint(waypointindex).finish=waypoint(waypointindex).finish-1
  w=waypointiovercursor
  for twayp=1 to waypointmax
   for tw=waypoint(twayp).start to waypoint(twayp).finish
    if w<waypointcoord(tw).link then waypointcoord(tw).link=waypointcoord(tw).link-1
   next tw
   if twayp<>waypointindex
    if w<waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start-1
    if w<waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish-1
   endif
  next twayp
 endif
 if waypoint(waypointindex).count>0
  createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
 else
  if object exist(editorwaypointoffset+waypointindex)=1
   delete object editorwaypointoffset+waypointindex
  endif
 endif
 waypointiovercursor=0
 mdoubleclick=0
 onedragmode=0
 onedrag=0
endif

rem Insert waypoint at selected
if inputsys.keyshift=1 and mclickdone=1 and waypointiovercursor>0
 w=waypointiovercursor+1
 if w>=waypointcoordmax
  rem at end
  inc waypointcoordmax
  dim waypointcoord(waypointcoordmax)
  w=waypointcoordmax
 else
  rem shuffle
  inc waypointcoordmax
  dim waypointcoord(waypointcoordmax)
  w=waypointcoordmax
  while w>waypointiovercursor+1
   waypointcoord(w).x=waypointcoord(w-1).x
   waypointcoord(w).y=waypointcoord(w-1).y
   waypointcoord(w).z=waypointcoord(w-1).z
   waypointcoord(w).link=waypointcoord(w-1).link
   waypointcoord(w).index=waypointcoord(w-1).index
   dec w
  endwhile
  w=waypointiovercursor+1
 endif
 waypointcoord(w).x=waypointcoord(w-1).x+10
 waypointcoord(w).y=waypointcoord(w-1).y
 waypointcoord(w).z=waypointcoord(w-1).z+10
 waypointcoord(w).link=0
 waypointcoord(w).index=waypointindex
 waypoint(waypointindex).count=waypoint(waypointindex).count+1
 waypoint(waypointindex).finish=waypoint(waypointindex).finish+1
 for twayp=1 to waypointmax
  if twayp<>waypointindex
   if w<=waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start+1
   if w<=waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish+1
  endif
  for tw=waypoint(twayp).start to waypoint(twayp).finish
   if waypointcoord(tw).link>0
    if w<=waypointcoord(tw).link then waypointcoord(tw).link=waypointcoord(tw).link+1
   endif
  next tw
 next twayp
 if waypoint(waypointindex).count>0
  createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
 else
  if object exist(editorwaypointoffset+waypointindex)=1
   delete object editorwaypointoffset+waypointindex
  endif
 endif
 waypointiovercursor=0
 onedragmode=0
 onedrag=0
endif

rem Show selected waypoint
if object exist(editorwaypointoffset+0)=1
 if waypointiovercursor>0
  w=waypointiovercursor
  position object editorwaypointoffset+0,waypointcoord(w).x,waypointcoord(w).y,waypointcoord(w).z
  show object editorwaypointoffset+0
 else
  hide object editorwaypointoffset+0
 endif
endif

return


`
` Function to build waypoint object
`


function createwaypointobj(obj,waypointindex)
if obj<=editorwaypointoffsetmax
 if waypoint(waypointindex).count>0
  polycount=((waypoint(waypointindex).count-1)*2)+(waypoint(waypointindex).count*2)
  makepolymesh(obj,polycount)
  w=waypoint(waypointindex).start
  fwx#=waypointcoord(w).x
  fwy#=waypointcoord(w).y+6
  fwz#=waypointcoord(w).z
  polyindex=0
  diffuse as DWORD
  rem lines
  for w=waypoint(waypointindex).start+1 to waypoint(waypointindex).finish
   wx#=waypointcoord(w).x
   wy#=waypointcoord(w).y+6
   wz#=waypointcoord(w).z
   wa#=atanfull(wx#-fwx#,wz#-fwz#)-90
   pwa#=wa# : fwa#=wa#
   fade#=1.0-(abs(waypointcoord(w).y-waypointeditheight#)/500.0)
   tcolorcycle=waypointcoord(w).index-((waypointcoord(w).index/6)*6)
   if tcolorcycle=0 then diffuse=rgb(0*fade#,0*fade#,155*fade#)
   if tcolorcycle=1 then diffuse=rgb(155*fade#,0,0)
   if tcolorcycle=2 then diffuse=rgb(0,155*fade#,0)
   if tcolorcycle=3 then diffuse=rgb(155*fade#,155*fade#,0)
   if tcolorcycle=4 then diffuse=rgb(155*fade#,0,155*fade#)
   if tcolorcycle=5 then diffuse=rgb(0,155*fade#,155*fade#)
   if w=waypoint(waypointindex).start+1 then lastdiffuse=diffuse
   c1x#=newxvalue(fwx#,fwa#,5) : c1z#=newzvalue(fwz#,fwa#,5) : c1y#=fwy#
   c2x#=newxvalue(fwx#,fwa#,-5) : c2z#=newzvalue(fwz#,fwa#,-5) : c2y#=fwy#
   c3x#=newxvalue(wx#,pwa#,5) : c3z#=newzvalue(wz#,pwa#,5) : c3y#=wy#
   c4x#=newxvalue(wx#,pwa#,-5) : c4z#=newzvalue(wz#,pwa#,-5) : c4y#=wy#
   addpolytomesh(obj,polyindex+0,lastdiffuse,diffuse,diffuse,c1x#,c1y#,c1z#,c3x#,c3y#,c3z#,c4x#,c4y#,c4z#)
   addpolytomesh(obj,polyindex+1,lastdiffuse,lastdiffuse,diffuse,c2x#,c2y#,c2z#,c1x#,c1y#,c1z#,c4x#,c4y#,c4z#)
   fwx#=wx# : fwy#=wy# : fwz#=wz# : fwa#=wa# : lastdiffuse=diffuse : inc polyindex,2
  next w
  rem stars
  for w=waypoint(waypointindex).start to waypoint(waypointindex).finish
   wx#=waypointcoord(w).x
   wy#=waypointcoord(w).y+6
   wz#=waypointcoord(w).z
   if waypointcoord(w).link>0
    if abs(waypointcoord(w).y-waypointeditheight#)<50
     diffuse=rgb(0,255,255)
    else
     diffuse=rgb(0,128,128)
    endif
   else
    if abs(waypointcoord(w).y-waypointeditheight#)<50
     diffuse=rgb(255,255,0)
    else
     diffuse=rgb(255,0,0)
    endif
   endif
   if w=waypoint(waypointindex).start then tsize#=1.5 else tsize#=1.0
   c1x#=newxvalue(wx#,55,8*tsize#) : c1z#=newzvalue(wz#,55,8*tsize#) : c1y#=wy#
   c2x#=newxvalue(wx#,-55,8*tsize#) : c2z#=newzvalue(wz#,-55,8*tsize#) : c2y#=wy#
   c3x#=newxvalue(wx#,180,10*tsize#) : c3z#=newzvalue(wz#,180,10*tsize#) : c3y#=wy#
   c4x#=newxvalue(wx#,235,8*tsize#) : c4z#=newzvalue(wz#,235,8*tsize#) : c4y#=wy#
   c5x#=newxvalue(wx#,125,8*tsize#) : c5z#=newzvalue(wz#,125,8*tsize#) : c5y#=wy#
   c6x#=newxvalue(wx#,0,10*tsize#) : c6z#=newzvalue(wz#,0,10*tsize#) : c6y#=wy#
   addpolytomesh(obj,polyindex+0,diffuse,diffuse,diffuse,c1x#,c1y#,c1z#,c2x#,c2y#,c2z#,c3x#,c3y#,c3z#)
   addpolytomesh(obj,polyindex+1,diffuse,diffuse,diffuse,c4x#,c4y#,c4z#,c5x#,c5y#,c5z#,c6x#,c6y#,c6z#)
   inc polyindex,2
  next w
  finalisepolymesh(obj)
 else
  if object exist(obj)=1 then delete object obj
 endif
endif
endfunction

function makepolymesh(obj,polycount)
 `
 rem Free old memblock
 memblock=1 : if memblock exist(1)=1 then delete memblock 1
 `
 rem Make a Simple Cube Mesh Memblock
 headersize=12 : fvf=338 : vertsize=36 : verts=polycount*3
 memsize=headersize+(vertsize*verts)
 make memblock 1,memsize
 `
 rem Set header info
 write memblock dword 1,0,fvf
 write memblock dword 1,4,vertsize
 write memblock dword 1,8,verts
 `
endfunction

function addpolytomesh(obj,polyindex,diffuse1 as DWORD,diffuse2 as DWORD,diffuse3 as DWORD,x1#,y1#,z1#,x2#,y2#,z2#,x3#,y3#,z3#)
 `
 rem Create vertex data (3 make a triangle polygon)
 diff as DWORD
 memblock=1 : vertsize=36
 for t=0 to 2
  `
  rem Corners of poly
  if t=0 then x#=x1#:y#=y1#:z#=z1# : diff=diffuse1
  if t=1 then x#=x2#:y#=y2#:z#=z2# : diff=diffuse2
  if t=2 then x#=x3#:y#=y3#:z#=z3# : diff=diffuse3
  v=(polyindex*3)+t
  `
  rem Position of vertex in memblock
  pos=12+(v*vertsize)
  `
  rem Create some random vertex data
  nx#=0 : ny#=1.0 : nz#=0
  `
  rem Set vertex position
  write memblock float 1,pos+0,x#
  write memblock float 1,pos+4,y#
  write memblock float 1,pos+8,z#
  `
  rem Set vertex normals
  write memblock float 1,pos+12,nx#
  write memblock float 1,pos+16,ny#
  write memblock float 1,pos+20,nz#
  `
  rem Set vertex diffuse
  write memblock dword 1,pos+24,diff
  `
  rem Set vertex texture UV coords
  write memblock float 1,pos+28,0
  write memblock float 1,pos+32,0
  `
 next t
 `
endfunction

function finalisepolymesh(obj)
 `
 rem Make a new object from the memblock
 if object exist(obj)=1 then delete object obj
 if mesh exist(2)=1 then delete mesh 2
 memblock=1 : make mesh from memblock 2,memblock
 make object obj,2,0 : set object obj,1,0,0,0,0,0,0
 texture object obj,editorimagesoffset+13
 set object transparency obj,2
 set object collision off obj
 disable object zdepth obj
 set object light obj,0
 ghost object on obj
 set object transparency obj,2
 disable object zread obj
 `
endfunction


rem
rem FUNCTIONS FOR LINKING EXES
rem

`
` FUNCTION TO LAUNCH BROWSER
`
function browseropen$(browsemode)

rem this way still used by segment editor
localdesc$=""
if segobjusedforsegeditor=1

 `
 ` FOR SEGMENT EDITOR
 `

 rem Clear result
 resultstring$=""

 rem Store directory
 curdir$=get dir$()

 rem Launch browser in freeze mode
 set dir rootdir$ : set dir ".."

 rem Run if not currently active
 if window exist(browsername$)=0
  execute file browserexe$,"",""
  while window exist(browsername$)=0
   sync
  endwhile
 else
  window to front browsername$
 endif

 rem Trigger it to provide correct cateogory for browse
 filemapname$=browsername$+"(ACTIVE)"
 write filemap value filemapname$,1
 filemapname$=browsername$+"(MODE)"
 write filemap value filemapname$,browsemode
 write filemap string filemapname$,strarr$(42)

 rem Switch this app to processor friendly
 sync off : always active off

 rem Must wait for response..
 filemapname$=browsername$+"(ACTIVE)"
 while read filemap value(filemapname$)<>2
 endwhile

 rem This app must wait for..
 tresult=0
 tresult$=""
 filemapname$=browsername$+"(RESULT)"
 while tresult=0
  if window exist(browsername$)=1
   window to front browsername$
   tresult=read filemap value(filemapname$)
  else
   exit
  endif
 endwhile

 rem Take action based on result
 if tresult=0 then resultstring$=""
 if tresult=1 then resultstring$=read filemap string(filemapname$)
 if tresult=2 then resultstring$=""

 rem Restore primary activity
 window to back browsername$
 window to front
 sync on : always active on : sync

 rem set directory to return string (or restore)
 if len(resultstring$)>0
  tfile$=getfile(resultstring$)
  tpath$=left$(resultstring$,len(resultstring$)-len(tfile$))
  set dir rootdir$ : set dir tpath$
  resultstring$=get dir$()+"\"+tfile$
 else
  set dir curdir$
 endif

else

`
` FOR MAP EDITOR
`

rem Prepare browse type settings
browsetype=browsemode
baseimagepath$=".\editors\gfx\browser\"
if browsetype=1
 browsetitle$=strarr$(43)
 baselib$=""
 baseimage$="all.bmp"
endif
if browsetype=2
 browsetitle$=strarr$(44)
 baselib$="texturebank\"
 baseimage$="texture.bmp"
endif
if browsetype=3
 browsetitle$=strarr$(45)
 baselib$="meshbank\"
 baseimage$="mesh.bmp"
endif
if browsetype=4
 browsetitle$=strarr$(46)
 baselib$="audiobank\"
 baseimage$="audio.bmp"
endif
if browsetype=5
 browsetitle$=strarr$(47)
 baselib$="effectbank\"
 baseimage$="effect.bmp"
endif
if browsetype=6
 browsetitle$=strarr$(48)
 baselib$="segments\"
 baseimage$="segment.bmp"
endif
if browsetype=7
 browsetitle$=strarr$(49)
 baselib$="prefabs\"
 baseimage$="prefab.bmp"
endif
if browsetype=8
 browsetitle$=strarr$(50)
 baselib$="mapbank\"
 baseimage$="map.bmp"
endif
if browsetype=9
 browsetitle$=strarr$(51)
 baselib$="entitybank\"
 baseimage$="entity.bmp"
endif

rem Assign filters to browse types
browseextcount=0
dim browseext$(64)
if browsetype=1
 browseext$(browseextcount+1)=".*"
 inc browseextcount,1
endif
if browsetype=2
 browseext$(browseextcount+1)="tga"
 inc browseextcount,1
endif
if browsetype=3
 browseext$(browseextcount+1)="x"
 inc browseextcount,1
endif
if browsetype=4
 browseext$(browseextcount+1)="wav"
 browseext$(browseextcount+2)="mp3"
 inc browseextcount,2
endif
if browsetype=5
 browseext$(browseextcount+1)="fx"
 inc browseextcount
endif
if browsetype=6
 browseext$(browseextcount+1)="fps"
 inc browseextcount
endif
if browsetype=7
 browseext$(browseextcount+1)="fpp"
 inc browseextcount
endif
if browsetype=8
 browseext$(browseextcount+1)="fpm"
 inc browseextcount
endif
if browsetype=9
 browseext$(browseextcount+1)="fpe"
 inc browseextcount
endif

rem Build extension string (ie .wav,.mp3)
extstring$=""
for t=1 to browseextcount
 if t>1 then extstring$=extstring$+","
 extstring$=extstring$+browseext$(t)
next t

rem Call up browser dialog
set file map string$ 1, 1000, rootdir$+"\"+baselib$
set file map string$ 1, 1256, browsetitle$

rem File Filter
set file map string$ 1, 1768,extstring$

rem Default image if no thumbnail found
set file map string$ 1, 2024, rootdir$+"\"+baseimagepath$+baseimage$

rem Window Title
set file map string$ 1, 2280, browsetitle$

rem Set last location for navigation
if browserfolderhistory$(browsetype)<>""
 set file map string$ 1, 2536, browserfolderhistory$(browsetype)
endif

rem Wait for dialog session to end
set file map dword 1, 800, 1
wait for file map event 1
while get file map dword(1,800)=1
 wait for file map event 1
endwhile

rem localized description of selection
rem V109 BETA7 - 30408 - prevents editor overwriting when click item and change category (from 1768)
`localdesc$=get file map string$( 1, 1768 )
localdesc$=get file map string$( 1, 1256 )

rem return string from browser dialog
set dir rootdir$
resultstring$=get file map string$( 1, 1512 )
if resultstring$<>""
 rem Final return string
 rem Store location as we leave browser
 resultstring$=right$(resultstring$,len(resultstring$)-len(rootdir$+"\"))
 browserfolderhistory$(browsetype)=right$(resultstring$,len(resultstring$)-len(baselib$))
 resultstring$=get dir$()+"\"+resultstring$
else
 rem No return string
endif

rem Seg Or Map Browser version
endif

endfunction resultstring$

`
` FUNCTION TO LAUNCH SEGEDIT (INDEPENDENT TOOL)
`
function segedit$(segeditmode)

rem Clear result
resultstring$=""

rem Store directory
curdir$=get dir$()

rem Launch in freeze mode
set dir rootdir$ : set dir ".."

rem Run if not currently active
if window exist(segeditname$)=0
 execute file segeditexe$,"",""
 while window exist(segeditname$)=0
  sync
 endwhile
else
 window to front segeditname$
endif

endfunction

rem
rem FLAK
rem

_flak_init:

rem V109 BETA10 - 120508 - only load flak data files
`rem Load in all flak
`gosub _flak_scaninall

rem Scan entire flaks folder
gosub _flak_scaninall_ref

rem Load all flak data only
gosub _flak_scaninall_dataonly

rem Start with no flak
flakid=0

return

_flak_initonlyused:

rem V109 BETA10 - 120508 - only load flak that has been flagged
for flakid=1 to flakmax
 flak$=flak(flakid).name$
 if flak(flakid).usedinlevel=1
  gosub _flak_load
 endif
next flakid

return

_flak_loaddata:

flak(flakid).profile.physics=1
flak(flakid).profile.phyweight=100
flak(flakid).profile.collisionmode=5
`
dim data$(100)
filename$="gamecore\flak\"+flak$+"\flakspec.txt"
load array filename$,data$()
addfiletocollection(filename$)
remstart

remend
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem flak START
   if field$="throwangle" then flak(flakid).throwangle=value1
   if field$="throwforward" then flak(flakid).throwforward=value1
   if field$="throwheight" then flak(flakid).throwheight=value1
   `
   rem flak MOVEMENT
   if field$="lifespan" then flak(flakid).profile.lifespan=value1
   if field$="yinc" then flak(flakid).profile.yinc=value1
   if field$="zinc" then flak(flakid).profile.zinc=value1
   if field$="xspeed" then flak(flakid).profile.xspeed=1.0+(value1/1000.0)
   if field$="yspeed" then flak(flakid).profile.yspeed=1.0+(value1/1000.0)
   if field$="zspeed" then flak(flakid).profile.zspeed=1.0+(value1/1000.0)
   if field$="weight" then flak(flakid).profile.weight=value1/1000.0
   if field$="spinx" then flak(flakid).profile.spinx=value1/10.0
   if field$="bounceonhit" then flak(flakid).profile.bounceonhit=value1
   if field$="explodeonhit" then flak(flakid).profile.explodeonhit=value1
   if field$="noexplosion" then flak(flakid).noexplode=value1
   if field$="blood" then flak(flakid).blood=value1
   if field$="stick" then flak(flakid).stick=value1
   if field$="sticklife" then flak(flakid).sticklife=value1
   if field$="damage" then flak(flakid).profile.damage=value1
   `
   rem flak EXPLOSION
   if field$="exponfloor" then flak(flakid).exponfloor$=value$
   if field$="expinair" then flak(flakid).expinair$=value$
   `
   rem flak SOUND
   if field$="sndbounce" then flak(flakid).sound.sndbounce$=value$
   if field$="sndexplode" then flak(flakid).sound.sndexplode$=value$
   `
   if field$="script" then flak(flakid).profile.script$=value$
   if field$="collisionmode" then flak(flakid).profile.collisionmode=value1
   if field$="physics" then flak(flakid).profile.physics=value1
   if field$="phywieght" then flak(flakid).profile.phyweight=value1
   if field$="phyfriction" then flak(flakid).profile.phyfriction=value1
  endif
 endif
next l
undim data$()

rem V109 BETA10 - by default, flak is not used
flak(flakid).usedinlevel=0

return

_flak_load_script:
 aidir$="scriptbank\"
 for flakid=1 to flakmax
  if flak(flakid).profile.script$<>""
   if lower$(right$(flak(flakid).profile.script$,4))<>".fpi" then flak(flakid).profile.script$=flak(flakid).profile.script$+".fpi"
   ai$=flak(flakid).profile.script$
   inc aiindexmaster : aiindex=aiindexmaster
   dim scriptbank$(aiindexmaster) : scriptbank$(aiindex)=ai$
   gosub _ai_load
   flak(flakid).libindex=aiindex
  endif
 next flakid
return

_flak_load:

 rem Load flak data
gosub _flak_loaddata

rem Load flak models
currentflakobj=loadflak("gamecore\flak\"+flak$+"\PROJECTILE.x")
flak(flakid).obj=currentflakobj

if flak(flakid).stick=1
 flak(flakid).stickobj=flakstickbankoffset+(currentflakobj-flakbankoffset)

 if file exist("gamecore\flak\"+flak$+"\stick.x") and file exist("gamecore\flak\"+flak$+"\stick.dbo")=0
  load object "gamecore\flak\"+flak$+"\stick.x",flak(flakid).stickobj
  save object "gamecore\flak\"+flak$+"\stick.dbo",flak(flakid).stickobj
  delete object flak(flakid).stickobj
 endif
 if file exist("gamecore\flak\"+flak$+"\stick.dbo")
  load object "gamecore\flak\"+flak$+"\stick.dbo",flak(flakid).stickobj
  position object flak(flakid).stickobj,-1000,-1000,-1000
 else
  flak(flakid).stick=0
 endif
endif

rem Effect on projectiles
`if guseeffectongunsstate=0 `lee, currently no NORMAL MAPS for projectiles!
if 1
 `
 rem Base texture for fast moving projectiles
 img$="gamecore\flak\"+flak$+"\projectile_D2.tga" : imgD2id=loadinternalimage(img$)
 texture object currentflakobj,imgD2id
 `
 if flak(flakid).stick=1
  img$="gamecore\flak\"+flak$+"\stick_D2.tga" : stickimgD2id=loadinternalimage(img$)
  texture object flak(flakid).stickobj,stickimgD2id
 endif
 `
else
 `
 rem Load Effect
 tfile$="effectbank\BumpCubeReflectAlpha\BumpCubeReflectAlpha.fx"
 debugfilename(tfile$,"effect for flak")
 teffectid=loadinternaleffect(tfile$)
 `
 rem First Textures are PLATES
 img$="gamecore\flak\"+flak$+"\flak_D.tga" : imgDid=loadinternalimage(img$)
 img$="gamecore\flak\"+flak$+"\flak_N.tga" : imgNid=loadinternalimage(img$)
 img$="gamecore\flak\"+flak$+"\flak_R.tga" : imgRid=loadinternalimage(img$)
 `
 rem Last Texture Image is CUBE
 img$="gamecore\flak\"+flak$+"\flak_cube.dds" : imgCUBEid=loadinternalimage(img$)
 if file exist(img$)=1 then load image img$,imgCUBEid,2
 addfiletocollection(img$)
 `
 rem Bump Quality
 texture object currentflakobj,0,imgDid
 texture object currentflakobj,1,imgNid
 texture object currentflakobj,2,imgRid
 texture object currentflakobj,3,imgCUBEid
 `
 rem Apply effect to object
 set object effect currentflakobj,teffectid
 objecteffect(currentflakobj)=teffectid
 `
endif

rem Setup flak for correct visuals
set object transparency currentflakobj,1
disable object zdepth currentflakobj

rem Setup flak for animation
set object speed currentflakobj,45
loop object currentflakobj

rem Find Explosion for this flak
decal$=flak(flakid).exponfloor$ : gosub _decal_find : flak(flakid).exponfloorid=decalid : if decalid>0 then decal(decalid).active=1
decal$=flak(flakid).expinair$ : gosub _decal_find : flak(flakid).expinairid=decalid : if decalid>0 then decal(decalid).active=1

rem Load sounds into bank
flak(flakid).sound.sndbounceid=loadinternalsoundcore("gamecore\flak\"+flak$+"\"+flak(flakid).sound.sndbounce$,1)
flak(flakid).sound.sndexplodeid=loadinternalsoundcore("gamecore\flak\"+flak$+"\"+flak(flakid).sound.sndexplode$,1)

return

_flak_scaninall_ref:

rem Scan entire flaks folder
set dir "gamecore" : flakid=1
empty array filelist$()
buildfilelist("flak","")
set dir ".."
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   rem V109 BETA10 - 120508 - check for projectile replaced with flak text file (always find these)
   if lower$(right$(file$,12))="flakspec.txt"
    if flakid>flakmax
     flakmax=flakid
     dim flak(flakmax) as flaktype
    endif
    flak(flakid).name$=left$(file$,len(file$)-13)
    inc flakid
   endif
  endif
 next chkfile
endif

return

_flak_scaninall_dataonly:
 for flakid=1 to flakmax
  flak$=flak(flakid).name$
  gosub _flak_loaddata
 next flakid
return

_flak_addanynewflaktoexistingdataonlylist:
 `
 rem FPGC - 100710 - typically called when add a new entity (in mapeditor) such as might have
 rem been downloaded from the Game Creator Store (mapeditor NEEDS to know about the flak data now!)
 rem Scan entire flaks folder (again)
 ttstoreolderfolder$=get dir$()
 set dir "gamecore" : flakid=1
 empty array filelist$()
 buildfilelist("flak","")
 set dir ".."
 if array count(filelist$())>0
  for chkfile=0 to array count(filelist$())
   fffile$=filelist$(chkfile)
   if fffile$<>"." and fffile$<>".."
    if lower$(right$(fffile$,12))="flakspec.txt"
     rem scan to make sure this is a new flak item
     ttgotthisone=0
     ttnewflakname$=lower$(left$(fffile$,len(fffile$)-13))
     for ttflakid=1 to flakmax
      if lower$(flak(flakid).name$)=ttnewflakname$ then ttgotthisone=1
     next ttflakid
     if ttgotthisone=0
      rem found a new flak item
      inc flakmax
      flakid=flakmax
      dim flak(flakmax) as flaktype
      flak(flakid).name$=ttnewflakname$
      flak$=flak(flakid).name$
      gosub _flak_loaddata
     endif
    endif
   endif
  next chkfile
 endif
 set dir ttstoreolderfolder$
 `
return

`V109 BETA10 - not needed - do not load ALL flak!
`_flak_scaninall:
`rem Scan entire flaks folder
`gosub _flak_scaninall_ref
`rem Load all flaks
`for flakid=1 to flakmax
` flak$=flak(flakid).name$
` gosub _flak_load
`next flakid
`return

_flak_findindex:
 `tindex=-1
 rem V109 BETA6 - 290408 - this would crash array if no flak found for weapon!
 tindex=0
 for flakid=1 to flakmax
  if flak$=flak(flakid).name$
   tindex=flakid : exit
  endif
 next flakid
return

`
` FLAK ELEMENTS HANDLING
`

_flakelement_create:

rem FPGC - 300710 - duel function weapons in arena mode, should not allow absent flak to proceed
if flak(flakid).obj>0
 for tf=1 to flakelementmax
  if flakelement(tf).active=0 then exit
 next tf
 if tf<flakelementmax
  Rem if flak has a script turn it into an entity
  if flak(flakid).profile.script$<>""
   `
   Rem check to see if we have a free spot for flak
   tflakokay=0
   for i=1 to entityelementlist
    if entityelement(i).isflak>0 and entityelement(i).beenkilled=1 then tflakokay=i : exit
   next i
   `
   rem new entity for flak
   if tflakokay=0
    if entityelementlist+1>entityelementmax or entityelementlist=entityelementmax
     inc entityelementlist : inc entityelementmax : dim entityelement(entityelementmax) as entitytype
     dim entitydebug$(entityelementmax)
    else
     inc entityelementlist
    endif
    rem entity profile data
    if entidmaster+1>entidmastermax or entidmaster=entidmastermax
     inc entidmaster : inc entidmastermax : dim entityprofile(entidmastermax) as entityprofiletype
    else
     inc entidmaster
    endif
    fentid=entidmaster
    felement=entityelementlist
   else
    felement=tflakokay
    fentid=entityelement(e).bankindex
   endif
   `
   rem Create Flak Object
   flakelement(tf).obj=flakelementoffset+tf
   tfobj=flakelement(tf).obj
   if object exist(tfobj)=1 then delete object tfobj : ode destroy object tfobj
   objecteffect(tfobj)=0
   instance object tfobj,flak(flakid).obj
   tfprofobj=entitybankoffset+fentid
   instance object tfprofobj,flak(flakid).obj
   `
   rem Fill in entity details
   ttempe=e : e=felement
   entityelement(e).eleprof.name$="flak "+str$(e)
   entityelement(e).ai.state$="0"
   entityelement(e).obj=tfobj
   entityelement(e).profileobj=tfprofobj
   entityelement(e).isflak=flakid
   entityelement(e).eleprof.explodable=3
   entityelement(e).ai.libindex=flak(flakid).libindex
   entityelement(e).x=flakx
   entityelement(e).y=flaky
   entityelement(e).z=flakz
   Position Object tfobj,flakx,flaky,flakz
   entityelement(e).active=1
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
   `
   Rem Entity Profile details
   entityelement(e).bankindex=fentid
   `entityprofile(fentid).ischaracter=1
   `entityprofile(fentid).physics=flak(flakid).profile.physics
   `entityprofile(fentid).collisionmode=flak(flakid).profile.collisionmode
   `entityprofile(fentid).phyweight=flak(flakid).profile.phyweight
   `entityprofile(fentid).phyfriction=flak(flakid).profile.phyfriction
   entityprofile(fentid).speed=100
   entityprofile(fentid).ischaracter=0 : rem lee - flak entities should not act as characters, they navigate around other characters
   entityprofile(fentid).physics=2 : rem lee - entity controlled object
   entityprofile(fentid).collisionmode=0
   entityprofile(fentid).phyweight=0
   entityprofile(fentid).phyfriction=0
   entityprofile(fentid).phyalways=1 : rem lee - ensure script runs despite distance
   `
   rem copy entity profile details into the eleprof
`   entityelement(e).eleprof.speed=entityprofile(fentid).speed
   entityelement(e).eleprof.speed=entityprofile(entidmaster).speed
   entityelement(e).eleprof.physics=flak(flakid).profile.physics
   entityelement(e).eleprof.phyweight=flak(flakid).profile.phyweight
   entityelement(e).eleprof.phyfriction=flak(flakid).profile.phyfriction
   entityelement(e).eleprof.phyalways=1
   entityelement(e).nofloorlogic=1 : rem lee - cannot be stopped in thin air (viscolmap)
   entityelement(e).nogravity=1 : rem lee - cannot use gravity by default (entities controlled by script)
   `
   rem Mark as "active"
   flakelement(tf).active=-1
   `
   rem Rotate flak correctly
   tempobj=obj : obj=tfobj
   if flakowner=0
    set object to camera orientation tfobj
    entityelement(e).rx=Camera Angle X() : entityelement(e).ry=Camera Angle Y() : entityelement(e).rz=Camera Angle Z()
   else
    rotate object tfobj,flakpitch,flakangle,0
    entityelement(e).rx=flakpitch : entityelement(e).ry=flakangle : entityelement(e).rz=0
   endif
   `
   rem create the entity object
   gosub _entity_createelementasobject
   gosub _ode_setupewithphysics
   obj=tempobj
   `
   rem show flak object
   show object tfobj
   e=ttempe
   `
  else
   rem found free flak element
   flakelement(tf).flakid=flakid
   flakelement(tf).profile=flak(flakid).profile
   rem activate new flak element
   flakelement(tf).active=1
   flakelement(tf).range=0
   flakelement(tf).xpos=flakx
   flakelement(tf).ypos=flaky
   flakelement(tf).zpos=flakz
   flakelement(tf).owner=flakowner
   rem create projectile
   flakelement(tf).obj=flakelementoffset+tf
   tfobj=flakelement(tf).obj
   if object exist(tfobj)=1 then delete object tfobj
   objecteffect(tfobj)=0
   rem instanced objects can't have their own emissve
   `instance object tfobj,flak(flakid).obj
   clone object tfobj,flak(flakid).obj
   rem use ORIENT to get correct rotation and intertias
   if flakowner=0
    set object to camera orientation tfobj
   else
    rotate object tfobj,flakpitch,flakangle,0
   endif
   move object tfobj,flakelement(tf).profile.zinc
   flakelement(tf).profile.xinc=object position x(tfobj)*2
   flakelement(tf).profile.yinc=flakelement(tf).profile.yinc+(object position y(tfobj)*2)
   flakelement(tf).profile.zinc=object position z(tfobj)*2
   flakelement(tf).xpos=flakelement(tf).xpos+(flakelement(tf).profile.xinc*flakspeed#)
   flakelement(tf).ypos=flakelement(tf).ypos+(flakelement(tf).profile.yinc*flakspeed#)
   flakelement(tf).zpos=flakelement(tf).zpos+(flakelement(tf).profile.zinc*flakspeed#)
   position object tfobj,99999,99999,99999

   set object diffuse tfobj,rgb(128,128,128)
   set object ambience tfobj,rgb(255,255,255)
   set object emissive tfobj,0
   set object specular tfobj,0

   rem show flak object
   show object tfobj
  endif
 else
  rem no more free flak
 endif
endif

return

_flakelement_explodeinstantly:
 rem last tick before BANG! (tf from _flakelement_create)
 flakelement(tf).profile.lifespan=1
return

_flakelement_control:

rem update me vars
mex#=camera position x()
mey#=camera position y()
mez#=camera position z()

rem Control all flak activity
for f=1 to flakelementmax
 tobj=flakelement(f).obj
 if flakelement(f).active>0
  Rem Scene commander, track if flak has moved
  flakelement(f).lastx=flakelement(f).xpos
  flakelement(f).lasty=flakelement(f).ypos
  flakelement(f).lastz=flakelement(f).zpos
  if object in screen(tobj) then flaki=f : gosub _lighting_applyflakcolor
 endif
 if flakelement(f).active=1
  rem update flak object (initial so we see starting position of flak)
  tflakid=flakelement(f).flakid
  position object tobj,flakelement(f).xpos,flakelement(f).ypos,flakelement(f).zpos
  xrotate object tobj,object angle x(tobj)+flakelement(f).profile.spinx
  rem affect flak by inertia and gravity
  tmpx1#=flakelement(f).xpos : tmpy1#=flakelement(f).ypos : tmpz1#=flakelement(f).zpos
  flakelement(f).xpos=flakelement(f).xpos+(timeelapsed#*flakelement(f).profile.xinc)
  flakelement(f).ypos=flakelement(f).ypos+(timeelapsed#*flakelement(f).profile.yinc)
  flakelement(f).zpos=flakelement(f).zpos+(timeelapsed#*flakelement(f).profile.zinc)
  txinc#=flakelement(f).profile.xinc-(flakelement(f).profile.xinc/flakelement(f).profile.xspeed)
  flakelement(f).profile.xinc=flakelement(f).profile.xinc-(txinc#*timeelapsed#)
  tyinc#=flakelement(f).profile.yinc-(flakelement(f).profile.yinc/flakelement(f).profile.yspeed)
  flakelement(f).profile.yinc=flakelement(f).profile.yinc-(tyinc#*timeelapsed#)
  tzinc#=flakelement(f).profile.zinc-(flakelement(f).profile.zinc/flakelement(f).profile.zspeed)
  flakelement(f).profile.zinc=flakelement(f).profile.zinc-(tzinc#*timeelapsed#)
  flakelement(f).profile.yinc=flakelement(f).profile.yinc-(flakelement(f).profile.weight*timeelapsed#)
  rem handle flak collision
  tdetonate=0 : tcollide=0
  rem handle timer delay
  if flakelement(f).profile.lifespan>0
   if (flak(tflakid).noexplode=1 and flakelement(f).profile.explodeonhit>0) or flak(tflakid).noexplode=0
    dec flakelement(f).profile.lifespan,timeelapsed#
    if flakelement(f).profile.lifespan<=0
     flakelement(f).profile.lifespan=0
     flakelement(f).preexplode=1
     tdetonate=1
     endoflife=1
    endif
   endif
  endif
  if tdetonate=0
   `
   rem if not zero-life
   if flakelement(f).ypos<0
    flakelement(f).profile.yinc=flakelement(f).profile.yinc*-0.9
    flakelement(f).ypos=0
    tcollide=1
   endif
   `
   tmpx2#=tmpx1#+(flakelement(f).profile.xinc*3.0)
   tmpy2#=tmpy1#+(flakelement(f).profile.yinc*3.0)
   tmpz2#=tmpz1#+(flakelement(f).profile.zinc*3.0)
   if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
    `
    rem checklist now filled with collision feedback data
    flakelement(f).profile.xinc=checklist fvalue a(8)
    flakelement(f).profile.yinc=checklist fvalue b(8)
    flakelement(f).profile.zinc=checklist fvalue c(8)
    flakelement(f).profile.xinc=flakelement(f).profile.xinc*0.4
    flakelement(f).profile.yinc=flakelement(f).profile.yinc*0.6
    flakelement(f).profile.zinc=flakelement(f).profile.zinc*0.4
    flakelement(f).xpos=checklist fvalue a(6)+flakelement(f).profile.xinc
    flakelement(f).ypos=checklist fvalue b(6)+flakelement(f).profile.yinc
    flakelement(f).zpos=checklist fvalue c(6)+flakelement(f).profile.zinc
    tcollide=2
    rem collision bounce requires orientation
    if flakelement(f).profile.bounceonhit>0
     point object tobj,flakelement(f).xpos+(flakelement(f).profile.xinc*10.0),flakelement(f).ypos+(flakelement(f).profile.yinc*10.0),flakelement(f).zpos+(flakelement(f).profile.zinc*10.0)
    endif
    `
    rem kill Y ineria if get too low
    if abs(flakelement(f).profile.yinc)<0.02
     flakelement(f).profile.spinx=0
     flakelement(f).profile.yinc=0
    endif
    `
   endif
   rem collides with entity in area
   spherex#=flakelement(f).xpos
   spherey#=flakelement(f).ypos
   spherez#=flakelement(f).zpos
   spherenx#=spherex#+flakelement(f).profile.xinc
   sphereny#=spherey#+flakelement(f).profile.yinc
   spherenz#=spherez#+flakelement(f).profile.zinc
   gosub _entity_spherecollision
   if spheree<>-1
    if flakelement(f).owner=spheree
     rem owners of flak are excempt
    else
     rem backtrack to leave collision
     flakelement(f).profile.xinc=flakelement(f).profile.xinc*-1
     flakelement(f).profile.zinc=flakelement(f).profile.zinc*-1
     flakelement(f).xpos=flakelement(f).xpos+flakelement(f).profile.xinc
     flakelement(f).ypos=flakelement(f).ypos+flakelement(f).profile.yinc
     flakelement(f).zpos=flakelement(f).zpos+flakelement(f).profile.zinc
     tcollide=1
    endif
   endif
   rem scene commander, track if flak has moved, if not deactivate and hide. (not movement caused if flak generated too close of obstacle).
   if flakelement(f).lastx=flakelement(f).xpos and flakelement(f).lasty=flakelement(f).ypos and flakelement(f).lastz=flakelement(f).zpos
    if flak(tflakid).stick=1
     flakelement(f).active=4
     hide object tobj
    else
     flakelement(f).active=2
    endif
   endif
   rem if shot BY entity, can collide with player
   if flakelement(f).owner<>0
    tx#=flakelement(f).xpos-mex#
    tz#=flakelement(f).zpos-mez#
    td#=sqrt(abs(tx#*tx#)+abs(tz#*tz#))
    ty#=abs(flakelement(f).ypos-mey#)
    if td#<30.0 and ty#<100.0 then tcollide=1
   endif
   rem complete collision code
   if tcollide>0
    if flakelement(f).profile.explodeonhit>0 or flakelement(f).profile.bounceonhit>0
     if flakelement(f).profile.bounceonhit>0 and flakelement(f).profile.explodeonhit=0
      flakelement(f).profile.bounceonhit=flakelement(f).profile.bounceonhit-1
      if tcollide=1 and flak(tflakid).noexplode=1 then bouncingonhit=1 : tdetonate=1
      playinternal3dsound(flak(tflakid).sound.sndbounceid,tmpx1#,tmpy1#,tmpz1#)
     else
      rem detonate at last collision, add scorch - Scene commander change for floor explosion
      flakelement(f).preexplode=0
      tdetonate=1
     endif
    else
     rem bouncing flak hasn't worked as it was intended! This needs to be here so once there are no more bounces
     rem the object will detonate on next collision!
     if flakelement(f).profile.bounceonhit<=0
      if flak(tflakid).noexplode=1
       tdetonate=1
       Rem Scene commander - fix for non working grenades
      else
       flakelement(f).active=1
       show object tobj
      endif
     endif
    endif
   endif
   `
  endif
  `
  rem detonate trigger
  if tdetonate=1
   if flak(tflakid).noexplode=0
    rem trigger explosion
    flakelement(f).active=2
   else
    flakelement(f).active=4
   endif
  endif
 endif
 `
 if flakelement(f).active=5
 endif
 `
 if flakelement(f).active=2
  Rem Scene Commander fix for flak using correct decals - will use default of no flak specified in flak FPE
  newone=0
  if showflak=1
   decalscalemodx=0:decalorient=0
   decalx=tmpx1#:decaly=tmpy1#:decalz=tmpz1#:originatore=-1
   if flak(tflakid).expinairid>0 and flakelement(f).preexplode=1
    decalid=flak(tflakid).expinairid
    decalrange=10000
    gosub _decalelement_create
    newone=1
   endif
   if flak(tflakid).exponfloorid>0 and flakelement(f).preexplode=0
    decalid=flak(tflakid).exponfloorid
    decalrange=10000
    gosub _decalelement_create
    newone=1
   endif
  endif
  `
  rem hide flak object
  tobj=flakelement(f).obj
  if tobj>0
   hide object tobj
  endif
  `
  rem trigger exploder
  frox#=flakelement(f).xpos
  froy#=flakelement(f).ypos
  froz#=flakelement(f).zpos
  if newone=0 and showflak=1 then gosub _part_triggerexplosion
  `
  rem make sound seem louder by moving it closer to player
  playinternal3dsound(flak(tflakid).sound.sndexplodeid,decalx,decaly,decalz)
  rem ONLY affect decal with ZBIAS if explosion that needs to be seen by player in full
  if object exist(tobj)=1 then enable object zbias tobj,-500.0,0.0
  `
  rem initial blast creates scorch (in six directions)
  if showflak=1
   for tscdir=1 to 6
    if tscdir=1 then t=static raycast(frox#+0,froy#,froz#,frox#-400,froy#,froz#)
    if tscdir=2 then t=static raycast(frox#+0,froy#,froz#,frox#+400,froy#,froz#)
    if tscdir=3 then t=static raycast(frox#,froy#+0,froz#,frox#,froy#-400,froz#)
    if tscdir=4 then t=static raycast(frox#,froy#+0,froz#,frox#,froy#+400,froz#)
    if tscdir=5 then t=static raycast(frox#,froy#,froz#+0,frox#,froy#,froz#-400)
    if tscdir=6 then t=static raycast(frox#,froy#,froz#+0,frox#,froy#,froz#+400)
    rem AirMod - Done
    tsize#=45-rnd(30) : if t=1 then add static scorch tsize#,4+rnd(3)
   next tscdir
   rem initial blast creates light flash
   spotflash=100 : tx#=decalx : ty#=decaly : tz#=decalz
   tcolr=255
   tcolg=255
   tcolb=0
   gosub _lighting_spotflash
   Rem Scene commander, end show explosion
  endif
  rem start range of expanding explosion at zero
  flakelement(f).range=0
  rem create force of damage
  flakelement(f).active=3
  rem all entities that can take damage (characters, windows)
  tx#=flakelement(f).xpos : ty#=flakelement(f).ypos : tz#=flakelement(f).zpos
  spheredamage=flakelement(f).profile.damage
  spherex#=tx# : spherey#=ty# : spherez#=tz# : sphereforce#=1.0
  gosub _entity_addforcesphere
 endif
 `
 if flakelement(f).active=3
  rem increase range as force expands
  flakelement(f).range=flakelement(f).range+10
  if flakelement(f).range>100
   flakelement(f).active=0
  endif
  rem detonate any other flak (other grenades)
  tx#=flakelement(f).xpos
  ty#=flakelement(f).ypos
  tz#=flakelement(f).zpos
  for sf=1 to flakelementmax
   if f<>sf and flakelement(sf).active=1 and flak(tflakid).noexplode=0
    tsx#=flakelement(sf).xpos-tx#
    tsy#=flakelement(sf).ypos-ty#
    tsz#=flakelement(sf).zpos-tz#
    d#=sqrt(abs(tsx#*tsx#)+abs(tsy#*tsy#)+abs(tsz#*tsz#))
    if d#<flakelement(f).range
     flakelement(sf).preexplode=1
     rem explode the flak
     flakelement(sf).active=2
     flakelement(sf).range=0
    endif
   endif
  next sf
 endif
 if flakelement(f).active=4
  gosub _stickyflakplacement
  playinternal3dsound(flak(tflakid).sound.sndexplodeid,flakelement(f).xpos,flakelement(f).ypos,flakelement(f).zpos)
  rem hide flak object
  if bouncingonhit=0 then hide object tobj
  if endoflife=0
   if tcollide=1
    if spheree<>-1
     tdamagex#=flakelement(f).xpos : tdamagey#=flakelement(f).ypos : tdamagez#=flakelement(f).zpos
     damagede=spheree : nocalcpoi=1
     if flak(tflakid).blood=1 then gosub _create_blood
     tdamage=flak(tflakid).profile.damage
     tdamagesource=0 : timpacttype=1 : tdir=0
     ste=e : sttentid=tentid
     tentid=entityelement(spheree).bankindex
     e=spheree
     if entityprofile(tentid).ischaracter=1
      `if tdamage<30 then timpacttype=1
      entityelement(e).shotby=996
      gosub _entity_deducthealth
     else
      gosub _entity_delayeddeducthealth
     endif
     e=ste : tentid=sttentid
    else
     tdamage=flak(tflakid).profile.damage
     gosub _player_takedamage
    endif
   else
    rem we hit a wall
    if flak(tflakid).stick=1
     `gosub _stickyflakplacement
     for i=1 to flakelementmax
      if flakstick(i).used=0
       flakstick(i).used=1
       flakstick(i).flakid=tflakid
       flakstick(i).life=timer()
       flakstick(i).x=flakelement(f).xpos
       flakstick(i).y=flakelement(f).ypos
       flakstick(i).z=flakelement(f).zpos
       rem instanced objects can't have their own emissve
       clone object flakstick(i).obj,flak(tflakid).stickobj
       position object flakstick(i).obj,flakstick(i).x,flakstick(i).y,flakstick(i).z
       rotate object flakstick(i).obj,object angle x(tobj),object angle y(tobj),object angle z(tobj)
       set object diffuse flakstick(i).obj,rgb(128,128,128)
       set object ambience flakstick(i).obj,rgb(255,255,255)
       set object emissive flakstick(i).obj,0
       set object specular flakstick(i).obj,0
       exit
      endif
     next i
    endif
   endif
  endif
  rem allow for flak to bounce off enemies and hurt them while continuing to bounce
  if bouncingonhit=0 then flakelement(f).active=0 else flakelement(f).active=1
  bouncingonhit=0
 endif
 `
next f

endoflife=0
gosub _flakstick_control

return

_flakstick_control:
 for i=1 to flakelementmax
  if flakstick(i).used=1
   flaki=i
   if object in screen(flakstick(i).obj) then gosub _lighting_applyflakstickcolor
   `text object screen x(flakstick(i).obj),object screen y(flakstick(i).obj),str$(flak(flakstick(i).flakid).sticklife)
  if timer()-flakstick(i).life>=flak(flakstick(i).flakid).sticklife

    flakstick(i).used=0
    delete object flakstick(i).obj
   endif
  endif
 next i
return

`
` FUNCTIONS FOR FLAK
`

function loadflak(tfile$)
 index=0
 if flakbankmax>0
  for t=1 to flakbankmax
   if tfile$=flakbank$(t) then index=flakbankoffset+t : exit
  next t
 else
  t=flakbankmax+1
 endif
 if t>flakbankmax
  inc flakbankmax
  `
  rem V109 BETA6 - replaced X file load with optional DBO convert/load for HUD.X
  `addfiletocollection(tfile$)
  `load object tfile$,index
  if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
  if file exist(tfile$)=1 or file exist(tdbofile$)=1
   index=flakbankoffset+flakbankmax
   flakbank$(flakbankmax)=tfile$
   rem V109 BETA6 - replaced X file load with optional DBO convert/load for HUD.X
   if file exist(tdbofile$)=1
    tfile$=tdbofile$
    tdbofile$=""
   else
    rem allowed to save DBO (once only)
   endif
   load object tfile$,index
   if len(tdbofile$)>1
    save object tdbofile$,index
    if file exist(tdbofile$)=1
     delete object index
     load object tdbofile$,index
     tfile$=tdbofile$
    endif
   endif
   addfiletocollection(tfile$)
   `
   yrotate object index,180
   fix object pivot index
   set object collision off index
   hide object index
  endif
 endif
endfunction index

rem
rem DECAL
rem

_decal_init:

rem Load in all decal
gosub _decal_scaninallref

rem Precreate elements as each is unique (UV writing)
for f=1 to decalelementmax
 tobj=decalelementoffset+f : decalelement(f).obj=tobj
 if object exist(tobj)=1 then delete object tobj
 objecteffect(tobj)=0
 make object plain tobj,100,100
 set object transparency tobj,2
 set object collision off tobj
 disable object zwrite tobj
 set object texture tobj,0,0
 set object light tobj,0
 set object cull tobj,0
 hide object tobj
next f

rem ensure water ripple decal available
decal$="ripple"
gosub _decal_find
if decalid>0
 waterdecalripple=decalid
 decal(waterdecalripple).active=1
else
 waterdecalripple=0
endif
waterdecalripplemaster=waterdecalripple

rem splash decal
decal$="splash"
gosub _decal_find
if decalid>0
 splashdecalid=decalid
 decal(splashdecalid).active=1
else
 splashdecalid=0
endif

return

_decal_loaddata:
`
rem FPGC - 310310 - establish some defaults
decal(decalid).across                  = 4
decal(decalid).down                    = 4
decal(decalid).particle.offsety        = 0
decal(decalid).particle.scale          = 0
decal(decalid).particle.randomstartx   = 0
decal(decalid).particle.randomstarty   = 0
decal(decalid).particle.randomstartz   = 0
decal(decalid).particle.linearmotionx  = 0
decal(decalid).particle.linearmotiony  = 0
decal(decalid).particle.linearmotionz  = 0
decal(decalid).particle.randommotionx  = 0
decal(decalid).particle.randommotiony  = 0
decal(decalid).particle.randommotionz  = 0
decal(decalid).particle.mirrormode     = 0
decal(decalid).particle.camerazshift   = 500
decal(decalid).particle.scaleonlyx     = 100
decal(decalid).particle.lifeincrement  = 100
decal(decalid).particle.alphaintensity = 100
rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
decal(decalid).particle.animated = 0 `Off by default
`
dim data$(100)
filename$="gamecore\decals\"+decal$+"\decalspec.txt"
addfiletocollection(filename$)
load array filename$,data$()
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem decal
   if field$="across" then decal(decalid).across=value1
   if field$="down" then decal(decalid).down=value1
   `
   rem FPGC - 310310 - additional fields for decal based particle function
   if field$="offsety" then decal(decalid).particle.offsety=value1
   if field$="scale" then decal(decalid).particle.scale=value1
   if field$="randomstartx" then decal(decalid).particle.randomstartx=value1
   if field$="randomstarty" then decal(decalid).particle.randomstarty=value1
   if field$="randomstartz" then decal(decalid).particle.randomstartz=value1
   if field$="linearmotionx" then decal(decalid).particle.linearmotionx=value1
   if field$="linearmotiony" then decal(decalid).particle.linearmotiony=value1
   if field$="linearmotionz" then decal(decalid).particle.linearmotionz=value1
   if field$="randommotionx" then decal(decalid).particle.randommotionx=value1
   if field$="randommotiony" then decal(decalid).particle.randommotiony=value1
   if field$="randommotionz" then decal(decalid).particle.randommotionz=value1
   if field$="mirrormode" then decal(decalid).particle.mirrormode=value1
   if field$="camerazshift" then decal(decalid).particle.camerazshift=value1
   if field$="scaleonlyx" then decal(decalid).particle.scaleonlyx=value1
   if field$="lifeincrement" then decal(decalid).particle.lifeincrement=value1
   if field$="alphaintensity" then decal(decalid).particle.alphaintensity=value1
   rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
   if field$="animated" then decal(decalid).particle.animated=value1
   `
  endif
 endif
next l
undim data$()

rem default scale is 100
if decal(decalid).particle.scale=0 then decal(decalid).particle.scale=100

rem Some pre-game calculations
decal(decalid).framemax=decal(decalid).across*decal(decalid).down

return

_decal_load:

rem Load decal data
gosub _decal_loaddata

rem Load decal image and store name in bank
loaddecal("gamecore\decals\"+decal$+"\decal.tga",decalid)

return

_decal_scaninallref:

rem Scan entire decals folder
set dir "gamecore" : decalid=1
empty array filelist$()
buildfilelist("decals","")
set dir ".."
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   rem V109 BETA7 - 300408 - relied on DDS file that is no longer there sometimes
   remstart
   tryfile$=lower$(right$(file$,9))
   if left$(tryfile$,len(tryfile$)-4)="decal"
    newdecal$=left$(file$,len(file$)-10)
    for tdecalid=1 to decalmax
     if decal(tdecalid).name$=newdecal$ then exit
    next tdecalid
    if tdecalid>decalmax
     if decalid>decalmax
      decalmax=decalid
      dim decal(decalmax) as decaltype
     endif
     decal(decalid).name$=newdecal$
     inc decalid
    endif
   endif
   remend
   tryfile$=lower$(right$(file$,13))
   if tryfile$="decalspec.txt"
    newdecal$=left$(file$,len(file$)-14)
    for tdecalid=1 to decalmax
     if decal(tdecalid).name$=newdecal$ then exit
    next tdecalid
    if tdecalid>decalmax
     if decalid>decalmax
      decalmax=decalid
      dim decal(decalmax) as decaltype
     endif
     decal(decalid).name$=newdecal$
     decal(decalid).across=0
     inc decalid
    endif
   endif
  endif
 next chkfile
endif
decalmax=decalid-1

return

_decal_scaninall:

rem Load all decal data list in
gosub _decal_scaninallref

rem Load all decals
for decalid=1 to decalmax
 decal$=decal(decalid).name$
 decal(decalid).active=1
 gosub _decal_load
next decalid

return

_decal_loadonlyactivedecals:

rem Load all decals that have been activated
for decalid=1 to decalmax
 if decal(decalid).active=1
  decal$=decal(decalid).name$
  gosub _decal_load
 endif
next decalid

return

_decal_getparticlefile:
 `
 rem FPGC - 310710 - if not scanned decal folder, do this now (before we can retrieve particle data)
 if decal(1).name$="" then gosub _decal_scaninallref
 `
 rem FPGC - 310710 - takes particlefile$, fill gotparticle with data
 for decalid=1 to decalmax
  if lower$(decal(decalid).name$)=lower$(particlefile$)
   if decal(decalid).across=0
    decal(decalid).active=1
    gosub _decal_loaddata
   endif
   gotparticle=decal(decalid).particle
   exit
  endif
 next decalid
 `
return

`
` decal ELEMENTS HANDLING
`

_decalelement_create:
`
rem FPGC - 170610 - early out if decal over 1000 units away from camera
tdxx=decalx-camera position x()
tdyy=decaly-camera position y()
tdzz=decalz-camera position z()
tddd=sqrt(abs(tdxx*tdxx)+abs(tdyy*tdyy)+abs(tdzz*tdzz))
if tddd>decalrange then decalrange=800:return
`
for d=1 to decalelementmax
 if decalelement(d).active=0 then exit
next d
if d<decalelementmax
 rem activate new decal element
 currentdecald=d
 decalelement(d).decalid=decalid
 decalelement(d).active=1
 decalelement(d).xpos=decalx
 decalelement(d).ypos=decaly
 decalelement(d).zpos=decalz
 decalelement(d).frame=0
 decalelement(d).orient=decalorient
 decalelement(d).originator=originatore
 rem FPGC - 300710 - particle settings now per instance
 decalelement(d).particle=decal(decalid).particle
 if originatore>0
  if entityelement(originatore).eleprof.particleoverride=1
   decalelement(d).particle=entityelement(originatore).eleprof.particle
  endif
 endif
 if decalelement(d).orient=7
  rem FPGC - 300310 - decal based particle adjust the Y pos, mirror and IX
  decalelement(d).xpos=decalelement(d).xpos-((rnd(decalelement(d).particle.randomstartx)-(decalelement(d).particle.randomstartx/2))/100.0)
  decalelement(d).ypos=decalelement(d).ypos-((rnd(decalelement(d).particle.randomstarty)-(decalelement(d).particle.randomstarty/2))/100.0)
  decalelement(d).zpos=decalelement(d).zpos-((rnd(decalelement(d).particle.randomstartz)-(decalelement(d).particle.randomstartz/2))/100.0)
  decalelement(d).particleix=((decalelement(d).particle.randommotionx/2)-rnd(decalelement(d).particle.randommotionx))/100.0
  decalelement(d).particleiy=((decalelement(d).particle.randommotiony/2)-rnd(decalelement(d).particle.randommotiony))/100.0
  decalelement(d).particleiz=((decalelement(d).particle.randommotionz/2)-rnd(decalelement(d).particle.randommotionz))/100.0
  if decal(decalid).particle.mirrormode=0 then decalelement(d).particlemirror=0
  if decal(decalid).particle.mirrormode=1 then decalelement(d).particlemirror=1
  if decal(decalid).particle.mirrormode=2 then decalelement(d).particlemirror=rnd(1)
 endif
 rem prepare decal object
 tobj=decalelement(d).obj
 ty=decal(decalid).particle.offsety
 position object tobj,decalelement(d).xpos,decalelement(d).ypos+ty,decalelement(d).zpos
 rem face camera or leave as is
 if decalelement(d).orient=0
  point object tobj,camera position x(),camera position y(),camera position z()
  xrotate object tobj,0 : zrotate object tobj,0
 endif
 if decalelement(d).orient=1
  rotate object tobj,decalorientx#,decalorienty#,decalorientz#
 endif
 if decalelement(d).orient=2
  rotate object tobj,90,0,0
 endif
 if decalelement(d).orient=3
  point object tobj,camera position x(),camera position y(),camera position z()
 endif
 if decalelement(d).orient=4
  point object tobj,camera position x(),camera position y(),camera position z()
  move object tobj,5.0
 endif
 if decalelement(d).orient=7
  rem FPGC - 300310 - spawn a decal based particle fragment (for new flame and fire) (once)
  point object tobj,camera position x(),camera position y(),camera position z()
  move object tobj,decalelement(d).particle.camerazshift/100.0
 endif
 enable object zbias tobj,0.0,0.0
 rem texture for this decal type
 texture object tobj,decal(decalid).imageid
 rem scale the decal
 if decalscalemodx=0
  decalelement(d).scalemodx=decalelement(d).particle.scale*(decalelement(d).particle.scaleonlyx/100.0)
  decalelement(d).scalemody=decalelement(d).particle.scale
 else
  decalelement(d).scalemodx=decalscalemodx*(decalelement(d).particle.scaleonlyx/100.0)
  decalelement(d).scalemody=decalscalemody
 endif
 `scale object tobj,decalelement(d).scalemodx,decalelement(d).scalemody,100
 rem AirMod - Special Decal Modifier >>>
 if tdecalairmodsize=1
  tdecalairmodsize=0
  scale object tobj,decalelement(d).scalemodx*tdecalairmodsizex#,decalelement(d).scalemody*tdecalairmodsizey#,100
 else
  scale object tobj,decalelement(d).scalemodx,decalelement(d).scalemody,100
 endif
 rem AirMod - Done <<<
 rem show decal object
 show object tobj
else
 tobj=0
endif

return

_decalelement_continue:
 `
 rem decal is looping, merely need to continue the current decal
 d=currentdecald
 if d>0 and decalelement(d).originator=originatore
  rem simply reset decal
  decalelement(d).frame=0
 else
  rem different, so recreate
  gosub _decalelement_create
 endif
 `
return

_decalelement_control:

rem Control all decal activity
for f=1 to decalelementmax
 if decalelement(f).active=1
  backuptimeelapsed#=timeelapsed#
   if screen fps()<=101
      decaltimeelapsed#=timeelapsed#
   else
      decaltimeelapsed#=timeelapsed#/1.2
   endif

  rem update decal object
  tobj=decalelement(f).obj : tdetonate=0
  rem if decal not in visible screen, destroy for performance - off no code
  if tdetonate=0
   rem possible movement
   if decalelement(f).orient=7
    rem FPGC - 300310 - decal based particle moves in 3D space
    decalelement(f).xpos=decalelement(f).xpos+(((decalelement(f).particleix/100.0)*100.0)*decaltimeelapsed#)
    decalelement(f).ypos=decalelement(f).ypos+(((decalelement(f).particleiy/100.0)*100.0)*decaltimeelapsed#)
    decalelement(f).zpos=decalelement(f).zpos+(((decalelement(f).particleiz/100.0)*100.0)*decaltimeelapsed#)
    decalelement(f).xpos=decalelement(f).xpos+((decalelement(f).particle.linearmotionx/100.0)*decaltimeelapsed#)
    decalelement(f).ypos=decalelement(f).ypos+((decalelement(f).particle.linearmotiony/100.0)*decaltimeelapsed#)
    decalelement(f).zpos=decalelement(f).zpos+((decalelement(f).particle.linearmotionz/100.0)*decaltimeelapsed#)
   endif
   rem animation
   decalid=decalelement(f).decalid
   rem next frame
   rem FPGC - 050710 - glass smash much slower than previous non-timer based system, so we speed it up!
   `decalelement(f).framedelay=decalelement(f).framedelay+decaltimeelapsed#
   decalelement(f).framedelay=decalelement(f).framedelay+(decaltimeelapsed#*2)
   if decalelement(f).framedelay>=1
    decalelement(f).framedelay=0
    decalelement(f).frame=decalelement(f).frame+(decalelement(f).particle.lifeincrement/100.0)
   endif
   if decalelement(f).frame>decal(decalid).framemax-1
    rem no more animation
    decalelement(f).frame=decal(decalid).framemax-0.1
    tdetonate=1
   endif
   rem write UV for correct anim frame
   if object visible(tobj)=1 and object in screen(tobj)=1 and tdetonate=0 or decalelement(f).decalid=waterdecalripple and tdetonate=0 and object exist(tobj)
    if decalelement(f).decalid=waterdecalripple and object exist(tobj) then set alpha mapping on tobj,8
    rem rotate to face camera if flagged
    if decalelement(f).orient=0
     point object tobj,camera position x(),camera position y(),camera position z()
     xrotate object tobj,0 : zrotate object tobj,0
    endif
    if decalelement(f).orient=2
     set object cull tobj,1
    else
     set object cull tobj,0
    endif
    if decalelement(f).orient=3
     point object tobj,camera position x(),camera position y(),camera position z()
    endif
    if decalelement(f).orient=7
     rem FPGC - 300310 - decal based particle faces camera always and moves
     ty=decal(decalid).particle.offsety
     position object tobj,decalelement(f).xpos,decalelement(f).ypos+ty,decalelement(f).zpos
     point object tobj,camera position x(),camera position y(),camera position z()
     rem also affect the alpha of the decal
     pt#=decal(decalid).framemax
     p#=(decal(decalid).framemax-decalelement(f).frame)/pt#
     set alpha mapping on tobj,sin(p#*180)*decalelement(f).particle.alphaintensity
    endif
    rem animation UVs
    rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
    if decalelement(f).orient=7 and decalelement(f).particle.animated<>1 and decalelement(f).decalid<>waterdecalripple
     rem FPGC - 300310 - decal based particle only uses first animation frame
     tframe=0
    else
     tframe=decalelement(f).frame
    endif
    ty=tframe/decal(decalid).across : tx=tframe-(ty*decal(decalid).across)
    qx#=1.0/(decal(decalid).across+0.0) : tx#=tx*qx#
    qy#=1.0/(decal(decalid).across+0.0) : ty#=ty*qy#
    if decalelement(f).orient=7 and decalelement(f).particlemirror=1
     rem FPGC - 300310 - decal based particle can mirror the image
     tx#=(tx*qx#)+qx# : qx#=qx#*-1
    endif
    lock vertexdata for limb tobj,0,1
    set vertexdata uv 0,tx#+qx#,ty#
    set vertexdata uv 1,tx#,ty#
    set vertexdata uv 2,tx#+qx#,ty#+qy#
    set vertexdata uv 3,tx#,ty#
    set vertexdata uv 4,tx#,ty#+qy#
    set vertexdata uv 5,tx#+qx#,ty#+qy#
    unlock vertexdata
   endif
  endif
  rem detonate trigger
  if tdetonate=1
   hide object decalelement(f).obj
   decalelement(f).originator=0
   decalelement(f).active=0
  endif
 endif
next f

return

_decal_triggermaterialdebris:
 `
 rem takes tsoundmaterial,tsx#,tsy#,tsz#
 if tsoundmaterial>0
  decalid=material(tsoundmaterial-1).decalid
  if tsy#<waterheight#+10 then decalid=0
  if decalid>0
   rem create the decal for this event
   decalscalemodx=0 : rem FPSCV101 - fix
   decalorient=4 : decalx=tsx# : decaly=tsy# : decalz=tsz#
   originatore=-1 : gosub _decalelement_create
  endif
  rem FPSCV101 - add
  tsoundmaterial=0
 endif
 `
return

`
` FUNCTIONS FOR decal
`

function loaddecal(tfile$,decalid)
 timg=loadinternalimagecompress(tfile$,5)
 decal(decalid).imageid=timg
endfunction timg

`
`
`

_gun_findweaponindexbyname_core:

foundgunid=0
if findgun$<>""
 for tid=1 to gunmax
  if lower$(findgun$)=lower$(gun(tid).name$)
   foundgunid=tid
   exit
  endif
 next tid
endif

return

_gun_findweaponindexbyname:
 `
 rem try to find gun
 storefindgun$=findgun$ : gosub _gun_findweaponindexbyname_core
 `
 rem V110 BETA3 - 060608 - if not found, try rescanning (as new guns can be added by store), and try a second time
 if foundgunid=0
  gosub _gun_scaninall_findnewlyaddedgun
  findgun$=storefindgun$ : gosub _gun_findweaponindexbyname_core
 endif
 `
return

_player_resettrail:
 playertrailmax=1
 for tp=0 to 100
  playertrial(tp).time=0
 next tp
return

_player_spawnsound:
 rem uses plrindex and te, make the spawn sound for the player appearing
 if gmultiplayergame=1
  tsnd=16
  if playersound(plrindex,tsnd)>0
   playinternal3dsoundfactor(playersound(plrindex,tsnd),entityelement(te).x,entityelement(te).y,entityelement(te).z,25.0)
  endif
 endif
return

_player_takedamage:

rem Either player One (main) or tplrid to use 'fake player entity soundset (multiplayer)
plrid=1 : tplrid=plrid : if gmultiplayergame=1 then tplrid=plrindex

rem special client case
if gmultiplayergame=1 and createorjoin=2
`
rem if multiplayer client, cannot take damage directly
`
else
`
rem Determine what to do from damage
rem Scene Commander armour
if isimmune<>0 then tdamage=0
t1=tdamage
if armouron<>0 and t1<>0 and drowned=0
    if t1>0
t1=tdamage-armour
armour=armour-tdamage
if armour>0 then t1=0
if t1>0
armour=0
endif
endif
endif

if t1<=0 then t1=0
tdamage=t1
if (tdamage>0 and player(plrid).health>0 and playerstartstrength>0) or (playerstartstrength=0 and tdamage>65000)
 if playerstartstrength>0 then player(plrid).health=player(plrid).health-tdamage
 if player(plrid).health<=0 and player(plrid).recovershield=0
  rem player looses a life
  player(plrid).recovershield=100
  player(plrid).health=0
  if playerstartlives>0 or plrid<>1
   rem FPGC - 160909 - only reduce lives if using lives
   player(plrid).lives=player(plrid).lives-1
  endif
  if player(plrid).lives<=0
   player(plrid).lives=0
  endif
  rem player grunts in deadness
  tsnd=15
  if playersound(tplrid,tsnd)>0
   broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0,-1)
   play sound playersound(tplrid,tsnd)
  endif
  rem player puts weapon away if fallen
  autoloadgun=0 : gosub _gun_change
  rem restore player zoom
  plrzoominchange=1 : plrzoomin#=0.0
  rem restore player modes
  onladder=0 : jumpaction=0 : crouchmode=0
  gunzoommode=0 : gunzoommag#=0
  rem stop any sliding force
  camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
  camforcex#=0 : camforcey#=0 : camforcez#=0
 else
  rem player grunts if hurt
  tsnd=12+rnd(2)
  if playersound(tplrid,tsnd)>0
   broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0,-1)
   play sound playersound(tplrid,tsnd)
  endif
 endif
 rem cause eyehud(red) to flare quickly
 rem GUI-X9 (knxrb) - Eyehud
 if guiUsed=0
     hudid=internaleyehud
     hud(hudid).hidedelay=3
     hud(hudid).hide=0
 else
     if guieyehud > -1
        guieyetimer = guihurttime
        gosub _gui_run
     endif
 endif
endif
`
endif

return

_decal_find:

rem Load all decals
for decalid=1 to decalmax
 if decal(decalid).name$=decal$ then exit
next decalid
if decalid>decalmax then decalid=-1

return

_gun_free:

rem Hide gun from HUD
if currentgunobj>0
 if object exist(currentgunobj)=1
  set object interpolation currentgunobj,100
  set object frame currentgunobj,firemode(gunid,0).action.show.s
  hide object currentgunobj
 endif
` if gun(gunid).secondobj>0
`  if object exist(gun(gunid).secondobj)=1 then hide object gun(gunid).secondobj
` endif
endif

rem Stop any gun sounds if free suddenly
if gunid>0
 for p=1 to 3
  if gunsound(gunid,p).soundid>0 then stop sound gunsound(gunid,p).soundid
  if gunsoundcompanion(gunid,p,0).soundid>0 then stop sound gunsoundcompanion(gunid,p,0).soundid
  if gunsoundcompanion(gunid,p,1).soundid>0 then stop sound gunsoundcompanion(gunid,p,1).soundid
  if gunsoundcompanion(gunid,p,2).soundid>0 then stop sound gunsoundcompanion(gunid,p,2).soundid
 next p
endif

rem Disassociate gun with player
gunselectionlockdown=0
currentgunobj=0

rem Hide support objects for gun
if gun(gunid).settings.flashlimb<>-1
 obj=hudbankoffset+5
 if object exist(obj)=1 then hide object obj
endif
if gun(gunid).settings.brasslimb<>-1
 for o=6 to 20
  obj=hudbankoffset+o
  if object exist(obj)=1 then hide object obj
 next o
endif
if gun(gunid).settings.smokelimb<>-1
 for o=21 to 30
  obj=hudbankoffset+o
  if object exist(obj)=1 then hide object obj
 next o
endif

rem Hide cross hair
if gdepthcameraid>0
 rem FPGC - 070710 - replace cross hair with sprite
 timg=gun(gunid).settings.crosshairimg
 if timg>0
  if image exist(timg)=1
   sprite effectmenuimagestart+40,-10000,-10000,timg
  endif
 endif
else
 obj=hudbankoffset+31
 if object exist(obj)=1 then hide object obj
endif

rem Clear basic gun vars
gunflash=0 : gunsmoke=0 : gunbrass=0 : gunshoot=0 : gunmode=5

return

_gun_scaninall_ref:

rem Scan entire guns folder
set dir "gamecore" : gunid=1
empty array filelist$()
buildfilelist(fpgchuds$,"")
set dir ".."
if array count(filelist$())>0
 dim gun(array count(filelist$())) as guntype
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   rem V109 BETA6 - 290408 - support for HUD DBO
   if lower$(right$(file$,5))="hud.x"
    gun(gunid).name$=left$(file$,len(file$)-6)
    inc gunid
   endif
   if lower$(right$(file$,7))="hud.dbo"
    gun(gunid).name$=left$(file$,len(file$)-8)
    inc gunid
   endif
  endif
 next chkfile
 gunmax=gunid-1
 dim gun(gunmax+1) as guntype
 dim firemode(gunmax+1,1) as guntype
 `dim bulletlimbs(gunmax+1,25)
 `dim gunsound(gunmax+1,5) as gunsoundbanktype
 `dim gunsoundcompanion(gunmax+1,5,2) as gunsoundbankcompaniontype
 Rem AirMod - Update next two lines for additional gun sounds
 dim gunsound(gunmax+1,15) as gunsoundbanktype
 dim gunsoundcompanion(gunmax+1,15,2) as gunsoundbankcompaniontype
 dim gunsounditem(gunmax+1,50) as gunsounditemtype
endif

rem Now sort the gun list into alphabetical order (MP needs gunid identical on each PC)
for tgid1=1 to gunmax
 for tgid2=1 to gunmax
  if tgid1<>tgid2
   tname1$=lower$(gun(tgid1).name$)
   tname2$=lower$(gun(tgid2).name$)
   if tname1$>tname2$
    rem smallest at top
    gun(tgid1).name$=tname2$
    gun(tgid2).name$=tname1$
   endif
  endif
 next tgid2
next tgid1

return

_gun_scaninall_findnewlyaddedgun:

rem V110 BETA3 - 060608 - if find gun that is not in list, if find, flag is 'found'
storegunid=gunid

rem gather files
set dir "gamecore"
empty array filelist$()
buildfilelist(fpgchuds$,"")
set dir ".."

rem go through file list of latest guns
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   findgun$=""
   if lower$(right$(file$,5))="hud.x"
    findgun$=left$(file$,len(file$)-6)
   else
    if lower$(right$(file$,7))="hud.dbo"
     findgun$=left$(file$,len(file$)-8)
    endif
   endif
   if findgun$<>""
    gosub _gun_findweaponindexbyname_core
    if foundgunid=0
     `
     inc gunmax
     dim gun(gunmax+1) as guntype
     dim firemode(gunmax+1,1) as guntype
     `dim bulletlimbs(gunmax+1,25)
     dim gunsound(gunmax+1,5) as gunsoundbanktype
     dim gunsoundcompanion(gunmax+1,5,2) as gunsoundbankcompaniontype
     dim gunsounditem(gunmax+1,50) as gunsounditemtype
     gun(gunmax).name$=findgun$
     gunid=gunmax : gun$=findgun$ : gosub _gun_loaddata
     `
    endif
   endif
  endif
 next chkfile
endif
gunid=storegunid

return


rem
rem Lighting Routines
rem

`
` General Visual Settings
`

_lighting_init:
 `
 rem Set approporiate ambience (FPI controlled)
 guivisualsettings.ambience=0
 `
 rem Lighting defaults
 guivisualsettings.shadows=1
 guivisualsettings.shadowstrength=128
 guivisualsettings.shadowshades=1
 guivisualsettings.dynamiclightcount=0
 guivisualsettings.updateflag=1
 `
 rem Initialize lighting objects
 if gdynamiclightingstate=1
  gosub _lighting_setupdynamiclights
  if gshowdebugtextingamestate=1
   activatedynamiclightsdebug=1
  else
   activatedynamiclightsdebug=0
  endif
 endif
 `
 rem Hero Light (used for source point for shadows and effects)
` set point light 0,50,50,-50
 color light 0,rgb(0,0,0)
 set light range 0,1
 hide light 0
 `
return

_lighting_postdefaults:

rem if no lights, set ambience to full
tokay=0
array index to top infinilight()
while array index valid(infinilight())
 if infinilight().islit=1
  tokay=1
 endif
 next array index infinilight()
 inc currentindex
endwhile
rem 310311 - TerryFix - make sure saved ambience is used (only once after load game during standalone)
if saveloadambience<>-1 and grealgameviewstate=1
 guivisualsettings.ambience=saveloadambience
 saveloadambience=-1
else
 if tokay=0 and guivisualsettings.ambiencescripted=0
  rem no lights, use full ambience (zero means no FPI aetting, go for defaults)
  if guseeffectonscenesstate=1
   guivisualsettings.ambience=25
  else
   guivisualsettings.ambience=75
  endif
 endif
endif
forceambientlightsetting=10

return

_lighting_ambientcontrol:

rem Irrespective of dynamic light setting
If gtestgamemodefromeditor=1
tempam=guivisualsettings.ambience
if inkey$()="," and guivisualsettings.ambience>0 then dec guivisualsettings.ambience : guivisualsettings.updateflag=1 : ambiencetimer=5 : watertimer=0
if inkey$()="." and guivisualsettings.ambience<100 then inc guivisualsettings.ambience : guivisualsettings.updateflag=1 : ambiencetimer=5 : watertimer=0
if ambiencetimer>0
 `
 if grawtextsize<>12 then set text size 12 : grawtextsizelast=-1
 if grawtextfont$<>"Verdana" then set text font "Verdana" : grawtextfontlast$="Verdana"
 `
 ambience$="Ambience: "+str$(guivisualsettings.ambience)+" Red: "+str$(hudambiencered)+" Blue: "+str$(hudambienceblue)+" Green: "+str$(hudambiencegreen)
 center text (gdisplaywidth/100.0)*50,1,ambience$
 `
 time$="Press enter to save ambience: "+str$(ambiencetimer)
 center text (gdisplaywidth/100.0)*50,Text Height(ambience$)+4,time$
 if keystate(28)=1
  rem FPGC - 130710 - if in test mode, save ambient setting from config file
  if file exist("editors\gridedit\testambience.txt")=1 then delete file "editors\gridedit\testambience.txt"
  open to write 1,"editors\gridedit\testambience.txt"
  write string 1,str$(guivisualsettings.ambience)
  close file 1
  ambiencetimer=0
 endif
 endif
 `
 if ambiencewatch=0 then ambiencewatch=timer()
 if timer()-ambiencewatch>=1000 then dec ambiencetimer : ambiencewatch=0
endif
if ambiencetimer<=0 then ambiencetimer=0

rem FPGC - 130710 - override ambient light
if guivisualsettings.ambienceoverride<>-1
 if guivisualsettings.ambience<guivisualsettings.ambienceoverride
  inc guivisualsettings.ambience,10
  if guivisualsettings.ambience>guivisualsettings.ambienceoverride
   guivisualsettings.ambience=guivisualsettings.ambienceoverride
  endif
  guivisualsettings.updateflag=1
 else
  if guivisualsettings.ambience>guivisualsettings.ambienceoverride
   dec guivisualsettings.ambience,10
   if guivisualsettings.ambience<guivisualsettings.ambienceoverride
    guivisualsettings.ambience=guivisualsettings.ambienceoverride
   endif
   guivisualsettings.updateflag=1
  else
   guivisualsettings.ambienceoverride=-1
  endif
 endif
endif

return

_lighting_control:
 `
 rem Direct keyboard control of adjustments
 tupdate=0
 if gdynamicshadowsstate=1
  if inkey$()="e" then guivisualsettings.shadows=0 : tupdate=1
  if inkey$()="r" then guivisualsettings.shadows=1 : tupdate=1
  if inkey$()="t" and guivisualsettings.shadowstrength>0 then dec guivisualsettings.shadowstrength : tupdate=1
  if inkey$()="y" and guivisualsettings.shadowstrength<255 then inc guivisualsettings.shadowstrength : tupdate=1
  if inkey$()="'" then guivisualsettings.shadowshades=1 : tupdate=1
  if inkey$()="#" then guivisualsettings.shadowshades=5 : tupdate=1
 endif
 if tupdate=1 then guivisualsettings.updateflag=1
 `
 rem Display lighting info
 if gshowdebugtextingamestate=1
  t$=strarr$(148)+str$(guivisualsettings.ambience)+strarr$(149)
`  if gdynamicshadowsstate=1
`   t$=t$+"  shad[E][R]:"+str$(guivisualsettings.shadows)+"  str[T][Y]:"+str$(guivisualsettings.shadowstrength)+"  shade['][#]:"+str$(guivisualsettings.shadowshades)
`  endif
  center text screen width()/2,screen height()-60, t$
 endif
 `
 rem Constantly handle spot lighting
 gosub _lighting_spotflash
 `
return

_lighting_controlupdate:
 `
 rem Automated update from force value
 if forceambientlightsetting>0 then guivisualsettings.updateflag=1 : dec forceambientlightsetting
 `
 rem Make adjustments to game settings
 if guivisualsettings.updateflag=1
  `
  rem make adjustments
  set ambient light guivisualsettings.ambience
  if guivisualsettings.shadows=1
   set global shadows on
  else
   set global shadows off
  endif
  set global shadow color 0,0,0,guivisualsettings.shadowstrength
  set global shadow shades guivisualsettings.shadowshades
  `
  rem reset update flag
  guivisualsettings.updateflag=0
  `
 endif
 `
return

`
` Dynamic Light Handling
`

_lighting_setupdynamiclights:

rem Create dynamic hardware lights
if light exist(1)=1 then hide light 1
for lightindex=2 to 7
 if light exist(lightindex)=0
  make light lightindex
 endif
 color light lightindex,0,0,0
next lightindex

rem Hero Gun/Fire Light
if light exist(1)=0 then make light 1
if light exist(1)=1 then hide light 1

rem Reset dynamic light array
activatedynamiclightscount=0
empty array infinilight(0)
testmarkerstart=50000
testmarker=testmarkerstart

rem FPGC - 100909 - Init element indices inside final infinilight structure
grefreshinfinilightentityindices=1

return

_lighting_restore:

rem Delete all spare lights
for lightindex=1 to 7
 if light exist(lightindex)=1
  hide light lightindex
  delete light lightindex
 endif
next lightindex

rem Delete any test objects
for tobj=testmarkerstart to testmarker
 if object exist(tobj)=1 then delete object tobj
next tobj

rem Default directional light
color light 0,rgb(255,255,255)
set directional light 0,0.1,-0.7,0.2
set light range 0,3000
show light 0

return


_lighting_adddynamiclight:

rem Add dynamic light
inc testmarker
if lgtype=1 then inc activatedynamiclightscount
array insert at bottom infinilight()
infinilight().used=0
infinilight().type=lgtype
infinilight().x=lgx#
infinilight().y=lgy#
infinilight().z=lgz#
infinilight().colrgb.r=lgr#
infinilight().colrgb.g=lgg#
infinilight().colrgb.b=lgb#
infinilight().range=lgrange#
infinilight().id=testmarker
infinilight().islit=1
infinilight().e=-1
if activatedynamiclightsdebug=1
 make object sphere testmarker,20
 set object collision off testmarker
 position object testmarker,infinilight().x,infinilight().y,infinilight().z
 color object testmarker,rgb(infinilight().colrgb.r,infinilight().colrgb.g,infinilight().colrgb.b)
 set object diffuse testmarker,rgb(infinilight().colrgb.r,infinilight().colrgb.g,infinilight().colrgb.b)
 set object ambient testmarker,0
endif

rem return index for possible entity tie
infinilightindex=array count(infinilight())

return

_lighting_managedynamiclights:

rem Only if dynamic lights in scene
if activatedynamiclightscount>0

rem Specify current location
mex#=camera position x()
mey#=camera position y()
mez#=camera position z()
mea#=camera angle y()

rem Fill list with six nearest lights
tnumlights=6
empty array infinilightshortlist(0)
worstoveralldist#=0
bestoveralldist#=999999
for l=1 to tnumlights
 if array count(infinilightshortlist(0))<tnumlights-1
  rem find nearest light
  currentindex=0
  bestdist#=999999 : bestindex=-1
  array index to top infinilight()
  while array index valid(infinilight())
   if activatedynamiclightsdebug=1
    if infinilight().id>0 and infinilight().id<22000000
     if object exist(infinilight().id)=1
      scale object infinilight().id,25,25,25
     endif
    endif
   endif
   if infinilight().used=0 and infinilight().type=1
    `
    rem And only those lights that are LIT
    if infinilight().islit=1
     `
     distx#=infinilight().x-mex#
     disty#=infinilight().y-mey#
     distz#=infinilight().z-mez#
     lgdist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
     tat#=atanfull(distx#,distz#)
     if tat#<0 then tat#=tat#+360
     tat#=abs(tat#-wrapvalue(mea#))
     if tat#>180 then tat#=360-tat#
     tokay=0
     if lgdist#<600.0 then tokay=1
     if lgdist#>=600.0
      if tat#<90.0 then tokay=1
     endif
     if tokay=1
      if lgdist#<bestdist#
       bestdist#=lgdist# : bestindex=currentindex
      endif
     endif
     `
    endif
    `
   endif
   next array index infinilight()
   inc currentindex
  endwhile
  if bestindex<>-1
   rem work out best and worst
   if bestdist#<bestoveralldist# then bestoveralldist#=bestdist#
   if bestdist#>worstoveralldist# then worstoveralldist#=bestdist#
   rem add to shortlist
   infinilight(bestindex).used=1
   infinilight(bestindex).dist=bestdist#
   array insert at bottom infinilightshortlist()
   infinilightshortlist()=bestindex
  endif
 endif
next l

rem FPGC - 100909 - refresh infinilight element indices once before debugger uses them
if grefreshinfinilightentityindices=1
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  if entityprofile(entid).islightmarker=1
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     tinfinilightindex=entityelement(e).eleprof.light.index
     infinilight(tinfinilightindex).e=e
    endif
   endif
  endif
 next e
 grefreshinfinilightentityindices=0
endif


rem Reveal lights in shortlist
lightindex=2
array index to top infinilightshortlist()
while array index valid(infinilightshortlist())
 `
 rem Place and configure light for this pass
 tindex=infinilightshortlist() : tobj=infinilight(tindex).id
 infinilight(tindex).used=0 : perc#=1.0
 set point light lightindex,infinilight(tindex).x,infinilight(tindex).y,infinilight(tindex).z
 color light lightindex,infinilight(tindex).colrgb.r*perc#,infinilight(tindex).colrgb.g*perc#,infinilight(tindex).colrgb.b*perc#
 set light range lightindex,infinilight(tindex).range
 next array index infinilightshortlist()
 show light lightindex
 `
 rem Show light as object if in debug mode
 if activatedynamiclightsdebug=1
  distx#=infinilight(tindex).x-mex#
  disty#=infinilight(tindex).y-mey#
  distz#=infinilight(tindex).z-mez#
  tat#=atanfull(distx#,distz#)
  if tat#<0 then tat#=tat#+360
  tat#=abs(tat#-wrapvalue(mea#))
  if tat#>180 then tat#=360-tat#
  t$=strarr$(150)+str$(tindex)+strarr$(151)+str$(lightindex)+strarr$(152)+str$(int(tat#))
  if infinilight(tindex).e>0
   t$=t$+"  state="+entityelement(infinilight(tindex).e).ai.state$ rem GUI-X9 (String States)
   t$=t$+"  localvar0="+str$(ailocals(infinilight(tindex).e,0))
  endif
  if object exist(tobj)=1
   if object in screen(tobj)=1
    center text object screen x(tobj),object screen y(tobj),t$
   endif
  else
   rem FPGC - 100909 - manual readout when light test objects are not present in final game
   text 20,80+(tindex*18),t$
  endif
 endif
 `
 rem Next light
 inc lightindex
 `
endwhile

rem Then Hide The Rest of the lights
while lightindex<=7
 if light exist(lightindex)=1
  hide light lightindex
 endif
 inc lightindex
endwhile

rem can skip if ZERO dynamic lights anywhere
endif

return

_lighting_managegloballightingreciever:
 `
 rem Optimisation Table for quick-re-reference of a particular grid location
 recx=recx#/25
 recy=recy#/100
 recz=recz#/-25
 if recx<0 then recx=0
 if recy<0 then recy=0
 if recz<0 then recz=0
 if recx>viscolx then recx=viscolx
 if recy>viscoly then recy=viscoly
 if recz>viscolz then recz=viscolz
 `
 rem Reset ready to store strongest point
 totaltlightpower#=0
 rem markblosser -instead of using player position, use generic recxyz# position so entities can find their strongest light as well
 avlightposx#=recx# : avlightposy#=recy# : avlightposz#=recz#
 `avlightposx#=mex# : avlightposy#=mey# : avlightposz#=mez#
 avlightcolr#=0 : avlightcolg#=0 : avlightcolb#=0
 tlightinfluencedbydynamiclight=0
 avlightrange#=0
 `
 rem Go through ALL scene lights
 titer=0 : tqty=0 : tqtyav#=1.0
 closestdist#=99999
 array index to top infinilight()
 while array index valid(infinilight())
  `
  rem V118 - instantly skip a light if it is dynamic and the entity (if specified) has no effect (FF provides lighting)
  okaytolight=0
  `
  rem Collect position of light
  ldistx#=infinilight().x-recx#
  ldisty#=infinilight().y-recy#
  ldistz#=infinilight().z-recz#
  `calculate distance from light
  ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
  `
  `rem light range gets a 1.5x multiplier when sent to lightmapper, need to extend light range
  `here for correct attenuation of SurfColor - 1.2 seems to work ok - markblosser
  `then check to make sure player/entity is within light's range - if not, ignore
  if ldist#<=infinilight().range*1.2
    okaytolight=1
  endif
  `
  if okaytolight=1
   `
   rem for all lights
   if infinilight().islit=1
    `
   `remember to extend light range a bit here -see above comment - markblosser
   `using a linear falloff to attenuate light and weight cumulative average
    tlightpower#=((infinilight().range*1.2)-ldist#)/(infinilight().range*1.2)
    `
    rem further weight lights within 1000(10 segment) radius of player/entity
    tplayercareabout#=1000.0
    `
    tlightrawstrength#=1.0-(ldist#/tplayercareabout#) : rem player can apprecirate/care about direction of light within this range
    tlightrawstrength#=tlightrawstrength#*tlightpower#
    if tlightrawstrength#<0.0 then tlightrawstrength#=0.0
    if tlightrawstrength#>1.0 then tlightrawstrength#=1.0
    if ldist#<tplayercareabout#
     `
     rem Work out average light position based on player/entity position
     avlightposx#=avlightposx#+(infinilight().x*tlightrawstrength#)
     avlightposy#=avlightposy#+(infinilight().y*tlightrawstrength#)
     avlightposz#=avlightposz#+(infinilight().z*tlightrawstrength#)
     tqtyav#=tqtyav#+tlightrawstrength#
     `
     rem check for dynamic type
     if infinilight().type=1
      tlightinfluencedbydynamiclight=1
     endif
     `
    endif
    `
    rem True entity colour
    avlightcolr#=avlightcolr#+(infinilight().colrgb.r*tlightrawstrength#)
    avlightcolg#=avlightcolg#+(infinilight().colrgb.g*tlightrawstrength#)
    avlightcolb#=avlightcolb#+(infinilight().colrgb.b*tlightrawstrength#)
    avlightrange#=avlightrange#+(ldist#*tlightrawstrength#)
    `inc tqty
    `
   endif
   `
  endif
  `
  next array index infinilight()
  `
 endwhile
 `
 rem Center to player for correct averaged single light position
 if tqtyav#>0
  avlightposx#=avlightposx#/tqtyav#
  avlightposy#=avlightposy#/tqtyav#
  avlightposz#=avlightposz#/tqtyav#
  rem (markblosser) also average the light colors so multiple lights are less likely to saturate SurfColor completely white!
  avlightcolr#=avlightcolr#/tqtyav#
  avlightcolg#=avlightcolg#/tqtyav#
  avlightcolb#=avlightcolb#/tqtyav#
 endif
 `
 rem get correct average light color
 if tqty>0
  rem V118 - 160211 - one light near enemy, 17 far away, then final color is almost black!!
  rem instead we use cumilative total of all influencing colours with range built in (fade)
  `avlightcolr#=avlightcolr#/tqty
  `avlightcolg#=avlightcolg#/tqty
  `avlightcolb#=avlightcolb#/tqty
 endif
 `
 rem FPSCV104RC8 - ensure colours not maxed
 if avlightcolr#>255 then avlightcolr#=255
 if avlightcolg#>255 then avlightcolg#=255
 if avlightcolb#>255 then avlightcolb#=255
 `
 rem debug lighting system for entities
 if activatedynamiclightsdebug=1
  entitydebug$(recentityindex)="LIGHTING RGB="+str$(int(avlightcolr#))+","+str$(int(avlightcolg#))+","+str$(int(avlightcolb#))
  entitydebug$(recentityindex)=entitydebug$(recentityindex)+" QTY="+str$(tqty)
 endif
 `
return

_lighting_managegloballighting:
 `
 recx#=mex# : recy#=mey# : recz#=mez#
 recentityindex=0
 gosub _lighting_managegloballightingreciever
 `
return

_lighting_applyplayerlighting:

rem Display test objects to show key markers
if activatedynamiclightsdebug=1
 tobj=49998 : if object exist(tobj)=0 then make object cone tobj,25 : xrotate object tobj,180
 set object collision off tobj
 position object tobj,avlightposx#,avlightposy#+20,avlightposz#
 if object in screen(tobj)=1
  center text object screen x(tobj),object screen y(tobj)-20,strarr$(153)
 endif
` if gdynamicshadowsstate=1
`  tsli=1
`  if array count(shadowlight())>=tsli
`   tobj=49999 : if object exist(tobj)=0 then make object cube tobj,25
`   set object collision off tobj
`   position object tobj,shadowlight(tsli).x#,shadowlight(tsli).y#,shadowlight(tsli).z#
`   if object in screen(tobj)=1
`    center text object screen x(tobj),object screen y(tobj)-20,strarr$(154)
`   endif
`  endif
` endif
endif

rem Apply averaged colour to player (avlightcolX#)
gosub _lighting_applyplayercolor

rem Shadow light controlled by most prominant light zero
`if gdynamicshadowsstate=1
` scene shadows disabled for V1.0
` for tsli=1 to array count(shadowlight())
`  set shadow light tsli,shadowlight(tsli).x#,shadowlight(tsli).y#,shadowlight(tsli).z#,shadowlight(tsli).range#
` next tsli
`endif

return

_lighting_applyplayercolor:
 `
 rem Apply player average colour to gun
 if gunid>0 then teffectid=gun(gunid).effectidused else teffectid=0
 if teffectid>0
  rem apply shader values
  r=make vector4(1)
  set vector4 1,avlightposx#,avlightposy#,avlightposz#,1.0
  set effect constant vector teffectid,"LightSource",1
  set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
  set effect constant vector teffectid,"SurfColor",1
  tamb#=guivisualsettings.ambience/100.0 : set vector4 1,tamb#,tamb#,tamb#,1.0
  set effect constant vector teffectid,"AmbiColor",1
  r=delete vector4(1)
 else
  rem illumonate player without shader
  if currentgunobj>0
   tcurrentguncolr=avlightcolr# : tcurrentguncolg=avlightcolg# : tcurrentguncolb=avlightcolb#
   if tcurrentguncolr<>currentguncolr or tcurrentguncolg<>currentguncolg or tcurrentguncolb<>currentguncolb
    currentguncolr=tcurrentguncolr : currentguncolg=tcurrentguncolg : currentguncolb=tcurrentguncolb
    set object emissive currentgunobj,rgb(avlightcolr#,avlightcolg#,avlightcolb#)
   endif
  endif
 endif
 `
return

_lighting_applyentitycolor:
 `
 rem Position of entity to calc light for
 recx#=entityelement(e).x
 recy#=entityelement(e).y
 recz#=entityelement(e).z
 `
 rem Optimise by only calculating light of entity shifts position - (markblosser) instead don't divide by 25 for smoother SurfColor when moving in/out of lights
 tcurrentcolx=recx#
 tcurrentcoly=recy#
 tcurrentcolz=recz#
 rem (markblosser) ALWAYS record color-light-calc-position
 `if tcurrentcolx<>entityelement(e).colr or tcurrentcoly<>entityelement(e).colg or tcurrentcolz<>entityelement(e).colb
  `
  rem Record new color-light-calc position
  entityelement(e).colr=tcurrentcolx : entityelement(e).colg=tcurrentcoly : entityelement(e).colb=tcurrentcolz
  `
  rem calculate light from base position
  recentityindex=e
  gosub _lighting_managegloballightingreciever
  `
  rem Apply average colour (now updated later on)
  teffectid=entityelement(e).eleprof.usingeffect
  if teffectid>0
   `
   rem apply shader values
   r=make vector4(1)
   set vector4 1,avlightposx#,avlightposy#,avlightposz#,1.0
   set effect constant vector teffectid,"LightSource",1
   set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
   set effect constant vector teffectid,"LightColor",1
   set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
   set effect constant vector teffectid,"SurfColor",1
   tamb#=guivisualsettings.ambience/100.0 : set vector4 1,tamb#,tamb#,tamb#,1.0
   set effect constant vector teffectid,"AmbiColor",1
   `
   rem (markblosser) - send spotflash light values to shader - light range is fixed at 600 in _lighting_spotflash:
   rem (markblosser) - SpotFlashPos.w is carrying the spotflash fadeout value
   set vector4 1,spotflashx#,spotflashy#,spotflashz#,spotfadeout#
   set effect constant vector teffectid,"SpotFlashPos",1
   set vector4 1,spotlightr#,spotlightg#,spotlightb#,1.0
   set effect constant vector teffectid,"SpotFlashColor",1
   `
   rem V118 - 110211 - send floorpositionY to shader if shader uses shadow style functionality
   tmp1#=entityelement(e).floorpositiony : rem Floor Position Y
   tmp2#=0 : rem Reserved
   tmp3#=0 : rem Reserved
   tmp4#=0 : rem Reserved
   set vector4 1,tmp1#,tmp2#,tmp3#,tmp4#
   set effect constant vector teffectid,"FloorPositionY",1
   r=delete vector4(1)
   if entityelement(e).attachmentobj>0
    if object exist(entityelement(e).attachmentobj)
     set object emissive entityelement(e).attachmentobj,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)
    endif
   endif
   `
  else
   rem no shader color for diffuse entities
   if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
    set object emissive entityelement(e).obj,rgb(255,255,255)
    if entityelement(e).attachmentobj>0
     if object exist(entityelement(e).attachmentobj)
      set object emissive entityelement(e).attachmentobj,rgb(255,255,255)
     endif
    endif
   else
    set object emissive entityelement(e).obj,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)
    if entityelement(e).attachmentobj>0
     if object exist(entityelement(e).attachmentobj)
      set object emissive entityelement(e).attachmentobj,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)
     endif
    endif
   endif
  `endif  - (markblosser) always record color-light-calc position
  `
 endif
 `
return

_lighting_applytoscene:

rem Set light zero for dynamic shadows of objects that cast them
`if gdynamicshadowsstate=1
` the old system for scene shadows, leave for next version
` disabled scene shadow for V1.0
` if array count(shadowlight(0))>0
` set global shadow color 0,0,0,128
`  tsli=1 : set point light 0,shadowlight(tsli).x#, shadowlight(tsli).y#, shadowlight(tsli).z#
`  shadowlight(tsli).range#
` endif
`endif

rem Constantly update hero light (for shadows and effects)
`set point light 0,camera position x(),camera position y(),camera position z()
rem for V1 need a way to handle this singular-light issue with SHADERS
rem for the ODE tests, a fixed light zero for the shadows
rem ultimate problem solver for shadow distance is a Sun-Style Light
`ODE physics controls shadow light now
`set point light 0,-1500,3000,1500
`
rem Scene can have effects in play (which require general parameters passed in)
tamb#=guivisualsettings.ambience/100.0
r=make vector4(1)
for tef=1 to effectbankmax
 teffectid=effectbankoffset+tef
 rem FPGC - 040110 - added LightSource data pass into scenery segments
 set vector4 1,avlightposx#,avlightposy#,avlightposz#,1.0
 set effect constant vector teffectid,"LightSource",1
 set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
 set effect constant vector teffectid,"LightColor",1
 set vector4 1,tamb#,tamb#,tamb#,1.0
 set effect constant vector teffectid,"AmbiColor",1
 `
 rem (markblosser) send scripted ambient color changes to shaders also
 set vector4 1,hudambiencered,hudambiencegreen,hudambienceblue,1.0
 set effect constant vector teffectid,"AmbiColorOverride",1
 `
 rem (markblosser) - send spotflash light values to shader - light range is fixed at 600 in _lighting_spotflash:
 rem (markblosser) - SpotFlashPos.w is carrying the spotflash fadeout value
 set vector4 1,spotflashx#,spotflashy#,spotflashz#,spotfadeout#
 set effect constant vector teffectid,"SpotFlashPos",1
 set vector4 1,spotlightr#,spotlightg#,spotlightb#,1.0
 set effect constant vector teffectid,"SpotFlashColor",1
 `
 rem markblosser - pass hud fog values to shaders
 set vector4 1,(hudfogred/255.0),(hudfoggreen/255.0),(hudfogblue/255.0),1.0
 set effect constant vector teffectid,"HudFogColor",1
 set vector4 1,hudfognear,hudfogfar,1.0,1.0
 set effect constant vector teffectid,"HudFogDist",1
 `
 rem V118 - 050211 - also send DYNAMIC lighting info to shaders (in case they support dynamic lighting)
 lightindex=2
 array index to top infinilightshortlist()
 while array index valid(infinilightshortlist())
  tindex=infinilightshortlist() : tobj=infinilight(tindex).id
  if infinilight(tindex).type=1
   set vector4 1,infinilight(tindex).x,infinilight(tindex).y,infinilight(tindex).z,1
   if lightindex=2 then set effect constant vector teffectid,"g_lights_pos0",1
   if lightindex=3 then set effect constant vector teffectid,"g_lights_pos1",1
   if lightindex=4 then set effect constant vector teffectid,"g_lights_pos2",1
   if lightindex=5 then set effect constant vector teffectid,"g_lights_pos3",1
   att#=infinilight(tindex).range : att#=att#/3.0 : att#=1.0/(att#*att#)
   set vector4 1,1.0,0,att#,0.0
   if lightindex=2 then set effect constant vector teffectid,"g_lights_atten0",1
   if lightindex=3 then set effect constant vector teffectid,"g_lights_atten1",1
   if lightindex=4 then set effect constant vector teffectid,"g_lights_atten2",1
   if lightindex=5 then set effect constant vector teffectid,"g_lights_atten3",1
   colrgbr#=infinilight(tindex).colrgb.r : colrgbr#=colrgbr#/255.0
   colrgbg#=infinilight(tindex).colrgb.g : colrgbg#=colrgbg#/255.0
   colrgbb#=infinilight(tindex).colrgb.b : colrgbb#=colrgbb#/255.0
   set vector4 1,colrgbr#,colrgbg#,colrgbb#,1
   if lightindex=2 then set effect constant vector teffectid,"g_lights_diffuse0",1
   if lightindex=3 then set effect constant vector teffectid,"g_lights_diffuse1",1
   if lightindex=4 then set effect constant vector teffectid,"g_lights_diffuse2",1
   if lightindex=5 then set effect constant vector teffectid,"g_lights_diffuse3",1
   inc lightindex
  endif
  next array index infinilightshortlist()
 endwhile
 set vector4 1,0,0,0,0
 while lightindex<7
  if lightindex=2 then set effect constant vector teffectid,"g_lights_diffuse0",1
  if lightindex=3 then set effect constant vector teffectid,"g_lights_diffuse1",1
  if lightindex=4 then set effect constant vector teffectid,"g_lights_diffuse2",1
  if lightindex=5 then set effect constant vector teffectid,"g_lights_diffuse3",1
  inc lightindex
 endwhile
 `
next tef
r=delete vector4(1)

return

_lighting_spotflash:
 `
 rem Control spot flash
 if spotflash=100
  spotflash=99 : spotflashx#=tx# : spotflashy#=ty# : spotflashz#=tz#
  if light exist(1)=1
   set point light 1,spotflashx#,spotflashy#,spotflashz# : set light range 1,flashrange
   spotlightr#=tcolr : spotlightg#=tcolg : spotlightb#=tcolb
   color light 1,spotlightr#,spotlightg#,spotlightb#
   show light 1
  endif
 endif
 if spotflash>0 and spotflash<100
  dec spotflash,20
  if spotflash>0
   if light exist(1)=1
    spotfadeout#=spotflash/100.0
    color light 1,spotlightr#*spotfadeout#,spotlightg#*spotfadeout#,spotlightb#*spotfadeout#
   endif
  else
   spotflash=0
   if light exist(1)=1 then hide light 1
  endif
 endif
 `
return

_lighting_applyflakcolor:
 `
 rem illumonate flak without shader
 if flakelement(flaki).obj>0

  recx#=flakelement(flaki).xpos
  recy#=flakelement(flaki).ypos
  recz#=flakelement(flaki).zpos
  tcurrentcolx=recx#/25
  tcurrentcoly=recy#/25
  tcurrentcolz=recz#/25
  if flakelement(flaki).colx<>tcurrentcolx or flakelement(flaki).coly<>tcurrentcoly or flakelement(flaki).colz<>tcurrentcolz
   flakelement(flaki).colx=tcurrentcolx
   flakelement(flaki).coly=tcurrentcoly
   flakelement(flaki).colz=tcurrentcolz

   gosub _lighting_managegloballightingreciever

   set object emissive flakelement(flaki).obj,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)

  endif
 endif

 `
return

_lighting_applyflakstickcolor:
 `
 rem illumonate flak without shader
 if flakstick(flaki).obj>0

  recx#=flakstick(flaki).x
  recy#=flakstick(flaki).y
  recz#=flakstick(flaki).z
  tcurrentcolx=recx#/25
  tcurrentcoly=recy#/25
  tcurrentcolz=recz#/25
  if flakstick(flaki).colx<>tcurrentcolx or flakstick(flaki).coly<>tcurrentcoly or flakstick(flaki).colz<>tcurrentcolz
   flakstick(flaki).colx=tcurrentcolx
   flakstick(flaki).coly=tcurrentcoly
   flakstick(flaki).colz=tcurrentcolz

   gosub _lighting_managegloballightingreciever

   set object emissive flakstick(flaki).obj,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)
  endif

 endif

 `
return

rem
rem ENTITY
rem

_entity_validatearraysize:
 `
 rem ensure enough space in entity profile arrays
 if entidmaster+32>entidmastermax
  entidmastermax=entidmaster+32
  dim entitybodypart(entidmastermax,100) as integer
  dim entityanim(entidmastermax,animmax) as entityanimtype
  dim entityfootfall(entidmastermax,footfallmax) as entityfootfalltype
  dim entityprofileheader(entidmastermax) as entityprofileheadertype
  dim entityprofile(entidmastermax) as entityprofiletype
  dim entitydecal$(entidmastermax,100) as string
  dim entitydecal(entidmastermax,100) as integer
  entitybankmax=entidmastermax
  dim entitybank$(entitybankmax)
  rem AirMod - Advanced blood
  dim entityblood(entidmastermax,BLOODMAX) as entitybloodtype
 endif
 `
return

_entity_savebank:

rem FPSCV104RC6 - scan entire entityelement, delete all entitybank entries not used
rem V106 RC3 but not if we are constructing the level (as ENT will not match ELE)
if gcompilestandaloneexe=0
 if entidmaster>0
  dim entitybankused(entidmaster)
  for tttentid=1 to entidmaster
   entitybankused(tttentid)=0
  next tttentid
  for ttte=1 to entityelementlist
   tttentid=entityelement(ttte).bankindex
   if tttentid>0
    entitybankused(tttentid)=1
   endif
  next ttte
  for tttentid=1 to entidmaster
   if entitybankused(tttentid)=0
    rem remove entity entry if not used when save FPM
    entitybank$(tttentid)=""
   endif
  next tttentid
  rem shuffle to remove empty entries
  for tttentid=1 to entidmaster
   rem not used to record where entities have been moved to
   entitybankused(tttentid)=0
  next tttentid
  treadentid=1 : tlargest=0
  for tttentid=1 to entidmaster
   if treadentid<=entidmaster
    while entitybank$(treadentid)=""
     inc treadentid : if treadentid>entidmaster then exit
    endwhile
    if treadentid<=entidmaster
     entitybank$(tttentid)=entitybank$(treadentid)
     entityprofileheader(tttentid)=entityprofileheader(treadentid)
     entityprofile(tttentid)=entityprofile(treadentid)
     for tt=0 to 100 : entitybodypart(tttentid,tt)=entitybodypart(treadentid,tt) : next tt
     for tt=0 to animmax : entityanim(tttentid,tt)=entityanim(treadentid,tt) : next tt
     for tt=0 to footfallmax : entityfootfall(tttentid,tt)=entityfootfall(treadentid,tt) : next tt
     for tt=0 to 100 : entitydecal$(tttentid,tt)=entitydecal$(treadentid,tt) : next tt
     for tt=0 to 100 : entitydecal(tttentid,tt)=entitydecal(treadentid,tt) : next tt
     entitybankused(treadentid)=tttentid
     tlargest=tttentid
    else
     entitybank$(tttentid)=""
    endif
   else
    entitybank$(tttentid)=""
   endif
   inc treadentid
  next tttentid
  rem new list size
  if entidmaster<>tlargest
   entidmaster=tlargest
   entityorsegmententrieschanged=1
  endif
  rem update bank index numbers in entityelements
  for ttte=1 to entityelementlist
   tttentid=entityelement(ttte).bankindex
   if tttentid>0
    rem new entity entry place index
    entityelement(ttte).bankindex=entitybankused(tttentid)
   endif
  next ttte
  undim entitybankused()
 endif
endif

rem Save segment bank
if file exist("mapbank\testmap\map.ent")=1 then delete file "mapbank\testmap\map.ent"
open to write 1,"mapbank\testmap\map.ent"
 write file 1,entidmaster
 if entidmaster>0
  for entid=1 to entidmaster
   write string 1,entitybank$(entid)
  next entid
 endif
close file 1

return

_entity_deletebank:

rem Destroy old entities
if entidmastermax>0
 rem V104RC6 changed from entidmaster
 for entid=1 to entidmastermax
  entobj=entitybankoffset+entid
  if object exist(entobj)=1 then delete object entobj
  entitybank$(entid)=""
 next entid
endif

rem FPGC - 250310 - ensure objecteffect array is cleared after any object delete
for o=1 to 65535
 if object exist(o)=0 then objecteffect(o)=0
next o

rem Destroy profile data
undim entityprofile()
dim entityprofile(100) as entityprofiletype
entidmastermax=100
entidmaster=0

return

_entity_loadbank:

rem If ent file exists
filename$=levelmapptah$+"map.ent"
if file exist(filename$)=1
 `
 rem Destroy old entities
 gosub _entity_deletebank
 `
 rem Load entity bank
 open to read 1,levelmapptah$+"map.ent"
  read file 1,entidmaster
  if entidmaster>0
   gosub _entity_validatearraysize
   for entid=1 to entidmaster
    read string 1,entitybank$(entid)
   next entid
  endif
 close file 1
 `
 rem Load in all entity objects and data
 gosub _entity_loadentitiesnow
 `
rem No file
endif

return

_entity_loadentitiesnow:

rem Load entities specified by bank
entdir$="entitybank\"
if entidmaster>0
 for entid=1 to entidmaster
  ent$=entitybank$(entid)
  entpath$=getpath(ent$)
  gosub _entity_load
  if desc$=""
   rem where entities have been lost, delete from list
   entitybank$(entid)=""
  endif
 next entid
endif

return

_entity_updatebank:

rem If ent file exists
filename$=levelmapptah$+"map.ent"
if file exist(filename$)=1

rem Clear non-present entries
for entid=entidmaster+1 to entitybankmax
 entitybank$(entid)=""
next entid

rem Update entity bank
open to read 2,filename$
 read file 2,tvalmax
 if tvalmax>0
  for tvalindex=1 to tvalmax
   read string 2,tent$
   addentityfile$=tent$
   gosub _entity_adduniqueentity
  next tvalindex
 endif
close file 2

rem No file
endif

return

_entity_adduniqueentity:

rem Ensure 'entitybank\' is not part of entity filename
entdir$="entitybank\"
if lower$(left$(addentityfile$,11))="entitybank\"
 addentityfile$=right$(addentityfile$,len(addentityfile$)-11)
endif

rem Check if entity already loaded in
talreadyloaded=0
for t=1 to entidmaster
 if entitybank$(t)=addentityfile$ then talreadyloaded=1 : entid=t
next t
if talreadyloaded=0
 `
 rem Allocate one more entity item in array
 if entidmaster>entitybankmax-4
  dim tempentitybank$(entitybankmax)
  for t=0 to entitybankmax : tempentitybank$(t)=entitybank$(t) : next t
  inc entitybankmax
  undim entitybank$(0)
  dim entitybank$(entitybankmax)
  for t=0 to entitybankmax-1 : entitybank$(t)=tempentitybank$(t) : next t
 endif
 `
 rem Add entity to bank
 inc entidmaster : gosub _entity_validatearraysize
 entitybank$(entidmaster)=addentityfile$
 `
 rem Load extra entity
 entid=entidmaster
 ent$=entitybank$(entid)
 entpath$=getpath(ent$)
 gosub _entity_load
 `
endif

return

_entity_loadextra:

rem load if entity is unique (unloaded - uses addentityfile$)
gosub _entity_adduniqueentity

rem Allocate one more into entity element array too
if entityelementlist>entityelementmax-4
 dim tempentityelement(entityelementmax) as entitytype
 for t=0 to entityelementmax : tempentityelement(t)=entityelement(t) : next t
 undim entityelement()
 undim entityshadervar()
 undim entitydebug$(0)
 inc entityelementmax
 dim entityelement(entityelementmax) as entitytype
 dim entityshadervar(entityelementmax,globalselectedshadermax)
 dim entitydebug$(entityelementmax)
 for t=0 to entityelementmax-1 : entityelement(t)=tempentityelement(t) : next t
endif

rem Ensure we subtract the offset used by the entity(which would be part of the seg-info)
addentityx=addentityx-entityprofile(entid).offx
addentityz=addentityz-entityprofile(entid).offz
addentityy=addentityy-entityprofile(entid).offy

rem Add reference to entity as element
gosub _entity_addelement

return

_entity_addelement:
 `
 rem find spare
 for e=1 to entityelementlist
  if entityelement(e).bankindex=0 then exit
 next e
 if e>entityelementlist
  rem add new
  inc entityelementlist
  if entityelementlist>entityelementmax
   entityelementmax=entityelementlist
   dim entityelement(entityelementmax) as entitytype
   dim entityshadervar(entityelementmax,globalselectedshadermax)
   dim entitydebug$(entityelementmax)
  endif
  e=entityelementlist
 endif
 `
 rem create element entry data
 gosub _entity_fillelementfromprofile
 entityelement(e).editorfixed=0
 entityelement(e).maintype=1
 entityelement(e).bankindex=entid
 entityelement(e).x=addentityx+entityprofile(entid).offx
 entityelement(e).y=addentityy+entityprofile(entid).offy
 entityelement(e).z=addentityz+entityprofile(entid).offz
 entityelement(e).rx=addentityrx+entityprofile(entid).rotx
 entityelement(e).ry=addentityry+entityprofile(entid).roty
 entityelement(e).rz=addentityrz+entityprofile(entid).rotz
 `
return

_entity_loadtexturesandeffect:

rem If entity object not exist, reset var
if entobj>0
 if object exist(entobj)=0 then entobj=0
endif

rem Only characters need a higher quality texture, rest use divide standard settings
tfullorhalfdivide=0
if segobjusedformapeditor=0
 if entityprofile(entid).ischaracter=1
  tfullorhalfdivide=2
 else
  if entityprofile(entid).reducetexture<>0
   if entityprofile(entid).reducetexture=-1
    tfullorhalfdivide=1
   else
    tfullorhalfdivide=2
   endif
  endif
 endif
endif
`
rem Apply TEXTURE to entity object
tcanceltheeffect=0
tuseeffecttexture=0
tfile$=entityprofile(entid).texd$
tfilealt$=entityprofile(entid).texaltd$
if tfile$<>""
 `
 rem optional texture path for getting at any texture (gamecore gun textures, etc)
 if entityprofile(entid).texpath$<>""
  texdir$=entityprofile(entid).texpath$+tfile$
  texaltdir$=entityprofile(entid).texpath$+tfilealt$
 else
  texdir$=entdir$+entpath$+tfile$
  texaltdir$=entdir$+entpath$+tfilealt$
 endif
 if entityprofile(entid).transparency=0
  texuseid=loadinternaltextureex(texdir$,1,tfullorhalfdivide)
 else
  texuseid=loadinternaltextureex(texdir$,5,tfullorhalfdivide)
 endif
 if texuseid=0
  rem if not local texture, look in texture bank
  texdir$=entityprofile(entid).texd$
  texaltdir$=entityprofile(entid).texaltd$
 endif
 `
 rem Effect Or No
 tstage=0
 tfile$=entityprofile(entid).effect$
 teffectuseslightmapstage=0 : gosub _common_makeeffecttextureset
 if tfile$<>"" and guseeffectonentitiesstate=1 and segobjusedformapeditor=0
  `
  rem Load and apply MAIN texture directly
  if gproducelogfiles=1 then timestampactivity(0,"Entity "+str$(entid)+" using "+tfile$)
  for tlayer=0 to 4
   if tlayer=0 then texfiletouse$=texdir1$
   if tlayer=1 then texfiletouse$=texdir2$
   if tlayer=2 then texfiletouse$=texdir3$
   if tlayer=3 then texfiletouse$=texdir4$
   if tlayer=4 then texfiletouse$=texdir5$
   if entityprofile(entid).transparency=0
    texuseid=loadinternalimagecompressquality(texfiletouse$,1,tfullorhalfdivide)
   else
    texuseid=loadinternalimagecompressquality(texfiletouse$,5,tfullorhalfdivide)
   endif
   if texuseid=0
    if tlayer=0
     rem can fall back to D2 if D not exist
     texdir1$=tstr1$+"D2"+tstr2$ : texfiletouse$=texdir1$
     if entityprofile(entid).transparency=0
      texuseid=loadinternalimagecompressquality(texfiletouse$,1,tfullorhalfdivide)
     else
      texuseid=loadinternalimagecompressquality(texfiletouse$,5,tfullorhalfdivide)
     endif
    endif
    if texuseid=0
     rem main support textures N and I might be global (ie aiko_1_D2 and aiko_2_D2 use aiko_N.TGA, etc)
     if tlayer>0
      if upper$(right$(texfiletouse$,5))="N.TGA" then texfiletouse$=left$(tstr1$,len(tstr1$)-2)+"N"+tstr2$
      if upper$(right$(texfiletouse$,5))="S.TGA" then texfiletouse$=left$(tstr1$,len(tstr1$)-2)+"S"+tstr2$
      if upper$(right$(texfiletouse$,5))="N.DDS" then texfiletouse$=left$(tstr1$,len(tstr1$)-2)+"N"+tstr2$
      if upper$(right$(texfiletouse$,5))="S.DDS" then texfiletouse$=left$(tstr1$,len(tstr1$)-2)+"S"+tstr2$
      if entityprofile(entid).transparency=0
       texuseid=loadinternalimagecompressquality(texfiletouse$,1,tfullorhalfdivide)
      else
       texuseid=loadinternalimagecompressquality(texfiletouse$,5,tfullorhalfdivide)
      endif
     endif
    endif
    if texuseid=0
     rem some effects NEED to have a specific texture, or we cancel the effect
     if absolutelyrequirethistexture>0 and (1+tlayer)=absolutelyrequirethistexture
      rem no texture for this layer means we
      tcanceltheeffect=1
     else
      rem some effects need a blank texture if no file available
      if tlayer<=ensureclearlayermax
       rem black texture if no texture
       texuseid=loadinternalimagecompressquality("texturebank\common\black.tga",1,0)
      endif
     endif
    endif
   endif
   if texuseid>0
    if entobj>0 then texture object entobj,tstage,texuseid
    if tstage=0 then entityprofile(entid).texdid=texuseid
    if tstage=1 then entityprofile(entid).tex1id=texuseid
    if tstage=2 then entityprofile(entid).tex2id=texuseid
    if tstage=3 then entityprofile(entid).tex3id=texuseid
    if tstage=4 then entityprofile(entid).tex4id=texuseid
    inc tstage
   endif
   if gproducelogfiles=1 then timestampactivity(0,"Texture "+str$(tlayer)+": texuseid="+str$(texuseid)+" texfiletouse$="+texfiletouse$)
  next tlayer
  if tstage<3
   for tst=tstage to 3
    if tst=1 then entityprofile(entid).tex1id=0
    if tst=2 then entityprofile(entid).tex2id=0
    if tst=3 then entityprofile(entid).tex3id=0
   next tst
  endif
  `
  rem Using effect
  if tcanceltheeffect=0
   if tstage>0 then tuseeffecttexture=1
  endif
  `
 endif
 `
 rem Record number of texture stages used
 entityprofile(entid).texidmax=tstage-1
 `
 rem Load basic D2 MAIN texture (if no effect textures)
 if tuseeffecttexture=0
  if entityprofile(entid).transparency=0
   texid=loadinternalimagecompressquality(texdir$,1,tfullorhalfdivide)
  else
   texid=loadinternalimagecompressquality(texdir$,5,tfullorhalfdivide)
  endif
  entityprofile(entid).texdid=texid
  `if gproducelogfiles=1 then timestampactivity(0,"Base Texture texuseid="+str$(texid)+" texfiletouse$="+texdir$)
  if entobj>0
   texture object entobj,texid
  endif
 endif
 `
 rem Load ALT texture if available
 texaltdid=loadinternalimagecompressquality(texaltdir$,1,tfullorhalfdivide)
 entityprofile(entid).texaltdid=texaltdid
 `
else
 `
 rem FPSCV101 - add texturenames from file into filecollection (or exes will not find them)
 if entobj>0
  limbtexturename$=findmaterialtexturesinmodelfile(entdir$+entpath$+entityprofile(entid).model$,entdir$+entpath$)
 endif
 `
endif
`
rem Apply effect to entity object (map editor does NOT use any effects)
if tcanceltheeffect=1
 rem FPGC - 050710 - make sure this entity cannot try to summon an effect later (no texture for such effect)
 rem typically this is an entity FPE file mistake, but the engine will correct it here for smoothness
 entityprofile(entid).effect$=""
endif
`
entityprofile(entid).usingeffect=0
if guseeffectonentitiesstate=1 and segobjusedformapeditor=0 and tcanceltheeffect=0
 tfile$=entityprofile(entid).effect$
 gosub _common_wipeeffectifnotexist
 if tfile$<>""
  teffectid=loadinternaleffect(tfile$)
  if teffectid>0
   entityprofile(entid).usingeffect=teffectid
  endif
 endif
endif
`
rem Set any entity transparenct
if entobj>0 then set object transparency entobj,entityprofile(entid).transparency
`
rem If transparent, no need to Z write
if entityprofile(entid).transparency>0 and entobj>0
 rem had to remove this as in the game, the minigun (trans=1) was rendered inside out
 if entityprofile(entid).transparency>=2
  disable object zwrite entobj
  enable object zbias entobj,0.0,-0.000001
 endif
endif

return

_entity_updatealttexture:
 `
 rem called from FPI action (obj,e)
 if obj>0
  if entityelement(e).alttextureused=0
   texture object obj,0,entityelement(e).eleprof.texdid
  else
   texture object obj,0,entityelement(e).eleprof.texaltdid
  endif
 Rem Scene commander - fix for corrupting of characters mesh during alt switch.
  if entityelement(e).eleprof.usingeffect>0 and entityelement(e).eleprof.texaltdid=0
   if entityelement(e).eleprof.tex1id<>0 then texture object obj,1,entityelement(e).eleprof.tex1id
   if entityelement(e).eleprof.tex2id<>0 then texture object obj,2,entityelement(e).eleprof.tex2id
   if entityelement(e).eleprof.tex3id<>0 then texture object obj,3,entityelement(e).eleprof.tex3id
   if entityprofile(entid).limbmax>1
    rem FPSC - 210111 - force CPU animation for entities with specific limb identities
    set object effect obj,entityelement(e).eleprof.usingeffect,1
   else
    set object effect obj,entityelement(e).eleprof.usingeffect,0
   endif
   objecteffect(obj)=entityelement(e).eleprof.usingeffect
  else
   rem FPGC - 100610 - fix issue which wipes 'material mode' when re-apply texture
   set object diffuse obj,rgb(128,128,128)
  endif
 endif
 `
return

_entity_load:

rem FPGC - 050909 - resource monitor of entities
openresource(entitybank$(entid))

rem Entity Object Index
entobj=entitybankoffset+entid

rem debug info
mytimer=timer()

rem Load Entity profile data
gosub _entity_loaddata

rem Only load characters for entity-local-testing
desc$=entityprofileheader(entid).desc$
if scanforentitiescharactersonly=1
 if entityprofile(entid).ischaracter=0
  desc$=""
 endif
endif

rem Only if profile data exists
if desc$<>""
 `
 rem progress report as this is a slow phase
 debugviewtext(175,strarr$(136)+str$(entid)+"a\"+str$(entidmaster)+" ("+entityprofile(entid).model$+")")
 `
 rem Load the model
 tfile$=entdir$+entpath$+entityprofile(entid).model$
 if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
 if tdbofile$<>"" and file exist(tdbofile$)=1 then tfile$=tdbofile$
 if file exist(tfile$)=0
  tfile$=entityprofile(entid).model$
  rem V109 BETA6 - 290408 - allow DBO creation/read if full relative path provides (i.e. meshbank\scifi\etc)
  if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
  if tdbofile$<>"" and file exist(tdbofile$)=1 then tfile$=tdbofile$
 endif
 if file exist(tfile$)=1
  `
  rem if DBO version exists, use that (quicker)
  if file exist(tdbofile$)=1
   tfile$=tdbofile$
   tdbofile$=""
  else
   rem allowed to save DBO (once only)
  endif
  `
  if entobj>0
  if object exist(entobj)=0
  rem Load entity (compile does not need the dynamic objects)
  load object tfile$,entobj
  set object filter entobj,2
  set object collision off entobj
  addfiletocollection(tfile$)
  endif
  endif

  if object exist(entobj)=1
   `
   rem Save if DBO not exist for entity (for fast loading)
   if len(tdbofile$)>1
    rem U75 - 070809 - ensure legacy compatibility (avoids new mapedito crashing build process)

    save object tdbofile$,entobj
    if file exist(tdbofile$)=1

     delete object entobj
     load object tdbofile$,entobj
     set object filter entobj,2
     set object collision off entobj
    endif
   endif
   `
   rem main profile object adjustments
  ` if object exist(entobj)=1

   if entityprofile(entid).scale<>0 then scale object entobj,entityprofile(entid).scale,entityprofile(entid).scale,entityprofile(entid).scale
   `
   rem Apply texture and effect to entity profile obj
   gosub _entity_loadtexturesandeffect

   rem until static bonemodel scales when not animaating, loop

   if entityprofile(entid).ischaracter=1
    loop object entobj : stop object entobj
   endif

   `
   rem if entity has decals, find indexes to decals (which are already preloaded)
   entityprofile(entid).bloodscorch=0
   if entityprofile(entid).decalmax>0
    for tq=0 to entityprofile(entid).decalmax-1
     decal$=entitydecal$(entid,tq)
     if lower$(decal$)="blood" then entityprofile(entid).bloodscorch=1
     gosub _decal_find
     if decalid<0 then decalid=0
     entitydecal(entid,tq)=decalid
    next tq
   endif
   `
   rem Hide object away
  position object entobj,100000,100000,100000
   `
   endif
 ` endif
 else
  debugstring(right$(tfile$,70),strarr$(100))
  rem V110 - 260508 - prevent crash when model name wrong/geometry file missing/etc
  make object sphere entobj,1
  position object entobj,100000,100000,100000

 endif
 `
 rem Resolve default weapon gun ids
 if entityprofile(entid).isweapon$<>""
  findgun$=lower$(entityprofile(entid).isweapon$) : gosub _gun_findweaponindexbyname
  entityprofile(entid).isweapon=foundgunid
  if foundgunid>0 then gun(foundgunid).activeingame=1
 else
  entityprofile(entid).isweapon=0
 endif
 rem Finding hasweapon also in createlemenents (as eleprof may have changed the weapon!)
 if entityprofile(entid).hasweapon$<>""
  findgun$=lower$(entityprofile(entid).hasweapon$) : gosub _gun_findweaponindexbyname
  entityprofile(entid).hasweapon=foundgunid
  if foundgunid>0 and entityprofile(entid).isammo=0 then gun(foundgunid).activeingame=1
 else
  entityprofile(entid).hasweapon=0
 endif
 `
 rem see if we can find head automatically
 if entityprofile(entid).ischaracter=1
  if entityprofile(entid).headlimb=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_head"
      entityprofile(entid).headlimb=tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif
  endif
  if entityprofile(entid).firespotlimb=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="firespot"
      entityprofile(entid).firespotlimb=tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif
  endif
  if entityprofile(entid).spine=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_spine1"
      entityprofile(entid).spine=tc-1
      exit
     endif
    next tc
   endif
  endif
 if entityprofile(entid).spine2=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_spine2"
      entityprofile(entid).spine2=tc-1
      exit
     endif
    next tc
   endif
  endif
 endif

 ` Scene Commander limb scaling/scaling - requires standard limb naming convention

   rem left calf
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_l_calf"
      entityprofile(entid).LC = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem right calf
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_r_calf"
      entityprofile(entid).RC = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem left foot
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_l_foot"
      entityprofile(entid).LF = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem right foot
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_r_foot"
      entityprofile(entid).RF = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

 rem left hand

if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_l_hand"
      entityprofile(entid).LH = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem right hand
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_r_hand"
      entityprofile(entid).RH = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem left forearm
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_l_forearm"
      entityprofile(entid).LFA = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem right forearm
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_r_forearm"
      entityprofile(entid).RFA = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem left uppderarm
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_l_upperarm"
      entityprofile(entid).LUA = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem right upperarm
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_r_upperarm"
      entityprofile(entid).RUA = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem NECK
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_neck"
      entityprofile(entid).NECK = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem spine 3
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_spine3"
      entityprofile(entid).SP3 = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem left thigh
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_l_thigh"
      entityprofile(entid).LT = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif

   rem right thigh
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_r_thigh"
      entityprofile(entid).RT = tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif


 rem assign physics weight and friction (if not set)
 if entityprofile(entid).physics<>0
  tfriction=(object size x(entobj)*75)+(object size y(entobj)*75)+(object size z(entobj)*75)
  tweight=(object size x(entobj)*25)+(object size y(entobj)*25)+(object size z(entobj)*25)
  tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
  if tweight<200 then tweight=200
`  if entityprofile(entid).phyweight=0 then entityprofile(entid).phyweight=tweight
`  if entityprofile(entid).phyfriction=0 then entityprofile(entid).phyfriction=tfriction
  entityprofile(entid).phyweight=tweight
  entityprofile(entid).phyfriction=tfriction
 endif
 `
rem no profile exists endif
endif

rem debug info and timestamp list (if logging)
debugviewtext(-1,"Built "+ent$+" in "+str$(timer()-mytimer)+"ms")
if entobj>0
 if object exist(entobj)=1
  timestampactivity(0,"Loaded "+str$(entid)+":"+ent$)
 endif
endif

rem FPGC - 050909 - resource monitor of entities
closeresource()

return

_entity_loaddata:

rem Ensure entity profile still exists
entityprofileheader(entid).desc$=""
tprofile$=left$(entdir$+ent$,len(entdir$+ent$)-4)+".bin"
if isbinaryfileolderthantxtfileforent(tprofile$,entdir$+ent$)=1 then delete file tprofile$
if file exist(entdir$+ent$)=1 or file exist(tprofile$)=1

rem Export entity FPE file if flagged
if gexportassets=1
 tthumbbmpfile$=left$(entdir$+ent$,len(entdir$+ent$)-4)+".bmp"
 addfiletocollection(entdir$+ent$) : addfiletocollection(tthumbbmpfile$)
endif

rem Check if binary version of entity profile exists (DELETE BIN AT MOMEMENT!)
addfiletocollection(tprofile$)
if file exist(tprofile$)=0
 `
 rem Must be reset before parse
 entityprofile(entid).limbmax=0
 entityprofile(entid).animmax=0
 entityprofile(entid).footfallmax=0
 entityprofile(entid).headlimb=-1
 entityprofile(entid).firespotlimb=-1
 entityprofile(entid).physics=1
 entityprofile(entid).phyweight=100
 entityprofile(entid).phyfriction=0
 entityprofile(entid).raisefactor=0
 entityprofile(entid).phyalways=0
 entityprofile(entid).spine=-1
 entityprofile(entid).spine2=-1
 entityprofile(entid).decaloffsetangle=0
 entityprofile(entid).decaloffsetdist=0
 entityprofile(entid).decaloffsety=0
 entityprofile(entid).noragdoll=0
 entityprofile(entid).nothrowscript=0
 for q=0 to 100 : entitybodypart(entid,q)=0 : next q
 `
 rem Load entity Data from file
 dim data$(400)
 load array entdir$+ent$,data$()
 for l=0 to 399
  line$=data$(l)
  if len(line$)>0
   if left$(line$,1)<>";"
    `
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value1#=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem entity header
    if field$="desc" then entityprofileheader(entid).desc$=value$
    `
    rem entity AI
    tryfield$="aiinit"
    if field$=tryfield$ then entityprofile(entid).aiinit$=value$
    tryfield$="aimain"
    if field$=tryfield$ then entityprofile(entid).aimain$=value$
    tryfield$="aidestroy"
    if field$=tryfield$ then entityprofile(entid).aidestroy$=value$
    tryfield$="aishoot"
    if field$=tryfield$ then entityprofile(entid).aishoot$=value$
    tryfield$="soundset"
    if field$=tryfield$ then entityprofile(entid).soundset$=value$
    tryfield$="soundset1"
    if field$=tryfield$ then entityprofile(entid).soundset1$=value$
    `
    rem entity AI related vars
    tryfield$="usekey"
    if field$=tryfield$ then entityprofile(entid).usekey$=value$
    tryfield$="ifused"
    if field$=tryfield$ then entityprofile(entid).ifused$=value$
    tryfield$="ifusednear"
    if field$=tryfield$ then entityprofile(entid).ifusednear$=value$
    `
    rem entity SPAWN
    tryfield$="spawnmax"
    if field$=tryfield$ then entityprofile(entid).spawnmax=value1
    tryfield$="spawndelay"
    if field$=tryfield$ then entityprofile(entid).spawndelay=value1
    tryfield$="spawnqty"
    if field$=tryfield$ then entityprofile(entid).spawnqty=value1
    rem entity orientation
    tryfield$="model"
    if field$=tryfield$ then entityprofile(entid).model$=value$
    tryfield$="offx"
    if field$=tryfield$ then entityprofile(entid).offx=value1
    tryfield$="offy"
    if field$=tryfield$ then entityprofile(entid).offy=value1
    tryfield$="offz"
    if field$=tryfield$ then entityprofile(entid).offz=value1
    tryfield$="rotx"
    if field$=tryfield$ then entityprofile(entid).rotx=value1
    tryfield$="roty"
    if field$=tryfield$ then entityprofile(entid).roty=value1
    tryfield$="rotz"
    if field$=tryfield$ then entityprofile(entid).rotz=value1
    tryfield$="scale"
    if field$=tryfield$ then entityprofile(entid).scale=value1
    tryfield$="fixnewy"
    if field$=tryfield$ then entityprofile(entid).fixnewy=value1
    tryfield$="raisefactor"
    if field$=tryfield$
     rem FPGC - V116 - some FPE characters use a range 0.1-0.9, must be accounted!
     if value1#>-1.0 and value1#<1.0 then value1=1
     entityprofile(entid).raisefactor=value1
    endif
    tryfield$="forwardfacing"
    if field$=tryfield$ then entityprofile(entid).forwardfacing=value1
    tryfield$="defaultheight"
    if field$=tryfield$ then entityprofile(entid).defaultheight=value1
    tryfield$="defaultstatic"
    if field$=tryfield$ then entityprofile(entid).defaultstatic=value1
    tryfield$="collisionmode"
    if field$=tryfield$ then entityprofile(entid).collisionmode=value1
    tryfield$="materialindex"
    if field$=tryfield$ then entityprofile(entid).materialindex=value1
    tryfield$="debrisshape"
    if field$=tryfield$ then entityprofile(entid).debrisshapeindex=value1
    `
    rem physics setup
    tryfield$="physics"
    if field$=tryfield$ then entityprofile(entid).physics=value1
    tryfield$="phyweight"
    if field$=tryfield$ then entityprofile(entid).phyweight=value1
    tryfield$="phyfriction"
    if field$=tryfield$ then entityprofile(entid).phyfriction=value1
    tryfield$="explodable"
    if field$=tryfield$ then entityprofile(entid).explodable=value1
    `
    rem FPGC - 280710 - added NORAGDOLL to entity profile
    tryfield$="noragdoll"
    if field$=tryfield$ then entityprofile(entid).noragdoll=value1
    `
    rem FPGC - 160511 - added NOTHROWSCRIPT to entity profile
    tryfield$="nothrowscript"
    if field$=tryfield$ then entityprofile(entid).nothrowscript=value1
    `
    rem cone of sight
    tryfield$="coneheight"
    if field$=tryfield$ then entityprofile(entid).coneheight=value1
    tryfield$="coneangle"
    if field$=tryfield$ then entityprofile(entid).coneangle=value1
    `
    rem visual info
    tryfield$="texturepath"
    if field$=tryfield$ then entityprofile(entid).texpath$=value$
    tryfield$="textured"
    if field$=tryfield$ then entityprofile(entid).texd$=value$
    tryfield$="texturealtd"
    if field$=tryfield$ then entityprofile(entid).texaltd$=value$
    tryfield$="effect"
    if field$=tryfield$ then entityprofile(entid).effect$=value$
    tryfield$="transparency"
    if field$=tryfield$ then entityprofile(entid).transparency=value1
    tryfield$="reducetexture"
    if field$=tryfield$ then entityprofile(entid).reducetexture=value1
    tryfield$="castshadow"
    if field$=tryfield$ then entityprofile(entid).castshadow=value1
    `
    rem entity identity details
    tryfield$="strength"
    if field$=tryfield$ then entityprofile(entid).strength=value1
    tryfield$="lives"
    if field$=tryfield$ then entityprofile(entid).lives=value1
    tryfield$="speed"
    if field$=tryfield$ then entityprofile(entid).speed=value1
    tryfield$="hurtfall"
    if field$=tryfield$ then entityprofile(entid).hurtfall=value1
    `
    tryfield$="isimmobile"
    if field$=tryfield$ then entityprofile(entid).isimmobile=value1
    tryfield$="isobjective"
    if field$=tryfield$ then entityprofile(entid).isobjective=value1
    tryfield$="alwaysactive"
    if field$=tryfield$ then entityprofile(entid).phyalways=value1
    `
    tryfield$="ischaracter"
    if field$=tryfield$
    entityprofile(entid).ischaracter=value1
    `Was causing conflict with cartoon model pack and some custom media.
    ` If entityprofile(entid).scale<80 then entityprofile(entid).scale=80
    endif

      tryfield$="custombiped"
      if field$=tryfield$ then entityprofile(entid).custombiped=value1

    tryfield$="cantakeweapon"
    if field$=tryfield$ then entityprofile(entid).cantakeweapon=value1
    tryfield$="isweapon"
    if field$=tryfield$ then entityprofile(entid).isweapon$=value$
    `
    rem fpgc - same internals just sanitized  -NEED TO GO IN EDITOR TOO!
    tryfield$="isequipment"
    if field$=tryfield$
     entityprofile(entid).isweapon$=value$
     if len(value$)>2
      rem FPGC - 280809 - if equipment specified, this entity is ALWAYS ACTIVE (so can pickup AND DROP the item)
      entityprofile(entid).phyalways=1
     endif
    endif
    `
    tryfield$="isammo"
    if field$=tryfield$ then entityprofile(entid).isammo=value1
    tryfield$="hasweapon"
    if field$=tryfield$ then entityprofile(entid).hasweapon$=value$
    tryfield$="hasequipment"
    if field$=tryfield$ then entityprofile(entid).hasweapon$=value$
    tryfield$="ishealth"
    if field$=tryfield$ then entityprofile(entid).ishealth=value1
    tryfield$="isflak"
    if field$=tryfield$ then entityprofile(entid).isflak=value1
    `
    rem marker extras
    tryfield$="ismarker"
    if field$=tryfield$ then entityprofile(entid).ismarker=value1
    tryfield$="markerindex"
    if field$=tryfield$ then entityprofile(entid).markerindex=value1
    `
    rem light extras
    tryfield$="lightcolor"
    if field$=tryfield$ then entityprofile(entid).light.color=value1
    tryfield$="lightrange"
    if field$=tryfield$ then entityprofile(entid).light.range=value1
    tryfield$="lightoffsetup"
    if field$=tryfield$ then entityprofile(entid).light.offsetup=value1
    tryfield$="lightoffsetz"
    if field$=tryfield$ then entityprofile(entid).light.offsetz=value1
    `
    rem trigger extras
    tryfield$="areax"
    if field$=tryfield$ then entityprofile(entid).trigger.areax1=value1 : entityprofile(entid).trigger.areax2=value2
    tryfield$="areay"
    if field$=tryfield$ then entityprofile(entid).trigger.areay1=value1 : entityprofile(entid).trigger.areay2=value2
    tryfield$="areaz"
    if field$=tryfield$ then entityprofile(entid).trigger.areaz1=value1 : entityprofile(entid).trigger.areaz2=value2
    `
    rem FPGC - 170610 - extra decal offset (ideal for placing flames in torches, etc)
    tryfield$="decalangle"
    if field$=tryfield$ then entityprofile(entid).decaloffsetangle=value1
    tryfield$="decaldist"
    if field$=tryfield$ then entityprofile(entid).decaloffsetdist=value1/10.0
    tryfield$="decaly"
    if field$=tryfield$ then entityprofile(entid).decaloffsety=value1/10.0
    `
    rem entity body part list (20/01/11 - refeatured for V118)
    tryfield$="limbmax"
    if field$=tryfield$ then entityprofile(entid).limbmax=value1
    if entityprofile(entid).limbmax>100 then entityprofile(entid).limbmax=100
    if entityprofile(entid).limbmax>0
     for q=0 to entityprofile(entid).limbmax-1
      tryfield$="limb"+str$(q)
      if lower$(field$)=lower$(tryfield$)
       entitybodypart(entid,q)=value1
       `use headlimbs and auto-detect now for this
       `if value1=1
       ` rem record head seperately too
       ` entityprofile(entid).headlimb=q
       `endif
      endif
     next q
    endif
    `
    rem FPGC - V117 - 090210 - determine if entity has a head, and which limbs represent it
    tryfield$="headlimbs"
    if field$=tryfield$ then entityprofile(entid).headframestart=value1 : entityprofile(entid).headframefinish=value2
    `
    rem entity decal refs
    tryfield$="decalmax"
    if field$=tryfield$ then entityprofile(entid).decalmax=value1
    if entityprofile(entid).decalmax>0
     for q=0 to entityprofile(entid).decalmax-1
      tryfield$="decal"+str$(q)
      if field$=tryfield$ then entitydecal$(entid,q)=value$
     next q
    endif
    `
    rem entity animation sets
    tryfield$="animmax"
    if field$=tryfield$ then entityprofile(entid).animmax=value1
    if entityprofile(entid).animmax>0
     for q=0 to entityprofile(entid).animmax-1
      tryfield$="anim"+str$(q)
      if field$=tryfield$ then entityanim(entid,q).start=value1 : entityanim(entid,q).finish=value2 : entityanim(entid,q).found=1
      if entityanim(entid,q).found=0 then entityanim(entid,q).start=-1 : entityanim(entid,q).finish=-1
     next q
    endif
    `
    rem V110 BETA5 - 080608 - get foot fall data (optional)
    tryfield$="footfallmax"
    if field$=tryfield$ then entityprofile(entid).footfallmax=value1
    if entityprofile(entid).footfallmax>0
     for q=0 to entityprofile(entid).footfallmax-1
      tryfield$="footfall"+str$(q)
      if field$=tryfield$ then entityfootfall(entid,q).keyframe=value1 : entityfootfall(entid,q).soundtype=value2
     next q
    endif
    `
    rem more data
    tryfield$="quantity"
    if field$=tryfield$ then entityprofile(entid).quantity=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Localisation must change desc to local name
 if entityprofileheader(entid).desc$<>""
  if left$(entityprofileheader(entid).desc$,1)<>"%"
   tflocalfilename$="languagebank\"+language$+"\textfiles\library\"+entdir$+ent$
   tflocalfilename$=left$(tflocalfilename$,len(tflocalfilename$)-4)+".loc"
   if file exist(tflocalfilename$)=1
    dim tflocal$(1)
    load array tflocalfilename$,tflocal$()
    entityprofileheader(entid).desc$=tflocal$(0)
    undim tflocal$()
   endif
  endif
 endif
 `
 rem Translate entity references inside entity profile (token translations)
 if lower$(entityprofileheader(entid).desc$)="%key"
  entityprofileheader(entid).desc$=strarr$(472)
 endif
 if lower$(entityprofileheader(entid).desc$)="%light"
  entityprofileheader(entid).desc$=strarr$(473)
 endif
 if lower$(entityprofileheader(entid).desc$)="%remote door"
  entityprofileheader(entid).desc$=strarr$(474)
 endif
 if lower$(entityprofileheader(entid).desc$)="%teleporter in"
  entityprofileheader(entid).desc$=strarr$(615)
 endif
 if lower$(entityprofileheader(entid).desc$)="%teleporter out"
  entityprofileheader(entid).desc$=strarr$(616)
 endif
 if lower$(entityprofileheader(entid).desc$)="%lift"
  entityprofileheader(entid).desc$=strarr$(617)
 endif
 if lower$(entityprofile(entid).usekey$)="%key"
  entityprofile(entid).usekey$=strarr$(472)
 endif
 if lower$(entityprofile(entid).ifused$)="%light"
  entityprofile(entid).ifused$=strarr$(473)
 endif
 if lower$(entityprofile(entid).ifused$)="%remote door"
  entityprofile(entid).ifused$=strarr$(474)
 endif
 if lower$(entityprofile(entid).ifused$)="%teleporter in"
  entityprofile(entid).ifused$=strarr$(615)
 endif
 if lower$(entityprofile(entid).ifused$)="%teleporter out"
  entityprofile(entid).ifused$=strarr$(616)
 endif
 if lower$(entityprofile(entid).ifused$)="%lift"
  entityprofile(entid).ifused$=strarr$(617)
 endif
 `
 rem All profile defaults
 if entityprofile(entid).ismarker<>1
  if entityprofile(entid).lives<1 then entityprofile(entid).lives=1
 endif
 if entityprofile(entid).speed=0 then entityprofile(entid).speed=100
 if entityprofile(entid).hurtfall=0 then entityprofile(entid).hurtfall=100
 if entityprofile(entid).ischaracter=1
  if entityprofile(entid).quantity=0 then entityprofile(entid).quantity=1
 endif
 `
 rem Physics Data Defaults
 if entityprofile(entid).ismarker=0
  rem default physics settings (weight and friction done during object load (we need the obj size!)
  entityprofile(entid).phyforcedamage=100
  entityprofile(entid).rotatethrow=1
  entityprofile(entid).explodedamage=100
  entityprofile(entid).phyweight=0
  entityprofile(entid).phyfriction=0
  rem health packs have no physics by default for A compatibility
  if entityprofile(entid).ishealth<>0
   entityprofile(entid).physics=0
   endif
 else
  entityprofile(entid).physics=0
 endif
 `
 rem Spawn defaults
 entityprofile(entid).spawnatstart=1
 entityprofile(entid).spawndelayrandom=0
 entityprofile(entid).spawnqtyrandom=0
 entityprofile(entid).spawnvel=0
 entityprofile(entid).spawnvelrandom=0
 entityprofile(entid).spawnangle=0 : rem 90
 entityprofile(entid).spawnanglerandom=0
 entityprofile(entid).spawnlife=0
 if entityprofile(entid).spawnmax>0
  entityprofile(entid).spawnupto=entityprofile(entid).spawnmax
  entityprofile(entid).spawnafterdelay=1
  if entityprofile(entid).ischaracter=1
   entityprofile(entid).spawnwhendead=1
  else
   entityprofile(entid).spawnwhendead=0
  endif
 else
  entityprofile(entid).spawnupto=0
  entityprofile(entid).spawnafterdelay=0
  entityprofile(entid).spawnwhendead=0
 endif
 `
 rem If animation data insufficient, make up rest with basic null sets
 if entityprofile(entid).animmax>0
  if entityprofile(entid).animmax<100
   rem AI animation code relies on standard animation-set-numbers
   for q=entityprofile(entid).animmax to 99
    entityanim(entid,q).start=0 : entityanim(entid,q).finish=1
   next q
   entityprofile(entid).animmax=100
  endif
 endif
 `
 rem Save entity profile as binary
 dim tempe(0) as entityprofiletype
 open to write 1,tprofile$
 rem V110 BETA5 - 080608 - added version control to entity BIN files
 write string 1,"version" : write file 1,gversion
 write string 1,entityprofileheader(entid).desc$
 tempe(0)=entityprofile(entid)
 if memblock exist(1)=1 then delete memblock 1
 tempe(0).aiinit$=free string()
 tempe(0).aimain$=free string()
 tempe(0).aidestroy$=free string()
 tempe(0).aishoot$=free string()
 tempe(0).soundset$=free string()
 tempe(0).soundset1$=free string()
 tempe(0).usekey$=free string()
 tempe(0).ifused$=free string()
 tempe(0).ifusednear$=free string()
 tempe(0).model$=free string()
 tempe(0).texpath$=free string()
 tempe(0).texd$=free string()
 tempe(0).texaltd$=free string()
 tempe(0).effect$=free string()
 tempe(0).isweapon$=free string()
 tempe(0).hasweapon$=free string()
 make memblock from array 1,tempe(0)
 write memblock 1,1
 write string 1,entityprofile(entid).aiinit$
 write string 1,entityprofile(entid).aimain$
 write string 1,entityprofile(entid).aidestroy$
 write string 1,entityprofile(entid).aishoot$
 write string 1,entityprofile(entid).soundset$
 write string 1,entityprofile(entid).soundset1$
 write string 1,entityprofile(entid).usekey$
 write string 1,entityprofile(entid).ifused$
 write string 1,entityprofile(entid).ifusednear$
 write string 1,entityprofile(entid).model$
 write string 1,entityprofile(entid).texpath$
 write string 1,entityprofile(entid).texd$
 write string 1,entityprofile(entid).texaltd$
 write string 1,entityprofile(entid).effect$
 write string 1,entityprofile(entid).isweapon$
 write string 1,entityprofile(entid).hasweapon$
 for q = 0 to entityprofile(entid).limbmax-1
  write file 1,entitybodypart(entid,q)
 next q
 for q = 0 to entityprofile(entid).animmax-1
  write file 1,entityanim(entid,q).start
  write file 1,entityanim(entid,q).finish
 next q
 for q = 0 to entityprofile(entid).footfallmax-1
  write file 1,entityfootfall(entid,q).keyframe
  write file 1,entityfootfall(entid,q).soundtype
 next q
 for q = 0 to entityprofile(entid).decalmax-1
  write string 1,entitydecal$(entid,q)
 next q
 close file 1
 delete memblock 1
 undim tempe(0)
 `
else
 `
 rem load binary version of entity profile file
 dim tempe(0) as entityprofiletype
 open to read 1,tprofile$
 rem V110 BETA5 - 080608 - added version control to entity BIN files
 read string 1,tstr$ : read file 1,tversion
 read string 1,tstr$ : entityprofileheader(entid).desc$=tstr$
 read memblock 1,1
 make array from memblock tempe(0),1
 entityprofile(entid)=tempe(0)
 read string 1,tstr$ : entityprofile(entid).aiinit$=tstr$
 read string 1,tstr$ : entityprofile(entid).aimain$=tstr$
 read string 1,tstr$ : entityprofile(entid).aidestroy$=tstr$
 read string 1,tstr$ : entityprofile(entid).aishoot$=tstr$
 read string 1,tstr$ : entityprofile(entid).soundset$=tstr$
 read string 1,tstr$ : entityprofile(entid).soundset1$=tstr$
 read string 1,tstr$ : entityprofile(entid).usekey$=tstr$
 read string 1,tstr$ : entityprofile(entid).ifused$=tstr$
 read string 1,tstr$ : entityprofile(entid).ifusednear$=tstr$
 read string 1,tstr$ : entityprofile(entid).model$=tstr$
 read string 1,tstr$ : entityprofile(entid).texpath$=tstr$
 read string 1,tstr$ : entityprofile(entid).texd$=tstr$
 read string 1,tstr$ : entityprofile(entid).texaltd$=tstr$
 read string 1,tstr$ : entityprofile(entid).effect$=tstr$
 read string 1,tstr$ : entityprofile(entid).isweapon$=tstr$
 read string 1,tstr$ : entityprofile(entid).hasweapon$=tstr$
 for q = 0 to entityprofile(entid).limbmax-1
  read file 1,entitybodypart(entid,q)
 next q
 for q = 0 to entityprofile(entid).animmax-1
  read file 1,entityanim(entid,q).start
  read file 1,entityanim(entid,q).finish
 next q
 for q = 0 to entityprofile(entid).footfallmax-1
  read file 1,entityfootfall(entid,q).keyframe
  read file 1,entityfootfall(entid,q).soundtype
 next q
 for q = 0 to entityprofile(entid).decalmax-1
  read string 1,entitydecal$(entid,q)
 next q
 close file 1
 delete memblock 1
 undim tempe(0)
 `
endif
`
rem FPGC - 280710 - if from legacy model pack, force NORAGDOLL
entnoslash$=ent$
if mid$(entnoslash$,1)="\" then entnoslash$=right$(entnoslash$,len(entnoslash$)-1)
if entityprofile(entid).ischaracter=1
 tlegacypackentity=0
 t$="model pack 4" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="cartoonfantasypack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="dungeonpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="egyptian characters" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="fantasy characters" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="fantasypack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="freaks and abominations" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="medievalpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="romanpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="tropical pack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="vikingpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 if tlegacypackentity=1
  rem No Ragdoll (X9 packs not designed with ragdoll bone structures in mind)
  entityprofile(entid).noragdoll=1
 endif
endif
`
rem FPGC - 260310 - new field as we now have pure lights and entity lights
if entityprofile(entid).ismarker=2 or entityprofile(entid).ismarker=5
 if entityprofile(entid).ismarker=5 then entityprofile(entid).ismarker=0
 entityprofile(entid).islightmarker=1
 rem FPGC - 300310 - entitylights always active as they may control a dynamic light and possibly decal-particle(mode7)
 entityprofile(entid).phyalways=1
else
 entityprofile(entid).islightmarker=0
endif
`
rem FPGC - 100610 - all FPGC characters are ALWAYS ACTIVE for full speed logic (more predictable)
if entityprofile(entid).ischaracter=1 and fpgcgenre=0
 entityprofile(entid).phyalways=1
 rem FPGC - 110610 - and ALL are invincible
 entityprofile(entid).strength=0
endif
`
rem fileexistelse
else
 rem File not exist, provide debug information (only if file specified (old entities can be renamed and still hang around inside FPMs)
 if len(entdir$+ent$)>len("entitybank\")
  debugfilename(entdir$+ent$,tprofile$)
 endif
endif

rem V109 BETA5 - 250408 - flag material is being used
if entityprofile(entid).materialindex>0
 mi=entityprofile(entid).materialindex-1
 material(mi).usedinlevel=1
endif
if entityprofile(entid).debrisshapeindex>0
 di=entityprofile(entid).debrisshapeindex
 debrisshapeindexused(di)=1
endif

return

_entity_saveelementsdata:

rem Uses elementfilename$
if elementsfilename$="" then elementsfilename$="mapbank\testmap\map.ele"

rem Reduce list size if later elements blank
e=entityelementlist
while e>0
 if entityelement(e).maintype=0 then dec e else exit
endwhile
entityelementlist=e

rem Save entity element list
dw as DWORD
versionnumbersave=218
if file exist(elementsfilename$)=1 then delete file elementsfilename$
open to write 1,elementsfilename$
 write file 1,versionnumbersave
 write file 1,entityelementlist
 if entityelementlist>0
  for e=1 to entityelementlist
   if versionnumbersave>=101
    rem Version 1.01 - EA
    a=entityelement(e).maintype : write file 1,a
    a=entityelement(e).bankindex : write file 1,a
    a=entityelement(e).staticflag : write file 1,a
    a#=entityelement(e).x : write float 1,a#
    a#=entityelement(e).y : write float 1,a#
    a#=entityelement(e).z : write float 1,a#
    a#=entityelement(e).rx : write float 1,a#
    a#=entityelement(e).ry : write float 1,a#
    a#=entityelement(e).rz : write float 1,a#
    a$=entityelement(e).eleprof.name$ : write string 1,a$
    a$=entityelement(e).eleprof.aiinit$ : write string 1,a$
    a$=entityelement(e).eleprof.aimain$ : write string 1,a$
    a$=entityelement(e).eleprof.aidestroy$ : write string 1,a$
    a=entityelement(e).eleprof.isobjective : write file 1,a
    a$=entityelement(e).eleprof.usekey$ : write string 1,a$
    a$=entityelement(e).eleprof.ifused$ : write string 1,a$
    a$=entityelement(e).eleprof.ifusednear$ : write string 1,a$
    a=entityelement(e).eleprof.uniqueelement : write file 1,a
    a$=entityelement(e).eleprof.texd$ : write string 1,a$
    a$=entityelement(e).eleprof.texaltd$ : write string 1,a$
    a$=entityelement(e).eleprof.effect$ : write string 1,a$
    a=entityelement(e).eleprof.transparency : write file 1,a
    a=entityelement(e).editorfixed : write file 1,a
    a$=entityelement(e).eleprof.soundset$ : write string 1,a$
    a$=entityelement(e).eleprof.soundset1$ : write string 1,a$
    a=entityelement(e).eleprof.spawnmax : write file 1,a
    a=entityelement(e).eleprof.spawndelay : write file 1,a
    a=entityelement(e).eleprof.spawnqty : write file 1,a
    a=entityelement(e).eleprof.hurtfall : write file 1,a
    a=entityelement(e).eleprof.castshadow : write file 1,a
    a=entityelement(e).eleprof.reducetexture : write file 1,a
    a=entityelement(e).eleprof.speed : write file 1,a
    a$=entityelement(e).eleprof.aishoot$ : write string 1,a$
    a$=entityelement(e).eleprof.hasweapon$ : write string 1,a$
    a=entityelement(e).eleprof.lives : write file 1,a
    a=entityelement(e).spawn.max : write file 1,a
    a=entityelement(e).spawn.delay : write file 1,a
    a=entityelement(e).spawn.qty : write file 1,a
    a#=entityelement(e).eleprof.scale : write float 1,a#
    a#=entityelement(e).eleprof.coneheight : write float 1,a#
    a#=entityelement(e).eleprof.coneangle : write float 1,a#
    a=entityelement(e).eleprof.strength : write file 1,a
    a=entityelement(e).eleprof.isimmobile : write file 1,a
    a=entityelement(e).eleprof.cantakeweapon : write file 1,a
    a=entityelement(e).eleprof.quantity : write file 1,a
    a=entityelement(e).eleprof.markerindex : write file 1,a
    dw=entityelement(e).eleprof.light.color : dw=(dw<<8)>>8 : a=dw : write file 1,a
    a=entityelement(e).eleprof.light.range : write file 1,a
    a=entityelement(e).eleprof.trigger.areax1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areay1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areaz1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areax2 : write file 1,a
    a=entityelement(e).eleprof.trigger.areay2 : write file 1,a
    a=entityelement(e).eleprof.trigger.areaz2 : write file 1,a
    a$=entityelement(e).eleprof.basedecal$ : write string 1,a$
   endif
   if versionnumbersave>=102
    a=entityelement(e).eleprof.rateoffire : write file 1,a
    a=entityelement(e).eleprof.damage : write file 1,a
    a=entityelement(e).eleprof.accuracy : write file 1,a
    a=entityelement(e).eleprof.reloadqty : write file 1,a
    a=entityelement(e).eleprof.fireiterations : write file 1,a
    a=entityelement(e).eleprof.lifespan : write file 1,a
    a#=entityelement(e).eleprof.throwspeed : write float 1,a#
    a#=entityelement(e).eleprof.throwangle : write float 1,a#
    a=entityelement(e).eleprof.bounceqty : write file 1,a
    a=entityelement(e).eleprof.explodeonhit : write file 1,a
    a=entityelement(e).eleprof.weaponisammo : write file 1,a
    a=entityelement(e).eleprof.spawnupto : write file 1,a
    a=entityelement(e).eleprof.spawnafterdelay : write file 1,a
    a=entityelement(e).eleprof.spawnwhendead : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
   endif
   if versionnumbersave>=103
    rem V1 first draft - physics
    a=entityelement(e).eleprof.physics : write file 1,a
    a=entityelement(e).eleprof.phyweight : write file 1,a
    a=entityelement(e).eleprof.phyfriction : write file 1,a
    a=entityelement(e).eleprof.phyforcedamage : write file 1,a
    a=entityelement(e).eleprof.rotatethrow : write file 1,a
    a=entityelement(e).eleprof.explodable : write file 1,a
    a=entityelement(e).eleprof.explodedamage : write file 1,a
    a=entityelement(e).eleprof.phydw4 : write file 1,a
    a=entityelement(e).eleprof.phydw5 : write file 1,a
   endif
   if versionnumbersave>=104
    rem Addition of new physics field for BETA4
    a=entityelement(e).eleprof.phyalways : write file 1,a
   endif
   if versionnumbersave>=105
    rem Addition of new spawn fields for BETA8
    a=entityelement(e).eleprof.spawndelayrandom : write file 1,a
    a=entityelement(e).eleprof.spawnqtyrandom : write file 1,a
    a=entityelement(e).eleprof.spawnvel : write file 1,a
    a=entityelement(e).eleprof.spawnvelrandom : write file 1,a
    a=entityelement(e).eleprof.spawnangle : write file 1,a
    a=entityelement(e).eleprof.spawnanglerandom : write file 1,a
   endif
   if versionnumbersave>=106
    rem Addition of new fields for BETA10
    a=entityelement(e).eleprof.spawnatstart : write file 1,a
    a=entityelement(e).eleprof.spawnlife : write file 1,a
   endif
   if versionnumbersave>=107
    rem FPSCV104RC8 - forgot to save infinilight index (dynamic lights in final build never worked)
    a=entityelement(e).eleprof.light.index : write file 1,a
   endif
   if versionnumbersave>=199
    rem X10 specific version - any new save data must be higher than 200
    a=0
    write file 1,a : `entityelement(e).eleprof.ex.alignment=a
    write file 1,a : `entityelement(e).eleprof.ex.initmode=a
    write file 1,a : `entityelement(e).eleprof.ex.seemode=a
    write file 1,a : `entityelement(e).eleprof.ex.trigmode=a
    write file 1,a : `entityelement(e).eleprof.ex.hurtmode=a
    write file 1,a : `entityelement(e).eleprof.ex.hurtvalue=a
    write file 1,a : `entityelement(e).eleprof.ex.canstrafe=a
    write file 1,a : `entityelement(e).eleprof.ex.canduck=a
    write file 1,a : `entityelement(e).eleprof.ex.canhear=a
    write file 1,a : `entityelement(e).eleprof.ex.loadedweapon=a
    write file 1,a : `entityelement(e).eleprof.ex.attackrange=a
    write file 1,a : `entityelement(e).eleprof.ex.viewrange=a
    write file 1,a : `entityelement(e).eleprof.ex.maxrange=a
    write file 1,a : `entityelement(e).eleprof.ex.texturearray=a
    write file 1,a : `entityelement(e).eleprof.ex.showhealthbar=a
    write file 1,a : `entityelement(e).eleprof.ex.lungcapacity=a
    write file 1,a : `entityelement(e).eleprof.ex.glassstyle=a
   endif
   if versionnumbersave>=200
    rem X10 specific version - any new save data must be higher than 200
    a=0
    write file 1,a : `entityelement(e).eleprof.ex.score=a
    write file 1,a : `entityelement(e).eleprof.ex.showallyicon=a
    write file 1,a : `entityelement(e).eleprof.ex.factor=a
    write file 1,a : `entityelement(e).eleprof.ex.impactforce=a
    write file 1,a : `entityelement(e).eleprof.ex.decaytime=a
    write file 1,a : `entityelement(e).eleprof.ex.jumpheight=a
   endif
   if versionnumbersave>=217
    rem FPGC - 300710 - save new entity element data
    a=entityelement(e).eleprof.particleoverride : write file 1,a
    a=entityelement(e).eleprof.particle.offsety : write file 1,a
    a=entityelement(e).eleprof.particle.scale : write file 1,a
    a=entityelement(e).eleprof.particle.randomstartx : write file 1,a
    a=entityelement(e).eleprof.particle.randomstarty : write file 1,a
    a=entityelement(e).eleprof.particle.randomstartz : write file 1,a
    a=entityelement(e).eleprof.particle.linearmotionx : write file 1,a
    a=entityelement(e).eleprof.particle.linearmotiony : write file 1,a
    a=entityelement(e).eleprof.particle.linearmotionz : write file 1,a
    a=entityelement(e).eleprof.particle.randommotionx : write file 1,a
    a=entityelement(e).eleprof.particle.randommotiony : write file 1,a
    a=entityelement(e).eleprof.particle.randommotionz : write file 1,a
    a=entityelement(e).eleprof.particle.mirrormode : write file 1,a
    a=entityelement(e).eleprof.particle.camerazshift : write file 1,a
    a=entityelement(e).eleprof.particle.scaleonlyx : write file 1,a
    a=entityelement(e).eleprof.particle.lifeincrement : write file 1,a
    a=entityelement(e).eleprof.particle.alphaintensity : write file 1,a
   endif
   if versionnumbersave>=218
    rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
    a=entityelement(e).eleprof.particle.animated : write file 1,a
   endif
  next e
 endif
close file 1

return

_entity_deleteelementsdata:

rem Free any old elements
gosub _entity_deleteelements

rem Clear counter for new load
entityelementlist=0
entityelementmax=0

return

_entity_loadelementsdata:

rem Free any old elements
gosub _entity_deleteelementsdata

rem Uses elementfilename$ (element data from test game quick build - not from universe.ele created during full build)
if elementsfilename$="" then elementsfilename$="mapbank\testmap\map.ele"

rem load entity element list
dw as DWORD
failedtoload=0
versionnumbersupported=218
if file exist(elementsfilename$)=1
 `
 open to read 1,elementsfilename$
  read file 1,versionnumberload
  if versionnumberload<100
   rem Pre-version data - development only
   entityelementlist=versionnumberload
   versionnumberload=100
  else
   read file 1,entityelementlist
  endif
  if versionnumberload<=versionnumbersupported
   if entityelementlist>0
    undim entityelement()
    undim entityshadervar()
    undim entitydebug$()
    entityelementmax=entityelementlist
    dim entityelement(entityelementmax) as entitytype
    dim entityshadervar(entityelementmax,globalselectedshadermax)
    dim entitydebug$(entityelementmax)
    for e=1 to entityelementlist
     `
     rem actual file data
     if versionnumberload>=101
      rem Version 1.01
      read file 1,a : entityelement(e).maintype=a
      read file 1,a : entityelement(e).bankindex=a
      read file 1,a : entityelement(e).staticflag=a
      read float 1,a# : entityelement(e).x=a#
      read float 1,a# : entityelement(e).y=a#
      read float 1,a# : entityelement(e).z=a#
      read float 1,a# : entityelement(e).rx=a#
      read float 1,a# : entityelement(e).ry=a#
      read float 1,a# : entityelement(e).rz=a#
      read string 1,a$ : entityelement(e).eleprof.name$=a$
      read string 1,a$ : entityelement(e).eleprof.aiinit$=a$
      read string 1,a$ : entityelement(e).eleprof.aimain$=a$
      read string 1,a$ : entityelement(e).eleprof.aidestroy$=a$
      read file 1,a : entityelement(e).eleprof.isobjective=a
      read string 1,a$ : entityelement(e).eleprof.usekey$=a$
      read string 1,a$ : entityelement(e).eleprof.ifused$=a$
      read string 1,a$ : entityelement(e).eleprof.ifusednear$=a$
      read file 1,a : entityelement(e).eleprof.uniqueelement=a
      read string 1,a$ : entityelement(e).eleprof.texd$=a$
      read string 1,a$ : entityelement(e).eleprof.texaltd$=a$
      read string 1,a$ : entityelement(e).eleprof.effect$=a$
      read file 1,a : entityelement(e).eleprof.transparency=a
      read file 1,a : entityelement(e).editorfixed=a
      read string 1,a$ : entityelement(e).eleprof.soundset$=a$
      read string 1,a$ : entityelement(e).eleprof.soundset1$=a$
      read file 1,a : entityelement(e).eleprof.spawnmax=a
      read file 1,a : entityelement(e).eleprof.spawndelay=a
      read file 1,a : entityelement(e).eleprof.spawnqty=a
      read file 1,a : entityelement(e).eleprof.hurtfall=a
      read file 1,a : entityelement(e).eleprof.castshadow=a
      read file 1,a : entityelement(e).eleprof.reducetexture=a
      read file 1,a : entityelement(e).eleprof.speed=a
      read string 1,a$ : entityelement(e).eleprof.aishoot$=a$
      read string 1,a$ : entityelement(e).eleprof.hasweapon$=a$
      read file 1,a : entityelement(e).eleprof.lives=a
      read file 1,a : entityelement(e).spawn.max=a
      read file 1,a : entityelement(e).spawn.delay=a
      read file 1,a : entityelement(e).spawn.qty=a
      read float 1,a# : entityelement(e).eleprof.scale=a#
      read float 1,a# : entityelement(e).eleprof.coneheight=a#
      read float 1,a# : entityelement(e).eleprof.coneangle=a#
      read file 1,a : entityelement(e).eleprof.strength=a
      read file 1,a : entityelement(e).eleprof.isimmobile=a
      read file 1,a : entityelement(e).eleprof.cantakeweapon=a
      read file 1,a : entityelement(e).eleprof.quantity=a
      read file 1,a : entityelement(e).eleprof.markerindex=a
      read file 1,a : dw=a : dw=dw+0xFF000000 : entityelement(e).eleprof.light.color=dw
      read file 1,a : entityelement(e).eleprof.light.range=a
      read file 1,a : entityelement(e).eleprof.trigger.areax1=a
      read file 1,a : entityelement(e).eleprof.trigger.areay1=a
      read file 1,a : entityelement(e).eleprof.trigger.areaz1=a
      read file 1,a : entityelement(e).eleprof.trigger.areax2=a
      read file 1,a : entityelement(e).eleprof.trigger.areay2=a
      read file 1,a : entityelement(e).eleprof.trigger.areaz2=a
      read string 1,a$ : entityelement(e).eleprof.basedecal$=a$
     endif
     if versionnumberload>=102
      rem Version 1.02
      read file 1,a : entityelement(e).eleprof.rateoffire=a
      read file 1,a : entityelement(e).eleprof.damage=a
      read file 1,a : entityelement(e).eleprof.accuracy=a
      read file 1,a : entityelement(e).eleprof.reloadqty=a
      read file 1,a : entityelement(e).eleprof.fireiterations=a
      read file 1,a : entityelement(e).eleprof.lifespan=a
      read float 1,a# : entityelement(e).eleprof.throwspeed=a#
      read float 1,a# : entityelement(e).eleprof.throwangle=a#
      read file 1,a : entityelement(e).eleprof.bounceqty=a
      read file 1,a : entityelement(e).eleprof.explodeonhit=a
      read file 1,a : entityelement(e).eleprof.weaponisammo=a
      read file 1,a : entityelement(e).eleprof.spawnupto=a
      read file 1,a : entityelement(e).eleprof.spawnafterdelay=a
      read file 1,a : entityelement(e).eleprof.spawnwhendead=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
     endif
     if versionnumberload>=103
      rem Version 1.03 - V1 draft physics
      read file 1,a : entityelement(e).eleprof.physics=a
      read file 1,a : entityelement(e).eleprof.phyweight=a
      read file 1,a : entityelement(e).eleprof.phyfriction=a
      read file 1,a : entityelement(e).eleprof.phyforcedamage=a
      read file 1,a : entityelement(e).eleprof.rotatethrow=a
      read file 1,a : entityelement(e).eleprof.explodable=a
      read file 1,a : entityelement(e).eleprof.explodedamage=a
      read file 1,a : entityelement(e).eleprof.phydw4=a
      read file 1,a : entityelement(e).eleprof.phydw5=a
     endif
     if versionnumberload>=104
      rem Version 1.04 - BETA4 extra field
      read file 1,a : entityelement(e).eleprof.phyalways=a
     endif
     if versionnumberload>=105
      rem Version 1.05 - BETA8 extra fields
      read file 1,a : entityelement(e).eleprof.spawndelayrandom=a
      read file 1,a : entityelement(e).eleprof.spawnqtyrandom=a
      read file 1,a : entityelement(e).eleprof.spawnvel=a
      read file 1,a : entityelement(e).eleprof.spawnvelrandom=a
      read file 1,a : entityelement(e).eleprof.spawnangle=a
      read file 1,a : entityelement(e).eleprof.spawnanglerandom=a
     endif
     if versionnumberload>=106
      rem Version 1.06 - BETA10 extra fields
      read file 1,a : entityelement(e).eleprof.spawnatstart=a
      read file 1,a : entityelement(e).eleprof.spawnlife=a
     endif
     if versionnumberload>=107
      rem FPSCV104RC8 - forgot to save infinilight index (dynamic lights in final build never worked)
      read file 1,a : entityelement(e).eleprof.light.index=a
     endif
     if versionnumberload>=199
      rem X10 EXTRAS - Ignored in X9
      read file 1,a : `entityelement(e).eleprof.ex.alignment=a
      read file 1,a : `entityelement(e).eleprof.ex.initmode=a
      read file 1,a : `entityelement(e).eleprof.ex.seemode=a
      read file 1,a : `entityelement(e).eleprof.ex.trigmode=a
      read file 1,a : `entityelement(e).eleprof.ex.hurtmode=a
      read file 1,a : `entityelement(e).eleprof.ex.hurtvalue=a
      read file 1,a : `entityelement(e).eleprof.ex.canstrafe=a
      read file 1,a : `entityelement(e).eleprof.ex.canduck=a
      read file 1,a : `entityelement(e).eleprof.ex.canhear=a
      read file 1,a : `entityelement(e).eleprof.ex.loadedweapon=a
      read file 1,a : `entityelement(e).eleprof.ex.attackrange=a
      read file 1,a : `entityelement(e).eleprof.ex.viewrange=a
      read file 1,a : `entityelement(e).eleprof.ex.maxrange=a
      read file 1,a : `entityelement(e).eleprof.ex.texturearray=a
      read file 1,a : `entityelement(e).eleprof.ex.showhealthbar=a
      read file 1,a : `entityelement(e).eleprof.ex.lungcapacity=a
      read file 1,a : `entityelement(e).eleprof.ex.glassstyle=a
     endif
     if versionnumberload>=200
      rem X10 EXTRAS 190707 - Ignored in X9
      read file 1,a : `entityelement(e).eleprof.ex.score=a
      read file 1,a : `entityelement(e).eleprof.ex.showallyicon=a
      read file 1,a : `entityelement(e).eleprof.ex.factor=a
      read file 1,a : `entityelement(e).eleprof.ex.impactforce=a
      read file 1,a : `entityelement(e).eleprof.ex.decaytime=a
      read file 1,a : `entityelement(e).eleprof.ex.jumpheight=a
     endif
     if versionnumberload>=217
      rem FPGC - 300710 - save new entity element data
      read file 1,a : entityelement(e).eleprof.particleoverride=a
      read file 1,a : entityelement(e).eleprof.particle.offsety=a
      read file 1,a : entityelement(e).eleprof.particle.scale=a
      read file 1,a : entityelement(e).eleprof.particle.randomstartx=a
      read file 1,a : entityelement(e).eleprof.particle.randomstarty=a
      read file 1,a : entityelement(e).eleprof.particle.randomstartz=a
      read file 1,a : entityelement(e).eleprof.particle.linearmotionx=a
      read file 1,a : entityelement(e).eleprof.particle.linearmotiony=a
      read file 1,a : entityelement(e).eleprof.particle.linearmotionz=a
      read file 1,a : entityelement(e).eleprof.particle.randommotionx=a
      read file 1,a : entityelement(e).eleprof.particle.randommotiony=a
      read file 1,a : entityelement(e).eleprof.particle.randommotionz=a
      read file 1,a : entityelement(e).eleprof.particle.mirrormode=a
      read file 1,a : entityelement(e).eleprof.particle.camerazshift=a
      read file 1,a : entityelement(e).eleprof.particle.scaleonlyx=a
      read file 1,a : entityelement(e).eleprof.particle.lifeincrement=a
      read file 1,a : entityelement(e).eleprof.particle.alphaintensity=a
     endif
     if versionnumberload>=218
      rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
      read file 1,a : entityelement(e).eleprof.particle.animated=a
     endif
     `
     rem fill in the blanks if load older version
     ttentid=entityelement(e).bankindex
     if versionnumberload<103
      rem Version 1.03 - V1 draft physics (-1 means calculate at entobj-loadtime)
      entityelement(e).eleprof.physics=entityprofile(ttentid).physics
      entityelement(e).eleprof.phyweight=entityprofile(ttentid).phyweight
      entityelement(e).eleprof.phyfriction=entityprofile(ttentid).phyfriction
      entityelement(e).eleprof.phyforcedamage=entityprofile(ttentid).phyforcedamage
      entityelement(e).eleprof.rotatethrow=entityprofile(ttentid).rotatethrow
      entityelement(e).eleprof.explodable=entityprofile(ttentid).explodable
      entityelement(e).eleprof.phydw3=0
      entityelement(e).eleprof.phydw4=0
      entityelement(e).eleprof.phydw5=0
     endif
     if versionnumberload<104
      rem Version 1.04 - BETA4 extra field
      entityelement(e).eleprof.phyalways=entityprofile(ttentid).phyalways
     endif
     if versionnumberload<105
      rem Version 1.05 - BETA8
      entityelement(e).eleprof.spawndelayrandom=entityprofile(ttentid).spawndelayrandom
      entityelement(e).eleprof.spawnqtyrandom=entityprofile(ttentid).spawnqtyrandom
      entityelement(e).eleprof.spawnvel=entityprofile(ttentid).spawnvel
      entityelement(e).eleprof.spawnvelrandom=entityprofile(ttentid).spawnvelrandom
      entityelement(e).eleprof.spawnangle=entityprofile(ttentid).spawnangle
      entityelement(e).eleprof.spawnanglerandom=entityprofile(ttentid).spawnanglerandom
     endif
     if versionnumberload<106
      rem Version 1.06 - BETA10
      entityelement(e).eleprof.spawnatstart=entityprofile(ttentid).spawnatstart
      entityelement(e).eleprof.spawnlife=entityprofile(ttentid).spawnlife
     endif
     if versionnumberload<217
      rem FPGC - 300710 - older levels dont use particle override
      entityelement(e).eleprof.particleoverride=0
     endif
     entityelement(e).entitydammult#=1.0
      entityelement(e).entityacc=1.0
    next e
   endif
  else
   debugstring(strarr$(101),"")
   failedtoload=1
  endif
 close file 1
 `
endif

rem and erase any elements that DO NOT have a valid profile (file moved/deleted)
if failedtoload=1
 rem FPGC - 270410 - if entity binary from X10 (or just not supported), ensure NO entities!
 entityelementlist=0
 entityelementmax=0
else
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  if entid>0
   if len(entitybank$(entid))=0
    entityelement(e).bankindex=0
   endif
  endif
 next e
endif

return

_entity_applyuniquetextureandeffects:

rem FPGC - 250809 - determine if any per-element objects require unique textures and effects applied (for editor)
entdir$="entitybank\"
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entid>0
  gosub _entity_iseleprofunique
  if entityelement(e).eleprof.uniqueelement=1
   rem if unique, apply texture and effect to per-element object (using temp object)
   ent$=entitybank$(entid)
   entpath$=getpath(ent$)
   entobj=entitybankoffset+entid
   gosub _entity_updatetextureandeffectfromeleprof
   rem then restore original entity profile object
   entobj=entitybankoffset+entid : gosub _entity_loadtexturesandeffect
  endif
 endif
next e

return

_entity_setupelementobject:

rem place entity at correct position and orientation
if object exist(obj)=1
 `
 tscale=entityprofile(entid).scale
 if tscale<>0 then scale object obj,tscale,tscale,tscale
 `
 if entityprofile(entid).fixnewy<>0
  rotate object obj,0,entityprofile(entid).fixnewy,0
  fix object pivot obj
 endif
 `
 position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
 rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
 set object speed obj,125
 `
 rem setup lighting properties of entity
 set object diffuse obj,rgb(128,128,128)
 set object ambience obj,rgb(255,255,255)
 set object emissive obj,0
 set object specular obj,0
 `
 rem Load and Apply ''unique'' FX effect
 if entityelement(e).staticflag=0
  if guseeffectonentitiesstate=1
   tfile$=entityelement(e).eleprof.effect$
   if tfile$<>""
    teffectid=loadinternaleffectunique(tfile$,1)
    entityelement(e).eleprof.usingeffect=teffectid
    entityelement(e).eleprof.uniqueelement=1
   endif
  else
   rem fastbone for quick speed test (if system supports Vertex Shader
   if entityprofile(entid).ischaracter=1
    tthisentobjshallbetextured=0
    if gignorefastbone=0
     if total object frames(obj)>1
      rem and MUST have animation to bone animate
      if object exist(obj)=1
       if get maximum vertex shader version()>=2.0
        rem V118 - 050211 - upgraded fast bone to allow clipping (better reflection)
        if gnewblossershaders=1 and get maximum pixel shader version()>=2.0
         teffectid=loadinternaleffectunique("effectbank\ps_2_0\fastbone.fx",1)
        else
         teffectid=loadinternaleffectunique("effectbank\fastbone\fastbone.fx",1)
        endif
        if gproducelogfiles=1 then timestampactivity(0,"Base Effect effectid="+str$(teffectid)+"  file=effectbank\fastbone\fastbone.fx")
        if teffectid>0
         entityelement(e).eleprof.usingeffect=teffectid
         entityelement(e).eleprof.uniqueelement=1
         tthisentobjshallbetextured=1
        endif
       endif
      endif
     endif
    endif
    if tthisentobjshallbetextured=0
     rem this works, but if texture customised it gets wiped out I think (needs investigation)
     if entityelement(e).eleprof.texdid=0
      rem repair texture if not being uniquelement textured below
      entityelement(e).eleprof.texdid=entityprofile(entid).texdid
      texture object obj,entityelement(e).eleprof.texdid
     endif
    endif
   endif
  endif
 else
  rem if staic, universe needs this entity to be a shared FX (because the object will be deleted!)
  if guseeffectonentitiesstate=1
   if entityelement(e).eleprof.usingeffect>0
    entityelement(e).eleprof.uniqueelement=1
    `
    rem FPSCV105RC3 - illumination shader does not work with static entity (due to missing LM9 code)
    tttfile$=lower$(entityelement(e).eleprof.effect$)
    ttt$="illuminationent.fx"
    if lower$(right$(tttfile$,len(ttt$)))=ttt$
     rem change ENT shader to LM-based shader
     tttfile$="effectbank\illuminationmap\illuminationmap.fx"
     entityelement(e).eleprof.effect$=tttfile$
     teffectid=loadinternaleffect(tttfile$)
     if teffectid>0
      entityelement(e).eleprof.usingeffect=teffectid
      set object effect obj,entityelement(e).eleprof.usingeffect
      objecteffect(obj)=entityelement(e).eleprof.usingeffect
     endif
     rem load correct textures
     tfullorhalfdivide=0
     tttentid=entityelement(e).bankindex
     texdir$=entityprofile(tttentid).texd$
     tfile$=tttfile$ : teffectuseslightmapstage=0 : gosub _common_makeeffecttextureset
     entityelement(e).eleprof.texdid=loadinternalimagecompressquality(texdir1$,1,tfullorhalfdivide)
     entityelement(e).eleprof.tex1id=loadinternalimagecompressquality(texdir2$,1,tfullorhalfdivide)
     entityelement(e).eleprof.tex2id=loadinternalimagecompressquality(texdir3$,1,tfullorhalfdivide)
     rem add the required LM stage
     texture object obj,0,entityelement(e).eleprof.texdid
     texture object obj,1,entityelement(e).eleprof.tex1id
     texture object obj,2,entityelement(e).eleprof.tex2id
    else
     for tstage=0 to entityelement(e).eleprof.texidmax
      if tstage=0 then texture object obj,tstage,entityelement(e).eleprof.texdid
      if tstage=1 then texture object obj,tstage,entityelement(e).eleprof.tex1id
      if tstage=2 then texture object obj,tstage,entityelement(e).eleprof.tex2id
      if tstage=3 then texture object obj,tstage,entityelement(e).eleprof.tex3id
      if tstage=4 then texture object obj,tstage,entityelement(e).eleprof.tex4id
     next tstage
    endif
   endif
    `
  endif
 endif
 `
 rem If element unique, can take its own texture, effect and transparency
 teletransparency=entityelement(e).eleprof.transparency
 if entityelement(e).eleprof.uniqueelement=1
  teffectid=entityelement(e).eleprof.usingeffect
  if teffectid>0
   if entityprofile(entid).limbmax>1
    rem FPSC - 210111 - force CPU animation for entities with specific limb identities
    set object effect obj,teffectid,1
   else
    set object effect obj,teffectid,0
   endif
   objecteffect(obj)=teffectid
   rem FPGC - 250809 - apply element texture to shaded obj (fastbone for chars)
   if entityelement(e).eleprof.texdid>0
    rem V117 - 220110 - but only if have texture, otherwise you wipe out the internal object texture!
    texture object obj,0,entityelement(e).eleprof.texdid
   endif
  else
   if entityelement(e).eleprof.texdid>0
    rem V117 - 220110 - but only if have texture, otherwise you wipe out the internal object texture!
    texture object obj,0,entityelement(e).eleprof.texdid
   endif
  endif
 endif
 `
 rem Set entity element transparency also, so that it is placed correctly in render order
 set object transparency obj,teletransparency
 `
 rem If transparent, no need to Z write
 if teletransparency>0
  if teletransparency>=2
   enable object zbias obj,0.0,-0.000001
  endif
 endif
 `
 rem pre-use step for characters
 if total object frames(obj)>0
  set object frame obj,0
  if entityprofile(entid).ischaracter=1
   if entityprofile(entid).animmax>=1
    teai=0 : if entityanim(entid,1).start>0 then teai=1
    tbaseframe=teai : gosub _entity_getactualframestart : tfstart=tactualframe
    tbaseframe=teai : gosub _entity_getactualframefinish : tffinish=tactualframe
    loop object obj,tfstart,tffinish
   else
    loop object obj : stop object obj
   endif
  endif
 endif
 `
 rem weapon and ammo are none collidable
 if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
  entityelement(e).collisionactive=0
  set object collision off obj
 else
  set object collision on obj
 endif
 `
 rem do not allow player to stop at entity characters (so can run through them)
 if entityprofile(entid).ischaracter=1
  entityelement(e).collisionactive=0
  set object collision off obj
 endif
 `
endif

rem child spawns should remain invisible for now
if entityelement(e).spawn.leaderid>0
 if entityelement(e).spawn.leader=0
  if object exist(obj)=1
   entityelement(e).collisionactive=0
   set object collision off obj
   hide object obj
  endif
 endif
endif

rem makrers by default are hidden
if entityprofile(entid).ismarker>0
 if object exist(obj)=1
  entityelement(e).collisionactive=0
  set object collision off obj
  hide object obj
 endif
endif

return

_entity_createelementasobject:

rem preset entity data
entityelement(e).obj=obj
entid=entityelement(e).bankindex
if entityelement(e).isflak=0 then entityelement(e).profileobj=entitybankoffset+entid

rem delete any existing object and create new one
tgoaheadandsetup=0
if object exist(obj)=1 then delete object obj
objecteffect(obj)=0

if entityelement(e).profileobj>0
 if object exist(entityelement(e).profileobj)=1
  if entityelement(e).spawn.leader=1 and entityelement(e).spawn.max>0
   rem spawning entitiy leaders do not need visual obj (they are invisible makrings), but need obj for object XY ref
   make object triangle obj,0,0,0,0,0,0,0,0,0
   hide object obj
  else
   rem special clone which keeps the animation data in once place (smaller mem footprint)
   if entityelement(e).staticflag=1 and entityprofile(entid).ischaracter=1
    rem if static, and obj has animation (character) - hide it
    make object triangle obj,0,0,0,0,0,0,0,0,0
    hide object obj
   else
    if entityelement(e).isflak=0
     rem FPSCV10X - old U57 clone does not copy multi-materials over
     if entityprofile(entid).texd$=""
      ent$=entitybank$(entid)
      entdir$="entitybank\"
      entpath$=getpath(ent$)
      tfile$=entdir$+entpath$+entityprofile(entid).model$
      if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
      if tdbofile$<>"" and file exist(tdbofile$)=1 then tfile$=tdbofile$
      if file exist(tfile$)=0 then tfile$=entityprofile(entid).model$
      if file exist(tfile$)=1
       load object tfile$,obj
       set object filter obj,2
      else
       clone object obj,entityelement(e).profileobj,1
      endif
     else
     clone object obj,entityelement(e).profileobj,1
    endif
     tgoaheadandsetup=1
    else
     clone object obj,entityelement(e).profileobj,1
     position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
     rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
    endif
   endif
  endif
 else
  rem some elements can be empty - result of editing
  make object triangle obj,0,0,0,0,0,0,0,0,0
  hide object obj
 endif
else
 rem some elements can be empty - result of editing
 make object triangle obj,0,0,0,0,0,0,0,0,0
 hide object obj
endif

rem Setup element object (position and orientations)
if tgoaheadandsetup=1
 gosub _entity_setupelementobject
else
 if obj>0
  if object exist(obj)=1
   position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
   rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
  endif
 endif
endif

rem FPSCV101 - static entities that do not specify a texture draw from local TGA (however when used inside UNIVERSE.DBO the relative location of the texture is lost)
rem so we must manually insert a texture so the static entity has the path to get the actual texture
if entityelement(e).staticflag=1 and entityprofile(entid).texd$=""
 if obj>0
  if object exist(obj)=1
   tprofileobjnum=entityelement(e).profileobj
   if tprofileobjnum>0
    if object exist(tprofileobjnum)=1
     tscanfile$=entdir$+entpath$+entityprofile(entid).model$
     if lower$(right$(tscanfile$,2))=".x"
      if file exist(tscanfile$)=0
       tscanfile$=left$(tscanfile$,len(tscanfile$)-2)+".dbo"
      endif
     endif
     ttrythisone$=findmaterialtexturesinmodelfile(tscanfile$,entdir$+entpath$)
     limbtexid=loadinternalimagecompressquality(ttrythisone$,5,0)
     if limbtexid>0
      entityelement(e).eleprof.texd$=ttrythisone$
      addfiletocollection(entityelement(e).eleprof.texd$)
      entityelement(e).eleprof.texdid=limbtexid
      texture object obj,limbtexid
     endif
    endif
   endif
  endif
 endif
endif


rem Scene commander, x10 addition, if have weapon, and have melee weapins in model, hide melee weapons
if obj>0
 if entityelement(e).eleprof.hasweapon<>0
  tprofileobjnum=entityelement(e).profileobj
  if object exist(obj)=1 and object exist(tprofileobjnum)=1
   perform checklist for object limbs tprofileobjnum
   for tc=1 to checklist quantity()
    rem hide the bone and the mesh associated with the bone (+1)
    if upper$(checklist string$(tc))="MELEE-WEAPON-LEFT"
     hide limb tprofileobjnum,tc-1
     hide limb obj,tc-1
     hide limb tprofileobjnum,tc
     hide limb obj,tc
    endif
    if upper$(checklist string$(tc))="MELEE-WEAPON-RIGHT"
     hide limb tprofileobjnum,tc-1
     hide limb obj,tc-1
     hide limb tprofileobjnum,tc
     hide limb obj,tc
    endif
   next tc
  endif
 endif
endif

return

_entity_getgunidandflakid:

rem Use Weapon Name to get GUNID and FLAKID
if tgunid$<>""
 findgun$=lower$(tgunid$)
 gosub _gun_findweaponindexbyname
 tgunid=foundgunid
 tflakid$=firemode(tgunid,0).settings.flakname$
 if tflakid$<>""
  flak$=lower$(tflakid$) : gosub _flak_findindex
  tflakid=tindex
 else
  tflakid=0
 endif
else
 tgunid=0 : tflakid=0
endif

return

_entity_fillelementfromprofile:
 `
 rem Name
 entityelement(e).eleprof.name$=entityprofileheader(entid).desc$
 `
 rem AI values
 entityelement(e).eleprof.aiinit$=entityprofile(entid).aiinit$
 entityelement(e).eleprof.aimain$=entityprofile(entid).aimain$
 entityelement(e).eleprof.aidestroy$=entityprofile(entid).aidestroy$
 entityelement(e).eleprof.aishoot$=entityprofile(entid).aishoot$
 `
 rem AI use vars
 entityelement(e).eleprof.usekey$=entityprofile(entid).usekey$
 entityelement(e).eleprof.ifused$=entityprofile(entid).ifused$
 entityelement(e).eleprof.ifusednear$=entityprofile(entid).ifusednear$
 `
 rem Spawn
 entityelement(e).eleprof.spawnatstart=entityprofile(entid).spawnatstart
 entityelement(e).eleprof.spawnmax=entityprofile(entid).spawnmax
 entityelement(e).eleprof.spawndelay=entityprofile(entid).spawndelay
 entityelement(e).eleprof.spawnqty=entityprofile(entid).spawnqty
 entityelement(e).eleprof.spawnupto=entityprofile(entid).spawnupto
 entityelement(e).eleprof.spawnafterdelay=entityprofile(entid).spawnafterdelay
 entityelement(e).eleprof.spawnwhendead=entityprofile(entid).spawnwhendead
 entityelement(e).eleprof.spawndelayrandom=entityprofile(entid).spawndelayrandom
 entityelement(e).eleprof.spawnqtyrandom=entityprofile(entid).spawnqtyrandom
 entityelement(e).eleprof.spawnvel=entityprofile(entid).spawnvel
 entityelement(e).eleprof.spawnvelrandom=entityprofile(entid).spawnvelrandom
 entityelement(e).eleprof.spawnangle=entityprofile(entid).spawnangle
 entityelement(e).eleprof.spawnanglerandom=entityprofile(entid).spawnanglerandom
 entityelement(e).eleprof.spawnlife=entityprofile(entid).spawnlife
 `
 rem Scale, Cone
 entityelement(e).eleprof.scale=entityprofile(entid).scale
 entityelement(e).eleprof.coneheight=entityprofile(entid).coneheight
 entityelement(e).eleprof.coneangle=entityprofile(entid).coneangle
 `
 rem Texture and Effect Data (zero to begin with
 entityelement(e).eleprof.uniqueelement=0
 entityelement(e).eleprof.texd$=entityprofile(entid).texd$
 entityelement(e).eleprof.texaltd$=entityprofile(entid).texaltd$
 entityelement(e).eleprof.effect$=entityprofile(entid).effect$
 entityelement(e).eleprof.transparency=entityprofile(entid).transparency
 entityelement(e).eleprof.castshadow=entityprofile(entid).castshadow
 entityelement(e).eleprof.reducetexture=entityprofile(entid).reducetexture
 `
 rem Strength and Quantity
 entityelement(e).eleprof.strength=entityprofile(entid).strength
 entityelement(e).eleprof.lives=entityprofile(entid).lives
 entityelement(e).eleprof.isimmobile=entityprofile(entid).isimmobile
 entityelement(e).eleprof.cantakeweapon=entityprofile(entid).cantakeweapon
 entityelement(e).eleprof.hasweapon$=entityprofile(entid).hasweapon$
 entityelement(e).eleprof.quantity=entityprofile(entid).quantity
 entityelement(e).eleprof.isobjective=entityprofile(entid).isobjective
 entityelement(e).eleprof.speed=entityprofile(entid).speed
 entityelement(e).eleprof.hurtfall=entityprofile(entid).hurtfall
 `
 rem Decal and Soundset Name
 entityelement(e).eleprof.basedecal$=entitydecal$(entid,0)
 entityelement(e).eleprof.soundset$=entityprofile(entid).soundset$
 entityelement(e).eleprof.soundset1$=entityprofile(entid).soundset1$
 `
 rem FPGC - 310710 - default decal particle settings
 particlefile$=entityelement(e).eleprof.basedecal$
 gosub _decal_getparticlefile
 entityelement(e).eleprof.particleoverride=1
 entityelement(e).eleprof.particle=gotparticle
 `
 rem Marker Data
 entityelement(e).eleprof.markerindex=entityprofile(entid).markerindex
 entityelement(e).eleprof.light=entityprofile(entid).light
 entityelement(e).eleprof.trigger=entityprofile(entid).trigger
 `
 rem Data Extracted From GUN and FLAK
 tgunid$=entityprofile(entid).isweapon$
 gosub _entity_getgunidandflakid
 entityelement(e).eleprof.rateoffire=85
 entityelement(e).eleprof.weaponisammo=0
 if tgunid>0
  entityelement(e).eleprof.accuracy=firemode(tgunid,0).settings.accuracy
  entityelement(e).eleprof.reloadqty=firemode(tgunid,0).settings.reloadqty
  entityelement(e).eleprof.fireiterations=firemode(tgunid,0).settings.iterate
  if tflakid=0
   entityelement(e).eleprof.damage=firemode(tgunid,0).settings.damage
  else
   entityelement(e).eleprof.damage=flak(tflakid).profile.damage
   entityelement(e).eleprof.lifespan=flak(tflakid).profile.lifespan
   entityelement(e).eleprof.throwspeed=flak(tflakid).profile.zinc
   entityelement(e).eleprof.throwangle=flak(tflakid).profile.yinc
   entityelement(e).eleprof.bounceqty=flak(tflakid).profile.bounceonhit
   entityelement(e).eleprof.explodeonhit=flak(tflakid).profile.explodeonhit
   entityelement(e).eleprof.weaponisammo=tflakid
  endif
 endif
 `
 rem Physics Data
 entityelement(e).eleprof.physics=entityprofile(entid).physics
 entityelement(e).eleprof.phyalways=entityprofile(entid).phyalways
 entityelement(e).eleprof.phyweight=entityprofile(entid).phyweight
 entityelement(e).eleprof.phyfriction=entityprofile(entid).phyfriction
 entityelement(e).eleprof.phyforcedamage=entityprofile(entid).phyforcedamage
 entityelement(e).eleprof.rotatethrow=entityprofile(entid).rotatethrow
 entityelement(e).eleprof.explodable=entityprofile(entid).explodable
 entityelement(e).eleprof.explodedamage=entityprofile(entid).explodedamage
 `
 rem Copy over found data and or load it
 configureobj=0 : gosub _entity_configueelementforuse
 `
return

_entity_fillgrideleproffromprofile:
 `
 rem Name
 grideleprof.name$=entityprofileheader(entid).desc$
 `
 rem AI values
 grideleprof.aiinit$=entityprofile(entid).aiinit$
 grideleprof.aimain$=entityprofile(entid).aimain$
 grideleprof.aidestroy$=entityprofile(entid).aidestroy$
 grideleprof.aishoot$=entityprofile(entid).aishoot$
 `
 rem AI use vars
 grideleprof.usekey$=entityprofile(entid).usekey$
 grideleprof.ifused$=entityprofile(entid).ifused$
 grideleprof.ifusednear$=entityprofile(entid).ifusednear$
 `
 rem Spawn
 grideleprof.spawnatstart=entityprofile(entid).spawnatstart
 grideleprof.spawnmax=entityprofile(entid).spawnmax
 grideleprof.spawndelay=entityprofile(entid).spawndelay
 grideleprof.spawnqty=entityprofile(entid).spawnqty
 grideleprof.spawnupto=entityprofile(entid).spawnupto
 grideleprof.spawnafterdelay=entityprofile(entid).spawnafterdelay
 grideleprof.spawnwhendead=entityprofile(entid).spawnwhendead
 grideleprof.spawndelayrandom=entityprofile(entid).spawndelayrandom
 grideleprof.spawnqtyrandom=entityprofile(entid).spawnqtyrandom
 grideleprof.spawnvel=entityprofile(entid).spawnvel
 grideleprof.spawnvelrandom=entityprofile(entid).spawnvelrandom
 grideleprof.spawnangle=entityprofile(entid).spawnangle
 grideleprof.spawnanglerandom=entityprofile(entid).spawnanglerandom
 grideleprof.spawnlife=entityprofile(entid).spawnlife
 `
 rem Scale, Cone
 grideleprof.scale=entityprofile(entid).scale
 grideleprof.coneheight=entityprofile(entid).coneheight
 grideleprof.coneangle=entityprofile(entid).coneangle
 `
 rem Texture and Effect Data
 grideleprof.uniqueelement=0
 grideleprof.texd$=entityprofile(entid).texd$
 grideleprof.texaltd$=entityprofile(entid).texaltd$
 grideleprof.effect$=entityprofile(entid).effect$
 grideleprof.transparency=entityprofile(entid).transparency
 grideleprof.castshadow=entityprofile(entid).castshadow
 grideleprof.reducetexture=entityprofile(entid).reducetexture
 `
 rem Strength and Quantity
 grideleprof.strength=entityprofile(entid).strength
 grideleprof.lives=entityprofile(entid).lives
 grideleprof.isimmobile=entityprofile(entid).isimmobile
 grideleprof.cantakeweapon=entityprofile(entid).cantakeweapon
 grideleprof.hasweapon$=entityprofile(entid).hasweapon$
 grideleprof.quantity=entityprofile(entid).quantity
 grideleprof.isobjective=entityprofile(entid).isobjective
 grideleprof.hurtfall=entityprofile(entid).hurtfall
 grideleprof.speed=entityprofile(entid).speed
 `
 rem Decal and Sound Name
 grideleprof.basedecal$=entitydecal$(entid,0)
 grideleprof.soundset$=entityprofile(entid).soundset$
 grideleprof.soundset1$=entityprofile(entid).soundset1$
 `
 rem FPGC - 310710 - decal particle settings
 particlefile$=grideleprof.basedecal$
 gosub _decal_getparticlefile
 grideleprof.particleoverride=1
 grideleprof.particle=gotparticle
 `
 rem Marker Data
 grideleprof.markerindex=entityprofile(entid).markerindex
 grideleprof.light=entityprofile(entid).light
 grideleprof.trigger=entityprofile(entid).trigger
 `
 rem Data Extracted From GUN and FLAK
 tgunid$=entityprofile(entid).isweapon$
 gosub _entity_getgunidandflakid
 grideleprof.rateoffire=85
 grideleprof.weaponisammo=0
 if tgunid>0
  grideleprof.accuracy=firemode(tgunid,0).settings.accuracy
  grideleprof.reloadqty=firemode(tgunid,0).settings.reloadqty
  grideleprof.fireiterations=firemode(tgunid,0).settings.iterate
  if tflakid=0
   grideleprof.damage=firemode(tgunid,0).settings.damage
  else
   grideleprof.damage=flak(tflakid).profile.damage
   grideleprof.lifespan=flak(tflakid).profile.lifespan
   grideleprof.throwspeed=flak(tflakid).profile.zinc
   grideleprof.throwangle=flak(tflakid).profile.yinc
   grideleprof.bounceqty=flak(tflakid).profile.bounceonhit
   grideleprof.explodeonhit=flak(tflakid).profile.explodeonhit
   grideleprof.weaponisammo=tflakid
  endif
 endif
 `
 rem Physics Data
 grideleprof.physics=entityprofile(entid).physics
 grideleprof.phyalways=entityprofile(entid).phyalways
 grideleprof.phyweight=entityprofile(entid).phyweight
 grideleprof.phyfriction=entityprofile(entid).phyfriction
 grideleprof.phyforcedamage=entityprofile(entid).phyforcedamage
 grideleprof.rotatethrow=entityprofile(entid).rotatethrow
 grideleprof.explodable=entityprofile(entid).explodable
 grideleprof.explodedamage=entityprofile(entid).explodedamage
 `
return

_entity_createattachment:
 `
 rem Load all VWEAPS for each entity that wants weapon attachments
 entid=entityelement(e).bankindex
 entityelement(e).attachmentobj=0
 entityelement(e).attachmentbaseobj=0
 entityelement(e).attachmentweapontype=0
 entityelement(e).attachmentobjfirespotlimb=0
 if entityprofile(entid).ischaracter=1
  if object exist(eleobj+e)=1
   if entityprofile(entid).firespotlimb>-1
    `
    rem all vweaps (that are active)
    rem FPSCV104 - changed so MULTIPLAYER=ALL weapons, SINGLEPLAYER=only weapon being held (quicker/bugfree/load)
    ttattachindex=0
    for tgindex=1 to gunmax
     if gun(tgindex).activeingame=1
      tweaponname$=gun(tgindex).name$
      if tweaponname$<>""
       `
       rem FPSCV104 - either multiplayer or single player entity has this gun in their hands
       tthasweapon$=lower$(entityelement(e).eleprof.hasweapon$)
       if tthasweapon$=tweaponname$ or gmultiplayergame=1
        `
        rem go and load this gun (attached to calling entity instance)
        inc ttattachindex
        inc entityattachmentindex
        ttobj=entityattachmentsoffset+entityattachmentindex
        if ttattachindex=1 then entityelement(e).attachmentbaseobj=ttobj
        if object exist(ttobj)=1 then delete object ttobj
        objecteffect(ttobj)=0
        `
        rem V109 BETA6 - replaced X file load with optional DBO convert/load
        tfile$="gamecore\"+fpgchuds$+"\"+tweaponname$+"\vweap.x"
        `rem FPSCV10X some weapons do not have vweap.x models
        `if file exist(tfile$)=1
        ` load object tfile$,ttobj : addfiletocollection(tfile$)
        `else
        ` rem invisible weapon attachment
        ` make object triangle ttobj,0,0,0,0,0,0,0,0,0
        `endif
        if lower$(right$(tfile$,2))=".x" then tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo" else tdbofile$=""
        if file exist(tfile$)=1 or file exist(tdbofile$)=1
         if file exist(tdbofile$)=1
          tfile$=tdbofile$
          tdbofile$=""
         endif
         load object tfile$,ttobj
         set object filter ttobj,2
         if len(tdbofile$)>1
          save object tdbofile$,ttobj
          if file exist(tdbofile$)=1
           delete object ttobj
           load object tdbofile$,ttobj
           set object filter ttobj,2
           tfile$=tdbofile$
          endif
         endif
         addfiletocollection(tfile$)
        else
         rem invisible weapon attachment
         make object triangle ttobj,0,0,0,0,0,0,0,0,0
        endif
        `
        texuseid=loadinternaltexture("gamecore\"+fpgchuds$+"\"+tweaponname$+"\"+fpgchud$+"_D2.tga")
        set object transparency ttobj,1
        set object collision off ttobj
        texture object ttobj,texuseid
        hide object ttobj
        `
       endif
       `
      endif
     endif
    next tgindex
    rem Opportunity for default first weapon to be attached
    tobj=eleobj+e : gosub _entity_switchattachment
    `
   endif
  endif
 endif
 `
 rem Create blob shadow for characters
 if entityprofile(entid).ischaracter=1
  if object exist(eleobj+e)=1
   inc entityattachmentindex
   ttobj=entityattachmentsoffset+entityattachmentindex
   entityelement(e).attachmentblobobj=ttobj
   make object plain ttobj,40,40
   xrotate object ttobj,90
   set object light ttobj,0
   disable object zwrite ttobj
   set object cull ttobj,1
   position object ttobj,-50000,-50000,50000
   ttexid=loadinternaltextureex("gamecore\decals\blob\blob.png",5,1)
   texture object ttobj,ttexid
   set object transparency ttobj,2
   if entityelement(e).hideshadow=1 then hide object ttobj
  endif
 endif
 `
return

_entity_switchattachment:
 `
 rem uses tobj, e, entid, [hasweapon$ can be changed]
 thasweapon$=lower$(entityelement(e).eleprof.hasweapon$)
 tvweapobj=entityelement(e).attachmentobj
 `
 rem unglue old VWEAP (if any)
 if tvweapobj>0
  rem re-hide object
  if object exist(tvweapobj)=1
   unglue object tvweapobj
   position object tvweapobj,0,0,0
   hide object tvweapobj
  endif
 endif
 `
 rem reset entity so not carrying
 entityelement(e).attachmentobjfirespotlimb=0
 entityelement(e).attachmentweapontype=0
 entityelement(e).attachmentobj=0
 entityelement(e).currentweapon=0
 `
 rem pick new VWEAP model to attach
 tvweapobj=0
 ttattachindex=0
 if gmultiplayergame=1
  rem arena characters have all guns attached to them
  for tgindex=1 to gunmax
   if gun(tgindex).activeingame=1
    if gun(tgindex).name$<>"" then inc ttattachindex
    if lower$(gun(tgindex).name$)=thasweapon$ then tvweapobj=entityelement(e).attachmentbaseobj+(ttattachindex-1) : exit
   endif
  next tgindex
 else
  rem FPSCV10X - single play characters have one gun - but still need to return gunindex
  ttattachindex=1
  for tgindex=1 to gunmax
   if gun(tgindex).activeingame=1
    if lower$(gun(tgindex).name$)=thasweapon$ then tvweapobj=entityelement(e).attachmentbaseobj+(ttattachindex-1) : exit
   endif
  next tgindex
 endif
 tentid=entityelement(e).bankindex
 if tvweapobj>0
  rem FPSCV10X - removing VWEAP.X no longer crashes
  if object exist(tvweapobj)=0
   tvweapobj=0
  else
   if entityprofile(tentid).firespotlimb=-1
    tvweapobj=0
   else
    if object exist(tobj)=1
     if limb exist(tobj,entityprofile(tentid).firespotlimb)=0
      tvweapobj=0
     endif
    else
     tvweapobj=0
    endif
   endif
  endif
 endif
 if tvweapobj>0
  entityelement(e).attachmentweapontype=gun(tgindex).weapontype
  entityelement(e).currentweapon=tgindex
 endif
 `
 rem if new gun selected
 if tvweapobj>0
  rem new attached object
  entityelement(e).attachmentobj=tvweapobj
  rem glue new VWEAP to entity(character)
  position object tvweapobj,0,0,0
  `glue object to limb tvweapobj,tobj,entityprofile(tentid).firespotlimb
  rem relocate firepsot within VWEAP model for entity use
  entityelement(e).attachmentobjfirespotlimb=0
  perform checklist for object limbs tvweapobj
  for tc=1 to checklist quantity()
   if lower$(checklist string$(tc))="firespot"
    entityelement(e).attachmentobjfirespotlimb=tc-1
    tc=checklist quantity()+1
   endif
  next tc
  rem finally show thw weapon (if not spawn child)
  if entityelement(e).spawn.leaderid=0
   show object tvweapobj
  else
   hide object tvweapobj
  endif
 endif
 `
return

_entity_iseleprofunique:
 `
 rem Entity unique if texture or effect different
 tokay=0
 if (len(entityprofile(entid).texd$)>0 or len(entityelement(e).eleprof.texd$)>0) and entityprofile(entid).texd$<>entityelement(e).eleprof.texd$ then tokay=1
 if (len(entityprofile(entid).texaltd$)>0 or len(entityelement(e).eleprof.texaltd$)>0) and entityprofile(entid).texaltd$<>entityelement(e).eleprof.texaltd$ then tokay=1
 if (len(entityprofile(entid).effect$)>0 or len(entityelement(e).eleprof.effect$)>0) and entityprofile(entid).effect$<>entityelement(e).eleprof.effect$ then tokay=1
 if tokay=1
  entityelement(e).eleprof.uniqueelement=1
 else
  entityelement(e).eleprof.uniqueelement=0
 endif
 `
return

_entity_updatetextureandeffectfromeleprof:
 `
 rem Texture and Effect (use entityprofile loader)
 storeentdefaults as entityprofiletype
 storeentdefaults=entityprofile(entid)
 entityprofile(entid).texd$=entityelement(e).eleprof.texd$
 entityprofile(entid).texaltd$=entityelement(e).eleprof.texaltd$
 entityprofile(entid).texdid=entityelement(e).eleprof.texdid
 entityprofile(entid).texaltdid=entityelement(e).eleprof.texaltdid
 entityprofile(entid).effect$=entityelement(e).eleprof.effect$
 entityprofile(entid).usingeffect=entityelement(e).eleprof.usingeffect
 entityprofile(entid).tex1id=entityelement(e).eleprof.tex1id
 entityprofile(entid).tex2id=entityelement(e).eleprof.tex2id
 entityprofile(entid).tex3id=entityelement(e).eleprof.tex3id
 entityprofile(entid).tex4id=entityelement(e).eleprof.tex4id
 entityprofile(entid).texidmax=entityelement(e).eleprof.texidmax
 entityprofile(entid).transparency=entityelement(e).eleprof.transparency
 entityprofile(entid).reducetexture=entityelement(e).eleprof.reducetexture
 gosub _entity_loadtexturesandeffect
 entityelement(e).eleprof.texd$=entityprofile(entid).texd$
 entityelement(e).eleprof.texaltd$=entityprofile(entid).texaltd$
 entityelement(e).eleprof.texdid=entityprofile(entid).texdid
 entityelement(e).eleprof.texaltdid=entityprofile(entid).texaltdid
 entityelement(e).eleprof.effect$=entityprofile(entid).effect$
 entityelement(e).eleprof.usingeffect=entityprofile(entid).usingeffect
 entityelement(e).eleprof.tex1id=entityprofile(entid).tex1id
 entityelement(e).eleprof.tex2id=entityprofile(entid).tex2id
 entityelement(e).eleprof.tex3id=entityprofile(entid).tex3id
 entityelement(e).eleprof.tex4id=entityprofile(entid).tex4id
 entityelement(e).eleprof.texidmax=entityprofile(entid).texidmax
 entityelement(e).eleprof.transparency=entityprofile(entid).transparency
 entityelement(e).eleprof.reducetexture=entityprofile(entid).reducetexture
 entityprofile(entid)=storeentdefaults
 `
return

_entity_isgrideleprofunique:
 `
 rem Entity unique if texture or effect different
 tokay=0
 if (len(entityprofile(entid).texd$)>0 or len(grideleprof.texd$)>0) and entityprofile(entid).texd$<>grideleprof.texd$ then tokay=1
 if (len(entityprofile(entid).texaltd$)>0 or len(grideleprof.texaltd$)>0) and entityprofile(entid).texaltd$<>grideleprof.texaltd$ then tokay=1
 if (len(entityprofile(entid).effect$)>0 or len(grideleprof.effect$)>0) and entityprofile(entid).effect$<>grideleprof.effect$ then tokay=1
 if tokay=1
  grideleprof.uniqueelement=1
 else
  grideleprof.uniqueelement=0
 endif
 `
return

_entity_updatetextureandeffectfromgrideleprof:
 `
 rem Texture and Effect (use entityprofile loader)
 storeentdefaults as entityprofiletype
 storeentdefaults=entityprofile(entid)
 entityprofile(entid).texd$=grideleprof.texd$
 entityprofile(entid).texaltd$=grideleprof.texaltd$
 entityprofile(entid).texdid=grideleprof.texdid
 entityprofile(entid).texaltdid=grideleprof.texaltdid
 entityprofile(entid).effect$=grideleprof.effect$
 entityprofile(entid).usingeffect=grideleprof.usingeffect
 entityprofile(entid).tex1id=grideleprof.tex1id
 entityprofile(entid).tex2id=grideleprof.tex2id
 entityprofile(entid).tex3id=grideleprof.tex3id
 entityprofile(entid).tex4id=grideleprof.tex4id
 entityprofile(entid).texidmax=grideleprof.texidmax
 entityprofile(entid).transparency=grideleprof.transparency
 entityprofile(entid).reducetexture=grideleprof.reducetexture
 gosub _entity_loadtexturesandeffect
 grideleprof.texd$=entityprofile(entid).texd$
 grideleprof.texaltd$=entityprofile(entid).texaltd$
 grideleprof.texdid=entityprofile(entid).texdid
 grideleprof.texaltdid=entityprofile(entid).texaltdid
 grideleprof.effect$=entityprofile(entid).effect$
 grideleprof.usingeffect=entityprofile(entid).usingeffect
 grideleprof.tex1id=entityprofile(entid).tex1id
 grideleprof.tex2id=entityprofile(entid).tex2id
 grideleprof.tex3id=entityprofile(entid).tex3id
 grideleprof.tex4id=entityprofile(entid).tex4id
 grideleprof.texidmax=entityprofile(entid).texidmax
 grideleprof.transparency=entityprofile(entid).transparency
 grideleprof.reducetexture=entityprofile(entid).reducetexture
 entityprofile(entid)=storeentdefaults
 `
return

_entity_configueelementforuse:
 `
 rem FPGC - 070909 - now have entityelement data, only load the actual scripts used
 gosub _ai_loadentityscriptsonlyfore
 `
 rem Resolve AI indexes from AI script filenames
 aifile$=entityelement(e).eleprof.aiinit$ : gosub _ai_findlibindex : entityelement(e).eleprof.aiinit=libindex
 aifile$=entityelement(e).eleprof.aimain$ : gosub _ai_findlibindex : entityelement(e).eleprof.aimain=libindex
 aifile$=entityelement(e).eleprof.aidestroy$ : gosub _ai_findlibindex : entityelement(e).eleprof.aidestroy=libindex
 aifile$=entityelement(e).eleprof.aishoot$ : gosub _ai_findlibindex : entityelement(e).eleprof.aishoot=libindex
 `
 rem prevent main AI from running in (multiplayer)
 if gmultiplayergame=1
  rem server entities by default
  entityelement(e).servercontrolled=1
  if entityprofile(entid).ischaracter=1
   rem characters are ALL possible players NO MAIN LOGIC - SERVER CONTROLLED ZOMBIE ENTITIES
   aifile$="default.fpi" : gosub _ai_findlibindex : entityelement(e).eleprof.aimain=libindex
  endif
 endif
 `
 rem Configure AI for element
 entityelement(e).active=1
 entityelement(e).dormant=1
 entityelement(e).collisionactive=1
 entityelement(e).ai.libinit=entityelement(e).eleprof.aiinit
 entityelement(e).ai.libmain=entityelement(e).eleprof.aimain
 entityelement(e).ai.libdestroy=entityelement(e).eleprof.aidestroy
 entityelement(e).ai.libshoot=entityelement(e).eleprof.aishoot
 entityelement(e).ai.libindex=entityelement(e).ai.libinit
 entityelement(e).mover.da=entityelement(e).ry
 entityelement(e).ai.waypoint.state=0
 entityelement(e).ai.state$="0" rem GUI-X9 (String States)
 entityelement(e).darkai.active=1
 `
 rem FPGC - 030710 - reset extra entity flags
 entityelement(e).alttextureused=0
 entityelement(e).ragdollon=0
 `
 rem Configure animation defaults
 if entityprofile(entid).ischaracter=1
  entityelement(e).animspeed=2.0
  entityelement(e).animatespeed=1 rem set default animate command speed (markblosser)
 else
  entityelement(e).animspeed=4.0
  entityelement(e).animatespeed=1 rem set default animate command speed (markblosser)
 endif
 `
 rem Spawn values
 entityelement(e).spawn.atstart=entityelement(e).eleprof.spawnatstart
 entityelement(e).spawn.max=entityelement(e).eleprof.spawnmax
 entityelement(e).spawn.delay=entityelement(e).eleprof.spawndelay
 entityelement(e).spawn.qty=entityelement(e).eleprof.spawnqty
 entityelement(e).spawn.upto=entityelement(e).eleprof.spawnupto
 entityelement(e).spawn.afterdelay=entityelement(e).eleprof.spawnafterdelay
 entityelement(e).spawn.whendead=entityelement(e).eleprof.spawnwhendead
 entityelement(e).spawn.delayrandom=entityelement(e).eleprof.spawndelayrandom
 entityelement(e).spawn.qtyrandom=entityelement(e).eleprof.spawnqtyrandom
 entityelement(e).spawn.vel=entityelement(e).eleprof.spawnvel
 entityelement(e).spawn.velrandom=entityelement(e).eleprof.spawnvelrandom
 entityelement(e).spawn.angle=entityelement(e).eleprof.spawnangle
 entityelement(e).spawn.anglerandom=entityelement(e).eleprof.spawnanglerandom
 entityelement(e).spawn.life=entityelement(e).eleprof.spawnlife
 `
 rem Spawn off means spawn-ready to be used, so..
 if entityelement(e).spawn.atstart=0 and entityelement(e).spawn.max=0
  entityelement(e).spawn.max=1
  if entityelement(e).spawn.afterdelay=0 and entityelement(e).spawn.whendead=0
   entityelement(e).spawn.afterdelay=1
  endif
  if entityelement(e).spawn.qty=0 then entityelement(e).spawn.qty=1
  if entityelement(e).spawn.upto=0 then entityelement(e).spawn.upto=1
 endif
 `
 rem Configure health from strength
 if entityelement(e).eleprof.strength>0
  entityelement(e).health=entityelement(e).eleprof.strength
 else
  entityelement(e).health=1
 endif
 `
 rem Moved from SETUP, as FX name can change here
 if guseeffectonentitiesstate=1
  tfile$=entityelement(e).eleprof.effect$
  if tfile$<>""
   if entityelement(e).staticflag=0
    rem dynamic entities cannot use scene FX, must be entity FX..
    rem for backwards EA compatibility with old entity eleprofs, bump.fx has become bumpent.fx
    if lower$(tfile$)="effectbank\bump\bump.fx" then tfile$="effectbank\bumpent\bumpent.fx"
    entityelement(e).eleprof.effect$=tfile$
    entityelement(e).eleprof.uniqueelement=1
   else
    rem if entity static, this routine called from UNIVERSE code to prepare static entities
    rem ENSURE the bumpent.fx is replaced with BUMP.FX as the former FX file would be wrong
    if lower$(tfile$)="effectbank\bumpent\bumpent.fx" then tfile$="effectbank\bump\bump.fx"
    if lower$(tfile$)="effectbank\bumpbone\bumpbone.fx" then tfile$="effectbank\bump\bump.fx"
    entityelement(e).eleprof.effect$=tfile$
   endif
  endif
 endif
 `
 rem Texture and Effect (use entityprofile loader)
 gosub _entity_iseleprofunique
 entdir$="entitybank\" : ent$=entitybank$(entid) : entpath$=getpath(ent$)
 entobj=configureobj : gosub _entity_updatetextureandeffectfromeleprof
 `
 rem Resolve default weapon gun ids
 if entityelement(e).eleprof.hasweapon$<>""
  findgun$=lower$(entityelement(e).eleprof.hasweapon$) : gosub _gun_findweaponindexbyname
  entityelement(e).eleprof.hasweapon=foundgunid
  if foundgunid>0 and entityprofile(entid).isammo=0 then gun(foundgunid).activeingame=1
 else
  entityelement(e).eleprof.hasweapon=0
 endif
 `
return

_entity_createelements:

rem pre-create element data (load from eleprof)
for e=1 to entityelementlist
 entobj=0 : entid=entityelement(e).bankindex
 configureobj=0 : gosub _entity_configueelementforuse
next e

rem spawn all elements (one element with a max.spawn of 5 means we duplicate another 4 here)
countnewselementsize=0
for spawne=1 to entityelementlist
 if entityelement(spawne).staticflag=0
  inc countnewselementsize,1+entityelement(spawne).spawn.max
 endif
next spawne

dim newentityelement(countnewselementsize) as entitytype
newentityelementlist=0
for spawne=1 to entityelementlist
 if entityelement(spawne).staticflag=0
  for te=1 to 1+entityelement(spawne).spawn.max
   inc newentityelementlist
   newentityelement(newentityelementlist)=entityelement(spawne)
   if te=1
    rem leader
    newentityelement(newentityelementlist).spawn.leader=1
    newentityelement(newentityelementlist).spawn.leadercount=0
    newentityelement(newentityelementlist).spawn.leaderid=0
    newentityelement(newentityelementlist).spawn.x=entityelement(spawne).x
    newentityelement(newentityelementlist).spawn.y=entityelement(spawne).y
    newentityelement(newentityelementlist).spawn.z=entityelement(spawne).z
    newentityelement(newentityelementlist).active=1
    newentityelement(newentityelementlist).dormant=0
    theleader=newentityelementlist
   else
    rem follower - uses MAX range to group followers to each leader
    newentityelement(newentityelementlist).spawn.leader=0
    newentityelement(newentityelementlist).spawn.leadercount=0
    newentityelement(newentityelementlist).spawn.leaderid=theleader
    newentityelement(newentityelementlist).active=0
    newentityelement(newentityelementlist).dormant=1
    newentityelement(newentityelementlist).health=0
    newentityelement(newentityelementlist).eleprof.lives=0
   endif
  next te
 endif
next spawne
undim entityelement()
undim entityshadervar()
undim entitydebug$()
entityelementlist=newentityelementlist
entityelementmax=entityelementlist
dim entityelement(entityelementmax) as entitytype
dim entityshadervar(entityelementmax,globalselectedshadermax)
dim entitybreadcrumbs(entityelementmax,50) as entitybreadcrumbstype
dim entitydebug$(entityelementmax)
for e=1 to entityelementmax
 entityelement(e)=newentityelement(e)
next e
undim newentityelement()

rem V109 BETA3 - create correct size array for local script variables
dim ailocals(entityelementmax,99)
dim aiuserlocals(entityelementmax,99) as uservar

rem create instances for all elements (create dynamic entities only)
debugviewtext(302,strarr$(102))
eleobj=entityobjectoffset : ttick=0 : ttickmax=entityelementlist/3 : rem V106 faster build time ttickmax=1
for e=1 to entityelementlist
 obj=eleobj+e
 if obj>0
  if entityelement(e).staticflag=0
   inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(302,strarr$(103)+str$(e)+"/"+str$(entityelementlist)+" ("+entityprofile(tentid).model$+")")
   tentid=entityelement(e).bankindex
   if entityprofile(tentid).ismarker=0
    gosub _entity_createelementasobject
   endif
  endif
 endif
next e

rem after leader creations, do not need leader flag if entity does not spawn
for e=1 to entityelementlist
 if entityelement(e).spawn.leader=1
  tentid=entityelement(e).bankindex
  if entityelement(e).spawn.max=0
   entityelement(e).spawn.leader=0
  endif
 endif
next e

rem Create Entity Attachments
debugviewtext(304,strarr$(104))
entityattachmentindex=0
eleobj=entityobjectoffset : ttick=0 : ttickmax=entityelementlist/3 : rem V106 faster build time ttickmax=1
for e=1 to entityelementlist
 inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(306,str$(e)+"\"+str$(entityelementlist)+" "+entityelement(e).eleprof.name$)
 gosub _entity_createattachment
next e

rem if entity is server controlled, hide entity initially (multiplayer)
if gmultiplayergame=1
 for e=1 to entityelementlist
  if entityelement(e).servercontrolled=1
   obj=entityelement(e).obj
   if obj>0
    if object exist(obj)=1
     hide object tobj
    endif
   endif
  endif
 next e
endif

rem Assign characters as fake players and set default weapon
fakeplayercount=2
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ischaracter=1
  entityelement(e).fakeplayerid=fakeplayercount
  inc fakeplayercount
 endif
 entityelement(e).currentweapon=entityelement(e).eleprof.hasweapon
 entityelement(e).currentclipammo=9999
 entityelement(e).currentammo=0
next e
rem recreate array to new size
playermax=fakeplayercount-1
dim player(playermax) as playertype
dim playersound(playermax,520) as integer
dim playersoundset$(playermax) as string
dim playermovementstep(playermax) as integer
dim playerinventory(playermax,100) as inventorytype
rem FPGC - 020909 - new sound management
dim playersoundsetindex(playermax) as integer

rem Transfer sound sets to player data
fakeplayercount=2
playersoundset$(1)=""
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives>0
  playersoundset$(1)=entityelement(e).eleprof.soundset$
 endif
 if entityprofile(entid).ischaracter=1
  playersoundset$(fakeplayercount)=entityelement(e).eleprof.soundset$
  entityelement(e).fakeplrindex=fakeplayercount
  inc fakeplayercount
 endif
next e

rem Activate any decals
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).decalmax>0
  for tq=0 to entityprofile(entid).decalmax-1
   decalid=entitydecal(entid,tq)
   if decalid>0
    decal(decalid).active=1
   endif
  next tq
 endif
next e

Rem Hockeykid - 050410 - Check for safe zone
debugviewtext(305,"Generating AI Safezones...")
dim aisafezone(0) as AISafeZoneType
for e=1 to entityelementlist
 if lower$(left$(entityelement(e).eleprof.name$,9))="safe zone"
  array insert at bottom aisafezone()
  xp=array count(aisafezone())
  aisafezone(xp).x=entityelement(e).x
  aisafezone(xp).y=entityelement(e).y
  aisafezone(xp).z=entityelement(e).z
 endif
next e

return

_entity_createelements_loadsoundlast:
 `
 rem Load any soundsets not belonging to characters or players (uses loadsoundrefonly)
 for e=1 to entityelementlist
  entityelement(e).soundset=0
  entid=entityelement(e).bankindex
  tokay=0
  rem FPGC - 190410 - characters can now load the second soundsset ($1 in scripts)
  if entityprofile(entid).ischaracter=1 and entityprofile(entid).ismarker=0 then tokay=2
  if entityprofile(entid).ischaracter=0 and entityprofile(entid).ismarker=0 then tokay=1
  if entityprofile(entid).ismarker=1 and entityprofile(entid).lives=0 then tokay=1
  if entityprofile(entid).ismarker=3 or entityprofile(entid).ismarker=4 then tokay=1
  if tokay<>0
   `
   rem V109BETA4 - 240408 - use 2D mode if MUSIC ZONE is the name
   if lower$(left$(entityelement(e).eleprof.name$,10))="music zone" then t3d=0 else t3d=1
   `
   rem V118 - 210211 - if AI script is PLRSOUNDINZONE then switch OFF 3D sound!
   if lower$(left$(entityelement(e).eleprof.aimain$,18))="plrsoundinzone.fpi" then t3d=0
   `
   rem Load sound sets
   if entityelement(e).eleprof.soundset$<>"" and tokay=1
    rem load as 3D sound ready for playing or looping in game (generator)
    tfile$=entityelement(e).eleprof.soundset$
    if soundfileexist(tfile$)=1
     addfiletocollection(tfile$)
     if loadsoundrefonly=0
      entityelement(e).soundset=loadinternalsoundcore(tfile$,t3d)
     endif
    endif
   endif
   if entityelement(e).eleprof.soundset1$<>"" and tokay<>0
    rem load as 3D sound ready for playing or looping in game (generator) ($1 speech of character)
    rem V118 - 150211 - character slots usually voice over, so don't use 3D
    if entityprofile(entid).ischaracter=1 then t3d=0
    tfile$=entityelement(e).eleprof.soundset1$
    if file exist(tfile$)=1
     addfiletocollection(tfile$)
     if loadsoundrefonly=0
      entityelement(e).soundset1=loadinternalsoundcore(tfile$,t3d)
     endif
    endif
   endif
   `
  endif
 next e
 `
return

_entity_createelements_loadsoundlast_fileref:
 `
 rem FPGC - 090610 - reference all files used by scripts ($0 and $1)
 loadsoundrefonly=1
 gosub _entity_createelements_loadsoundlast
 loadsoundrefonly=0
 `
return

_entity_attachelementstogame:

rem associate dynamic entities with game universe (vislinking)
eleobj=entityobjectoffset
for e=1 to entityelementlist
 obj=eleobj+e
 if obj>0
  entid=entityelement(e).bankindex
  if entityelement(e).staticflag=0
   if object exist(obj)=1
    attach object to static obj
   endif
  endif
 endif
next e

rem was here
gosub _player_resetobjectives

return

_entity_calculateobjectivestotal:

rem count all objective entities
missiongoaltotal=0
for e=1 to entityelementlist
 mi=entityelement(e).eleprof.isobjective
 if missiongoaltotal<mi then missiongoaltotal=mi
next e

rem count all as complete
for mi=1 to 99 : playerobjective(mi)=1 : next mi

rem and clear those awaiting to be filled in my entity
for e=1 to entityelementlist
 mi=entityelement(e).eleprof.isobjective
 if mi>0 then playerobjective(mi)=0
next e

return

_entity_deleteelements:

rem Quick deletes
if entityelementlist>0
 delete objects entityobjectoffset+1, entityobjectoffset+entityelementlist
endif
if entityattachmentindex>0
 delete objects entityattachmentsoffset+1, entityattachmentsoffset+entityattachmentindex
endif

rem FPGC - 250310 - ensure objecteffect array is cleared after any object delete
for o=1 to 65535
 if object exist(o)=0 then objecteffect(o)=0
next o

return

_entity_scanfornewentitiesnoload:

rem Scan for entities
entdir$="entitybank\"
empty array filelist$()
buildfilelist(entdir$,"")

rem If entities exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem entity name from folder
  ent$=filelist$(chkfile)
  `
  rem Check if filename valid
  if right$(ent$,4)=".fpe"
  `
  rem Check entity exists in bank
  tokay=1
  if entidmaster>0
   for entid=1 to entidmaster
    if entitybank$(entid)=ent$ then tokay=0
   next entid
  endif
  if tokay=1
    `
   rem Find Free entity Index
   freeentid=-1
   if entidmaster>0
    for entid=1 to entidmaster
     if entitybank$(entid)="" then freeentid=entid : exit
    next entid
   endif
   `
   rem New entity or Free One
   if freeentid=-1
    inc entidmaster : gosub _entity_validatearraysize
    entid=entidmaster
   else
    entid=freeentid
   endif
   `
   rem Load entity
   dim entitybank$(entid)
   entitybank$(entid)=ent$
   `
  endif
  `
  endif
  `
 next chkfile
endif

return


_entity_scanfornewentities:

rem Load all entity names
gosub _entity_scanfornewentitiesnoload

rem Load entities themselves
for entid=1 to endidmaster
 ent$=entitybank$(entid)
 entpath$=getpath(ent$)
 gosub _entity_load
next entid

return

_entity_addtoselection:

rem Load entity from file requester
set dir currententitydir$
ent$=browseropen$(9)
entdir$="entitybank\"
ent$=right$(ent$,len(ent$)-len(rootdir$+entdir$))
currententitydir$=get dir$()
set dir rootdir$
`
rem Check if filename valid
entnewloaded=0 : entid=0
if right$(ent$,4)=".fpe"
 `
 rem Check entity exists in bank
 tokay=1
 if entidmaster>0
  for entid=1 to entidmaster
   if entitybank$(entid)=ent$ then tokay=0 : tfoundid=entid : exit
  next entid
 endif
 if tokay=1
  `
  rem Find Free entity Index
  freeentid=-1
  if entidmaster>0
   for entid=1 to entidmaster
    if entityprofileheader(entid).desc$="" then freeentid=entid : exit
   next entid
  endif
  `
  rem New entity or Free One
  if freeentid=-1
   inc entidmaster : gosub _entity_validatearraysize
   entid=entidmaster
   entnewloaded=1
  else
   entid=freeentid
  endif
  `
  rem FPGC - 100710 - when add new entity, it may require updated FLAK data (should the entity have come direct from the GC store)
  gosub _flak_addanynewflaktoexistingdataonlylist
  `
  rem Load entity
  entitybank$(entid)=ent$
  entpath$=getpath(ent$)
  gosub _entity_load
  `
 else
  `
  rem already got, assign ID from existing
  entid=tfoundid
  `
 endif
 `
endif

return

_entity_delete:
 `
 rem Remove entity (and object)
 tdelobj=entitybankoffset+entid
 if tdelobj>0
  if object exist(tdelobj)=1 then delete object tdelobj
  objecteffect(tdelobj)=0
  entityprofileheader(entid).desc$=""
  entitybank$(entid)=""
  entityprofile(entid).aiinit$=""
  entityprofile(entid).aimain$=""
  entityprofile(entid).aidestroy$=""
  entityprofile(entid).aishoot$=""
  entityprofile(entid).soundset$=""
  entityprofile(entid).soundset1$=""
  entityprofile(entid).usekey$=""
  entityprofile(entid).ifused$=""
  entityprofile(entid).ifusednear$=""
  entityprofile(entid).spawnatstart=0
  entityprofile(entid).spawnmax=0
  entityprofile(entid).spawnupto=0
  entityprofile(entid).spawnafterdelay=0
  entityprofile(entid).spawnwhendead=0
  entityprofile(entid).spawndelay=0
  entityprofile(entid).spawnqty=0
  entityprofile(entid).spawndelayrandom=0
  entityprofile(entid).spawnqtyrandom=0
  entityprofile(entid).spawnvel=0
  entityprofile(entid).spawnvelrandom=0
  entityprofile(entid).spawnangle=0
  entityprofile(entid).spawnanglerandom=0
  entityprofile(entid).spawnlife=0
  entityprofile(entid).model$=""
  entityprofile(entid).offx=0.0
  entityprofile(entid).offy=0.0
  entityprofile(entid).offz=0.0
  entityprofile(entid).rotx=0.0
  entityprofile(entid).roty=0.0
  entityprofile(entid).rotz=0.0
  entityprofile(entid).scale=0.0
  entityprofile(entid).fixnewy=0.0
  entityprofile(entid).raisefactor=0
  entityprofile(entid).forwardfacing=0
  entityprofile(entid).defaultheight=0.0
  entityprofile(entid).defaultstatic=0
  entityprofile(entid).collisionmode=0
  entityprofile(entid).materialindex=0
  entityprofile(entid).debrisshapeindex=0
  entityprofile(entid).coneheight=0.0
  entityprofile(entid).coneangle=0.0
  entityprofile(entid).hurtfall=0
  entityprofile(entid).texpath$=""
  entityprofile(entid).texd$=""
  entityprofile(entid).texdid=0
  entityprofile(entid).texaltd$=""
  entityprofile(entid).texaltdid=0
  entityprofile(entid).tex1id=0
  entityprofile(entid).tex2id=0
  entityprofile(entid).tex3id=0
  entityprofile(entid).tex4id=0
  entityprofile(entid).texidmax=0
  entityprofile(entid).effect$=""
  entityprofile(entid).usingeffect=0
  entityprofile(entid).castshadow=0
  entityprofile(entid).transparency=0
  entityprofile(entid).reducetexture=0
  entityprofile(entid).strength=0
  entityprofile(entid).lives=0
  entityprofile(entid).speed=0
  entityprofile(entid).isimmobile=0
  entityprofile(entid).ischaracter=0
  entityprofile(entid).cantakeweapon=0
  entityprofile(entid).isweapon$=""
  entityprofile(entid).isweapon=0
  entityprofile(entid).isammo=0
  entityprofile(entid).hasweapon$=""
  entityprofile(entid).hasweapon=0
  entityprofile(entid).ishealth=0
  entityprofile(entid).isflak=0
  entityprofile(entid).limbmax=0
  entityprofile(entid).headlimb=0
  entityprofile(entid).firespotlimb=0
  entityprofile(entid).animmax=0
  entityprofile(entid).footfallmax=0
  entityprofile(entid).quantity=0
  entityprofile(entid).ismarker=0
  entityprofile(entid).markerindex=0
  entityprofile(entid).isobjective=0
  entityprofile(entid).decalmax=0
  entityprofile(entid).bloodscorch=0
  entityprofile(entid).rateoffire=0
  entityprofile(entid).damage=0
  entityprofile(entid).accuracy=0
  entityprofile(entid).reloadqty=0
  entityprofile(entid).fireiterations=0
  entityprofile(entid).lifespan=0
  entityprofile(entid).throwspeed=0.0
  entityprofile(entid).throwangle=0.0
  entityprofile(entid).bounceqty=0
  entityprofile(entid).explodeonhit=0
  entityprofile(entid).weaponisammo=0
  entityprofile(entid).physics=0
  entityprofile(entid).phyalways=0
  entityprofile(entid).phyweight=0
  entityprofile(entid).phyfriction=0
  entityprofile(entid).phyforcedamage=0
  entityprofile(entid).rotatethrow=0
  entityprofile(entid).explodable=0
  entityprofile(entid).explodedamage=0
  entityprofile(entid).spine=-1
  entityprofile(entid).spine2=-1
 endif
 `
return

`
` FUNCTION TO FIND ENTITY ELEMENT INDEX FROM OBJ VALUE
`
function findentityfromobj(objclicked)
 entitytoselect=0
 for e=1 to entityelementlist
  if objclicked=entityelement(e).obj
   entitytoselect=e : exit
  endif
 next e
endfunction entitytoselect

`
` FUNCTION TO FIND ALL TEXTURES IN MODEL FILE (for file collection)
`
function findmaterialtexturesinmodelfile(file$,texpath$)
 `
 rem To determine if a model file requires
 rem texture files, we scan the file for a
 rem match to the text .TGA or .JPG (and use texfile$)
 returntexfile$=""
 if file exist(file$)=1
 filesize=file size(file$)
 mbi=255
 open to read 11,file$
 make memblock from file mbi,11
 close file 11
 for b=0 to filesize-1
  if memblock byte(mbi,b+0)=asc(".")
   `
   tfoundpiccy=0
   if memblock byte(mbi,b+1)=asc("T") or memblock byte(mbi,b+1)=asc("t")
    if memblock byte(mbi,b+2)=asc("G") or memblock byte(mbi,b+2)=asc("g")
     if memblock byte(mbi,b+3)=asc("A") or memblock byte(mbi,b+3)=asc("a")
      tfoundpiccy=1
     endif
    endif
   endif
   if memblock byte(mbi,b+1)=asc("J") or memblock byte(mbi,b+1)=asc("j")
    if memblock byte(mbi,b+2)=asc("P") or memblock byte(mbi,b+2)=asc("p")
     if memblock byte(mbi,b+3)=asc("G") or memblock byte(mbi,b+3)=asc("g")
      tfoundpiccy=1
     endif
    endif
   endif
   `
   if tfoundpiccy=1
      rem track back
      for c=b to b-255 step -1
       if memblock byte(mbi,c)>=asc(" ") and memblock byte(mbi,c)<=asc("z") and memblock byte(mbi,c)<>34
        rem part of filename
       else
        rem no more filename
        exit
       endif
      next c
      texfile$=""
      for d=c+1 to b+3
       texfile$=texfile$+chr$(memblock byte(mbi,d))
      next d
      addfiletocollection(texpath$+texfile$)
      if returntexfile$="" then returntexfile$=texpath$+texfile$
      inc b,4
   endif
   `
  endif
 next b
 delete memblock mbi
 endif
 `
endfunction returntexfile$

rem
rem MAP FILE FORMAT
rem

`
` Blank New
`

_mapfile_newmap:
 `
 rem Free arrays
 undim map()
 undim mapolay()
 undim olaylist()
 `
 rem Defaults
 layermax=20 : maxx=40 : maxy=40
 olaylistmax=100
 `
 rem Create arrays
 dim map(layermax,maxx,maxy)
 dim mapolay(layermax,maxx,maxy)
 dim olaylist(olaylistmax,50) as DWORD
 `
return

`
` Load
`

_mapfile_loadmap:
 `
 rem Free arrays
 undim map()
 undim mapolay()
 undim olaylist()
 `
 rem Load header data (need main mapdata for visdata)
 filename$=levelmapptah$+"header.dat"
 if file exist(filename$)=1
  if file size(filename$)=16
   rem V-EA Header
   open to read 1,filename$
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
   close file 1
  endif
  if file size(filename$)=32
   rem V-V1 Header
   open to read 1,filename$
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
    read file 1,gmultiplayergame
    read file 1,temp
    read file 1,temp
    read file 1,temp
   close file 1
  endif
  if file size(filename$)>32
   rem X10 versioning
   open to read 1,filename$
    rem version number
    read file 1,x10headerversion
    rem standard
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
    read file 1,gmultiplayergame
    read file 1,temp
    read file 1,temp
    read file 1,temp
    rem extra data
    if x10headerversion>=1
     rem x10 effects and volume values
     rem strings
     read string 1,res$
     read string 1,res$
     read string 1,res$
     read string 1,res$
     read string 1,res$
     rem x10effects
     for t=0 to 19
      read file 1,a : `x10effectmenu(t)=a
     next t
     rem volumes
     for t=0 to 4
      read file 1,a : `volumemeter(t)=a
     next t
     rem reserved
     read file 1,a : `waterlevel#=a : usewaterlevelfromprevioussession#=waterlevel#
     read file 1,a
     read file 1,a
     read file 1,a
     read file 1,a
    endif
   close file 1
  endif
 else
  layermax=20 : maxx=40 : maxy=40
  olaylistmax=100
 endif
 `
 rem Create arrays
 dim map(layermax,maxx,maxy)
 dim mapolay(layermax,maxx,maxy)
 dim olaylist(olaylistmax,50) as DWORD
 `
 rem Dump main map data
 filename$=levelmapptah$+"map.fpmb"
 if file exist(filename$)=1 then load array filename$,map()
 `
 rem Dump array data
 if file exist("mapbank\testmap\map.fpmo")=1 then load array "mapbank\testmap\map.fpmo",mapolay()
 if file exist("mapbank\testmap\map.fpml")=1 then load array "mapbank\testmap\map.fpml",olaylist()
 `
return

`
` Save
`

_mapfile_savemap:
 `
 rem Store old folder
 old$=get dir$()
 `
 rem Enter folder
 set dir "mapbank\testmap\"
 `
 rem Clear old files out (TEMP)
 if file exist("map.fpmb")=1 then delete file "map.fpmb"
 if file exist("header.dat")=1 then delete file "header.dat"
 if file exist("map.fpmo")=1 then delete file "map.fpmo"
 if file exist("map.fpml")=1 then delete file "map.fpml"
 `
 rem Create header file
 open to write 1,"header.dat"
  `
  rem EA
  rem map dimensions
  write file 1,layermax
  write file 1,maxx
  write file 1,maxy
  rem list sizes
  write file 1,olaylistmax
  `
  rem V1
  write file 1,gmultiplayergame
  write file 1,0
  write file 1,0
  write file 1,0
  `
 rem end of header
 close file 1
 `
 rem Dump array data
 save array "map.fpmb",map()
 save array "map.fpmo",mapolay()
 save array "map.fpml",olaylist()
 `
 rem Restore
 set dir old$
 `
return

`
` ProjectFilename FPM Saver (ZIP)
`

_mapfile_saveproject_fpm:
 `
 rem Delete any olf file
 if file exist(projectfilename$)=1 then delete file projectfilename$
 `
 rem Copy CFG to testgame area for saving with other files
 tttfile$="cfg.cfg"
 if file exist(get dir$()+"\editors\gridedit\"+tttfile$)=1
  if file exist("mapbank\testmap\"+tttfile$)=1 then delete file "mapbank\testmap\"+tttfile$
  copy file get dir$()+"\editors\gridedit\"+tttfile$,"mapbank\testmap\"+tttfile$
 endif
 `
 rem Create a FPM (zipfile)
 create file block 1, projectfilename$
 set file block key 1, "mypassword"
 set dir "mapbank\testmap\"
 add file to block 1, "header.dat"
 add file to block 1, "map.ele"
 add file to block 1, "map.ent"
 add file to block 1, "map.seg"
 add file to block 1, "map.way"
 add file to block 1, "map.fpmb"
 add file to block 1, "map.fpmo"
 add file to block 1, "map.fpml"
 add file to block 1, "cfg.cfg"
 set dir "..\.."
 save file block 1
 `
return

_mapfile_loadgamemap_fpm:
 `
 rem FPM for level loaded into mapbank\testmap
 projectfilename$=level$(level).fpm$
 gosub _mapfile_loadproject_fpm
 `
return

_mapfile_loadproject_fpm:
 `
 rem Ensure FPM exists
 if file exist(projectfilename$)=1
  `
  rem Store and switch folders
  tdirst$=get dir$() : set dir "mapbank\testmap\"
  `
  rem Delete key testmap file (if any)
  if file exist("header.dat")=1
   delete file "header.dat"
  endif
  `
  rem Retore folder to Files (for extraction)
  set dir tdirst$

  rem Read FPM into testmap area
  open file block projectfilename$,1,"mypassword"
  perform checklist for file block data 1
  tpath$=rootpath$+"mapbank\testmap\"
  for i = 1 to checklist quantity( )
   extract file from block 1, checklist string$( i ), tpath$
  next i
  close file block 1
  `
  rem If file still not present, extraction failed
  set dir tdirst$+"\mapbank\testmap\"
  if file exist("header.dat")=0
   rem inform user the FPM could not be loaded (corrupt file)
   tloadsuccessfully=0
  endif
  `
  rem if CFG file present, copy to editor folder for later use (stores FPG for us)
  if tloadsuccessfully=1
   tttfile$="cfg.cfg"
   if file exist(tttfile$)=1
    if file exist(tdirst$+"\editors\gridedit\"+tttfile$)=1 then delete file tdirst$+"\editors\gridedit\"+tttfile$
    copy file tttfile$,tdirst$+"\editors\gridedit\"+tttfile$
   endif
  endif
  `
  rem Retore and switch folders
  set dir tdirst$
  `
 else
  tloadsuccessfully=0
 endif
 `
return

_mapfile_save_fpl:
 `
 rem Delete any old file before saving
 levelfilename$="levelbank\level"+str$(level)+".zip"
 if file exist(levelfilename$)=1 then delete file levelfilename$
 create file block 1, levelfilename$
 set file block key 1, "mypassword"
 set dir "levelbank\testlevel\"
 add file to block 1, "header.dat"
 add file to block 1, "map.ent"
 add file to block 1, "map.way"
 rem FPGC - 280410 - include obstacle data in level file
 for o=0 to 19
  add file to block 1, "map"+str$(o)+".obs"
 next o
 add file to block 1, "map.fpmb"
 add file to block 1, "universe.eff"
 add file to block 1, "universe.dbo"
 add file to block 1, "universephy.dbo"
 add file to block 1, "universe.dbu"
 add file to block 1, "universe.ele"
 add file to block 1, "universe.lgt"
 tdds=0
 while tdds<65535
  if file exist("lightmaps\"+str$(tdds)+".dds")=1
   add file to block 1,"lightmaps\"+str$(tdds)+".dds"
  else
   if file exist("lightmaps\"+str$(tdds)+".png")=1
    add file to block 1,"lightmaps\"+str$(tdds)+".png"
   else
    exit
   endif
  endif
  inc tdds
 endwhile
 set dir "..\.."
 save file block 1
 addfiletocollection(levelfilename$)
 `
return

_mapfile_load_fpl:
 `
 rem Load if exists
 levelfilename$="levelbank\level"+str$(level)+".zip"
 if file exist(levelfilename$)=1
  `
  rem Read FPL into testlevel area
  open file block levelfilename$,1,"mypassword"
  perform checklist for file block data 1
  tpath$=rootpath$+"levelbank\testlevel\"
  for i = 1 to checklist quantity( )
   extract file from block 1, checklist string$( i ), tpath$
  next i
  close file block 1
  `
 endif
 `
return


rem
rem GAMEFLOW (DEFAULT PIPELINE FOR FPSC-V1)
rem

_gameflow_default:
 `
 rem Test Game Mode - hide camera until ready
 if gtestgamemodefromeditor=1
  gtestgamemodefromeditorokaypressed=0
  set camera view 0,0,1,1
  rem Ready With Test Game Engine
  open file map 1, "FPSTESTGAMEDIALOG"
  wait for file map event 1
  if get file map dword( 1, 0 ) = 1
   set file map dword 1, 12, 1
   set file map string$ 1, 1000, strarr$(377)
   wait for file map event 1
   while get file map dword ( 1, 12 ) = 1
    wait for file map event 1
   endwhile
  endif
  close file map 1
 endif
 rem Build Executable Game Mode
 if gcompilestandaloneexe=1
  rem Ready With Build Game Engine
  open file map 1, "FPSBUILDGAME"
  set file map dword 1, 40, 12
  set file map dword 1, 44, 1
  set file map string$ 1, 1000, strarr$(378)
  wait for file map event 1
  while get file map dword ( 1, 44 ) = 1
   wait for file map event 1
  endwhile
  close file map 1
 endif

 rem Load numerics for effect menu
 tfile$="languagebank\"+language$+"\gamecore\huds\numeric3.png" : load image tfile$,effectmenuimagestart+31 : addfiletocollection(tfile$)

 rem Resource Meter Assets
 img=effectmenuimagestart+33
 tfile$="languagebank\"+language$+"\gamecore\huds\"
 if file exist(tfile$+"resmeter\resource-panel.png")=1
  load image tfile$+"resmeter\resource-panel.png",img+1
  load image tfile$+"resmeter\glass-tube.png",img+2
  sprite img+1,-10000,-10000,img+1
  sprite img+2,-10000,-10000,img+2
  size sprite img+1,238,335
  size sprite img+2,207,14
  imgbase=img+3
  for rmi=0 to 4
   if rmi=0 then t$="yellow" : n$="label-polygons.png"
   if rmi=1 then t$="green" : n$="label-physics.png"
   if rmi=2 then t$="blue" : n$="label-ai.png"
   if rmi=3 then t$="red" : n$="label-entity.png"
   if rmi=4 then t$="orange" : n$="label-memory.png"
   load image tfile$+"resmeter\"+n$,imgbase+0,1 : sprite imgbase+0,-10000,-10000,imgbase+0
   load image tfile$+"resmeter\bar-"+t$+"-start.png",imgbase+1,1 : sprite imgbase+1,-10000,-10000,imgbase+1
   load image tfile$+"resmeter\bar-"+t$+".png",imgbase+2,1 : sprite imgbase+2,-10000,-10000,imgbase+2
   load image tfile$+"resmeter\bar-"+t$+"-end.png",imgbase+3,1 : sprite imgbase+3,-10000,-10000,imgbase+3
   size sprite imgbase+0,150,8
   size sprite imgbase+1,5,10
   size sprite imgbase+2,10,10
   size sprite imgbase+3,5,10
   inc imgbase,4
  next rmi
 endif
 `
 rem v118 - special saveload variable
 rem 310311- TerryFix - define var to make sure saved ambience is used
 global saveloadambience as integer : saveloadambience=-1
 `
 rem App Loop
 loopapp=1
 while loopapp=1
  `
  rem Preapp Init
  gosub _ai_setkeywords
  gosub _ai_scanfornewscriptsonly
  gosub _ai_reset
  `
  rem Title screen
  controlSPACE=1
  controlESCAPE=1
  if gtestgamemodefromeditor=0 then gosub _screen_title_init
  if grealgameviewstate=1
   continueokay=0
   while continueokay=0
    gosub _screen_control
    if vrsidebysidestereo=1 then gosub _vrstereotogglescreen
    sync
   endwhile
   hide mouse : rem GUI-X9 (knxrb)
  else
   rem in test mode, we are the 'host'
   if gtestgamemodefromeditor<>0 then createorjoin=1
  endif
  `
  rem Obtain title screen info (multiplayer)
  if gmultiplayergame=1
   if gtestgamemodefromeditor<>0
    rem Test Game Mode
    playername$="testarenaplr"
    ipaddress$=""
   else
    rem Scan HUD array for name [and ip]
    for hudid=1 to hudmax
     if hud(hudid).maintype=8
      if hud(hudid).typemode=21 then playername$=hud(hudid).text$ : hudhaveplayername=1
      if hud(hudid).typemode=22 then ipaddress$=hud(hudid).text$
     endif
    next hidid
   endif
   rem Early init sets up connection (if it can)
   gosub _multi_earlyinit
  endif
  `
  rem until editor has flag set when building arena exe..
  gosub _multi_assetloader
  `
  rem Close title screen
  if gtestgamemodefromeditor=0 then gosub _screen_close
  `
  rem if not quitting
  if loopapp=1
   `
   rem Set first level
   controlSPACE=1
   controlESCAPE=0
   `
   rem V118 - 060211 - when in build mode, the level can 'start' based on 'startbuildingleveloverride'
   if gcompilestandaloneexe=1
    level=startbuildingleveloverride
   else
    level=1
   endif
   `
   rem Start level loop
   looplevel=1
   while looplevel=1
    `
    rem V113 BETA4 - Reset global variables (before loading from saved data below)
    gosub _ai_reset_presaveposition
    `
    rem [OPTIONAL] Triggers a 'saved game' dataset to load
    if loadsavedlevel$<>""
     saveloadfile$=loadsavedlevel$
     gosub _saveload_loadgame
     saveloadfile$=""
    endif
    `
    rem VR clears redundant side
    if vrsidebysidestereo=1
     gosub _vrstereotogglescreen
     cls 0 : sync
     gosub _vrstereotogglescreen
     cls 0 : sync
    endif
    `
    rem Loading level
    if gtestgamemodefromeditor=0 then gosub _screen_loading_init
    if grealgameviewstate=1
     gosub _screen_control
     if vrsidebysidestereo=1
      gosub _vrstereotogglescreen
      sync
      gosub _vrstereotogglescreen
     endif
     sync
    endif
    `
    rem CORE : LOAD GAME DATA
    gosub _ai_reset
    gosub _ai_scanfornewscriptsonly
    gosub _main_game_loadgamedata
    `
    rem Only play if not building the executable
    if gcompilestandaloneexe=1
     `
     rem First action of core is to finishing loading of level
     gosub _load_game_scene
     gosub _ai_hud_extra
     gosub _main_game_freeleveldata
     `
     rem Review FPI screens
     gosub _screen_game_init
     gosub _screen_levelcomplete_init
     gosub _screen_gameover_init
     `
     rem Will load all levels to gather all files required for standalone
     rem V118 - 060211 - new functionality terminates build, and re-launches with next level index set
     `inc level : if level>glevelmax then looplevel=0
     looplevel=0
     `
    else
     `
     rem First action of core is to finishing loading of level
     gosub _load_game_scene
     `
     rem Repeat an arema game
     repeatsamelevel=0
     repeat
      `
      rem Flag to control the repeat (multiplayer)
      if gmultiplayergame=1
       if repeatsamelevel<>0
        rem Game has been repeated, so reset some small elements to reproduce exact restart (quicker than reload)
        gosub _multiplayer_repeatresetgame
        rem Reset flag for another new game
        repeatsamelevel=0
       else
        rem copy entire entityelement states at start (for repeat renewgame)
        tcopyorrestart=0 : gosub _gun_resetgunsettings
        tcopyorrestart=0 : gosub _entity_resetentitiestorestartstates
       endif
      endif
      `
      rem Prepare Game HUD After Loading
      gosub _screen_close
      gosub _screen_game_init
      `
      rem Give entities a blast of logic
      rem (but after HUD-creation of status-panels) (entAI adds HUDS)
      gosub _entity_blastinitentities
      `
      rem [OPTIONAL] saveload data overwrite default level settings
      if loadsavedlevel$<>""
       gosub _saveload_retrievesavedata
       loadsavedlevel$=""
      endif
      `
      rem FPGC - 150310 - add any extra HUDs (controller hint overlay)
      gosub _ai_hud_extra
      `
      rem FPGC - 200310 - apply FULL SCREEN EFFECTS shaders to all game objects
      gosub _postprocess_apply
      `
      rem CORE : PLAY LEVEL
      controlSPACE=0
      controlESCAPE=2
      showgamemenu=0
      levelwon=0
      startofgametime=timer()
      continueokay=0
      gamewarmupcount=30.0
      ingameloop=1
      gosub _ode_beginphysics
      if gvrmode<>0 then vr920exist=reset left eye()
      while continueokay=0
       if showgamemenu=0
        gosub _main_game_core
       else
        rem pause mode
        if gmultiplayergame=1
         gosub _main_game_core
        else
         rem FPGC - 110809 - when in pause mode, freeze all 3D object frames
         `for o=1 to 65535
          `if object exist(o)=1
           `if object visible(o)=1
            `set object frame o,frozenframes#(o)
           `endif
          `endif
         `next o
         For lsi=1 to entityelementmax
         frobj=entityelement(lsi).obj
         if frobj>0
            if object exist(frobj)
               set object frame frobj,entityelement(lsi).frozen.frames
            endif
         endif
         next lsi

        endif
        gosub _screen_control
        if vrsidebysidestereo=1 then gosub _vrstereotogglescreen
        if len(loadsavedlevel$)<2 then gosub _main_sync
        if gvrmode<>0 then vr920exist=reset left eye()
       endif
      endwhile
      while control_mouseclick()<>0 : endwhile
      controlSPACE=1
      controlESCAPE=0
      ingameloop=0
      `
      rem FPGC - 050710 - clear camera view (so don't get ghost of last level at start of next level
      clear camera view rgb(0,0,0)
      `
      rem FPGC - 200310 - switch FULL SCREEN EFFECTS shaders off (back to cam zero)
      gosub _postprocess_off
      `
      rem If arena, pop up game win/lose screens (and repeat game choice)
      if gtestgamemodefromeditor<>0
       `
       remstart
       rem FPGC - 130710 - if in test mode, save ambient setting from config file
       if file exist("editors\gridedit\testambience.txt")=1 then delete file "editors\gridedit\testambience.txt"
       open to write 1,"editors\gridedit\testambience.txt"
       write string 1,str$(guivisualsettings.ambience)
       close file 1
       remend
       `
       rem Quick Exit from test arena mode
       repeatsamelevel=0
       `
      else
       `
       if gmultiplayergame=1
        `
        rem Stop ALL sounds from game
        for s=1 to 65535 : if sound exist(s)=1 : stop sound s : endif : next s
        `
        rem Ensure mouse button released totally
        while control_mouseclick()<>0 : sync : endwhile
        `
        rem ARENA GAME FINISHED
        rem levelwon (0-lost,1-won,2-skip)
        if levelwon=0 or levelwon=1
         if levelwon=0 then gosub _screen_gameover_init
         if levelwon=1 then gosub _screen_levelcomplete_init
         continueokay=0
         while continueokay=0
          gosub _screen_control
          sync
         endwhile
        endif
        `
        rem Absolutely leave leveloop after arena game
        looplevel=0
        `
       else
        `
        rem SINGLE PLAYER GAME FINISHED
        rem Record any player states
        gosub _player_savestate
        `
       endif
       `
      endif
      `
      rem Close down all HUDs
      gosub _screen_close
      `
     rem if AI has chosen to repeat level, repeatsamelevel will be set to 1
     until repeatsamelevel=0
     `
     rem CORE : FREE LEVEL DATA
     if gtestgamemodefromeditor<>0
      rem if test game, leave and let heap be removed entirely
      levelwon=2
      rem but multiplayer still needs freeing manually (or crash)
      if gmultiplayergame<>0 then gosub _multi_free
     else
      rem level free, or game free
      leavegamedataalone=1
      rem game free instead (removes usually retained AI and WEAPON arrays, etc)
      if levelwon=0 or levelwon=2 or (levelwon=1 and level+1>glevelmax)
       leavegamedataalone=0
      endif
      gosub _main_game_freeleveldata
     endif
     `
     rem If single player, do gameover/complete/nextlevel
     if gmultiplayergame=0
      `
      if levelwon=0
       `
       rem Game Over
       continueokay=0
       gosub _screen_gameover_init
       while continueokay=0
        gosub _screen_control
        sync
       endwhile
       gosub _screen_close
       `
       rem End level loop
       looplevel=0
       `
      endif
      if levelwon=1
       `
       if leveljump=0
        rem Next level
        inc level : if level>glevelmax then levelwon=2
       else
        level=leveljump : if level>glevelmax then levelwon=2
        leveljump=0
       endif
       `
      endif
      if levelwon=2
       `
       rem Game Complete
       if level>1 and level>glevelmax and gtestgamemodefromeditor=0
        continueokay=0
        gosub _screen_levelcomplete_init
        while continueokay=0
         gosub _screen_control
         sync
        endwhile
        gosub _screen_close
       endif
       `
       rem Level Quit - end level loop
       looplevel=0
       `
      endif
     endif
     `
    endif
    `
    rem TestGameFromEditor Mode
    if grealgameviewstate=0 and gcompilestandaloneexe=0
     rem Always terminate after the level has been won/lost
     looplevel=0 : loopapp=0
    endif
    `
   endwhile
   `
   rem QUICK-TEST-MODE : Leave after one pass
   if grealgameviewstate=0 then loopapp=0
   `
  endif
  `
 endwhile

 rem Instruct Map Editor To Relaunch and Reload Settings
 if gtestgamemodefromeditor=1
  rem Inform user of potentiall ylong delay while unloading
  set current bitmap 0
  set text font "Verdana" : set text size 24 : ink rgb(255,255,255),0
  for sss=0 to 3
   center text screen width()/2,screen height()/2,strarr$(379)
   sync
  next sss
  rem TestGameFromEditor Mode
  open file map 1, "FPSEXCHANGE"
  set file map string$ 1, 1000, "FPSC-MapEditor.exe"
  set file map string$ 1, 1256, "-r"
  set file map dword 1, 994, 0
  set file map dword 1, 924, 1
  wait for file map event 1
  close file map 1
  rem Terminate
  timestampactivity(0,"Test Game Delete Exit")
  end
 endif
 `
return

_vrstereotogglescreen:
 titlepagetoggle=1-titlepagetoggle
 if titlepagetoggle=0
  set camera view 0,0,screen width()/2,screen height()
  set sprite resize 0,0,0.5
 else
  set camera view screen width()/2,0,screen width(),screen height()
  set sprite resize 0,screen width()/2,0.5
 endif
return

rem
rem SCREEN TEMPLATES
rem

`
` TITLE
`
_screen_title_init:
 aifile$=titlefpi$
 gosub _screen_init
return

`
` LOADING
`
_screen_loading_init:
 aifile$=level$(level).fpi$
 gosub _screen_init
return

`
` GAME
`
_screen_game_init:
 aifile$=setupfpi$
 gosub _screen_init
return

`
` LEVEL COMPLETE
`
_screen_levelcomplete_init:
 aifile$=gamewonfpi$
 gosub _screen_init
return

`
` GAMEOVER
`
_screen_gameover_init:
 aifile$=gameoverfpi$
 gosub _screen_init
return

`
` SCREEN INPUT CONTROL
`
_screen_init:
 `
 rem Load AIFILE for screen
 inc aiindexmaster
 dim scriptbank$(aiindexmaster)
 aiindex=aiindexmaster : scriptbank$(aiindex)=aifile$
 aidir$="" : ai$=aifile$ : gosub _ai_load
 screenai=aiindex
 `
 rem Prepare Entity Zero
 obj=0 : e=0
 if array count(entityelement())<=0
  dim entityelement(e) as entitytype
  dim entityshadervar(e,globalselectedshadermax)
 endif
 entityelement(e).active=1
 entityelement(e).ai.state$="0" rem GUI-X9 (String States)
 `
 rem HUD Control
 hudselectionmade=0
 `
 rem GUI-X9 (knxrb)
 gosub _gui_run
 `
return

_screen_control:
 `
 rem Run Global AI Script (in entity element zero)
 if screenai>0
  obj=0 : e=0 : aiindex=screenai : gosub _ai_control
  if entityelement(e).active=0
   rem FPI has been ended
   continueokay=1
  endif
 endif
 `
 rem Run Any HUD activity
 gosub _ai_hud_view
 `
 rem GUI-X9 (knxrb)
 gosub _gui_run
 `
return

_screen_close:
 `
 rem Terminate screen AI
 if screenai>0
  aiindex=screenai
  gosub _ai_free
  screenai=0
 endif
 `
 rem Free HUDs
 hudmax=0
 `
 rem Reset HUD dependent vars
 internalloaderhud=0
 hudfadeoutoneatatime=0
 internalloaderhud=0
 internaleyehud=0
 internalfaderhud=0
 `
return

rem
rem UNIVERSE
rem

_universe_construct_skip:
 `
 rem compare this universe with last saved universe
 rem return flag as true if the universe is the same
 universeconstructskip=1
 `
 rem if no old file, no old data so no skip
 if file exist("levelbank\testlevel\old.dat")=0 then universeconstructskip=0 : return
 `
 rem FPGC - 130710 - if no universe DBO (due to FPSC cleaner), no skip
 if file exist("levelbank\testlevel\universephy.dbo")=0 then universeconstructskip=0 : return
 `
 rem check static entities/lights
 versionnumber=100
 open to read 1,"levelbank\testlevel\old.dat"
  `
  rem V109 - BETA11 - 130508 - version control (for bankindex to be inserted)
  read file 1,oldolaylistmax
  if oldolaylistmax=-1
   read file 1,versionnumber
   read file 1,oldolaylistmax
  endif
  `
  read file 1,oldentityelementlist
  dim oldentityelement(oldentityelementlist) as entitytype
  for i=1 to oldentityelementlist
   read file 1,e
   if e>0
    read float 1,a# : oldentityelement(e).x=a#
    read float 1,a# : oldentityelement(e).y=a#
    read float 1,a# : oldentityelement(e).z=a#
    read float 1,a# : oldentityelement(e).rx=a#
    read float 1,a# : oldentityelement(e).ry=a#
    read float 1,a# : oldentityelement(e).rz=a#
    read float 1,a# : oldentityelement(e).eleprof.light.range=a#
    read file 1,tcolr
    read file 1,tcolg
    read file 1,tcolb
    if versionnumber>=109
     rem V109 BETA11
     read file 1,a : oldentityelement(e).bankindex=a
    endif
    tcol=rgb(tcolr,tcolg,tcolb)
    oldentityelement(e).eleprof.light.color=tcol
    rem current entity must be static, and be identical to old otherwise cannot skip
    if e<=entityelementlist
     if entityelement(e).staticflag=1
      if entityelement(e).x<>oldentityelement(e).x then universeconstructskip=0
      if entityelement(e).y<>oldentityelement(e).y then universeconstructskip=0
      if entityelement(e).z<>oldentityelement(e).z then universeconstructskip=0
      if entityelement(e).rx<>oldentityelement(e).rx then universeconstructskip=0
      if entityelement(e).ry<>oldentityelement(e).ry then universeconstructskip=0
      if entityelement(e).rz<>oldentityelement(e).rz then universeconstructskip=0
      if entityelement(e).eleprof.light.range<>oldentityelement(e).eleprof.light.range then universeconstructskip=0
      if entityelement(e).eleprof.light.color<>oldentityelement(e).eleprof.light.color then universeconstructskip=0
      rem V109 BETA10 - 120508 - can remove an entity from the map, which only blanks this value
      if entityelement(e).bankindex<>oldentityelement(e).bankindex then universeconstructskip=0
     else
      universeconstructskip=0 : i=oldentityelementlist
     endif
    else
     universeconstructskip=0 : i=oldentityelementlist
    endif
   endif
  next i
  if universeconstructskip=1
   if entityelementlist>oldentityelementlist
    for e=i to entityelementlist
     if entityelement(e).staticflag=1
      rem any new static entities must be used in new construction
      universeconstructskip=0
     endif
    next e
   else
    rem V109 BEAT10 - 120508 - if you delete a static entity, it needs to refresh
    if entityelementlist<oldentityelementlist
     for e=entityelementlist+1 to oldentityelementlist
      if oldentityelement(e).bankindex=0
       universeconstructskip=0
      endif
     next e
    endif
   endif
  endif
  if versionnumber>=118
   rem V118 - 270111 - new build when toggle from no effects to full effects
   read file 1,ttguseeffectstate
  endif
 close file 1
 `
 rem V118 - 270111 - if toggled between none anf full effects, rebuild all (no skip)
 if ttguseeffectstate<>guseeffectstate then universeconstructskip=0
 `
 rem V109 BETA9 - 070508 - if overlay list changed, full rebuild
 if oldolaylistmax<>olaylistmax then universeconstructskip=0
 `
 rem V109 BETA9 - no skip if new file not present
 if file exist("levelbank\testlevel\oldmapolay.dat")=0 then universeconstructskip=0
 `
 rem check map and overlays
 if universeconstructskip=1
  dim oldmap(layermax,maxx,maxy)
  dim oldmapolay(layermax,maxx,maxy)
  dim oldolaylist(oldolaylistmax,50) as DWORD
  load array "levelbank\testlevel\oldmap.dat",oldmap()
  load array "levelbank\testlevel\oldmapolay.dat",oldmapolay()
  load array "levelbank\testlevel\oldolaylist.dat",oldolaylist()
  for lay=0 to layermax
   for y=0 to maxy-1
    for x=0 to maxx-1
     for olay=0 to 1
      if olay=0 then tolaymax=0
      if olay=1
       tolaymax=0 : olayindex=mapolay(lay,x,y)
       while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
       dec tolaymax
       rem V109 BETA9 - ensure deleting an overlay also triggers full rebuild
       toldolaymax=0 : oldolayindex=oldmapolay(lay,x,y)
       while oldolaylist(oldolayindex,toldolaymax)>0 and toldolaymax<50 : inc toldolaymax : endwhile
       dec toldolaymax
      endif
      if olay=1 and tolaymax<>toldolaymax
       rem V109 BETA9 - if number of overlays on a tile changes, rebuild
       universeconstructskip=0
      else
       if tolaymax>=0
        for olayti=0 to tolaymax
         if olay=0 then mapid=map(lay,x,y)
         if olay=1 then mapid=olaylist(olayindex,olayti)
         if olay=0 then oldmapid=oldmap(lay,x,y)
         if olay=1 then oldmapid=oldolaylist(olayindex,olayti)
         if mapid<>oldmapid
          rem there is a difference, must not skip construction
          universeconstructskip=0
         endif
        next olayti
       endif
      endif
     next olay
    next x
   next y
  next lay
 endif
 `
 rem free usages
 undim oldentityelement()
 undim oldmap()
 undim oldmapolay()
 undim oldolaylist()
 `
return

_universe_saveforskipcheck:
 `
 rem save map, overlay and static entity info
 rem for above check as to whether to skip universe construction
 tfile$="levelbank\testlevel\old.dat" : if file exist(tfile$)=1 then delete file tfile$
 open to write 1,tfile$
  rem V109 - BETA11 - 130508 - version control (for bankindex to be inserted)
  versionnumber=118
  write file 1,-1
  write file 1,versionnumber
  write file 1,olaylistmax
  write file 1,entityelementlist
  for e=1 to entityelementlist
   if entityelement(e).staticflag=1
    write file 1,e
    write float 1,entityelement(e).x
    write float 1,entityelement(e).y
    write float 1,entityelement(e).z
    write float 1,entityelement(e).rx
    write float 1,entityelement(e).ry
    write float 1,entityelement(e).rz
    write float 1,entityelement(e).eleprof.light.range
    write file 1,rgbr(entityelement(e).eleprof.light.color)
    write file 1,rgbg(entityelement(e).eleprof.light.color)
    write file 1,rgbb(entityelement(e).eleprof.light.color)
    if versionnumber>=109
     rem V109 BETA11
     write file 1,entityelement(e).bankindex
    endif
   else
    write file 1,0
   endif
  next e
  if versionnumber>=118
   rem V118 - 270111 - new build when toggle from no effects to full effects
   write file 1,guseeffectstate
  endif
 close file 1
 tfile$="levelbank\testlevel\oldmap.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,map()
 tfile$="levelbank\testlevel\oldmapolay.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,mapolay()
 tfile$="levelbank\testlevel\oldolaylist.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,olaylist()
 `
return

_universe_construct:

rem FPGC - 180909 - builds universe twice (one for physics collision, once for visual geometry)
rem FPGC - 280410 - switched gextracollisionbuilddisabled via flag to speed up build time, reduce memory
for tcollisionbuildfirst=gextracollisionbuilddisabled to 1
 gosub _universe_construct_child
next tcollisionbuildfirst

return

_universe_construct_child:

rem Set size of possible node tree (cubeshaped)
set static universe maxx*100,(layermax+1)*100,maxy*100

rem Reset any lighting information
delete light map lights

rem Some global statistics for game world
totalnumberofcollisionboxes=0

rem Lightmapping
activatelightmapping=glightmappingstate
if segobjusedformapeditor=1 then activatelightmapping=0

rem Shadow maps for processing data
dim mapobj(layermax,maxx,maxy)
dim mapcsg(layermax,maxx,maxy)

rem Free old objects if any
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj

rem Construct scene
csgpassmax=3
staticlightcount=0
for csgpass=1 to csgpassmax
`
rem debug info
if csgpass=1 then debugviewtext(200,strarr$(155))
if csgpass=2 then debugviewtext(210,strarr$(156))
if csgpass=3 then debugviewtext(220,strarr$(157))
`
rem Reset workvars
segobj=segobjstart
highesty=0
`
rem Feature to fill void with floor/landscape/horizon
if 1 and segobjusedformapeditor=0
 `
 rem Fill void tiles with floor
 if csgpass=1
  `
  rem if default floor switched on
  if gusefloorstate=1
   `
   rem get map tile ID
   mapid=map(0,0,0) : mapselection=1
   if mapid>0 then gosub _gridedit_getmapvalues
   `
   rem void tile filler (automatic floor is at layer zero)
   mapscaler = 0 : mapground = 3 : maprotate = 0
   maporient = 0 : mapsymbol = 0 : maptile = 0
   gosub _universe_makemapvalues
   floormapid=mapid : lay=0
   for y=0 to maxy-1
    for x=0 to maxx-1
     if map(lay,x,y)=0
      map(lay,x,y)=mapid
     endif
    next x
   next y
   `
   rem create horizonplanes
   gosub _universe_createhorizonplanes
   `
  endif
  `
 endif
 if csgpass>1
  rem Skip horizon objects
  if gusefloorstate=1
   inc segobj,4
  endif
 endif
 `
endif
`
rem Start traversal through universe tiles
for lay=0 to layermax
 for y=0 to maxy-1
  for x=0 to maxx-1
   for olay=0 to 1
    `
    rem MAP and MAPOLAY
    if olay=0 then tolaymax=0
    if olay=1
     tolaymax=0 : olayindex=mapolay(lay,x,y)
     while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
     dec tolaymax
    endif
    if tolaymax>=0
     `
     for olayti=0 to tolaymax
      if olay=0 then mapid=map(lay,x,y)
      if olay=1 then mapid=olaylist(olayindex,olayti)
      if mapid<>0
       `
       gosub _gridedit_getmapvalues
       if object exist(selectionbankoffset+mapselection)=1
        `
        rem Set segment identity
        seg=mapselection
        `
        rem Pass 1 - Create
        if csgpass=1
         `
         rem report progress
         if treportprogressonlayer<>lay or treportprogressonlayerslice<>y
          tproggy#=(9.0/layermax)*lay
          debugviewtext(201+tproggy#,strarr$(158)+str$(lay)+strarr$(159)+str$(y)+"...")
          treportprogressonlayer=lay : treportprogressonlayerslice=y
         endif
         `
         rem check if segment uses CSG, in which case clone not instance
         tusingcsgforthisegment=0
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            tusingcsgforthisegment=1
           endif
          endif
         next tp
         `
         rem FPGC - 250310 - make sure ALL segments use 'depth of field' (only if no shader of their own)
         if gpostprocessingnotransparency=1
          rem need to use parent to set effect (not instance)
          parentofsegobj=selectionbankoffset+mapselection
          if object exist(parentofsegobj)=1
           for tlimb=0 to segmentprofileheader(seg).lastmeshmax
            if limb exist(parentofsegobj,tlimb)=1
             if segmentprofile(seg,tlimb).effectid=0
              rem FPGC - 050410 - each limb could have multimeshes which also need effects applied
              if segmentprofile(seg,tlimb).multimeshstart>0
               for r=0 to 2
                if r=0 then tlimbchange=tlimb
                if r=1 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+0
                if r=2 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+1
                set limb effect parentofsegobj,tlimbchange,65533
               next r
              else
              set limb effect parentofsegobj,tlimb,65533
             endif
            endif
            endif
           next tlimb
          endif
         endif
         `
         rem clone for manipulation of segment (clone too draining)
         if ghsrmode=1
          clone object segobj,selectionbankoffset+mapselection
         else
          rem when instance, transparent details come from origin (not for mapeditor preview though)
          if segobjusedformapeditor=0
           if guseeffectonscenesstate=1 and gpostprocessingnotransparency=1
            rem FPGC - 200310 - new shader system uses alpha for distance not static transparency
            set object transparency selectionbankoffset+mapselection,0
           else
            set object transparency selectionbankoffset+mapselection,4
           endif
          endif
          instance object segobj,selectionbankoffset+mapselection
         endif
         `
         rem setup segment for universe conversion
         set object collision off segobj
         position object segobj,50+(x*100),50+(lay*100),((y*-100)-50)
         if (100+(lay*100))>highesty then highesty=(100+(lay*100))
         mapatl=lay : mapatx=x : mapaty=y
         obj=segobj : gosub _segment_customisesinglesegment
         if olay=0 then mapobj(lay,x,y)=obj
         `
         rem initially hide all non-basic meshes
         for tlimb=segmentprofileheader(seg).lastmeshmax+1 to segmentprofileheader(seg).partmax
          if limb exist(segobj,tlimb)=1
           hide limb segobj,tlimb
          endif
         next tlimb
         `
         rem show multimesh replacements, hide base mesh in those cases
         for tlimb=0 to segmentprofileheader(seg).lastmeshmax
          tmultimesh=segmentprofile(seg,tlimb).multimeshmode
          if tmultimesh=1
           if limb visible(segobj,tlimb)=1
            if segmentprofile(seg,tlimb).multimeshstart>0
             r=rnd(2)
             if r=0 then tlimbchange=tlimb
             if r=1 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+0
             if r=2 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+1
             if limb exist(segobj,tlimbchange)=0 then tlimbchange=tlimb
             hide limb segobj,tlimb : show limb segobj,tlimbchange
            endif
           endif
          endif
         next tlimb
         `
        endif
        `
        rem Pass 2 - Add CSG, Lights and Entities
        if csgpass=2
         `
         rem add any csg punch references
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            rem check boundbox of CSGPUNCH with surrounding segments
            for surrl=lay-1 to lay+1
             for surry=y-1 to y+1
              for surrx=x-1 to x+1
               if surrl>=0 and surrl<layermax
                if surry>=0 and surry<40
                 if surrx>=0 and surrx<40
                   `
                   rem for each segment-limb (not this seg though)
                   mapid=map(surrl,surrx,surry)
                   if mapid<>0
                    gosub _gridedit_getmapvalues
                    if object exist(selectionbankoffset+mapselection)=1
                     surrseg=mapselection
                     surrobj=mapobj(surrl,surrx,surry)
                     for surrlimb=0 to segmentprofileheader(surrseg).lastmeshmax
                      rem only non-immune meshes
                      if segmentprofile(surrseg,surrlimb).csgimmune=0
                       rem first ensure meshes affected by a CSG must use base mesh, not multimesh
                       if segmentprofile(surrseg,surrlimb).multimeshstart>0
                        if limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0)=1 or limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1)=1
                         show limb surrobj,surrlimb
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1
                        endif
                       endif
                       rem if punch limb collides with surrounding segment-limb
                       tpactual=segmentprofile(seg,tp).actuallimb
                       if limb collision(segobj,tpactual,surrobj,surrlimb)=1 and limb visible(surrobj,surrlimb)=1
                        `
                        rem report progress
                        tproggy#=(9.0/layermax)*lay
                        debugviewtext(211+tproggy#,strarr$(160)+str$(lay)+","+str$(x)+","+str$(y))
                        `
                        rem make new limb
                        ttempobj1=lastsegobj+0
                        ttempobj2=lastsegobj+1
                        if object exist(ttempobj1)=1 then delete object ttempobj1
                        if object exist(ttempobj2)=1 then delete object ttempobj2
                        make object from limb ttempobj1,segobj,tpactual
                        make object from limb ttempobj2,surrobj,surrlimb
                        `
                        rem recreate object from CSG PUNCH MESH
                        lgx#=limb position x(segobj,tpactual)
                        lgy#=limb position y(segobj,tpactual)
                        lgz#=limb position z(segobj,tpactual)
                        position object ttempobj1,lgx#,lgy#,lgz#
                        texture object ttempobj1,segmentprofile(seg,tpactual).texid
                        `
                        rem recreate object from DEST NEIGHBOR MESH
                        lgx#=limb position x(surrobj,surrlimb)
                        lgy#=limb position y(surrobj,surrlimb)
                        lgz#=limb position z(surrobj,surrlimb)
                        position object ttempobj2,lgx#,lgy#,lgz#
                        texture object ttempobj2,segmentprofile(surrseg,surrlimb).texid
                        `
                        rem perform CSG Punch on neighboring limb now
                        perform csg difference ttempobj2,ttempobj1
                        `
`                        rem CSG meshes must cast shadows (unless flagged as off)
`                        if glightshadowsstate=1 then tshadow=3 else tshadow=0

`                        rem scene scadow casting disabled (for performance)
`                        if gdynamicshadowsstate=1 then tshadow=2
                        `
                        rem reapply effect if have one
                        if segmentprofile(surrseg,surrlimb).effectid>0
                         texture object ttempobj2,0,segmentprofile(surrseg,surrlimb).texdid
                         if segmentprofile(surrseg,surrlimb).texiid<>0 then texture object ttempobj2,1,segmentprofile(surrseg,surrlimb).texiid
                         if segmentprofile(surrseg,surrlimb).texnid<>0 then texture object ttempobj2,2,segmentprofile(surrseg,surrlimb).texnid
                         if segmentprofile(surrseg,surrlimb).texsid<>0 then texture object ttempobj2,3,segmentprofile(surrseg,surrlimb).texsid
                         set object effect ttempobj2,segmentprofile(surrseg,surrlimb).effectid
                        else
                         rem FPGC - 250310 - make sure ALL static use 'depth of field' only if no shader of their own
                         if gpostprocessingnotransparency=1
                          set object effect ttempobj2,65533
                         endif
                        endif
                        `
                        rem add new limb to node tree now (polycol after csg)
                        tarbvalue=segmentprofile(surrseg,surrlimb).material.index
                        if tarbvalue=0 then tarbvalue=1
                        if guseeffectonscenesstate=1 and gpostprocessingnotransparency=1
                         rem FPGC - 200310 - new shader system uses alpha for distance not static transparency
                         set object transparency ttempobj2,0
                        else
                         set object transparency ttempobj2,4
                        endif
                        `
                        rem X9 - 070208 - new field in segments for V108 so we can specify that a mesh is DEFINATELY A BLOCKER
                        `make static object ttempobj2,0,tarbvalue,tshadow,1
                        if segmentprofile(seg).properties.kindof=11
                         rem 11anytotallysolidsegment - means a FAKE segment which has CSG but then it is filled in SOLID
                         tdefoblocker=2
                        else
                         if segmentprofile(surrseg).properties.kindof=11
                          rem 11anytotallysolidsegment - means other segments which are solid despite any CSG activity
                          tdefoblocker=2
                         else
                          rem 1straight,2corner,3tjunc,4cross,5deadend - these mean the CSG is cutting through a corridor, okay
                          tdefoblocker=1
                         endif
                        endif
                        make static object ttempobj2,0,tarbvalue,tshadow,tdefoblocker
                        `
                        rem remove temp object
                        delete object ttempobj1
                        delete object ttempobj2
                        `
                        rem hide the segment-limb
                        hide limb surrobj,surrlimb
                        `
                       endif
                      endif
                     next surrlimb
                    endif
                   endif
                   `
                 endif
                endif
               endif
              next surrx
             next surry
            next surrl
           endif
          endif
         next tp
         `
         rem restore map data
         if olay=0 then mapid=map(lay,x,y)
         if olay=1 then mapid=olaylist(olayindex,olayti)
         gosub _gridedit_getmapvalues
         `
        endif
        `
        rem Pass 3 - Add To NodeTree
        if csgpass=3
         `
         rem prepare object with HSR process
         usesegobj=0
         if ghsrmode=1
          `
          rem report progress
          tproggy#=(9.0/layermax)*lay
          debugviewtext(221+tproggy#,strarr$(161)+str$(lay)+","+str$(x)+","+str$(y))
          `
          rem create super-ground-punch (arbitary usage)
`         groundpunchobj=64998
`         if object exist(groundpunchobj)=0
`          make object box groundpunchobj,80000,100,80000
`          position object groundpunchobj,0,-50,0
`          hide object groundpunchobj
`         endif
          `
          rem check boundbox of CSGPUNCH with surrounding segments
          for surrl=lay-1 to lay+1
           for surry=y-1 to y+1
            for surrx=x-1 to x+1
             if surrl>=0 and surrl<layermax
              if surry>=0 and surry<40
               if surrx>=0 and surrx<40
                 mapid=map(surrl,surrx,surry)
                 if mapid<>0
                  gosub _gridedit_getmapvalues
                  if object exist(selectionbankoffset+mapselection)=1
                   rem object bounding object to add to universe
                   surrobj=mapobj(surrl,surrx,surry)
                   if surrobj>0
                    perform csg clip segobj,surrobj
                   endif
                  endif
                 endif
               endif
              endif
             endif
            next surrx
           next surry
          next surrl
          `
          rem Now punch out ground (arbitary usage)
`         perform csg clip segobj,groundpunchobj
          `
         endif
         `
         rem make node tree addition
         for tlimb=0 to segmentprofileheader(seg).partmax
          `
          rem only visible meshes are used to make universe
          if limb exist(segobj,tlimb)=1
          if limb visible(segobj,tlimb)=1
           `
           rem shadow all except floor,wall,ceiling (and meshes with shadow switched off)
`           if glightshadowsstate=1 then tshadow=3 else tshadow=0
`           if gdynamicshadowsstate=1 then tshadow=2

           if tlimb=segmentprofile(seg).vis.f then tshadow=0
           if tlimb=segmentprofile(seg).vis.r then tshadow=0
           if tlimb=segmentprofile(seg).vis.wb then tshadow=0
           if tlimb=segmentprofile(seg).vis.wr then tshadow=0
           if tlimb=segmentprofile(seg).vis.wf then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owb then tshadow=0
           if tlimb=segmentprofile(seg).vis.owr then tshadow=0
           if tlimb=segmentprofile(seg).vis.owf then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbl then tshadow=0
           `
           rem set transparency for universe add
`           set object transparency segobj,segmentprofile(seg,tlimb).transparency
`           set object transparency segobj,1 `need alpha test active (depth-sort-via-alpha-test)
           if guseeffectonscenesstate=1 and gpostprocessingnotransparency=1
            rem FPGC - 200310 - new shader system uses alpha for distance not static transparency
            set object transparency segobj,0
           else
            set object transparency segobj,4
           endif
           `
           rem add mesh to universe
           tcolmode=segmentprofile(seg,tlimb).colmode
           tarbvalue=segmentprofile(seg,tlimb).material.index
           if segmentprofile(seg,tlimb).transparency=2 then tarbvalue=0 : rem FPSCV101 - no bullethole in trasparent(2) static
           if tcolmode=1 then inc totalnumberofcollisionboxes
           if segmentprofile(seg).vis.portalmode>0
            rem choose portal manually form segment profile
            tportalblocker=segmentprofile(seg).vis.portalmode-1
           else
            rem default portal generation
            if segmentprofile(seg).vis.overlay=0
             if segmentprofile(seg).properties.kindof>0
              rem currently only corridors are true for this, and ARE ALL solid!
              rem 1straight,2corner,3tjunc,4cross,5deadend,11anytotallysolidsegment
              tportalblocker=2
             else
              tportalblocker=1
             endif
            else
             tportalblocker=0
            endif
           endif
           make static limb segobj,tlimb,tcolmode,tarbvalue,tshadow,tportalblocker
           `
          endif
          endif
          `
         next tlimb
         `
         rem hide original object (still used for SURROBJ HSR culling)
         hide object segobj
         `
        endif
        `
        rem PassEnd
        `
        rem Increment segment objid
        inc segobj
        `
        rem When run out of segments to build map, leave immediately
        if segobj>=universebuildobjendoffset
         rem end all loop conditions - no crash - just shortened level
         lay=layermax : y=maxy-1 : x=maxx-1
         olay=1 : olayti=tolaymax
        endif
        `
       endif
      endif
     next olayti
    endif
   next olay
  next x
 next y
next lay
`
rem When all objects added (first pass)
if csgpass=1
 rem leefix - 070408 - V109B2 - four corner markers 9for correct universe culling)
 rem add a zero-size high object for top of universe (need clearance for player on roofs)
 `tuniverseheightbuffer=550
 rem leefix - V111 - 160608 - detect all static entities that poke above highest point, then determine buffer if any
 textendbufferby=0
 eleobj=entityobjectoffset
 for e=1 to entityelementlist
  obj=eleobj+e
  entid=entityelement(e).bankindex
  if obj>0
   if entityelement(e).staticflag=1
    if entityprofile(entid).ismarker=0
     if object exist(obj)=1
      if entityelement(e).y+object size y(obj)>highesty
       textendbufferby=(entityelement(e).y+object size y(obj))-highesty
       textendbufferby=textendbufferby/100
       textendbufferby=textendbufferby+1
       textendbufferby=textendbufferby*100
      endif
     endif
    endif
   endif
  endif
 next e
 tuniverseheightbuffer=50+textendbufferby
 if highesty+tuniverseheightbuffer>20*100 then tuniverseheightbuffer=(20*100)-highesty
 make object box segobj,0,100,0 : position object segobj,0,highesty+tuniverseheightbuffer,0 : inc segobj
 make object box segobj,0,100,0 : position object segobj,40*100,highesty+tuniverseheightbuffer,0 : inc segobj
 make object box segobj,0,100,0 : position object segobj,40*100,highesty+tuniverseheightbuffer,-39*100 : inc segobj
 make object box segobj,0,100,0 : position object segobj,0,highesty+tuniverseheightbuffer,-39*100 : inc segobj
 rem record last segment object
 lastsegobj=segobj
endif
if csgpass=3
 if object exist(segobj)=1
  for fourcornermarkers=0 to 3
   if guseeffectonscenesstate=1 and gpostprocessingnotransparency=1
    rem FPGC - 200310 - new shader system uses alpha for distance not static transparency
    set object transparency segobj,0
   else
    set object transparency segobj,4
   endif
   rem FPGC - 250310 - make sure ALL static use 'depth of field' (only if no shader of their own)
   if gpostprocessingnotransparency=1
    if object exist(segobj)=1
     if objecteffect(segobj)=0
      set object effect segobj,65533
     endif
    endif
   endif
   make static object segobj,0,0,0,1
   hide object segobj : inc segobj
  next fourcornermarkers
 endif
endif
`
rem next pass
next csgpass

rem V102RC6 remove all segment objects to free up memory for next phase ( except the horizon polys )
if gusefloorstate=1 then inc segobjstart,4
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj
if gusefloorstate=1 then dec segobjstart,4

rem FPGC - 250310 - ensure objecteffect array is cleared after any object delete
for o=1 to 65535
 if object exist(o)=0 then objecteffect(o)=0
next o

rem FPSCV104RC7 - new lightmapper
rem FPSCV105RC1 - added new flag 'glightmappingold'
useoldlightmapper=glightmappingold
usedarklightmapper=1-glightmappingold
if usedarklightmapper=1 and tcollisionbuildfirst=1
 rem DarkLIGHTS Settings
 LM Start
endif

rem debug info
debugviewtext(230,strarr$(162))

rem add pure static entities to node tree now
eleobj=entityobjectoffset
ttick=0 : ttickmax=entityelementlist/10 : ttickmax=1
for e=1 to entityelementlist
 obj=eleobj+e
 entid=entityelement(e).bankindex
 tentid=entityelement(e).bankindex
 if obj>0
  rem add static entities to node tree now
  if entityelement(e).staticflag=1
   inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(232,strarr$(163)+str$(e)+"/"+str$(entityelementlist)+" ("+entityprofile(tentid).model$+")")
   if entityprofile(tentid).ismarker=0
    rem this next routine should texture, but because entobj is zero, no, need to use OBJ!!!
    configureobj=obj : gosub _entity_configueelementforuse
    gosub _entity_createelementasobject
    if object exist(obj)=1
     rem collision mode for static entities (0-poly,1-box,2-reduced) dynamic (3-cylinder,4-sphere)
     tcolmode=2 : rem default is to use a reduced mesh
     if entityprofile(tentid).collisionmode>0 and entityprofile(tentid).collisionmode<3
      rem so FPE colmode=1 is POLY (0)
      rem so FPE colmode=2 is BOX (1)
      tcolmode=entityprofile(tentid).collisionmode-1
     endif
     rem static entities must cast shadows (unless flagged as off)
`     if glightshadowsstate=1 then tshadow=3 else tshadow=0
`     if gdynamicshadowsstate=1 then tshadow=2
     tarbvalue=entityprofile(tentid).materialindex
     enable object zwrite obj
     if guseeffectonscenesstate=1 and gpostprocessingnotransparency=1
      rem FPGC - 200310 - new shader system uses alpha for distance not static transparency
      set object transparency obj,0
     else
      set object transparency obj,4
     endif
     rem handle entities that animate
     useobj=obj
     if 0
      rem old pre-V109 approach, V109 introduces new 1000+ collison mode to single out one solid mesh amongst non collider limbs
      `make static object useobj,tcolmode,tarbvalue,tshadow,0
     else
      if object exist(useobj)=1
       perform checklist for object limbs useobj
       for tlimb=0 to checklist quantity()-1
        tswitchoffcull=0
        if limb exist(useobj,tlimb)=1
         tcolmode=2 : rem default is to use a reduced mesh
         tcollisionmodevalue=entityprofile(tentid).collisionmode
         if tcollisionmodevalue>=1000
          rem leeadd - 160308 - new collision mode to specify only ONE collision solid,
          rem the rest are non-col (for static trees and shrubs)
          if (tcollisionmodevalue-1000)=tlimb
           tcolmode=2 : rem redmesh - trunk
          else
           tcolmode=3 : rem none - leaves, grass, bushes
           tswitchoffcull=1 : rem ensure double sided as well!
          endif
         else
          if tcollisionmodevalue>0 and tcollisionmodevalue<3
           rem so FPE colmode=1 is POLY (0)
           rem so FPE colmode=2 is BOX (1)
           tcolmode=entityprofile(tentid).collisionmode-1
          endif
         endif
         rem leeadd - 160308 - double sided static geometry
         if tswitchoffcull=1
          set object cull useobj,0
         else
          set object cull useobj,1
         endif
         rem FPGC - 250310 - make sure ALL static entities use 'depth of field' (only if no shader of their own)
         if gpostprocessingnotransparency=1
          if object exist(useobj)=1
           if objecteffect(useobj)=0
            set object effect useobj,65533
           endif
          endif
         endif
         tarbvalue=entityprofile(tentid).materialindex
         tshadow=0 : tportalblocker=0
         rem tcolmode : 0-poly, 1-box, 2-redmesh, 3-none (all overridden by ODE universe submitted as collision polygons)
         rem but we use a modified CONVERT TO SINGLE MESH to extract all the non-culled polygons (leaves, etc)
         if tcollisionbuildfirst=1
          make static limb useobj,tlimb,tcolmode,tarbvalue,tshadow,tportalblocker
         else
          if tcolmode=1
           rem FPGC - 140909 - only BOX collision shapes are made boxes for the universephy.dbo
           if tlimb=0
            ttempobj1=lastsegobj+0
            if object exist(ttempobj1)=1 then delete object ttempobj1
            tlimbsizex=object size x(useobj)
            tlimbsizey=object size y(useobj)
            tlimbsizez=object size z(useobj)
            make object box ttempobj1,tlimbsizex,tlimbsizey,tlimbsizez
            position object ttempobj1,object position x(useobj)+object collision center x(useobj),object position y(useobj)+object collision center y(useobj),object position z(useobj)+object collision center z(useobj)
            rotate object ttempobj1,object angle x(useobj),object angle y(useobj),object angle z(useobj)
            make static object ttempobj1,tcolmode,tarbvalue,tshadow,tportalblocker
            delete object ttempobj1
           endif
          else
           rem reduced mesh and poly col modes remain full polygon shapes for the uuniversephy.dbo
           make static limb useobj,tlimb,tcolmode,tarbvalue,tshadow,tportalblocker
          endif
         endif
        endif
       next tlimb
      endif
     endif
     rem FPGC - 180410 - create an AI obstacle from the static entity (+sizey ensures if sunk into floor they still work)
     taddtocontainer=(object position y(useobj)+object size y(useobj))/100.0
     if taddtocontainer<0 then taddtocontainer=0
     if taddtocontainer>19 then taddtocontainer=19
     AI ADD STATIC OBSTACLE useobj,1,taddtocontainer
     taddtocontainer2=(object position y(useobj)+5)/100.0
     if taddtocontainer<>taddtocontainer2 and object size y(useobj)>10
      rem ensure we add OBS data for large ceiling items not already covered by above
      if taddtocontainer2<0 then taddtocontainer2=0
      if taddtocontainer2>19 then taddtocontainer2=19
      AI ADD STATIC OBSTACLE useobj,1,taddtocontainer2
     endif
     rem then delete the un-needed static entity
     delete object useobj
    endif
   endif
  endif
  rem add dynamic and static lights from entities (FPGC - 051109 - tcollisionbuildfirst - only on second pass (first is collision only))
  if entityprofile(tentid).islightmarker=1 and tcollisionbuildfirst=1
   lgx#=entityelement(e).x
   lgy#=entityelement(e).y
   lgz#=entityelement(e).z
   if entityprofile(tentid).ismarker=0
    rem FPGC - 260310 - new entitylight can be offset with lightoffsetup and lightoffsetz
    lgy#=lgy#+entityprofile(tentid).light.offsetup
    lgx#=lgx#+newxvalue(0,entityelement(e).ry,entityprofile(tentid).light.offsetz)
    lgz#=lgz#+newzvalue(0,entityelement(e).ry,entityprofile(tentid).light.offsetz)
   endif
   lgrange#=entityelement(e).eleprof.light.range
   lgr#=rgbr(entityelement(e).eleprof.light.color)
   lgg#=rgbg(entityelement(e).eleprof.light.color)
   lgb#=rgbb(entityelement(e).eleprof.light.color)
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     lgtype=1 : gosub _lighting_adddynamiclight
     entityelement(e).eleprof.light.index=infinilightindex
    endif
   else
    if activatelightmapping=1
     if useoldlightmapper=1
      add light map light lgx#, lgy#, lgz#, lgrange#, lgr#, lgg#, lgb#, 100, 1
     endif
     if usedarklightmapper=1
      size# = lgrange#
      falloff# = size#/2
      radius# = size#+falloff#
      zerorange# = ( radius# * glightzerorange ) / 100.0
      atten# = glightatten / (radius#*radius#)
      outer# = 1.0 + falloff#
      brighter# = radius# / outer#
      lgr#=lgr#*brighter#
      lgg#=lgg#*brighter#
      lgb#=lgb#*brighter#
      LM Add Custom Point Light lgx#, lgy#, lgz#, radius#, zerorange#, atten#,lgr#/255.0, lgg#/255.0, lgb#/255.0
     endif
     lgtype=0 : gosub _lighting_adddynamiclight
     inc staticlightcount
    endif
    if gdynamicshadowsstate=1
     array insert at bottom shadowlight()
     shadowlight().x# = lgx#
     shadowlight().y# = lgy#
     shadowlight().z# = lgz#
     shadowlight().range# = lgrange#
    endif
   endif
  endif
 endif
next e

rem V118 - if level has NO static lights, must create at least one (small black one)
rem to allow the light mapping to be created so full effects can predict LM existence
if staticlightcount=0
 lgx#=-500 : lgy#=-500 : lgz#=500
 lgrange#=50 : size# = lgrange# : falloff# = size#/2
 radius# = size#+falloff# : zerorange# = ( radius# * glightzerorange ) / 100.0
 atten# = glightatten / (radius#*radius#) : outer# = 1.0 + falloff#
 brighter# = radius# / outer#
 lgr#=0 : lgg#=0 : lgb#=0
 if activatelightmapping=1
  if usedarklightmapper=1
   LM Add Custom Point Light lgx#, lgy#, lgz#, radius#, zerorange#, atten#,lgr#/255.0, lgg#/255.0, lgb#/255.0
  endif
  lgtype=0 : gosub _lighting_adddynamiclight
  inc staticlightcount
 endif
endif

rem New portals section of game runner
debugviewtext(240,strarr$(164))
build static portals

rem Apply shadow lights to scene (which will compute shadows direct from node tree
if gdynamicshadowsstate=1
 debugviewtext(250,strarr$(165))
 set global shadow shades 1
 set global shadow color 0,0,0,128
` disabled scene shadows for performance reasons
` for tsli=1 to array count(shadowlight(0))
`  set shadow light tsli, shadowlight(tsli).x#, shadowlight(tsli).y#, shadowlight(tsli).z#, shadowlight(tsli).range#
` next tsli
endif

rem New lightmapping section of game runner
if activatelightmapping=1 and staticlightcount>0
 rem delete old lightmaps
 debugviewtext(259,strarr$(166))
 tl=0
 while tl<65535
  neither=0 : rem FPSCV105RC2 - lightmaps where not deleted after PNG was added
  tl$="levelbank\testlevel\lightmaps\"+str$(tl)+".dds"
  if file exist(tl$)=1 then delete file tl$ else inc neither
  tl$="levelbank\testlevel\lightmaps\"+str$(tl)+".png"
  if file exist(tl$)=1 then delete file tl$ else inc neither
  if neither=2 then exit
  inc tl
 endwhile
 rem add universe for lightmapping (FPGC - 051109 - only for second build pass - first is collision)
 if tcollisionbuildfirst=1
  debugviewtext(260,strarr$(167))
  if useoldlightmapper=1
   add static objects to light map pool
   debugviewtext(270,strarr$(168))
   if glightmapsize>0
    create light maps glightmapsize,glightmapquality,"levelbank\testlevel\lightmaps\"
   else
    create light maps 8,100,"levelbank\testlevel\lightmaps\"
   endif
  endif
 endif
endif

rem Must be done 'after' lightmapping phase
if grealgameviewstate=0 and segobjusedformapeditor=0 and goptimizemode=1
 `
 rem Saving effects (as some scene geometry needs setting changes)
 debugviewtext(273,strarr$(169))
 filename$="levelbank\testlevel\universe.eff"
 if file exist(filename$)=1 then delete file filename$
 open to write 1,filename$
  write file 1,effectbankmax
  for eff=1 to effectbankmax
   write string 1,effectbank$(eff)
  next eff
  write string 1,thorizonplanetex$
 close file 1
 `
 rem Builds final universe reload file (even when test game)
 debugviewtext(274,strarr$(170))
 universefile$="levelbank\testlevel\universe.dbu" : if file exist(universefile$)=1 then delete file universefile$
 universefile$="levelbank\testlevel\universe.dbo" : if file exist(universefile$)=1 then delete file universefile$
 save static objects universefile$
 `
 rem FPSCV104RC9 - pregenerate physics universe (faster loading)
 debugviewtext(275,"Pregenerate physics universe...")
 if tcollisionbuildfirst=0 or gextracollisionbuilddisabled=1
  rem FPGC - 140909 - only generate physics universe on first pass (with static entity boxes)
  phyunimesh$="levelbank\testlevel\universephy.dbo" : if file exist(phyunimesh$)=1 then delete file phyunimesh$
  universeobj=universebuildobjstartoffset-1
  load object "levelbank\testlevel\universe.dbo",universeobj
  set object filter universeobj,2
  make mesh from object universeobj,universeobj,1
  convert mesh to vertexdata universeobj
  delete object universeobj
  make object universeobj,universeobj,0
  delete mesh universeobj
  save object phyunimesh$,universeobj
  delete object universeobj
 endif
 `
 rem If DarkLIGHT lightmapper used (FPGC - 051109 - only on second build pass, not collision pass)
 debugviewtext(276,"Begin universe lighting...")
 if activatelightmapping=1 and staticlightcount>0 and usedarklightmapper=1 and tcollisionbuildfirst=1
  `
  rem load and lightmap static universe
  universeobj=universebuildobjstartoffset-1
  if object exist(universeobj)=1 then delete object universeobj
  load object universefile$,universeobj
  set object filter universeobj,2
  if glightshadowsstate=0
   rem Quick Lightmapping
   LM Add Collision Object universeobj
  else
   rem Full Lightmapping
   LM Add Transparent Collision Object universeobj,1
  endif
  LM Add Light Map Object universeobj
  LM Build collision Data
  `
  rem ambient setting (full ambient control in scene)
  LM Set Ambient Light glightambientr/100.0,glightambientg/100.0,glightambientb/100.0
  if glightsunr<>0 or glightsung<>0 or glightsunb<>0
   LM Add Directional Light glightsunx,glightsuny,glightsunz,glightsunr/100.0,glightsung/100.0,glightsunb/100.0
  endif
  `
rem settings
  LM Boost Curved Surface Quality glightmaxsize,(glightboost*1.0)
  `
  rem start the light mapping thread
  lm set light map name ""
  lm set light map file format 1 : rem DDS
  lm set light map folder "levelbank\testlevel\lightmaps\"
  quality#=glightquality/100.0
  if glightthreadmax=-2
   rem FPSCV105 - 090307 - new mode, to revert to non-thread approach (for some users stability)
   debugviewtext(270,strarr$(168))
   LM Build Light Maps glighttexsize,quality#,glightblurmode
  else
   LM Build Light Maps Thread glighttexsize,quality#,glightblurmode,glightthreadmax
   load dll "Kernel32.dll",1
   while LM Get Complete()=0
    debugviewtext(276,LM Get Status( )+"  "+str$(int(LM Get Percent()))+"%")
    call dll 1,"Sleep",1
   endwhile
   delete dll 1
  endif
  `
  rem close lightmapper
  LM Reset
  `
  rem save lightmapped universe
  if file exist(universefile$)=1 then delete file universefile$
  set object light universeobj,1
  set light mapping on universeobj,0,1
  save object universefile$,universeobj
  delete object universeobj
  `
  rem load static universe back in
  load static objects universefile$,gdividetexturesize
  `
 endif
 `
 rem V106 RC3 Save lighting data (for uni-skip)
 gosub _version_universe_saveELEandLGT
 `
 rem Only perform these saves if BUILDING EXE
 if gcompilestandaloneexe=1
  `
  rem FPGC - 290410 - standalone requires OBS data to be calculated soon
  gosub _darkai_createlevel : gosub _darkai_free
  `
  rem Version control on EXE Building
  gosub _version_universe_construct
  `
 endif
 `
 rem V106 save old map, overlay and static entity data for future test game pass
 gosub _universe_saveforskipcheck
 `
endif

return

_universe_recreateinfinilights:
 `
 rem V109 BETA3 - 210408 - when use DBU-skip, new elements do not tally with inifnilight LGT data, so recreate
 rem for the test gamwe quick rebuild feature
 `
 rem Reset dynamic light array
 activatedynamiclightscount=0
 empty array infinilight(0)
 testmarkerstart=50000
 testmarker=testmarkerstart
 staticlightcount=0
 infinilightindex=0
 `
 rem Lighting flag
 activatelightmapping=glightmappingstate
 if segobjusedformapeditor=1 then activatelightmapping=0
 `
 rem Rebuild inifnilights
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  tentid=entityelement(e).bankindex
  rem add dynamic and static lights from entities
  if entityprofile(tentid).islightmarker=1
   lgx#=entityelement(e).x
   lgy#=entityelement(e).y
   lgz#=entityelement(e).z
   if entityprofile(tentid).ismarker=0
    rem FPGC - 260310 - new entitylight can be offset with lightoffsetup and lightoffsetz
    lgy#=lgy#+entityprofile(tentid).light.offsetup
    lgx#=lgx#+newxvalue(0,entityelement(e).ry,entityprofile(tentid).light.offsetz)
    lgz#=lgz#+newzvalue(0,entityelement(e).ry,entityprofile(tentid).light.offsetz)
   endif
   lgrange#=entityelement(e).eleprof.light.range
   lgr#=rgbr(entityelement(e).eleprof.light.color)
   lgg#=rgbg(entityelement(e).eleprof.light.color)
   lgb#=rgbb(entityelement(e).eleprof.light.color)
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     lgtype=1 : gosub _lighting_adddynamiclight
     entityelement(e).eleprof.light.index=infinilightindex
    endif
   else
    if activatelightmapping=1
     if usedarklightmapper=1
      size# = lgrange#
      falloff# = size#/2
      radius# = size#+falloff#
      zerorange# = ( radius# * glightzerorange ) / 100.0
      atten# = glightatten / (radius#*radius#)
      outer# = 1.0 + falloff#
      brighter# = radius# / outer#
      lgr#=lgr#*brighter#
      lgg#=lgg#*brighter#
      lgb#=lgb#*brighter#
     endif
     lgtype=0 : gosub _lighting_adddynamiclight
     inc staticlightcount
    endif
   endif
  endif
 next e
 `
return

_universe_destruct:

rem Remove universe and all constructed preview assets
delete static objects : set static universe maxx*100,(layermax+1)*100,maxy*100

return

_universe_camera:

rem Input source
tkeystate30=0 : tkeystate32=0 : tkeystate17=0 : tkeystate31=0 : tkeystate44=0
if inputsys.kscancode=87 then tkeystate17=1
if inputsys.kscancode=83 then tkeystate31=1
if inputsys.kscancode=65 then tkeystate30=1
if inputsys.kscancode=68 then tkeystate32=1
if inputsys.kscancode=90 then tkeystate44=1
cammovex#=inputsys.xmousemove
cammovey#=inputsys.ymousemove



Rem Scene commander end

rem Camera old information
cox#=camera position x()
coy#=camera position y()
coz#=camera position z()

rem Control camera movement
movement=0 : speed#=6.0
x#=camera angle x() : z#=camera angle z() : sy#=camera angle y() : y#=sy#
if tkeystate30=1 then dec y#,90 : movement=1
if tkeystate32=1 then inc y#,90 : movement=1
rotate camera 0,y#,0
if tkeystate17=1 or tkeystate30=1 or tkeystate32=1 then move camera speed# : movement=1
if tkeystate31=1 then move camera speed#*-1.0 : movement=1
rotate camera x#,sy#,z#

rem Float Key
if tkeystate44=1 then position camera camera position x(),camera position y()+4.0,camera position z() : grav#=-1.0

rem Camera new information
cmx#=camera position x()
cmy#=camera position y()-grav#
cmz#=camera position z()

rem Overall ellipse collision for camera
tcameraeyey#=20.0
if deactivatecollision=0
 if static volume(cox#,coy#-tcameraeyey#,coz#,cmx#,cmy#-tcameraeyey#,cmz#,1.0)=1
  cmx#=cox#+get static collision x()
  cmy#=coy#+get static collision y()
  cmz#=coz#+get static collision z()
  if get static collision floor()=1
   rem FPGC - 150610 - added floor check for player floor material value (stops using wall material for footfalls)
   tcolmaterialtype=get static collision value()-1
   colmaterialtype=tcolmaterialtype
  endif
  grav#=1
 else
  inc grav#,1
 endif
endif

rem Non node tree collision floor stopper (and edge of universe stopper)
if cmx#<0.0 then cmx#=0.0
if cmx#>maxx*100.0 then cmx#=maxx*100.0
if cmy#<45.0 then cmy#=45.0
if cmz#<maxy*-100.0 then cmz#=maxy*-100.0
if cmz#>0.0 then cmz#=0.0

rem Update camera position
zrotate camera curveangle(0,camera angle z(0),1.75)
`position listener cmx#/10.0,cmy#/3.0,cmz#/10.0
`rotate listener 0,camera angle y(0),0

rem Camera rotation speeds
t=abs(cammovex#)+abs(cammovey#)
if t=1 then camrotspeed#=0.05
if t=2 then camrotspeed#=0.1
if t=3 then camrotspeed#=0.15
if t=4 then camrotspeed#=0.2
if t>=5 then camrotspeed#=0.25
camangx#=camera angle x()+(cammovey#*camrotspeed#)
camangy#=camera angle y()+(cammovex#*camrotspeed#)

rem Control camera view
if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<275 then camangx#=275.0

rotate camera camangx#,camangy#,camera angle z()

return

_universe_preparelimbflags:

rem Create limb flag array
limbflagmax=segmentprofileheader(seg).lastmeshmax
undim limbflag()
dim limbflag(limbflagmax)

rem Fill array with null limbs
for tlimb=0 to limbflagmax
 limbflag(tlimb)=0
next tlimb

return

_universe_createhorizonplanes:
 `
 rem TODO take MAXX and MAXY into account!
 `
 rem Load texture for horizon plane
 thorizonplanetex$=""
 thorizonplanetexid=segmentprofile(mapselection,0).texid
 if thorizonplanetexid<>0
  thorizonplanetex$=segmentprofile(mapselection,0).tex$
 else
  thorizonplanetexid=segmentprofile(mapselection,0).texdid
  if thorizonplanetexid<>0
   thorizonplanetex$=segmentprofile(mapselection,0).texd$
  else
   thorizonplanetex$="texturebank\common\ground_D2.tga"
   thorizonplanetexid=loadinternalimage(thorizonplanetex$)
  endif
 endif
 `
 rem Place horizon planes on four sides
 tdim=(40*100)/2.0 : tdimneg=tdim*-1 : tdimlong=tdim*3 : lay=0
 rem Left
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,tdimneg,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Right
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,(maxx*100)+tdim,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Top
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,tdim
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 rem Bottom
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,(maxy*-100)+tdimneg
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 `
 rem And place fog to finish horizon blur to sky (by colour)
 rem FPSCV104RC3 - fog is controlled by FPI elsewhere
 `fog on : fog distance 2000.0,4000.0 : fog color 0,0,0
 `
return

_universe_makemapvalues:
 `
 mapid = 0
 mapid = mapid + ( ( mapselection && %111111111111 ) << 20 )
 mapid = mapid + ( ( mapscaler && %1111 ) << 16 )
 mapid = mapid + ( ( mapground && %11 ) << 14 )
 mapid = mapid + ( ( maprotate && %11 ) << 12 )
 mapid = mapid + ( ( maporient && %11 ) << 10 )
 mapid = mapid + ( ( mapsymbol && %111111 ) << 4 )
 mapid = mapid + ( ( maptile && %1111 ) )
 rem mapid out
 `
return


`
` Player and AI Shared Code
`

_entity_getactualframe:
 `
 rem work out actual frame from base frame and entity-character state and weapon used
 Rem Hockeykid - 050510 - Check To make sure that the animation exist, if not attempt to remove offset
 if entityprofile(entid).ischaracter=1
  if entityelement(e).attachmentweapontype>0
   foundframe=0
   if entityanim(entid,50+tbaseframe).start=-1 and entityanim(entid,50+tbaseframe).finish=-1 then foundframe=1
  Endif
 Endif
 rem only applies to characters with weapons
 if entityprofile(entid).ischaracter=1
  if entityelement(e).attachmentweapontype>0
   rem if weapon, use 50-99 range
   if tbasetype=1 then tactualframe=entityanim(entid,50+tbaseframe).start
   if tbasetype=2 then tactualframe=entityanim(entid,50+tbaseframe).finish
   rem if greater than pistol, apply an offset to final frame number
   if tbaseframe>=10 and tbaseframe<=22
    if tbaseframe=13 or tbaseframe=16
     tokay=1
    else
     tokay=0
    endif
   else
    tokay=1
   endif
   if tokay=1
    if entityelement(e).attachmentweapontype=2 then tactualframe=tactualframe+389
    if entityelement(e).attachmentweapontype=3 then tactualframe=tactualframe+778
    if entityelement(e).attachmentweapontype=4 then tactualframe=tactualframe+1167
    if entityelement(e).attachmentweapontype=5 then tactualframe=tactualframe+1556
   endif
  else
   rem if no weapon, we are done (NOWEAP)
   if tbasetype=1 then tactualframe=entityanim(entid,tbaseframe).start
   if tbasetype=2 then tactualframe=entityanim(entid,tbaseframe).finish
  endif
  rem assign crouch flag (profile of character for hit detect)
  if tbaseframe>=31 and tbaseframe<40 then entityelement(e).crouchprofile=1 else entityelement(e).crouchprofile=0
 else
  if tbasetype=1 then tactualframe=entityanim(entid,tbaseframe).start
  if tbasetype=2 then tactualframe=entityanim(entid,tbaseframe).finish
 endif
 Rem act as if entity has no weapon to avoid fram offset
 if foundframe=1
  if tbasetype=1 then tactualframe=entityanim(entid,tbaseframe).start
  if tbasetype=2 then tactualframe=entityanim(entid,tbaseframe).finish
 endif
 `
return

_entity_getactualframestart:
 tbasetype=1 : gosub _entity_getactualframe
return

_entity_getactualframefinish:
 tbasetype=2 : gosub _entity_getactualframe
return


_player_determinevisibility:

rem used by an entity when looking at mex#,mey#,mez#
rem determine if player exposed to be visible to tmpx#,tmpy#,tmpz#,dist# and (e)
tvisibility=1
tvisibilityifbreak=0 : tvisibilityifbreakdist#=9999.99

rem deduct from 100 percent visible, if drop below zero, enemy cannot see plr
visprobcount=100

rem instant block if other object obstructs it
for tte=1 to entityelementlist
 if tte<>e
  if entityelement(tte).active=1 and entityelement(tte).dormant=0 and entityelement(tte).collisionactive=1
   tdistx#=entityelement(e).x-entityelement(tte).x
   tdisty#=entityelement(e).y-entityelement(tte).y
   tdistz#=entityelement(e).z-entityelement(tte).z
   ttdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if ttdist#<=dist# and entityelement(tte).obj>0
    ttdst#=intersect object(entityelement(tte).obj,tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
    if ttdst#>0
     if entityelement(tte).eleprof.transparency=0 then tvisibility=0
     if entityelement(tte).eleprof.transparency>0
      if ttdst#<tvisibilityifbreakdist#
       tvisibilityifbreak=tte
       tvisibilityifbreakdist#=ttdst#
      endif
     endif
     if tvisibility=0 then tte=entityelementlist+1
    endif
   endif
  endif
 endif
next tte

rem loose accuracy on exposure of player (if peeking, crouched, moving)
if tvisibility=1
 if peeklean#<>0.0 then dec visprobcount,10
 if movement=0 then dec visprobcount,25
 if crouchmode<>0 then dec visprobcount,10
endif

rem loose accuracy on distance
if tvisibility=1
 if dist#>1000 then dec visprobcount,10
 if dist#>2000 then dec visprobcount,50
endif

rem loose accuracy on light level of player
if tvisibility=1
 if dist#>200
  if array count(infinilight())<>-1 : rem U74 - V115 - fix thanks to S4REAL
   tavlightcol#=(avlightcolr#+avlightcolg#+avlightcolb#)/3.0
   tavlightcol#=tavlightcol#/2.5
   tavlightcol=100-tavlightcol# : if tavlightcol<1 then tavlightcol=1
   tavlightcol=tavlightcol/2
   dec visprobcount,tavlightcol
  endif
 endif
endif

rem use visual probability count for final visibile check
if tvisibility=1
 if visprobcount<0 then tvisibility=0
endif

return

_player_leavetrail:
 `
 rem leave trail one per tile
 if trailaction=0
  trax1=trailx#/100
  tray1=traily#/100
  traz1=trailz#/100
  trax2=playertrial(playertrailmax).x/100
  tray2=playertrial(playertrailmax).y/100
  traz2=playertrial(playertrailmax).z/100
 else
  trax1=trailx#/5
  tray1=traily#/50
  traz1=trailz#/5
  trax2=playertrial(playertrailmax).x/5
  tray2=playertrial(playertrailmax).y/50
  traz2=playertrial(playertrailmax).z/5
 endif
 if trax1<>trax2 or tray1<>tray2 or traz1<>traz2
  `
  rem deposit new trail blob
  inc playertrailmax
  if playertrailmax>100 then playertrailmax=1
  playertrial(playertrailmax).time=timer()
  playertrial(playertrailmax).x=trailx#
  playertrial(playertrailmax).y=traily#
  playertrial(playertrailmax).z=trailz#
  `
  rem if in debug, create object to illustrate blob
  if gshowdebugtextingamestate=1
   `
   rem create fresh new blob
   tobj=gamdebugobjoffset+playertrailmax
   if object exist(tobj)=0 then make object cube tobj,10 : set object collision off tobj
   position object tobj,trailx#,traily#,trailz#
   set object emissive tobj,rgb(255,200,0)
   scale object tobj,100,100,100
   `
   rem discolour rest of blobs by their age
   tai=playertrailmax
   for ta=1 to 99
    dec tai : if tai<1 then tai=100
    tobj=gamdebugobjoffset+tai
    if object exist(tobj)=1
     set object emissive tobj,rgb(255-(ta*2.5),200-(ta*2),0)
     scale object tobj,100.0-(ta*0.95),100,100.0-(ta*0.95)
    endif
   next ta
   `
  endif
  `
 endif
 `
return

`
` Entities and AI Shared Code
`

_entity_controlrecalcdist:
 ttokay=0
 if entityelement(e).active=1
  if gmultiplayergame=0 then ttokay=1
  if gmultiplayergame=1 and PlayerCanStart=1 then ttokay=1
 endif
 if ttokay=1
  distx#=mex#-entityelement(e).x
  disty#=(mey#-phyeyeheight#)-entityelement(e).y
  distz#=mez#-entityelement(e).z
  dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  diffangle#=atanfull(distx#,distz#)
  if diffangle#<0 then diffangle#=diffangle#+360
 else
  dist#=9999999
 endif
return

_entity_conescanforentity:
 `
 rem e looking for another e of type tentitytype (1=weapon)
 entityelement(e).mover.viewconeused=10
 tfounde=0
 telex#=entityelement(e).x
 teley#=entityelement(e).y+65.0
 telez#=entityelement(e).z
 for te=1 to entityelementlist
  tokay=0
  if entityelement(te).active=1
   tentid=entityelement(te).bankindex
   if tentitytype=1
    if entityprofile(tentid).isweapon<>0 then tokay=1
   endif
  endif
  if tokay=1
   tdistx#=telex#-entityelement(te).x
   tdisty#=teley#-entityelement(te).y+10.0
   tdistz#=telez#-entityelement(te).z
   tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if tdist#<1000.0
    tmpx#=entityelement(te).x
    tmpy#=entityelement(te).y+6.0
    tmpz#=entityelement(te).z
    if static raycast(telex#,teley#,telez#,tmpx#,tmpy#,tmpz#)=0
     tfounde=te : te=entityelementlist
    endif
   endif
  endif
 next te
 `
return

_entity_playerhavekey:
 rem FPGC - check if demilited key
 masterkeyname$=entityelement(e).eleprof.usekey$
 tmultikey=0
 for n=1 to len(masterkeyname$)
  if mid$(masterkeyname$,n)=";"
   tmultikey=1
  endif
 next n
 rem Is USEKEY Collected?
 tokay=0
 if tmultikey=0
  rem (SINGLE)
  for te=1 to entityelementlist
   if entityelement(te).collected=1
    if lower$(entityelement(te).eleprof.name$)=lower$(masterkeyname$)
     tokay=1 : exit
    endif
   endif
  next te
 else
  rem (MULTIPLE)
  tokay=1
  n=1
  while n<=len(masterkeyname$)
   keyname$=""
   while n<=len(masterkeyname$)
    if mid$(masterkeyname$,n)=";" then exit
    keyname$=keyname$+mid$(masterkeyname$,n)
    inc n
   endwhile
   rem look for this key
   ttokay=0
   for te=1 to entityelementlist
    if entityelement(te).collected=1
     if lower$(entityelement(te).eleprof.name$)=lower$(keyname$)
      ttokay=1 : exit
     endif
    endif
   next te
   rem any key not found means overall master key not valid
   if ttokay=0 then tokay=0
   inc n
  endwhile
 endif
return

_entity_activatename_single:
 rem Activate All Entities that share TNAME$ (from IFUSED$ field) (using tstate)
 for te=1 to entityelementlist
  if entityelement(te).active=1
   if lower$(entityelement(te).eleprof.name$)=lower$(tname$)
    ttttokay=1
    if tonlyactivateifnearautotoggle=1
     ttttokay=0
     rem only if player close enough to entity
     ttttdx#=entityelement(te).x-mex#
     ttttdy#=entityelement(te).y-mey#
     ttttdz#=entityelement(te).z-mez#
     ttttd#=sqrt(abs(ttttdx#*ttttdx#)+abs(ttttdy#*ttttdy#)+abs(ttttdz#*ttttdz#))
     if ttttd#<80 then ttttokay=1
    endif
    if ttttokay=1
     entityelement(te).activated=tstate
     entityelement(te).logiccount=0 : entityelement(te).logiccountburst=120
     entityelement(te).dormant=0
    endif
   endif
  endif
 next te
return

_entity_checkforproximityofactivatename_single:
 rem Check if close to TNAME$ (from IFUSED$ field), return foundttte of 1 if so
 foundttte=0
 for te=1 to entityelementlist
  if entityelement(te).active=1
   if lower$(entityelement(te).eleprof.name$)=lower$(tname$)
    rem only if player close enough to entity
    ttttdx#=entityelement(te).x-mex#
    ttttdy#=entityelement(te).y-mey#
    ttttdz#=entityelement(te).z-mez#
    ttttd#=sqrt(abs(ttttdx#*ttttdx#)+abs(ttttdy#*ttttdy#)+abs(ttttdz#*ttttdz#))
    if ttttd#<80 then foundttte=te
   endif
  endif
 next te
return

_entity_findname_single:
 rem return number of entity rhat is called TNAME$ (from IFUSED$ field)
 foundte=0
 for te=1 to entityelementlist
  if entityelement(te).active=1
   if lower$(entityelement(te).eleprof.name$)=lower$(tname$)
    foundte=te : exit
   endif
  endif
 next te
return

_entity_activatename:
 rem FPGC - check if demilited
 masterkeyname$=tname$
 tmultikey=0
 for ttn=1 to len(masterkeyname$)
  if mid$(masterkeyname$,ttn)=";"
   tmultikey=1
  endif
 next ttn
 if tmultikey=0
  rem (SINGLE)
  gosub _entity_activatename_single
 else
  rem (MULTIPLE)
  ttn=1
  while ttn<=len(masterkeyname$)
   tname$=""
   while ttn<=len(masterkeyname$)
    if mid$(masterkeyname$,ttn)=";" then exit
    tname$=tname$+mid$(masterkeyname$,ttn)
    inc ttn
   endwhile
   rem act on this
   gosub _entity_activatename_single
   inc ttn
  endwhile
 endif
 rem can set this flag to only activate things close to entity, but it resets to avoid bugs
 rem currently used by equipment code that calls this function
 tonlyactivateifnearautotoggle=0
return

_entity_findname:
 rem FPGC - check if demilited
 masterkeyname$=tname$
 tmultikey=0
 for ttn=1 to len(masterkeyname$)
  if mid$(masterkeyname$,ttn)=";"
   tmultikey=1
  endif
 next ttn
 if tmultikey=0
  rem (SINGLE)
  gosub _entity_findname_single
 else
  rem (MULTIPLE)
  ttn=1
  while ttn<=len(masterkeyname$)
   tname$=""
   while ttn<=len(masterkeyname$)
    if mid$(masterkeyname$,ttn)=";" then exit
    tname$=tname$+mid$(masterkeyname$,ttn)
    inc ttn
   endwhile
   rem act on this
   gosub _entity_findname_single
   inc ttn
  endwhile
 endif
return

_entity_activateallinzone:
 for te=1 to entityelementlist
  if entityelement(te).active=1 or entityelement(te).spawn.atstart=0
   tex=entityelement(te).x
   tey=entityelement(te).y
   tez=entityelement(te).z
   if tex>condx1 and tex<condx2
    if tey>condy1-5 and tey<condy2+5
     if tez<condz1 and tez>condz2
      entityelement(te).activated=tactivated
      entityelement(te).logiccount=0 : entityelement(te).logiccountburst=120
      entityelement(te).dormant=0
     endif
    endif
   endif
  endif
 next te
return


`
` AI and HUD Shared Code
`

_ai_hud_controller:
 `
 rem FPGC - 220210 - Controller
 ttmouseclick=0 : tjtx#=0 : tjty#=0
 if gxbox=1
  rem some controllers do not use TWIST like the XBOX360 (right analog)
  tjtx1#=(joystick x()/10.0)
  tjty1#=(joystick y()/10.0)
  tjtx2#=0 : tjty2#=0
  if gxboxcontrollertype=0
   tjtx2#=(joystick twist x()-32767.0)/(327.67*0.5)
   tjty2#=(joystick twist y()-32767.0)/327.67
  endif
  if gxboxcontrollertype=1
   tjtx2#=(joystick z()/10.0)
   tjty2#=(joystick twist z()-32767.0)/327.67
  endif
  tjtx#=tjtx1# : if abs(tjtx2#)>abs(tjtx1#) then tjtx#=tjtx2#
  tjty#=tjty1# : if abs(tjty2#)>abs(tjty1#) then tjty#=tjty2#
  if ttcontrolofmousepos=1
   if abs(tjtx#)>50 or abs(tjty#)>50
    tjtx#=inputmousex()+(tjtx#/10.0)
    tjty#=inputmousey()+(tjty#/10.0)
    inputpositionmouse(tjtx#,tjty#)
   endif
  endif
  if gxboxcontrollertype=0
   if joystick z()<-500 then ttmouseclick=1
  endif
  if gxboxcontrollertype=1
   if joystick fire x(5)=1 or joystick fire x(7)=1 then ttmouseclick=1
  endif
  if joystick fire a()=1 then ttmouseclick=1
  if joystick fire b()=1 then ttmouseclick=1
  if joystick fire c()=1 then ttmouseclick=1
  if joystick fire d()=1 then ttmouseclick=1
 endif
 `
return

_ai_hud_view:
 `
 rem GUI-X9 (knxrb) - Draw background without having to call the 'backdrop' command each draw.
 if guiUsed = 1
     if ingameloop=0 and sprite exist(65534)
      size sprite 65534,screen width(),screen height()
      paste sprite 65534,0,0
     endif
 endif
 `
 rem FPGC - 280610 - must be called to ensure we have latest mouse position from mouse input (movemousexy)
 if ingameloop=1 and showgamemenu=0
  rem except when in actual game where the HUD mouse would wipe out the game mouse!
 else
  inputupdatemouse()
 endif
 `
 rem FPGC - 160909 - intercept HUD creation on some occasions
 if gmultiplayergame=0
  rem FPGC - 020810 - but only for single player
  for hudid=1 to hudmax

   if hud(hudid).maintype=1 or hud(hudid).maintype=4 or hud(hudid).maintype=6 or hud(hudid).maintype=7
    if hud(hudid).typemode=1 and playerstartlives=0 then hud(hudid).hide=1
    if hud(hudid).typemode=2 and playerstartstrength=0 then hud(hudid).hide=1
   endif
  next hudid
 endif
 `
 rem Fill HUD with data based on type
 for hudid=1 to hudmax

      Rem Scene Commander, rescale sprite if it's changed

     if hud(hudid).update=1
      if sprite exist(hudid)=1
      stretch sprite hudid,hud(hudid).scalex,hud(hudid).scaley
      hud(hudid).update=0
      endif
     endif

      Rem Scene Commander updated hud alpha if changed.

     if hud(hudid).update=2
      if sprite exist(hudid)=1
      set sprite alpha hudid,hud(hudid).alpha
      hud(hudid).update=0
      endif
     endif
  `
  rem STATUS or NUMERIC
  if hud(hudid).maintype=4 or hud(hudid).maintype=6
   if hud(hudid).typemode=1 then hud(hudid).text$=str$(player(1).lives)
   if hud(hudid).typemode=2 then hud(hudid).text$=str$(player(1).health)
   if hud(hudid).typemode=3
    if weaponammoindex>0
     `if gun(gunid).settings.reloadqty>0
     if firemode(gunid,firemode).settings.reloadqty>0
      if gun(gunid).settings.weaponisammo=1
       hud(hudid).text$=str$(weaponammo(weaponammoindex))
      else
       tpool=firemode(gunid,firemode).settings.poolindex
       if tpool=0 then ammo=weaponclipammo(weaponammoindex+ammooffset) else ammo=ammopool(tpool).ammo
       hud(hudid).text$=str$(weaponammo(weaponammoindex+ammooffset))+"\"+str$(ammo)
      endif
     else
      hud(hudid).text$=""
     endif
    else
     hud(hudid).text$=""
    endif
   endif
   if hud(hudid).typemode=4
    rem frags
    if ggameobjectivetype<>1
     fr$=str$(frags(iLocalEL))
     if ggameobjectivetype=2 then fr$=fr$+"\"+str$(ggameobjectivevalue)
    else
     fr$=""
    endif
    hud(hudid).text$=fr$
   endif
   if hud(hudid).typemode=5
    rem time
    if ggameobjectivetype=3
     fr$=str$((timer()-dwStartTime)/1024)+"\"+str$(ggameobjectivevalue)
    else
     fr$=""
    endif
    hud(hudid).text$=fr$
   endif
   rem Variable System - Need this section in order to update the numeric HUD
   if hud(hudid).typemode=6 and hud(hudid).maintype=6
    rem user variable
    if hud(hudid).uservarislocal=0 then hud(hudid).text$=str$(uservars(hud(hudid).uservar).value)
    if hud(hudid).uservarislocal>0 then hud(hudid).text$=str$(aiuserlocals(hud(hudid).uservarislocal,hud(hudid).uservar).value)
   endif
  endif
  `
  rem WEAPON IMAGE
  if hud(hudid).maintype=4
   if hud(hudid).typemode=3
    if weaponammoindex>0
     if weaponhud(weaponammoindex)>0
      if hud(hudid).image<>weaponhud(weaponammoindex)
       hud(hudid).image=weaponhud(weaponammoindex)
       if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
      endif
     endif
    else
     hud(hudid).image=0
    endif
   endif
  endif
  `
  rem WEAPON ZOOMSCOPE OVERRIDE
  if hud(hudid).maintype=5
   if hud(hudid).typemode=4
    if firemode(gunid,firemode).zoomscope<>0
     hud(hudid).image=firemode(gunid,firemode).zoomscope
    else
     hud(hudid).image=internalzoomhudimage
    endif
    if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
   endif
  endif
  `
  rem ANIM
  if hud(hudid).maintype=7
   if hud(hudid).typemode=1 then tnum#=(player(1).lives/100.0)*10.0
   if hud(hudid).typemode=2 then tnum#=(player(1).health/100.0)*10.0
   tnum=tnum#
   if tnum<0 then tnum=0
   if tnum>10 then tnum=10
   hud(hudid).image=hud(hudid).baseanim+tnum
   if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
  endif
  `
  rem IPLIST BOX
  if hud(hudid).maintype=9
   if hud(hudid).hide=0
    rem refresh list auto periodically
    if refreshipaddresstimer<=0
     gosub _ai_hud_refreshiplist
     refreshipaddresstimer=200
    else
     dec refreshipaddresstimer
    endif
    rem display list
    set text size 30
    tipx=hud(hudid).posx
    tipy=hud(hudid).posy+88
    if hudiplistmax=-1
     center text screen width()/2,(screen height()/2)-10,strarr$(631)
    else
     for ty=0 to hudiplistmax
      text tipx+45,tipy+(ty*20),str$(1+ty)
      text tipx+100,tipy+(ty*20),hudiplist$(ty,0)
      center text tipx+400,tipy+(ty*20),hudiplist$(ty,1)
     next ty
    endif
   endif
  endif
  `
  rem FADEOUT control
  if hud(hudid).fadeout>0
   if hudfadeoutoneatatime=0 then hudfadeoutoneatatime=hudid
   if hudid=hudfadeoutoneatatime
    hud(hudid).fadeout=hud(hudid).fadeout-(timeelapsed#*3)
    if hud(hudid).fadeout>0
     if hud(hudid).fadeout>100
      talpha#=255.0
     else
      talpha#=(255.0/100.0)*hud(hudid).fadeout
     endif
    else
     rem hudfadeoutoneatatime allows one at a time
     hudfadeoutoneatatime=0
     hud(hudid).fadeout=0
     hud(hudid).hide=1
     talpha#=0.0
    endif
    if hud(hudid).image>0 then set sprite alpha hudid,talpha#
   else
    if hud(hudid).image>0 then set sprite alpha hudid,0
   endif
  endif
  `
 next hudid
 `
 rem Display using direct paste (fastest)
 ink rgb(255,255,255),0

for cLayer = 0 to 11 step 1 : rem V118 - 110810 - knxrb - Hud Layers
for hudid=1 to hudmax
 if hud(hudid).layer = cLayer : rem V118 - 110810 - knxrb - Hud Layers
  if hud(hudid).hide=0
   if hud(hudid).maintype=6
    rem NUMERIC
    for tt=1 to len(hud(hudid).text$)
     ttnum=-1
     if mid$(hud(hudid).text$,tt)="." then ttnum=10
     if mid$(hud(hudid).text$,tt)="\" then ttnum=11
     if ttnum=-1 then ttnum=asc(mid$(hud(hudid).text$,tt))-asc("0")
     if ttnum<>-1
      ttnumy=ttnum/4 : ttnum=ttnum-(ttnumy*4) : ttbitx#=(1.0/64.0)*16 : ttbity#=(1.0/64.0)*16
      if hud(hudid).image>0
       set sprite texture coord hudid,0,(ttbitx#*ttnum),(ttbity#*ttnumy)
       set sprite texture coord hudid,1,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)
       set sprite texture coord hudid,2,(ttbitx#*ttnum),(ttbity#*ttnumy)+ttbity#
       set sprite texture coord hudid,3,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)+ttbity#
       rem leefix - 301212 - use actual width of screen to work out spacing
       `paste sprite hudid,hud(hudid).posx+((tt-1)*12),hud(hudid).posy
       numhudadjust#=((gdisplaywidth+0.0)/1024.0)*12.0
       paste sprite hudid,hud(hudid).posx+((tt-1)*numhudadjust#),hud(hudid).posy
      endif
     endif
    next tt
   else
    rem IMAGE+TEXT
    if hud(hudid).image>0
     tokay=1
     if gmultiplayergame=1
      if hud(hudid).maintype=1 and hud(hudid).typemode>0
       if hud(hudid).typemode=1 and goneshotkills=0 then tokay=0
       if hud(hudid).typemode=2 and ggameobjectivetype<>1 then tokay=0
       if hud(hudid).typemode=5 and ggameobjectivetype<>3 then tokay=0
      endif
     endif
      tokay=1 : rem HACK!!
     if tokay=1
      if hud(hudid).fadeout>0
       tfadeout=hud(hudid).fadeout : if tfadeout>100 then tfadeout=100
       paste sprite hudid,hud(hudid).posx,hud(hudid).posy-(100-tfadeout)
      else
       paste sprite hudid,hud(hudid).posx,hud(hudid).posy
      endif
     endif
    endif
    if hud(hudid).text$<>"" and hud(hudid).image=0
     tfont$=hud(hudid).font$ : if tfont$<>"" and tfont$<>tlastfont$ then set text font tfont$ : tlastfont$=tfont$
      Rem Scene Commander, if text hud font different from rawtext, force reset.
      if tfont$<>grawtextfontlast$
      grawtextlast$=""
      endif
     tfontsize=hud(hudid).fontsize : if tfontsize<>0 and tfontsize<>tlastfontsize then set text size tfontsize : tlastfontsize=tfontsize
      Rem Scene Commander, if text hud font size different from rawtext, force reset.
      if grawtextsizelast<>tfontsize
      grawtextsizelast=-1
      endif
     center text hud(hudid).posx+(hud(hudid).sizex/2),(hud(hudid).posy+hud(hudid).sizey)+(hud(hudid).fadeout/5.0),hud(hudid).text$
    endif
   endif
  else
   if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
  endif
 endif : rem V118 - 110810 - knxrb - Hud Layers
next hudid
next cLayer : rem V118 - 110810 - knxrb - Hud Layers
 `
 rem After Image Text pasting
 for hudid=1 to hudmax
  `
  rem EDIT BOX
  if hud(hudid).maintype=8
   if hud(hudid).hide=0

    if hud(hudid).typemode<10
     hud(hudid).typemode=hud(hudid).typemode+10
    else
     if hud(hudid).typemode<20
      `
      rem show current entry
      rem V118 - 090810 - knxrb - Edited line to allow backspace key to remove characters from player
      rem name in the Name Entry box and the IP address in the IP Address entry box in arena games.
      `string$=entry$() : length=15
      string$=entry$(1) : length=15
      if len(string$)>length then string$=left$(string$,length)
      set cursor hud(hudid).posx+18,hud(hudid).posy+14
      print string$;
      if rnd(1)=1 then print "_" else print ""
      `
      rem if IP selection not valid
      if returnkey()=1
       if hud(hudid).typemode=12
        tnc=0
        for tn=1 to len(string$)
         if mid$(string$,tn)="." then inc tnc
        next tn
        if tnc=3
         rem valid IP address - use this
        else
         rem numerical selection
         tnv=val(string$)
         if hudiplistmax>=0
          if tnv>=1 and tnv<=1+hudiplistmax
           rem valid entry using ID - obtain IPaddress from list
           string$=hudiplist$(tnv-1,1)
          else
           rem not a valid entry
           string$=""
          endif
         else
          rem not a valid entry
          string$=""
         endif
        endif
       endif
       hud(hudid).text$=string$
       if len(string$)>0
        hud(hudid).typemode=hud(hudid).typemode+10
       else
        hud(hudid).typemode=hud(hudid).typemode-10
       endif
      endif
      `
     endif
    endif
   endif
  endif
  `
  rem IPADDRESS BOX
  if hud(hudid).maintype=11
   if hud(hudid).hide=0
    set text size 24
    ink rgb(8,8,8),0
    center text hud(hudid).posx,hud(hudid).posy-8,serveripaddress$
    if left$(serveripaddress$,8)<>"192.168."
     if left$(localipaddress$,8)="192.168."
      center text hud(hudid).posx,screen height()-22,"YOU CAN ALSO PLAY WITHIN YOUR NETWORK WITH IP ADDRESS "+localipaddress$
     endif
    endif
    ink rgb(255,255,255),0
   endif
  endif
  `
  rem WINNERSNAME BOX
  if hud(hudid).maintype=12
   if hud(hudid).hide=0
    set text size 24
    rem list of players
    tylinevalue=hud(hudid).posy
    if multi_match_type > 0
    center text hud(hudid).posx,tylinevalue,"Winning Team: "+characterlist$(characterchosen(winnerel))+" MVP: "+multiplayername$(mvpel)+" Kills: "+str$(frags(mvpel))
   inc tylinevalue,30
    for el=1 to multiplayermax
     if multiplayeridlink(el)<>1
      center text hud(hudid).posx,tylinevalue,characterlist$(characterchosen(el))+" Player: "+multiplayername$(el)+" Kills: "+str$(frags(el))
      inc tylinevalue,30
     endif
    next el
   else

    center text hud(hudid).posx,tylinevalue,"Winner: "+multiplayername$(winnerel)+" Kills: "+str$(frags(winnerel))
inc tylinevalue,30
    for el=1 to multiplayermax
     if multiplayeridlink(el)<>1
      center text hud(hudid).posx,tylinevalue,multiplayername$(el)+"    "+str$(frags(el))
      inc tylinevalue,30
     endif
    next el
   endif
  endif
  endif
  `
 next hudid
 `
 rem Handle HUD control
 for hudid=1 to hudmax
  `
  rem Special HUD Pointer
  if hud(hudid).maintype=2 and guiUsed = 0 and MouseSprite = -1 : rem GUI-X9 (knxrb)
   `
   rem FPGC - 220210 - Contoller
   ttmouseclick=0 : ttcontrolofmousepos=1 : gosub _ai_hud_controller
   `
   rem Can Display At Mouse Coordinate
   hud(hudid).posx=inputmousex()-((hud(hudid).width/2)*gratiox#)
   hud(hudid).posy=inputmousey()-((hud(hudid).height/2)*gratioy#)
   aihudpointerimagestore=hud(hudid).image
   rem Can Detect When Select HUD Item
   rem V118 - 110810 - knxrb - Hud Layers
   hLayer = -1
   for thudid=1 to hudmax
    rem Only selectables
    hud(thudid).highlighted=0
    if hud(thudid).maintype=3
     if hud(hudid).posx>hud(thudid).posx
      if hud(hudid).posx<hud(thudid).posx+(hud(thudid).width*gratiox#)
       if hud(hudid).posy>hud(thudid).posy
        if hud(hudid).posy<hud(thudid).posy+(hud(thudid).height*gratioy#)
         hud(thudid).highlighted=1
        endif
       endif
      endif
     endif
    endif
    rem V118 - 110810 - knxrb - Hud Layers (Save hud name of ANY hud highlighted with mouse [hudHName$])
    if control_mouseclick() = 1
    if hud(thudid).hide=0
     if hud(hudid).posx>hud(thudid).posx
      if hud(hudid).posx<hud(thudid).posx+(hud(thudid).width*gratiox#)
       if hud(hudid).posy>hud(thudid).posy
        if hud(hudid).posy<hud(thudid).posy+(hud(thudid).height*gratioy#)
         if hud(thudid).layer > hLayer
          hudHName$ = hud(thudid).name$
          hLayer = hud(thudid).layer
         endif
        endif
       endif
      endif
     endif
    endif
    endif

    if hud(thudid).hide=0
     if hud(hudid).posx>hud(thudid).posx
      if hud(hudid).posx<hud(thudid).posx+(hud(thudid).width*gratiox#)
       if hud(hudid).posy>hud(thudid).posy
        if hud(hudid).posy<hud(thudid).posy+(hud(thudid).height*gratioy#)
         if hud(thudid).layer > hLayer
          hudNName$ = hud(thudid).name$
          hLayer = hud(thudid).layer
         endif
        endif
       endif
      endif
     endif
    endif
   next thudid
   `
   if control_mouseclick()<>0
    for thudid=1 to hudmax
     if hud(thudid).highlighted=1
      hudselectionmade=hud(thudid).typemode
     endif
    next thudid
   endif
  endif
  `
  rem Delayed display, then hide
  if hud(hudid).hidedelay>0
   hud(hudid).hidedelay=hud(hudid).hidedelay-timeelapsed#
   if hud(hudid).hidedelay<=0 then hud(hudid).hidedelay=0 : hud(hudid).hide=1
  endif
  `
  rem Radar Blip (v1.1)
  if hud(hudid).maintype=4 and hud(hudid).typemode=11
   `
   rem Mimic radar blip - Scene Commander legacy radar
   for e=1 to entityelementlist
    if entityelement(e).health>0
     tentid=entityelement(e).bankindex
     if entityprofile(tentid).ischaracter=1
      fundx#=entityelement(e).x-camera position x()
      fundy#=camera position z()-entityelement(e).z
      funangle#=atanfull(fundy#,fundx#)
      rrr#=funangle#-camera angle y()
      if hud(hudid).image>0
       paste sprite hudid,hud(hudid).posx-8+(cos(rrr#)*40),hud(hudid).posy-8+(sin(rrr#)*40)
      endif
     endif
    endif
   next e
   `
  endif
  `
 next hudid

rem Compass - Scene commander, original code used with permission (knxrb).

if compassOn = 1
   if madeCompass = 0
      makecompass()
      madeCompass = 1
   endif

 if compassSpin = 1
      if sprite exist(compassobject)=1
         rotate sprite compassobject,wrapvalue(-camera angle y())
      endif
   endif
   if needleSpin = 1
      if sprite exist(needleobject)=1
         rotate sprite needleobject,wrapvalue(camera angle y())
      endif
   endif
   if sprite exist(compassobject)=1

      paste sprite compassobject,compassX,compassY
   endif
   if sprite exist(needleobject)=1

      paste sprite needleobject,compassX,compassY
   endif

endif

 rem Radar Blip Dark AI - Scene commander

rem Scene Commander, if radar used, and not made, make it.

if maderadar=0 and darkradar<>0
makeradar()
maderadar=1
endif

 rem hide radar if it exists but is off
 if darkradar=0 and sprite exist(radarobject)=1
 hide sprite radarobject
 endif

rem calculate player level for character radar cull
 if darkradar<>0 and sprite exist(radarobject)=1 and object exist(physicsplayerborble)
         playerlevel=int(object position y(physicsplayerborble))/100
          if playerlevel<0 then playerlevel=0
          if playerlevel>19 then playerlevel=19

          show sprite radarobject
          paste sprite radarobject,radarx,radary


          for e=1 to entityelementlist

          if entityelement(e).objectiveradarrange=0 then entityelement(e).objectiveradarrange=70

         if entityelement(e).health>0
         tentid=entityelement(e).bankindex

            if entityprofile(tentid).ischaracter=1 and entityelement(e).beenkilled=0 and (entityelement(e).active<>0 and entityelement(e).spawn.leader=0) and entityelement(e).beenkilled=0
               rem calculate entity level for character radar cull
            entitylevel=int(entityelement(e).y)/100
            if entitylevel<0 then entitylevel=0
            if entitylevel>19 then entitylevel=19
            fundx#=entityelement(e).x-camera position x()
            fundy#=camera position z()-entityelement(e).z
            funangle#=atanfull(fundy#,fundx#)
            rrr#=funangle#-camera angle y()
               if playerlevel=entitylevel
               entobj=entityelement(e).obj
                  if entobj>0 and physicsplayerborble>0

                  rem calculate radar distance
                  tcamx#=object position x(physicsplayerborble)
                  tcamy#=object position y(physicsplayerborble)
                  tcamz#=object position z(physicsplayerborble)

                  tdx#=entityelement(e).x-tcamx#
                  tdy#=entityelement(e).y+(object size(entobj)/2)-tcamy#
                  tdz#=entityelement(e).z-tcamz#
                  howfar=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
                  entityelement(e).radardistance=howfar
                  howfar=int(howfar/12)

                  beenonradar=0

                     if ai entity exist(entobj)=1

                     for onradar=1 to 20

                     entityelement(e).onradar=0
                     if entityelement(e).darkai.team=onradar and sprite exist(onradar+radarobject) and howfar<=radarrange
                     offset sprite onradar+radarobject,sprite width(onradar+radarobject)/2,sprite height(onradar+radarobject)/2

                     if rotateblip=1 then rotate sprite onradar+radarobject,wrapvalue(object angle y(entobj))

                     paste sprite onradar+radarobject,radarx-8+(cos(rrr#)*howfar),radary-8+(sin(rrr#)*howfar)
                     entityelement(e).onradar=1

                     beenonradar=1

                     endif

                     next onradar

                     endif

                     if sprite exist(666671) and howfar<=radarrange and beenonradar=0
                     offset sprite 666671,sprite width(666671)/2,sprite height(666671)/2

                      if rotateblip=1 then rotate sprite 666671,wrapvalue(object angle y(entobj))

                     paste sprite 666671,radarx-8+(cos(rrr#)*howfar),radary-8+(sin(rrr#)*howfar)

                     endif


                  endif

               endif

            endif

         rem Check for objective display

         if entityelement(e).isanobjective<>0
         istheobjective=entityelement(e).isanobjective
         displayobjective()
         endif

    endif
   next e
   `



  endif


rem Scene Commander display armour value

if armouron<>0

a$=str$(armour)

specialpaste(armx,army,a$)

rem Scene Commander display air value

endif

if airmax<>0 and airleft>airmax then airleft=airmax

if airon<>0 or noairon<>0 or alwaysshowair<>0

a$=str$(airleft)

specialpaste(airx,airy,a$)

endif


 `
 rem Draw Raw Text to screen HUD
 if grawtext$<>""
  if grawtextfont$<>grawtextfontlast$
   grawtextfontlast$=grawtextfont$
   set text font grawtextfont$
   Rem Scene Commander, if not same text font as hudtext force reset
   if tfontlast$<>grawtextfont$
      tfontlast$=""
      endif
   endif
  if grawtextsize<>grawtextsizelast
   grawtextsizelast=grawtextsize
   set text size grawtextsize
   Rem Scene Commander, if not same text size force reset hudtext size
   if grawtextsize<>tfontsize
   tlastfontsize=-1
   endif
   endif
  grawtextx#=screen width() : grawtextx#=(grawtextx#/100)*grawtextx
  grawtexty#=screen height() : grawtexty#=(grawtexty#/100)*grawtexty
  `
  rem FPGC - 131009 - added black border to improve visual of text
  ink 0,0
  for bordery=-2 to 2
   for borderx=-2 to 2
    center text grawtextx#+borderx,grawtexty#+bordery,grawtext$
   next borderx
  next bordery
  ink rgb(grawtextr/2,grawtextg/2,grawtextb/2),0
  for bordery=-1 to 1
   for borderx=-1 to 1
    center text grawtextx#+borderx,grawtexty#+bordery,grawtext$
   next borderx
  next bordery
  ink rgb(grawtextr,grawtextg,grawtextb),0
  center text grawtextx#,grawtexty#,grawtext$
  `
  rem Global eventual reset of RAWTEXT
  if grawtextcount>0
   grawtextcount=grawtextcount-(timeelapsed#*5)
   if grawtextcount<=0
    grawtextcount=0
    grawtext$=""
   endif
  endif
  `
 endif
 `
return

_ai_hud_refreshiplist:
 `
 rem update list from file(for now)
 gosub _ai_gamelist_refresh
 `
return

_ai_gamelist_add:
 `
 rem server adds to gamelist, uses addip$ and addname$
 action$="action=add&"
 serverid$="server_id="+guniquegamecode$+"&"
 ip$="ip="+addip$+"&" : ipfromadd$=ip$
 if multi_match_type = 0 then typeofmatch$="DM"
 if multi_match_type = 1 then typeofmatch$="TDM"
 if multi_match_type = 2 then typeofmatch$="OBJ"
 title$="title="+serverhostname+" "+typeofmatch$+"&"
 title$="title="+addname$+"&"
 data$="data=none"
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  idfromadd$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ip$+title$+data$)
  if val(idfromadd$)=0 then tryagain=1
  dec tryattempts
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_delete:
 `
 rem server deletes from gamelist
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  action$="action=delete&"
  serverid$="server_id="+guniquegamecode$+"&"
  return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ipfromadd$+"id="+idfromadd$)
  if return$="1" then serverhasremoveditselffromonlinelist=1
  if return$<>"1" then tryagain=1
  dec tryattempts
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_keepalive:
 `
 rem send this to keep game item listed in database
 HTTP CONNECT strarr$(619)
 action$="action=keepalive&"
 serverid$="server_id="+guniquegamecode$+"&"
 return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ipfromadd$+"id="+idfromadd$)
 HTTP DISCONNECT
 `
return

_ai_gamelist_refresh:
 `
 rem client views gamelist choices, fill array
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  action$="action=list&"
  serverid$="server_id="+guniquegamecode$
  return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$)
  if return$<>""
   c=1 : hudiplistmax=-1 : fromc=0
   repeat
    if asc(mid$(return$,c))=10
     if fromc>0
      thudiplist$=left$(return$,c-1)
      thudiplist$=right$(thudiplist$,len(thudiplist$)-fromc)
     else
      thudiplist$=left$(return$,c-1)
     endif
     for c1=1 to len(thudiplist$)
      if mid$(thudiplist$,c1)="," then exit
     next c1
     thudiplist1$=left$(thudiplist$,c1-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c1))
     for c2=1 to len(thudiplist$)
      if mid$(thudiplist$,c2)="," then exit
     next c2
     thudiplist2$=left$(thudiplist$,c2-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c2))
     for c3=1 to len(thudiplist$)
      if mid$(thudiplist$,c3)="," then exit
     next c3
     thudiplist3$=left$(thudiplist$,c3-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c3))
     for c4=1 to len(thudiplist$)
      if mid$(thudiplist$,c4)="," then exit
     next c4
     thudiplist4$=left$(thudiplist$,c4-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c4))
`     if thudiplist1$=thisgamecode$
      inc hudiplistmax
      hudiplist$(hudiplistmax,0)=thudiplist4$
      hudiplist$(hudiplistmax,1)=thudiplist3$
 `    endif
     fromc=c+1
    else
     rem skip char, finding end
    endif
    inc c
   until c>len(return$)
  else
   tryagain=1
   dec tryattempts
  endif
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_checkforfirewall:
 `
 rem FSCV105RC2 - server has a script to give is the real machine IP
 `http://www.fpscreator.com/gamehost/whatismyip.php
 serveripaddress$=""
 `
 rem added for 090307
 rem check three times to connect to FPSC gamelist server
 HTTP CONNECT strarr$(619)
 tryattempts=3
 repeat
  action$=""
  return$=HTTP REQUEST DATA("POST", "gamehost/whatismyip.php",action$)
  errorcodestring$=return$
  return$=lower$(return$)
  checkfor$="error code"
  if return$<>""
   for n=0 to len(return$)-len(checkfor$)-1
    if left$(right$(return$,(len(return$)-n)),len(checkfor$))=checkfor$
     rem error code returned when attempted to access HTTP command
     errorcode$=errorcodestring$
    endif
   next n
   if errorcode$="" and len(return$)>0
    rem FPSCV105RC2 - 100307 - puts the actual HOSTable IP address in serveripaddress$
    serveripaddress$=return$
    tryattempts=0
   endif
  endif
  dec tryattempts
 until tryattempts<=0 or len(errorcode$)=0
 HTTP DISCONNECT
 `
 rem if fail, report and exit
 if errorcode$<>""
  s$="Failed to establish a connection with the gamelist server. "
  s$=s$+"This could be caused by loss of internet connectivity, or the presence of a firewall."
  exit prompt s$,errorcode$
  end
 endif
 `
return

_ai_hud_extra:

rem FPGC - 150310 - default HUD additions
if gcontrollerhint=1 and gxbox<>0
 `
 rem Specify HUD
 workhudmake$="display"
 workhudname$="controllerhelp"
 workhudtype=0 : rem always
 workhudsizex=0
 workhudsizey=0
 workhudsizez=0
 workhudred=255
 workhudgreen=255
 workhudblue=255
 workhudimagefile$="gamecore\huds\controller\base.png"
 addfiletocollection(workhudimagefile$)
 timgvalue=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimage=timgvalue
 workhudfont$=""
 workhudsize=0
 workhudtext$=""
 workhudhide=0
 workhudx=gdisplaywidth-(image width(workhudimage)/2)
 workhudy=gdisplayheight-(image height(workhudimage)/2)
 `
 rem Add HUD (controller base image) to game
 gosub _ai_hud_add
 `
 rem Add HUD (controller OVERLAY) to game
 workhudname$="controllerhelpoverlay"
 workhudimagefile$="gamecore\huds\controller\base.png" : addfiletocollection(workhudimagefile$)
 workhudimage=loadinternalimagecompressquality(workhudimagefile$,5,1)
 gosub _ai_hud_add
 gcontrollerhinthudid=hudid
 gcontrollerhintbase=workhudimage
 `
 rem load in extra images for the controller hints
 workhudimagefile$="gamecore\huds\controller\use.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonuse=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\run.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonrun=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\duck.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonduck=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\jump.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonjump=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\walk1.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonwalk1=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\walk2.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonwalk2=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\walk3.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonwalk3=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\walk4.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonwalk4=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\look1.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonlook1=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\look2.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonlook2=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\look3.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonlook3=loadinternalimagecompressquality(workhudimagefile$,5,1)
 workhudimagefile$="gamecore\huds\controller\look4.png" : addfiletocollection(workhudimagefile$)
 gcontrollerhintbuttonlook4=loadinternalimagecompressquality(workhudimagefile$,5,1)
 `
endif

return

_ai_hud_add:

rem HUD Types based on name
workhudmake$=lower$(workhudmake$)

rem Existing HUD
if workhudname$>""
 for thudi=1 to hudmax
  if lower$(workhudname$)=lower$(hud(thudi).name$)
   hudid=thudi : exit
  endif
 next thudi
else
 thudi=hudmax+1
endif
`
rem go and add
if thudi>hudmax
 `
 rem New HUD
 inc hudmax : hudid=hudmax
 dim hud(hudmax) as hudtype

   rem Scene Commander scales default
   hud(hudid).scalex=100
   hud(hudid).scaley=100
   hud(hudid).alpha=255
 rem HUD Type
 hud(hudid).maintype=0
 if workhudmake$="display"
  hud(hudid).maintype=1
  hud(hudid).typemode=workhudtype : rem 0always,X-objectivetype(mutliplayer)
 endif
 rem V118 - 110810 - knxrb - Hud Layers (Force cursor/pointer above all other hud layers [layer 11], added bit after colon only.)
 if workhudmake$="pointer" then hud(hudid).maintype=2 : hud(hudid).layer = 11
 if workhudmake$="button"
  hud(hudid).maintype=3
  hud(hudid).typemode=workhudtype : rem 1new,2load,3save,4continue,5exit
 endif
 if workhudmake$="status"
  hud(hudid).maintype=4
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,4frags,5time,11blip
 endif
 if workhudmake$="internal"
  hud(hudid).maintype=5
  hud(hudid).typemode=workhudtype : rem 1loader,2eyehud,3fader,4zoom
  if workhudtype=1 then internalloaderhud=hudid
  if workhudtype=2 then internaleyehud=hudid
  if workhudtype=3 then internalfaderhud=hudid
  if workhudtype=4 then internalzoomhud=hudid : internalzoomhudimage=workhudimage
 endif
 if workhudmake$="numeric"
  hud(hudid).maintype=6
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,11blip
 endif
 if workhudmake$="anim"
  hud(hudid).maintype=7
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,11blip
  hud(hudid).baseanim=workhudimage
 endif
 if workhudmake$="edit"
  hud(hudid).maintype=8
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="list"
  hud(hudid).maintype=9
  hud(hudid).typemode=workhudtype
  refreshipaddresstimer=0
 endif
 if workhudmake$="ipaddress"
  hud(hudid).maintype=11
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="winnersname"
  hud(hudid).maintype=12
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="textprompt"
  hud(hudid).maintype=21
  hud(hudid).typemode=0
 endif
 `
 rem HUD Data
 hud(hudid).name$=workhudname$
 hud(hudid).posx=workhudx
 hud(hudid).posy=workhudy
 hud(hudid).posz=workhudz
 hud(hudid).sizex=workhudsizex
 hud(hudid).sizey=workhudsizey
 hud(hudid).sizez=workhudsizez
 hud(hudid).red=workhudred
 hud(hudid).green=workhudgreen
 hud(hudid).blue=workhudblue
 hud(hudid).image=workhudimage
 hud(hudid).imagefile$=workhudimagefile$ : rem FPGC - 031109 - needed to reload HUD images
 hud(hudid).font$=workhudfont$
 hud(hudid).fontsize=workhudsize
 hud(hudid).text$=workhudtext$
 hud(hudid).hide=workhudhide
 hud(hudid).hidedelay=0
 hud(hudid).highlighted=0
 rem Gotta set the user variable index that we want for numeric variables
 hud(hudid).uservar=workhuduservar
 hud(hudid).uservarislocal=workhuduservarlocal
 `
 rem Calculate bounds of HUD (for selectability)
 if workhudsizex>0
  hud(hudid).width=workhudsizex
 else
  if hud(hudid).image>0
   hud(hudid).width=image width(hud(hudid).image)
  else
   if hud(hudid).font$<>"" then set text font hud(hudid).font$
   if hud(hudid).fontsize<>0 then set text size hud(hudid).fontsize
   hud(hudid).width=text width(hud(hudid).text$)
  endif
 endif
 if workhudsizey>0
  hud(hudid).height=workhudsizey
 else
  if hud(hudid).image>0
   hud(hudid).height=image height(hud(hudid).image)
  else
   if hud(hudid).font$<>"" then set text font hud(hudid).font$
   if hud(hudid).fontsize<>0 then set text size hud(hudid).fontsize
   hud(hudid).height=text height(hud(hudid).text$)
  endif
 endif
 `
 rem Offset position with size if image
 if hud(hudid).image>0
  hud(hudid).posx=hud(hudid).posx-((hud(hudid).width/2)*gratiox#)
  hud(hudid).posy=hud(hudid).posy-((hud(hudid).height/2)*gratioy#)
 endif
 `
 rem Update HUD sprites
 gosub _ai_hud_update
 `
endif

return

_ai_hud_update:
 `
 rem HUD Sprites
 set sprite 1,0,1
 sprite 1,-10000,-10000,1
 for tthudid=1 to hudmax
  if hud(tthudid).image>0
   sprite tthudid,-10000,-10000,hud(tthudid).image
   if hud(tthudid).sizex>0
    size sprite tthudid,hud(tthudid).sizex*gratiox#,hud(tthudid).sizey*gratioy#
   else
    size sprite tthudid,hud(tthudid).width*gratiox#,hud(tthudid).height*gratioy#
   endif
   set sprite diffuse tthudid,hud(tthudid).red,hud(tthudid).green,hud(tthudid).blue
   if hud(tthudid).fadeout>0
    rem else where
   else
    set sprite alpha tthudid,255
   endif
  endif
 next tthudid
 `
return

rem
rem VERSIONS (Full)
rem

_version_commandlineprompt:
 `
 rem Triggers use of file map messaging
 if lower$(cl$())="-t"
  gtestgamemodefromeditor=1
 endif
 `
return

_version_endofinit:

rem Ensure full game flag never set!!
`grealgameviewstate=0 `demo versions with noEXEsave do this

 rem Game Engine Demo would send this into filemap of OS
` filemapname$="FPSCComm"
` write filemap value filemapname$,42
` write filemap string filemapname$,"demo version"

return

_version_splashtext:
 `
 rem Update Splash Text
 open file map 2, "FPSSPLASH"
 set file map dword 2, 4, 1
 set file map string$ 2, 1000, strarr$(392)
 set file map dword 2, 8, 1
 wait for file map event 2
 close file map 2
 `
return

_version_onscreenlogos:
return

_version_permittestgame:
 `
 rem Map Editor launches test game
 open file map 1,"FPSEXCHANGE"
 set file map string$ 1, 1000, "FPSC-Game.exe"
 set file map string$ 1, 1256, "-t"
 set file map dword 1, 920, 1
 wait for file map event 1
 close file map 1
 `
return

_version_resourcewarning:
return

_version_universe_saveELEandLGT:
 `
 rem FPGC - 111209 - right after lightmapping build so know if exited that loop
 debugviewtext(278,"Saving ELE and LGT files..")
 `
 rem Save newer elements list (that includes scene dynamic entities)
 rem V106 also contains light indexes saved when universe is constructed
 elementsfilename$="levelbank\testlevel\universe.ele" : gosub _entity_saveelementsdata
 `
 rem Save LGT lighting data
 filename$="levelbank\testlevel\universe.lgt"
 if file exist(filename$)=1 then delete file filename$
 open to write 1,filename$
  tinfinimax=array count(infinilight())
  write file 1,tinfinimax
  for i=0 to tinfinimax
   write file 1,infinilight(i).used
   write file 1,infinilight(i).type
   write float 1,infinilight(i).x
   write float 1,infinilight(i).y
   write float 1,infinilight(i).z
   write float 1,infinilight(i).range
   write file 1,infinilight(i).id
   write float 1,infinilight(i).dist
   write file 1,infinilight(i).colrgb.r
   write file 1,infinilight(i).colrgb.g
   write file 1,infinilight(i).colrgb.b
   write file 1,infinilight(i).islit
  next i
 close file 1
 `
return

_version_universe_construct:
  `
  rem Save lighting data
  gosub _version_universe_saveELEandLGT
  `
  rem New entities may have been aded, resave map.ent for transfer to level area
  gosub _entity_savebank
  `
  rem Copy over key map data files this level required
  for tkey=1 to 4
   if tkey=1 then tfile$="levelbank\testlevel\header.dat" : tfile2$="mapbank\testmap\header.dat"
   if tkey=2 then tfile$="levelbank\testlevel\map.fpmb" : tfile2$="mapbank\testmap\map.fpmb"
   if tkey=3 then tfile$="levelbank\testlevel\map.ent" : tfile2$="mapbank\testmap\map.ent"
   if tkey=4 then tfile$="levelbank\testlevel\map.way" : tfile2$="mapbank\testmap\map.way"
   if file exist(tfile$)=1 then delete file tfile$
   copy file tfile2$,tfile$
  next tkey
  `
  rem Save ALL data in leveltest under a level file FPL (for use to extract new levels to play)
  gosub _mapfile_save_fpl
  `
return

_version_buildgame:
 `
 rem Is called when BUILD GAME selected from file menu
 gosub _interface_openbuildgame : gosub _interface_handlebuildgame :  gosub _interface_closebuildgame
 `
return

_version_main_game_buildexe:

rem Despot file collection
if file exist("..\buildfiles.ini")=1 then delete file "..\buildfiles.ini"
save array "..\buildfiles.ini",filecollection$()

rem Store root folder
rootpath$=get dir$()

rem Name without EXE
exename$=gbuildname$
if lower$(right$(exename$,4))=".exe"
 exename$=left$(exename$,len(exename$)-4)
endif

rem Path to EXE
if mid$(gbuildpath$,2)=":"
 exepath$=gbuildpath$
else
 exepath$=exedir$
endif
if right$(exepath$,1)<>"\" then exepath$=exepath$+"\"
if path exist(exepath$)=0 then exepath$=rootpath$+"\..\MyGames\"

rem if gimageblockmode=0 then GUI_CITF(exepath$, exename$) : rem GUI-X9 (knxrb)

rem Despot file collection
if file exist("..\buildfiles.ini")=1 then delete file "..\buildfiles.ini"
save array "..\buildfiles.ini",filecollection$()

rem Store root folder
rootpath$=get dir$()

rem FPSCV104RC7 - user can delete the MyGames folder?
if path exist(exepath$)=0
 set dir rootpath$ : set dir ".."
 make directory "MyGames"
endif

rem Create game folder
set dir exepath$
make directory exename$
set dir exename$
make directory "Files"
set dir "Files"

rem FPSCV10X, ensure gamesaves files are removed (if any)
if path exist("gamesaves")=1
 set dir "gamesaves"
 perform checklist for files
 for c=1 to checklist quantity()
  tfile$=checklist string$(c)
  if len(tfile$)>2
   if file exist(tfile$)=1 then delete file tfile$
  endif
 next c
 set dir ".."
endif

rem V109 BETA4 - 230408 - delete entries that already exist in IMAGEBLOCK
if gimageblockmode=1
 perform checklist for imageblock files
 filesmax=array count(filecollection$())
 for fileindex=0 to filesmax
  srcstring$=lower$(filecollection$(fileindex))
  if len(srcstring$)>0
   rem and only if NOT in effectbank (some shaders NEED external image files)
   if left$(srcstring$,11)<>"effectbank\"
    rem scan imageblock
    for c=1 to checklist quantity()
     imageblockfile$=lower$(checklist string$(c))
     if imageblockfile$=srcstring$
      filecollection$(fileindex)=""
      c=checklist quantity()+1
     endif
    next c
   endif
  endif
 next fileindex
 addfiletocollection("imageblock.bin")
endif

rem V109 BETA5 - 250408 - build image block CLOSE
if gcompilestandaloneexe=1 and gimageblockmode=1 then close imageblock

rem ensure file path exists (by creating folders)
filesmax=array count(filecollection$())
for fileindex=0 to filesmax
 olddir$=get dir$()
 src$=filecollection$(fileindex)
 srcstring$=src$
 while len(srcstring$)>0
  for c=1 to len(srcstring$)
   if mid$(srcstring$,c)="\" or mid$(srcstring$,c)="/"
    chunk$=left$(srcstring$,c-1)
    if len(chunk$)>0
     if path exist(chunk$)=0 then make directory chunk$
     set dir chunk$
    endif
    srcstring$=right$(srcstring$,len(srcstring$)-c)
    exit
   endif
  next c
  if c>len(srcstring$) then exit
 endwhile
 set dir olddir$
next fileindex

rem v107 - 070807 - also detect for any HUD.X copies, and also copy texture files in its folder
set dir rootpath$
for fileindex=0 to filesmax
 src$=filecollection$(fileindex)
 if right$(lower$(src$),6)="\hud.x"
  rem find all files in the folder that shares this file and add to collection
  addallfilestocollection(left$(src$,len(src$)-5))
 endif
next fileindex
filesmax=array count(filecollection$())

rem copy file collection to exe folder
set dir rootpath$
debugviewtext(-1,strarr$(393))
for fileindex=0 to filesmax
 src$=filecollection$(fileindex)
 dest$=exepath$+exename$+"\Files\"+src$
 if file exist(dest$)=1 then delete file dest$
 copy file src$,dest$
next fileindex

rem copy game engine and rename it
set dir rootpath$ : set dir ".."
dest$=exepath$+exename$+"\"+exename$+".exe"
if file exist(dest$)=1 then delete file dest$
copy file "FPSC-Game.exe",dest$

rem create a setup.ini file here reflecting game
dim setuparr$(999)
setupfile$=exepath$+exename$+"\setup.ini" : i=0
setuparr$(i)="gametype=0" : inc i
setuparr$(i)=" serverhostname= FPSC Arena" : inc i
for num=1 to 30
setuparr$(i)="taunt"+str$(num)+"="+str$(listkey(num)) : inc i
next num
setuparr$(i)="[GAMERUN]" : inc i
setuparr$(i)="realgameview=1" : inc i
setuparr$(i)="dynamiclighting="+str$(gdynamiclightingstate) : inc i
setuparr$(i)="dynamicshadows="+str$(gdynamicshadowsstate) : inc i
setuparr$(i)="useeffects="+str$( guseeffectstate ) : inc i
setuparr$(i)="useeffectsonguns="+str$( guseeffectongunsstate ) : inc i
setuparr$(i)="useeffectsonscene="+str$( guseeffectonscenesstate ) : inc i
setuparr$(i)="useeffectsonentities="+str$( guseeffectonentitiesstate ) : inc i
setuparr$(i)="dividetexturesize="+str$( gdividetexturesize ) : inc i
setuparr$(i)="controllerhint="+str$( gcontrollerhint ) : inc i
rem FPGC - 070411 - we can force the standalone games to use VRMODE when using VRQUEST
if fpgcgenre=0
 setuparr$(i)="vrmode=6" : inc i
 setuparr$(i)="vrmodemag=100" : inc i
else
 setuparr$(i)="vrmode="+str$( gvrmode ) : inc i
 setuparr$(i)="vrmodemag="+str$( gvrmodemag ) : inc i
endif
setuparr$(i)="mousesensitivity="+str$( gmousesensitivity ) : inc i
setuparr$(i)="producelogfiles="+str$( gproducelogfiles ) : inc i
setuparr$(i)="hsrmode="+str$( ghsrmode ) : inc i
setuparr$(i)="aspectratio="+str$( gaspectratio ) : inc i
setuparr$(i)="newblossershaders="+str$( gnewblossershaders ) : inc i
setuparr$(i)="postprocessing="+str$( gpostprocessing ) : inc i
setuparr$(i)="showaioutlines="+str$( gshowaioutlines ) : inc i
setuparr$(i)="airadius="+str$( gairadius ) : inc i
setuparr$(i)="disablepeeking="+str$( gdisablepeeking ) : inc i
setuparr$(i)="disableparticles="+str$( gparticlesnotused ) : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEMULTIPLAYER]" : inc i
setuparr$(i)="multiplayergame="+str$(gmultiplayergame) : inc i
setuparr$(i)="gameobjectivetype="+str$(ggameobjectivetype) : inc i
setuparr$(i)="gameobjectivevalue="+str$(ggameobjectivevalue) : inc i
setuparr$(i)="oneshotkills="+str$(goneshotkills) : inc i
setuparr$(i)="maxplayers="+str$(numberofplayers) : inc i
setuparr$(i)="spawnrandom="+str$(gspawnrandom) : inc i
setuparr$(i)="uniquegamecode="+guniquegamecode$ : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEDEBUG]" : inc i
setuparr$(i)="usesky=1" : inc i
setuparr$(i)="usefloor="+str$( gusefloorstate ) : inc i
setuparr$(i)="useenvsounds=1" : inc i
setuparr$(i)="useweapons=1" : inc i
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEPROFILE]" : inc i
setuparr$(i)="title="+titlefpi$ : inc i
setuparr$(i)="global="+setupfpi$ : inc i
setuparr$(i)="gamewon="+gamewonfpi$ : inc i
setuparr$(i)="gameover="+gameoverfpi$ : inc i
for num=1 to 11
 setuparr$(i)="key"+str$(num)+"="+str$(listkey(num)) : inc i
next num
for num=1 to 30
 setuparr$(i)="taunt"+str$(num)+"="+str$(listkey(num)) : inc i
next num
for num=1 to 9
 setuparr$(i)="slot"+str$(num)+"="+gunslots$(num) : inc i
next num
setuparr$(i)="levelmax="+str$(glevelmax) : inc i
for num=1 to glevelmax
 setuparr$(i)="levelfpm"+str$(num)+"="+level$(num).fpm$ : inc i
 setuparr$(i)="levelfpi"+str$(num)+"="+level$(num).fpi$ : inc i
next num
if file exist(setupfile$)=1 then delete file setupfile$
save array setupfile$,setuparr$()
undim setuparr$()
`
rem Also save out the localisation ptr file
dim setuparr$(2)
setupfile$=exepath$+exename$+"\userdetails.ini"
setuparr$(0)="[LOCALIZATION]"
setuparr$(1)="language="+language$
save array setupfile$,setuparr$()
undim setuparr$()
`
rem FPGC - also account for missing folders/files required by ZERO-GENRE
if fpgcgenre=0
 rem directory tells EXE it is a non-shooter
 set dir exepath$ : set dir exename$ : set dir "Files\gamecore\"
 if path exist("equipment")=0 then make directory "equipment"
endif
if fpgcgenre=1
 rem directory tells EXE it is a shooter
 set dir exepath$ : set dir exename$ : set dir "Files\gamecore\"
 if path exist("guns")=0 then make directory "guns"
endif
`
rem Cannot depend on FPG being preserved, find from file collection
currentFPG$="mygame"
for fileindex=0 to filesmax
 src$=filecollection$(fileindex)
 if right$(lower$(src$),14)="\titlepage.fpi"
  tsrc$=left$(src$,len(src$)-14)
  for nn=len(tsrc$) to 1 step -1
   if mid$(tsrc$,nn)="\" or mid$(tsrc$,nn)="/"
    currentFPG$=right$(tsrc$,len(tsrc$)-nn)
    nn=0 : exit
   endif
  next nn
 endif
next fileindex
`
rem GUI-X9 - knxrb
rem set dir exepath$ : set dir ".."
rem CheckBuildScripts(exepath$+exename$,language$)
`
rem Restore directory
set dir rootpath$

return

rem
rem ODE specific code
rem

_ode_init:

rem start ode
ode start : rem set to regular world stepping
ode set world gravity physicsgravx#,physicsgravy#,physicsgravz#
rem FPGC - 210210 - now set gravity after warm up to prevent objects falling down before their time (maybe?)
`ode set world gravity 0,0,0

rem FPGC - 210210 - made ragdolls mode solid by decreasing CFM (need this for ragdolls onyl)
`ode set world step 0.05 : rem needed for accuracy (only used in 2005 version of ODE)
`softness#=2.5 : rem soft as the player (was 2.0)
`ode set world erp (0.2)*softness#
`ode set world cfm (10^-5)*softness#
rem 030707 - made ragdolls mode solid by decreasing CFM (need this for ragdolls onyl)
ode set world cfm 0.000002 : rem this is good for ragdolls who hold their fixed joints
ode set world erp 0.2 : rem 0.1 soft for ragdolls and crates

rem make physics universe
if object exist(physicsuniverseobj)=1 then delete object physicsuniverseobj
phyunimesh$="levelbank\testlevel\universephy.dbo"
if file exist(phyunimesh$)=0
 load object "levelbank\testlevel\universe.dbo",physicsuniverseobj
 make mesh from object physicsuniverseobj,physicsuniverseobj
 convert mesh to vertexdata physicsuniverseobj
 delete object physicsuniverseobj
 make object physicsuniverseobj,physicsuniverseobj,0
 delete mesh physicsuniverseobj
 rem FPSCV104RC9-accelerate loading
 save object phyunimesh$,physicsuniverseobj
else
 load object phyunimesh$,physicsuniverseobj
endif
debugviewtext(321,"Created static geometry for physics universe")
ode create static triangle mesh physicsuniverseobj
delete object physicsuniverseobj
if physicsproto=1
 load static objects "levelbank\testlevel\universe.dbo",0
endif
debugviewtext(322,"Submitted geometry to physics engine")

rem create entity assignments
for e=1 to entityelementmax
 `
 rem Sentinel disables physics for common non-physics items (non-multiplayer)
 entid=entityelement(e).bankindex
 if physicson>0 and gmultiplayergame=0
  rem and promotes others to specific types (1-normal,2-ignorestatic,3-becomestatic)
  rem Weapons, Ammo, Non-Objects, Immobile
  if entityprofile(entid).isweapon<>0 or entityprofile(entid).isammo<>0
   entityelement(e).eleprof.physics=0
  else
   if entityprofile(entid).ischaracter=1
    entityelement(e).eleprof.physics=2
   endif
   if entityelement(e).eleprof.isimmobile=1
    rem FPGC - 290710 - contravertial change, if using PIVOT, physics cannot reflect this, so switch off physics
    if entityprofile(entid).fixnewy<>0
     entityelement(e).eleprof.physics=0
    else
     entityelement(e).eleprof.physics=3
    endif
   endif
  endif
  if entityelement(e).obj=0
   entityelement(e).eleprof.physics=0
  endif
 else
  rem usually no physics (most made static after loadentities see gamemain)
  entityelement(e).eleprof.physics=0
  rem multiplayer needs 'windows' as physics objects
  if gmultiplayergame=1
   if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0
    if entityelement(e).eleprof.isimmobile=1
     entityelement(e).eleprof.physics=3
    endif
   endif
  endif
 endif
 `
 rem Safety trap, can cancel if entity not complet
 if entityelement(e).eleprof.physics<>0
  if entityelement(e).profileobj>0
   if object exist(entityelement(e).profileobj)=0
    entityelement(e).eleprof.physics=0
   endif
  else
   entityelement(e).eleprof.physics=0
  endif
 endif
 `
 rem apply physics creation of object
 if entityelement(e).eleprof.physics<>0
  rem for physics bodies that have a center of mass, entity positions need altering to reflect correct position
  tobj=entityelement(e).obj
`  if entityelement(e).eleprof.physics<>3 (not 2'characters' either) - only regular physics objs
  if entityelement(e).eleprof.physics=1
   if tobj>0
    if object exist(tobj)=1
     tprofileobj=entityelement(e).profileobj
     tadj#=object collision center y(tprofileobj)
     rem V111 BETA7 - 010708 - scaling now applied to bounds calculation (which also creates collision center)
     rem but the limb offset is ALSO scaled with the regular scaling of the object (SCALE<>100 in FPE), so we
     rem need to negate this scale normally (change to OBJECT COLLIISION CENTER made to do this in FPSC code,
     rem and the initial adjustment of objects must ensure entities do not start inside the floor
     if entityprofile(entid).scale<>0
      applyscalefactor#=(entityprofile(entid).scale/100.0)
      tadj#=tadj#*applyscalefactor#
     endif
     entityelement(e).y=entityelement(e).y+tadj#
     if object exist(tobj)=1 then position object tobj,object position x(tobj),object position y(tobj)+tadj#,object position z(tobj)
    endif
   endif
  endif
  rem create the physics body (if not child spawn entities)
  tspawnhide=0
  if entityelement(e).spawn.leaderid>0
   if entityelement(e).spawn.leader=0
    tspawnhide=1
   endif
  endif
  if tspawnhide=0
   if entityelement(e).spawn.leader=1
    rem spawn master does not need physics object
    gosub _ode_ensurephysicsobjvalid
   else
    rem everything else has physics to create
    gosub _ode_setupewithphysics
   endif
  else
   rem still need to reserve all obj ids with E
   gosub _ode_ensurephysicsobjvalid
  endif
 endif
 `
next e

rem Report progress
debugviewtext(323,"Applied physics settings to dynamic elements")

rem eat any old ODE messages
while ODE COLLISION MESSAGE EXISTS()
 ODE COLLISION GET MESSAGE
endwhile

rem shadow light position for global shadow effect
set point light 0,-2000,10000,2000
set ambient light 75

rem no need for dbpro standard collision 'automated' system
SET GLOBAL COLLISION OFF

return

_ode_beginphysics:
 `
 rem ensure internal ODE timer is not going to cause HUGE physics calc
 rem (from time between setting up ODE and the game starting)
 ode update 0.001
 `
return

_ode_ensurephysicsobjvalid:
 `
 rem redim new size (takes tobj and e)
 tmax=array count(phyobjele())
 if tobj>tmax
  tmax=tobj
  dim phyobjvelocity#(tmax)
  dim phylasttravelled#(tmax)
  dim phylastfloorstop#(tmax)
  dim phyobjsounding(tmax)
  dim phyobjremove(tmax)
  dim phyobjele(tmax)
  dim shadowobj(tmax)
 endif
 rem setup inits
 phyobjvelocity#(tobj)=0
 phylasttravelled#(tobj)=0
 phylastfloorstop#(tobj)=0
 phyobjsounding(tobj)=0
 phyobjremove(tobj)=0
 phyobjele(tobj)=e
 shadowobj(tobj)=0
 `
return

_ode_loadmateriallist_init:
`
rem load material list
tfile$="audiobank\materials\materialdefault.txt"
addfiletocollection(tfile$)
if file exist(tfile$)=1
 `
 rem Load Data from file
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem load max materials
    tryfield$="materialmax"
    if field$=tryfield$
     gmaterialmax=value1
     if gmaterialmax<18 then gmaterialmax=18 : rem V118 - BETA11 - water uses this in code!
     dim material(gmaterialmax) as materialsettingstype
    endif
    `
    rem load material data
    for m=0 to gmaterialmax
     tryfield$="matdesc"+str$(m) : if field$=tryfield$ then material(m).name$=value$
     tryfield$="matwave"+str$(m) : if field$=tryfield$ then material(m).tred0$=value$
     tryfield$="matwaves"+str$(m) : if field$=tryfield$ then material(m).scrape$=value$
     tryfield$="matwavei"+str$(m) : if field$=tryfield$ then material(m).impact$=value$
     tryfield$="matwaved"+str$(m) : if field$=tryfield$ then material(m).destroy$=value$
     tryfield$="matfreq"+str$(m) : if field$=tryfield$ then material(m).freq=value1
     tryfield$="matdecal"+str$(m) : if field$=tryfield$ then material(m).decal$=value$
    next m
    `
   endif
  endif
 next l
 undim data$()
endif
`
rem Fill in material defaults if info lacking
for m=0 to gmaterialmax
 if file exist(material(m).scrape$)=0 then material(m).scrape$=material(m).tred0$
 if file exist(material(m).impact$)=0 then material(m).impact$=material(m).tred0$
 if file exist(material(m).destroy$)=0 then material(m).destroy$=material(m).tred0$
 material(m).tred1$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A1.wav"
 material(m).tred2$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A2.wav"
 material(m).tred3$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A3.wav"
 material(m).tred0$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A4.wav"
 if material(m).freq=0 then material(m).freq=22000
next m
`
return

_ode_loadmateriallist_core:
`
rem Load material sounds into memory
tbase=materialsoundoffset
for m=0 to gmaterialmax
 `
 rem V109 BETA8 - 060508 - material used or all if test game
 tloadthismaterialsound=0
 if gtestgamemodefromeditor=1 then tloadthismaterialsound=1
 if material(m).usedinlevel=1 then tloadthismaterialsound=1
 `
 if material(m).name$<>"" and tloadthismaterialsound=1
  rem load tred sound (all five)
  snd$=material(m).tred0$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq+soundfrequencymodifier
   material(m).noise=tbase
   inc tbase
  else
   material(m).noise=0
  endif
  rem load scrape
  snd$=material(m).scrape$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq+soundfrequencymodifier
   material(m).scrapeid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).scrapeid=0
  endif
  rem load impact
  snd$=material(m).impact$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq+soundfrequencymodifier
   material(m).impactid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).impactid=0
  endif
  rem load destroy
  snd$=material(m).destroy$
  if file exist(snd$)=1
   load 3dsound snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq+soundfrequencymodifier
   material(m).destroyid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).destroyid=0
  endif
 endif
next m
materialsoundmax=(tbase-1)-materialsoundoffset
`
return

_ode_loadmateriallist:
`
rem Material list and sound loading moved to core above (called only before level one)
`
rem Load decals for materials
for m=0 to gmaterialmax
 material(m).decalid=0
 if material(m).name$<>""
  decal$=material(m).decal$
  gosub _decal_find
  if decalid<0 then decalid=0
  if decalid>0
   material(m).decalid=decalid
   decal(decalid).active=1
  endif
 endif
next m
`
return

_ode_triggermaterialsound:
 `
 rem when trigger, play a material sound
 if tsoundtrigger>0
  tvol#=100 : sbase=tsoundtrigger
  for tchannels=0 to 4
   ts=sbase+tchannels
   if sound exist(ts)=1
    if sound playing(ts)=0
     playinternalBC3dsound(ts,tsx#,tsy#,tsz#,25.0)
     set sound volume ts,80.0+(tvol#*0.2)
     if tspd#>2000 then set sound speed ts,tspd#+soundfrequencymodifier
     exit
    endif
   endif
  next tchannels
 endif
 `
return

_ode_setupewithphysics:
 ttentid=entid : entid=entityelement(e).bankindex
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   tprofileobj=entityelement(e).profileobj
   if tprofileobj>0
    if object exist(tprofileobj)=1
     `
     if entityelement(e).eleprof.physics=1
      rem LEETIP : Characters are set to physics mode of 2, so this code should not happen for characters at ALL!
      if entityprofile(entid).ischaracter=1
       rem FPSCV104RC9 - do not adjust X and Z as model offsets are not good indicators of center
       offset limb tprofileobj,0,0,object collision center y(tprofileobj)*-1,0
       offset limb tobj,0,0,object collision center y(tprofileobj)*-1,0
      else
       offset limb tprofileobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
       offset limb tobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
      endif
     endif
     set object collision off tobj
     `
     rem ensure entitydriven and pseudo-static start with null rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      rem record object angle before apply physics to object
      entityelement(e).rx=object angle x(tobj)
      entityelement(e).ry=object angle y(tobj)
      entityelement(e).rz=object angle z(tobj)
      rem must ensure default matrix in ODE is unrotated to begin with (RY controls angle)
      if entityelement(e).isflak=0 then yrotate object tobj,0
     endif
     `
     rem FPGC - 210210 - new ODE DLL requires all characters are 180 degree rotated (new internal matrix code)
     if entityprofile(entid).ischaracter=1 and entityelement(e).isflak=0
      yrotate object tobj,180
     endif
     `
     rem physics object is static or dynamic
     if entityelement(e).eleprof.physics=3
      rem static (dynamic response identical to static behaviour)
      ode create dynamic box tobj : ode set response tobj,2 : ode set gravity tobj,0
     else
      rem dynamic
      if entityprofile(entid).collisionmode=3
       ode create dynamic cylinder tobj
      else
       if entityprofile(entid).collisionmode=4
        ode create dynamic sphere tobj
       else
        ode create dynamic box tobj
       endif
      endif
      rem pre-test code to assign internally (now done in mapeditor)
      `tfriction=(object size x(tobj)*75)+(object size y(tobj)*75)+(object size z(tobj)*75)
      `tweight=(object size x(tobj)*25)+(object size y(tobj)*25)+(object size z(tobj)*25)
      `entityelement(e).eleprof.phyfriction=tfriction
      `entityelement(e).eleprof.phyweight=tweight
      entityelement(e).floorposy=object position y(tobj)
      ode set contact fdir1 tobj, entityelement(e).eleprof.phyfriction
      ode set body mass tobj,entityelement(e).eleprof.phyweight
      rem some objects ignore static geom and gravity
      if entityelement(e).eleprof.physics=2 then ode set response tobj,1 : ode set gravity tobj,0
      rem stabalize the object
      ode set linear velocity tobj,0,0,0
      ode set angular velocity tobj,0,0,0
      `
      rem recalc adjustment for objects that must find the floor perfectly
      centx#=ODE GET BODY ADJUSTMENT X(tobj)
      centy#=ODE GET BODY ADJUSTMENT Y(tobj)
      centz#=ODE GET BODY ADJUSTMENT Z(tobj)
      rem FPSCV101 - compensate for character model issues with a hack
      if entityprofile(entid).ischaracter=1
       rem U74 - 270409 - FPSCV115 - new U74 approach to floor placement
       if entityprofile(entid).raisefactor<>0
        rem does not use collision center offset to adjust character to floor position
        offset limb tobj,0,0,centy#,0
       else
        rem object center already scaled for correct floor adjustment
        offset limb tobj,0,0,((object collision center y(tprofileobj))*-1)+centy#,0
       endif
      else
       rem regular object full XYZ center needed
       offset limb tobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
      endif
     endif
     `
     rem ensure entitydriven and pseudo-static than uses RY for rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      ode set body rotation tobj,0,entityelement(e).ry,0
     endif
     `
    else
     hide object tobj
    endif
   else
    hide object tobj
   endif
  endif
 endif
 rem redim new size and init vars
 gosub _ode_ensurephysicsobjvalid
 entid=ttentid
return

_ode_applyphysicstoattachment:
 ode create dynamic box tobj
 tfriction=(object size x(tobj)*75)+(object size y(tobj)*75)+(object size z(tobj)*75)
 tweight=(object size x(tobj)*25)+(object size y(tobj)*25)+(object size z(tobj)*25)
 tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
 if tweight<200 then tweight=200
 ode set contact fdir1 tobj,tfriction
 ode set body mass tobj,tweight
 ode set linear velocity tobj,rnd(10)*timeelapsed#,(20+rnd(20)*timeelapsed#),rnd(10)*timeelapsed#
 ode set angular velocity tobj,0,0,0
 ode set gravity tobj,1
 ode set body rotation tobj,object angle x(tobj),object angle y(tobj),object angle z(tobj)
 tobj=tstore
return

_ode_deleteentity:
 ode destroy object tobj
return

_ode_pushusingtvelandangle:
 `
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   rem only for regular physics objects, not entitydriven characters, or statics (doors)
   if entityelement(e).eleprof.physics=1
    rem apply velocity and angle to physics object
    tvel#=tvel*2.0
    if tvel<>0
     tvelx#=newxvalue(0,entityelement(e).ry,tvel#)
     tvelz#=newzvalue(0,entityelement(e).ry,tvel#)
     tangle#=sin(tangle)*tvel#
     tvelx#=tvelx#*cos(tangle)
     tvelz#=tvelz#*cos(tangle)
     ode set linear velocity tobj,tvelx#,tangle#,tvelz#
    endif
    if entityelement(e).eleprof.rotatethrow<>0
     trotate#=entityelement(e).eleprof.rotatethrow/10.0
     ode set angular velocity tobj,trotate#,0,trotate#
    endif
   endif
  endif
 endif
 `
return

_ode_switchoffe:
 `
 ttobj=entityelement(e).obj
 if ttobj>0
  if object exist(ttobj)=1
   if entityelement(e).eleprof.physics<>0
    if shadowobj(ttobj)=1
     set shadow shading off ttobj
     shadowobj(ttobj)=0
    endif
    ode destroy object ttobj
    rem restore rotation of object (ode influence deleted)
    rotate object ttobj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
   endif
  endif
 endif
 `
return

_ode_ensureeisnotpenetrated:
 rem performed when physics object activates its presence (COLON)
 todee=e : todeobj=entityelement(e).obj
 for tte=1 to entityelementmax
  ttobj=entityelement(tte).obj
  if entityelement(tte).eleprof.physics<>0 and ttobj>0
   ttdy#=object position y(ttobj)-object position y(todeobj)
   if abs(ttdy#)<250
    rem if Ys close enough, do complete distance test
    ttdx#=object position x(ttobj)-object position x(todeobj)
    ttdz#=object position z(ttobj)-object position z(todeobj)
    ttdd#=sqrt(abs(ttdx#*ttdx#)+abs(ttdz#*ttdz#)+abs(ttdy#*ttdy#))
    if ttdd#<object size(todeobj)+object size(ttobj)
     rem give a nudge so it uses its own physics body to work out how to get out (brutal but efective)
     ode set linear velocity ttobj,0,0.01,0
    endif
   endif
  endif
 next tte
return

_ode_giveentitiesalittlenudgejustbeforelevelbegins:
 rem FPGC - 110610 - called just after warm up and new physics reset (calms irratic start)
 for tte=1 to entityelementmax
  ttobj=entityelement(tte).obj
  if entityelement(tte).eleprof.physics<>0 and ttobj>0
   ode set linear velocity ttobj,0,0.01,0
  endif
 next tte
return

_ode_playerborble:
 `
 rem can call this to force player to camerapositionx,y,z
 rem borble that rattles around inside player ellipse
 phycrouched#=10.0 : phystood#=40.0
 phycrouchedellipsevolumesize#=0.25
 phystoodellipsevolumesize#=1.0
 ellipsevolumesize#=phystoodellipsevolumesize#
 phyeyeheight#=phystood#
 ctx#=camerapositionx
 cty#=camerapositiony
 ctz#=camerapositionz
 `
 rem prepare object and physics
 if object exist(physicsplayerborble)=1
  ode destroy object physicsplayerborble
  delete object physicsplayerborble
 endif

 `make object sphere physicsplayerborble,30

 Eyeheight = 72

 make object sphere physicsplayerborble,Eyeheight/2

 Set Object Collision To Polygons physicsplayerborble

 Set Object Collision On physicsplayerborble
 Rem Hockeykid - 250210 - Dark AI add player to ai system
 if darkaiplayer=0
  ai add player physicsplayerborble,0
  ai set player height 0 : rem V118 - 240111 - player position is camera position (no need for height)
  darkaiplayer=1
 endif
 color object physicsplayerborble,rgb(255,255,0)
 set object collision off physicsplayerborble
 if plrcamoffseton=1
 position object physicsplayerborble,camerapositionx+newcamoffsetx#,(camerapositiony-phyeyeheight#)+6+newcamoffsety#,camerapositionz+newcamoffsetz#
 else
 position object physicsplayerborble,camerapositionx,(camerapositiony-phyeyeheight#)+6,camerapositionz
 endif
 if physicsdebug=1
  set object wireframe physicsplayerborble,1
  set object cull physicsplayerborble,0
 else
  hide object physicsplayerborble
 endif
 ode create dynamic sphere physicsplayerborble
 ode set contact fdir1 physicsplayerborble,500
 ode set body mass physicsplayerborble,physicsplayerweight#
 ode set linear velocity physicsplayerborble,0,0,0
 ode set angular velocity physicsplayerborble,0,0,0
 `
 rem ensure player has default gravity
 ode set gravity physicsplayerborble,1
 physuspendgravity=0
 phytotalmotioncount=0
 phytotalmotion#=0
 `
return

_ode_cleanup:

rem free universe
if physicsproto=1
 delete static objects
endif

rem free ode static collision
ode destroy object physicsuniverseobj
if object exist(physicsuniverseobj)=1
 delete object physicsuniverseobj
endif
ode destroy object physicsplayerborble
if object exist(physicsplayerborble)=1
 delete object physicsplayerborble
endif

rem free assignments
for e=1 to entityelementmax
 tobj=entityelement(e).obj
 if tobj>0
  if entityelement(e).eleprof.physics<>0
   if object exist(tobj)=1 then ode destroy object tobj
  endif
 endif
next e

rem end ode
ode end

rem free material sounds
gosub _ode_deletematerialsounds

return

_ode_deletematerialsounds:
 `
 rem delete all material sounds
 for s=materialsoundoffset to materialsoundoffset+materialsoundmax
  if sound exist(s)=1 then delete sound s
 next s
 `
return

`
` Player Controls
`

_ode_unmark:
 `
 rem remove player from viscol prior to movement (use vis from write state)
 tx=viscx#/25 : ty=viscy#/100 : tz=viscz#/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=-1 then viscolmap(tx,ty,tz)=0
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=-1 then viscolmap(ttx,tty,ttz)=0
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 `
return

_ode_mark:
 `
 rem place viscol data back after player movement
 tx=camerapositionx/25 : ty=camerapositiony/100 : tz=camerapositionz/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=0 then viscolmap(tx,ty,tz)=-1
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=0 then viscolmap(ttx,tty,ttz)=-1
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 viscx#=camerapositionx : viscy#=camerapositiony : viscz#=camerapositionz
 `
return

_ode_playerrelocations:
 `
 rem handle lift mechanism for player
 if meridinglift>1
  tobj=entityelement(meridinglift-1).obj
  if tobj>0
   meridinglifty#=object position y(tobj)+60
   tmex#=camerapositionx : tmey#=camerapositiony : tmez#=camerapositionz
   tdstx#=object position x(tobj)-tmex#
   tdstz#=object position z(tobj)-tmez#
   tdstt#=sqrt(abs(tdstx#*tdstx#)+abs(tdstz#*tdstz#))
   rem 071112 - Ensure player is moved by lift and account of camera offset
   camerapositiony=meridinglifty#
   if plrcamoffseton=1
    position camera camerapositionx+newcamoffsetx,camerapositiony+newcamoffsety,camerapositionz+newcamoffsetz
   else
    position camera camerapositionx,camerapositiony,camerapositionz
   endif
   gosub _ode_playerborble
   if tdstt#>90
    meridinglift=0
   endif
   grav#=0 : gravlasty#=tmey#
  endif
 endif
 `
 rem player frozen on spot for X number of seconds
 if mefrozen>0
  if timer()-mefrozen<0
   cameraspeed=0
   camvelx#=0 : camforcex#=0
   camvely#=0 : camforcey#=0
   camvelz#=0 : camforcez#=0
   grav#=-10 : gravlasty#=grav#
   movement=0
  else
   mefrozen=0
  endif
 endif
 `
 rem handle transporter mechanism for player
 if meridingtransporter=1
  rem player coord moved to new location, must deactivate camera collision for movement
  position camera tranmex#,tranmey#,tranmez#
  rotate camera 0,tranmeangley#,0
  cx#=camera position x() : cy#=camera position y() : cz#=camera position z()
  cox#=cx# : coy#=cy# : coz#=cz#
  camerapositionx=camera position x()+newcamoffsetx
  camerapositiony=camera position y()+newcamoffsety
  camerapositionz=camera position z()+newcamoffsetz
  gosub _ode_playerborble
  meridingtransporter=0
 endif
 if memovingx#<>0.0
  memovingx#=0.0
 endif
 if memovingy#<>0.0
  memovingy#=0.0
 endif
 if memovingz#<>0.0
  memovingz#=0.0
 endif
 `
return

_ode_playercamera:

rem Camera in control of player one
plrid=1

rem Key configuration
if gtestgamemodefromeditor=1
 rem Preset TEST GAME Keys
 plrkeyW=17
 plrkeyA=30
 plrkeyS=31
 plrkeyD=32
 plrkeyQ=16
 plrkeyE=18
 plrkeyC=46
 plrkeyZ=44
 plrkeyR=19
 plrkeySPACE=57
 plrkeyRETURN=28
 plrkeySHIFT=42
 plrkeySHIFT2=54
 plrkeyF12=88
else
 rem from BUILD GAME config keys
 plrkeyW=listkey(1)
 plrkeyS=listkey(2)
 plrkeyA=listkey(3)
 plrkeyD=listkey(4)
 plrkeySPACE=listkey(5)
 plrkeyC=listkey(6)
 plrkeyRETURN=listkey(7)
 plrkeyR=listkey(8)
 plrkeyQ=listkey(9)
 plrkeyE=listkey(10)
 plrkeySHIFT=listkey(11)
 plrkeySHIFT2=54
 plrkeyZ=44
 plrkeyF12=88
endif

Rem Scene Commander edit
rem Read keys from config, and use in player control actions
if walkonkeys=1
if keystate(plrkeyW)=1 then plrkeyW=1 else plrkeyW=0
if keystate(plrkeyA)=1 then plrkeyA=1 else plrkeyA=0
if keystate(plrkeyS)=1 then plrkeyS=1 else plrkeyS=0
if keystate(plrkeyD)=1 then plrkeyD=1 else plrkeyD=0
endif

rem Scene Commander forced move
if forcemove>0
plrkeyW=1
endif

if forcemove<0
plrkeyS=1
endif

Rem Scene Commander edit
if keystate(plrkeyQ)=1 and peekonkeys=1 then plrkeyQ=1 else plrkeyQ=0
if keystate(plrkeyE)=1 and peekonkeys=1 then plrkeyE=1 else plrkeyE=0
Rem Scene Commander change
if keystate(plrkeyC)=1 and crouchonkey=1 then plrkeyC=1 else plrkeyC=0
`if keystate(plrkeyC)=1 then plrkeyC=1 else plrkeyC=0

Rem end change
if keystate(plrkeyZ)=1 then plrkeyZ=1 else plrkeyZ=0


   if keystate(plrkeyR)=1
   plrkeyR=1
   else
   plrkeyR=0
   endif
Rem Scene Commander edit
if keystate(plrkeySPACE)=1 and jumponkey=1 then plrkeySPACE=1 else plrkeySPACE=0
if keystate(plrkeyRETURN)=1 then plrkeyRETURN=1 else plrkeyRETURN=0
if keystate(plrkeySHIFT)=1 and runkeys=1 and jumpaction=0 then plrkeySHIFT=1 else plrkeySHIFT=0
if keystate(plrkeySHIFT2)=1 and runkeys=1 and jumpaction=0 then plrkeySHIFT2=1 else plrkeySHIFT2=0

rem hard coded arrow keys - Scene commander change
if arrowkeyson=1
if upkey()=1 then plrkeyW=1
if leftkey()=1 then plrkeyA=1
if downkey()=1 then plrkeyS=1
if rightkey()=1 then plrkeyD=1
endif
rem U71 - Contoller
if gxbox=1 : rem define in a config later
 `
 rem Hard Code XBOX360 controls to optional player controls
 if walkonkeys=1
 if joystick y()<-500 then plrkeyW=1
 if joystick y()>500 then plrkeyS=1
 if joystick x()<-500 then plrkeyA=1
 if joystick x()>500 then plrkeyD=1
 endif

 if joystick fire c()=1
   plrkeyR=1
   else
   plrkeyR=0
   endif
 if joystick fire a()=1 and jumponkey=1  then plrkeySPACE=1
 if joystick fire d()=1  then plrkeyRETURN=1
 if gxboxcontrollertype=0
  rem XBOX360 Controller
  if joystick fire x(8)=1 and crouchonkey=1then plrkeyC=1
  if joystick fire x(9)=1 then plrkeyZ=1
  if joystick z()>500 and runkeys=1  then plrkeySHIFT=1
 endif
 if gxboxcontrollertype=1
  rem Dual Action
  if joystick fire x(10)=1 and crouchonkey=1 then plrkeyC=1
  if joystick fire x(11)=1 then plrkeyZ=1
  if joystick fire x(4)=1 and runkeys=1 then plrkeySHIFT=1
  if joystick fire x(6)=1 and runkeys=1 then plrkeySHIFT=1
 endif
 `
endif

Rem Scene commander automated actions
select playeraction
case 1
player(1).state.firingmode=1
lastfired=gunid
endcase
case 2
gunzoommode=1
endcase
case 3
player(1).state.firingmode=2
endcase
case 4
forcecrouch=1
endcase
case 5
plrkeySPACE=1
endcase
case 6
plrkeyE=1
endcase
case 7
plrkeyQ=1
endcase
case 8
plrkeyRETURN=1
endcase
case 9
tmouseclick=1
endcase
case 10
tmouseclick=2
endcase
case 11
if gunid>0
firemode(gunid,firemode).settings.jammed=1
endif
endcase


endselect

if forcecrouch=1 and playeraction<>4
   forcecrouch=0
endif

if playeraction<>4
   playeraction=0
endif


`text 200,200,str$(playeraction)


`if firstturnjump=0
`plrkeySPACE=1
`firstturnjump=1
`endif


Rem Free weapon jam if reload used

if player(1).state.firingmode=2 and gunzoommode=0
   plrreloading=1
   firemode(gunid,firemode).settings.shotsfired=0
   rem play free jam animation if it exists
      if firemode(gunid,firemode).action2.clearjam.s<>0 and firemode(gunid,firemode).settings.jammed=1
      plrreloading=2
      custstart=firemode(gunid,firemode).action2.clearjam.s
      custend=firemode(gunid,firemode).action2.clearjam.e
      gunmode=9998
      endif
   firemode(gunid,firemode).settings.jammed=0
   firemode(gunid,firemode).settings.shotsfired=0
   rem Scene Commander, ensure weapon unjams affect both modes if sharing ammo
    if gun(gunid).settings.modessharemags=1
    firemode(gunid,0).settings.jammed=0
    firemode(gunid,1).settings.jammed=0
    endif

endif

Rem Scene commander end.

rem Camera old information
ctox#=ctx# : ctoy#=cty# : ctoz#=ctz#

rem camera eye height (eye drops to base of elipse when no health)
if player(plrid).health<=0 and playerstartstrength>0
 if ellipsevolumesize#=1.0 and (plrkeyC)=0
  phyeyeheight#=phyeyeheight#-1.0
  if phyeyeheight#<10.0 then phyeyeheight#=10.0
 else
  phyeyeheight#=phycrouched#
 endif
endif

rem get latest camera position
camerapositionx=object position x(physicsplayerborble)
camerapositiony=object position y(physicsplayerborble)+phyeyeheight#
camerapositionz=object position z(physicsplayerborble)
realcx#=camerapositionx : realcy#=camerapositiony : realcz#=camerapositionz

rem Umark player pos in viscolmap
gosub _ode_unmark

rem player can swim underwater
if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
 ode set gravity physicsplayerborble,0
else
 ode set gravity physicsplayerborble,1
endif

rem Handle any sudden playe relocations (transportation)
gosub _ode_playerrelocations

rem flyforce bleeds into camforce X and Y and Z
if camflyforcex#<0 then tsig=-1 else tsig=1
tamount#=camflyforcex# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcex#=(camflyforcex#-tamount#)*0.8
camforcex#=camforcex#+tamount#
`if camflyforcey#<0 then tsig=-1 else tsig=1
`tamount#=camflyforcey# : if abs(tamount#)>60 then tamount#=60*tsig
`camflyforcey#=(camflyforcey#-tamount#)*0.8
`camforcey#=camforcey#+tamount#
if camflyforcez#<0 then tsig=-1 else tsig=1
tamount#=camflyforcez# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcez#=(camflyforcez#-tamount#)*0.8
camforcez#=camforcez#+tamount#

rem All controls when player has health
movement=0
if (player(plrid).health>0 or playerstartstrength=0) and mefrozen=0
 `
 rem Peek controls (and adjustment)
 if gdisablepeeking=0
  rem FPGC - 280710 - added flag to disable peek controls if required
  if ((plrkeyQ)=1 or (plrkeyE)=1) and onladder=0
   if peekfreeze=0
    if (plrkeyQ)=1 and peeklean#>-10.0 then peeklean#=peeklean#-4.0 : movement=1
    if (plrkeyE)=1 and peeklean#<10.0 then peeklean#=peeklean#+4.0 : movement=1
   endif
  else
   peeklean#=curvevalue(0,peeklean#,4.0)
   if abs(peeklean#)<1.0 then peeklean#=0.0 : peekfreeze=0
  endif
 endif
 `
 rem Gun Zoom Control
 if gunzoommode>0
  if gunzoommode>=1 and gunzoommode<=8 then inc gunzoommode
  if gunzoommode>=11 and gunzoommode<=19 then inc gunzoommode
  if gunzoommode<10
   plrzoomin#=gunzoommode : plrzoominchange=1
  endif
  if gunzoommode=10
   rem in full zoom
  endif
  if gunzoommode>10
   plrzoomin#=10-(gunzoommode-10) : plrzoominchange=1
  endif
 endif
 `
 rem AirMod - CAM FOV >>>
 old_airmod_fov# = airmod_camfov#
 airmod_camfov_d# = curvevalue(0,airmod_camfov_d#,20.0)
 airmod_camfov# = curvevalue(airmod_camfov_d#,airmod_camfov#,10.0)
 if old_airmod_fov# <> airmod_camfov# then plrzoominchange=1
 rem AirMod - DONE<<<
  rem Handle optical effect of zoom
 if plrzoominchange=1
  if plrzoomin#>1.0
   rem AirMod - Modified for Simple Zoom
   if firemode(gunid,firemode).settings.simplezoom <> 0
    realfov#=75.0-(plrzoomin#*firemode(gunid,firemode).settings.simplezoom)+airmod_camfov#
    set camera fov realfov#
    set camera fov 1,realfov# : set camera fov 2,realfov#
    rem LightRay Addition
    if RayCam<>0 then if camera exist(RayCam)=1 then set camera fov RayCam,realfov#
    if bloom_cam<>0 then if camera exist(bloom_cam)=1 then set camera fov bloom_cam,realfov#
   else
    realfov#=75.0-(plrzoomin#*7)-gunzoommag#+airmod_camfov#
    set camera fov realfov#
    set camera fov 1,realfov# : set camera fov 2,realfov#
    rem LightRay Addition
    if RayCam<>0 then if camera exist(RayCam)=1 then set camera fov RayCam,realfov#
    if bloom_cam<>0 then if camera exist(bloom_cam)=1 then set camera fov bloom_cam,realfov#
   endif
   rem AirMod - Done
   rem AirMod - Modified for Simple Zoom
   if internalzoomhud>0 and (firemode(gunid,firemode).settings.simplezoom = 0 or firemode(gunid,firemode).zoomscope<>0) then hudid=internalzoomhud : hud(hudid).hide=0 : set sprite alpha hudid,(255.0/10.0)*plrzoomin#
  else
   rem AirMod - Modified for cam fov
   realfov#=75.0+airmod_camfov#
   set camera fov realfov#
   set camera fov 1,realfov# : set camera fov 2,realfov#
   rem LightRay Addition
   if RayCam<>0 then if camera exist(RayCam)=1 then set camera fov RayCam,realfov#
   if bloom_cam<>0 then if camera exist(bloom_cam)=1 then set camera fov bloom_cam,realfov#
   if internalzoomhud>0 then hudid=internalzoomhud : hud(hudid).hide=1
  endif
 endif
 plrzoominchange=0
 `
 rem crouch control
if (plrkeyC)=1 or forcecrouch=1
  if crouchmode=0 and onladder=0 and jumpaction=0 then crouchmode=1
 else
  if crouchmode=1 then crouchmode=0
  if crouchmode=2 then crouchmode=3
 endif
 `
 rem Control camera movement
 if crouchmode<>0
  basespeed#=20 : isrunning=0
 else
  if (plrkeySHIFT)=1 or (plrkeySHIFT2)=1
   basespeed#=55 : isrunning=1
  else
   basespeed#=35 : isrunning=0
  endif
  if alwaysrun=1
   basespeed#=55: isrunning=1
  endif

  rem AirMod - Slow player for simple zoom
  if (gunzoommode <> 0 and firemode(gunid,firemode).settings.simplezoom <> 0) then basespeed#=35-(20*firemode(gunid,firemode).settings.zoomwalkspeed) : isrunning=0
 endif
 if jumpaction=0
  rem regular speed from manouver
  speed#=basespeed#
 else
  rem fixed speed whilst jumping
  speed#=jumpspeed#
 endif
 `
 rem Movement (forward,backward,strafe)
 camerareachatrun#=0.0
 rem scene commander addition
 speedchange#=speedmod#/100
 basespeed#=basespeed#*speedchange#
 rem end screen commander addition
 speed#=basespeed#
 plrbasespeed#=basespeed#
 rem FPGC - 100310 - adjust actual viewing angle with VR tracker
 tmpcamy#=camera angle y()
 if gvrmode<>0 then tmpcamy#=tmpcamy#-vrmodetrackery#
 if jumpaction=0 then moveroty#=tmpcamy# else moveroty#=jumpangle#
 if onladder=0
  if (plrkeyW)=0 and (plrkeyA)=0 and (plrkeyD)=0 and (plrkeyS)=0
   cameraspeed=0
  endif
  remstart (old code 080411)
  if peeklean#=0.0
   if (plrkeyW)=1
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90
     if (plrkeyD)=1 then inc moveroty#,90
    endif
   endif
   phyangle#=moveroty#
   if (plrkeyW)=1 or (plrkeyS)=1 or (plrkeyA)=1 or (plrkeyD)=1
    movement=1 : if crouchmode<>0 then movement=2
    tcameraspeed#=speed#*playerspeedratio#*(0.5+(cameradampen#/2.0))
    if cameraspeed<tcameraspeed# then inc cameraspeed,10.0*timeelapsed#
    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
   endif
  endif
  if camerareachatrun#<cameraspeed/3.0 then camerareachatrun#=cameraspeed/3.0
  if camerareachatrun#<0 then camerareachatrun#=0
 else
 remend
  rem Terry - New A/D mutual exclusivity code
  if (plrkeyA)=1 and (plrkeyD)=1 then cameraspeed=0 : rem (not sure if this is needed)
  if peeklean#=0.0
   if (plrkeyW)=1
    if (plrkeyA)=1 and (plrkeyD)=1
     `do nothing
    else
     if (plrkeyA)=1 then dec moveroty#,35
     if (plrkeyD)=1 then inc moveroty#,35
    endif
   else
    if (plrkeyS)=1
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 and (plrkeyD)=1
      `do nothing
     else
      if (plrkeyA)=1 then dec moveroty#,145
      if (plrkeyD)=1 then inc moveroty#,145
     endif
    else
     if (plrkeyA)=1 and (plrkeyD)=1
      `do nothing
     else
      if (plrkeyA)=1 then dec moveroty#,90
      if (plrkeyD)=1 then inc moveroty#,90
     endif
    endif
   endif
   phyangle#=moveroty#
   if (plrkeyW)=1 or (plrkeyS)=1 or (plrkeyA)=1 or (plrkeyD)=1
    movement=1 : if crouchmode<>0 then movement=2
    tcameraspeed#=speed#*playerspeedratio#*(0.5+(cameradampen#/2.0))
    if (plrkeyA)=1 and (plrkeyD)=1
     `do nothing
    else
     if cameraspeed<tcameraspeed# then inc cameraspeed,10.0*timeelapsed#
     if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
    endif
   endif
  endif
  if camerareachatrun#<cameraspeed/3.0 then camerareachatrun#=cameraspeed/3.0
  if camerareachatrun#<0 then camerareachatrun#=0
 else
`ladder?
`  phyangle#=moveroty#
`  if (plrkeyW)=1
`   movement=1
`   tcameraspeed#=speed#
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
`  if (plrkeyS)=1
`   movement=1 : onladder=0
`   tcameraspeed#=speed#*-1
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
 endif
 `
 tmotionx#=ode get body linear velocity x(physicsplayerborble)
 tmotiony#=ode get body linear velocity y(physicsplayerborble)
 tmotionz#=ode get body linear velocity z(physicsplayerborble)
 `
 rem V118 - ensure motion while jumping never spikes higher than initially tracked speed
 if jumpaction<>0
  if motionytracked#=-1.0
   rem first motion Y after jump
   motionytracked#=tmotiony#
  else
   rem ensure we don't go HIGHER!
   if motionytracked#>0.0 then motionytracked#=motionytracked#-(timeelapsed#*1.0)
   if tmotiony#>motionytracked# then tmotiony#=motionytracked#
  endif
 else
  motionytracked#=-1.0
 endif
 `
 if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
  rem underwater
 else
  rem Only suspend gravity if total movement small
  tmotion#=abs(tmotionx#)+abs(tmotiony#)+abs(tmotionz#)
  phytotalmotion#=phytotalmotion#+tmotion#
  inc phytotalmotioncount
  if phytotalmotioncount>20
   phytotalmotion#=phytotalmotion#/phytotalmotioncount
   if phytotalmotion#<10.0
    physuspendgravity=1
   else
    physuspendgravity=0
   endif
   phytotalmotioncount=0
   phytotalmotion#=0
  endif
  rem update gravity with current motion
  grav#=tmotiony#
  rem suspend so can stand on slopes/stairs
  if movement<>0 or jumpaction=1 then physuspendgravity=0
  if physuspendgravity=1 or onladder=1
   ode set gravity physicsplayerborble,0
   if physuspendgravity=1 then grav#=0
  else
   ode set gravity physicsplayerborble,1
  endif
 endif
 `if physicsdebug=1 then print "GRAVITY VALUE=";grav#
 `
 if jumpaction=0 and jumpactionnorepeat=0
  if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
   rem reduce influence of movement when underwater
   tunderwaterspeed#=timeelapsed#*0.3 : rem V118 - sped up from 0.1 to improve gameplay
   camvelx#=tmotionx#+((newxvalue(0,phyangle#,cameraspeed))*tunderwaterspeed#)
   if (plrkeyA)=1 or (plrkeyD)=1
    rem strafing means no ascent/decent
   else
    if (plrkeyS)=1
     camvely#=tmotiony#+((sin(camera angle x())*cameraspeed*1)*tunderwaterspeed#*2)
    else
     camvely#=tmotiony#+((sin(camera angle x())*cameraspeed*-1)*tunderwaterspeed#*2)
    endif
    rem V118 - 270111 - allow no upward movement if volume collision (causing downward adjustment) in effect
    if camvolumecollisioncausingdownwardadjust=1
     if camvely#>-0.1 then camvely#=-0.1
    endif
   endif
   camvelz#=tmotionz#+((newzvalue(0,phyangle#,cameraspeed))*tunderwaterspeed#)
  else
   camvelx#=newxvalue(0,phyangle#,cameraspeed)
   camvely#=grav#
   camvelz#=newzvalue(0,phyangle#,cameraspeed)
  endif
 else
  camvelx#=tmotionx#
  camvely#=tmotiony#
  camvelz#=tmotionz#
 endif
 `
 rem Jump Control
 if onladder=0
  if player(plrid).health>0 or playerstartstrength=0
   if (plrkeySPACE)=1 and jumpaction=0 and meridinglift=0 and crouchmode=0 and jumpactionnorepeat=0 and grav#>-1
    jumpspeed#=speed# : jumpangle#=camera angle y() : leapedlanded=1
    camvely#=0.0
    camforcey#=playerdefaultjumpheight
    camforcey#=camforcey#*(0.5+(cameradampen#/2.0))
    rem V118 - 050211 - jump direction can be irratic coming from motion values
    `jumpmotionx#=tmotionx#
    `jumpmotionz#=tmotionz#
    jumpmotionx#=newxvalue(0,phyangle#,cameraspeed)
    jumpmotionz#=newzvalue(0,phyangle#,cameraspeed)
    if playersound(plrid,10)>0
     broadcast3dsound(camerapositionx,camerapositiony,camerapositionz,5.0,-1)
     play sound playersound(plrid,10)
    endif
    jumpaction=1 : jumpactionnorepeat=5
   endif
  endif
 endif
 if jumpactionnorepeat>0
  if jumpactionnorepeat>1 then dec jumpactionnorepeat
  if jumpactionnorepeat=1 and grav#<0 then jumpactionnorepeat=0
 endif
 if jumpaction<>0
  camvelx#=jumpmotionx# : camvelz#=jumpmotionz#
 endif
 `
 rem and apply any force here
 if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
  camvelx#=(camvelx#+camforcex#)/1.1 : camforcex#=0
  camvely#=(camvely#+camforcey#)/1.1 : camforcey#=0
  camvelz#=(camvelz#+camforcez#)/1.1 : camforcez#=0
 else
  camvelx#=camvelx#+camforcex# : camforcex#=0
  camvely#=camvely#+camforcey# : camforcey#=0
  camvelz#=camvelz#+camforcez# : camforcez#=0
 endif
 `
else
 `
 rem player has no health
 cameraspeed=0
 camvelx#=0 : camforcex#=0
 camvely#=0 : camforcey#=0
 camvelz#=0 : camforcez#=0
 movement=0
 grav#=0
 `
endif

rem Is player moving or not
player(plrid).state.moving=movement

rem Mark player position is viscolmap
gosub _ode_mark

return

_ode_playeraftermove:

rem Camera in control of player one (unmark as slide may change pos)
plrid=1
gosub _ode_unmark
movement=player(plrid).state.moving

rem Collisions
colmaterialtype=-1
tgravitydefeated=0

rem Check for physicsobjects collisions (and perform physics collision sounds)
gosub _ode_sounds

rem control player interaction
if gmultiplayergame=1 then gosub _multi_plrradial

rem Special Get Out of Jail Free collision key
if inkey$()<>"K" then tkickout=0
if inkey$()="K" and tkickout=0
 if playertrailmax>0
  trailx#=playertrial(playertrailmax).x
  traily#=playertrial(playertrailmax).y
  trailz#=playertrial(playertrailmax).z
  dec playertrailmax : if playertrailmax<1 then playertrailmax=100
  if playertrial(playertrailmax).time=0
   inc playertrailmax : if playertrailmax>100 then playertrailmax=1
  else
   camerapositionx=trailx#
   camerapositiony=traily#+phyeyeheight#
   camerapositionz=trailz#
   position camera camerapositionx,camerapositiony,camerapositionz
   cx#=camera position x() : cy#=camera position y() : cz#=camera position z()
   cox#=cx# : coy#=cy# : coz#=cz#
   gosub _ode_playerborble
   meridingtransporter=0
   meridinglift=0
   mefrozen=0
  endif
 endif
 tkickout=1
endif

rem Ellipse Collision with static scene
colmaterialtype=-1
if deactivatecollision=0 and skipcol=0
 `
 rem check ellipse against movement
 ctx#=camerapositionx+(camvelx#/4.0)
 if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
  cty#=camerapositiony+(camvely#/4.0)
 else
  cty#=camerapositiony
 endif
 ctz#=camerapositionz+(camvelz#/4.0)
 rem check if can crouch down from stood
 if crouchmode=1
  if static volume(ctox#,ctoy#-28,ctoz#,ctx#,(cty#-28)-15,ctz#,0.25)=1 `and playerunderwater=0 and tnearsurfaceofwater>=15
   if physicsdebug=1 then print "willgetstyckifcrouch"
  else
   ellipsevolumesize#=phycrouchedellipsevolumesize#
   phyeyeheight#=phycrouched#
   cty#=camerapositiony-12
   ctoy#=ctoy#-12
   crouchmode=2
  endif
 endif
 rem check if can stand up from crouch
 if crouchmode=3
  if static volume(ctox#,(ctoy#-9)+5,ctoz#,ctx#,(cty#-9)+40+5,ctz#,0.25)=1
   if physicsdebug=1 then print "willhitheadifgetup"
  else
   ellipsevolumesize#=phystoodellipsevolumesize#
   phyeyeheight#=phystood#
   cty#=camerapositiony+30+5
   ctoy#=ctoy#+30+5
   crouchmode=0
  endif
 endif
 rem determine center of ellipse (crouch and stood) (need contact with floor=walksound)
 if phyeyeheight#=phystood# then ellipsecentery#=35 else ellipsecentery#=23
 `
 rem ellipse test for final player mode (stood or crouch)
 camvolumecollisioncausingdownwardadjust=0
 if static volume(ctox#,ctoy#-ellipsecentery#,ctoz#,ctx#,cty#-ellipsecentery#,ctz#,ellipsevolumesize#)=1
  if physicsdebug=1 then print "volumecollision"
  adjx#=get static collision x()
  adjy#=get static collision y()
  adjz#=get static collision z()
  tstaticfloor=get static collision floor()
  if tstaticfloor=1
   rem FPGC - 150610 - added floor check for player floor material value (stops using wall material for footfalls)
   colmaterialtype=get static collision value()-1
  endif
  sctx#=ctx#
  scty#=cty#
  sctz#=ctz#
  ctx#=ctox#+adjx#
  cty#=ctoy#+adjy#
  ctz#=ctoz#+adjz#
  rem gravity defeated?
  if jumpactionnorepeat=0
   if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
    rem no gravity to defeat when in water
   else
    if tstaticfloor=1 and grav#<0 then tgravitydefeated=1
   endif
   rem handle if collide while jumping
   if jumpaction<>0 and camvely#>5.0 and cty#-scty#<0.0 then camvely#=camvely#*-1 : jumpaction=0
   rem V118 - 310111 - re-introduce to solve stair collision issue
   if abs(ctx#-sctx#)+abs(ctz#-sctz#)>8
    rem prevent player penetrating half-height geometry (metal stairs)
    camvelx#=ctx#-camerapositionx
    camvely#=cty#-camerapositiony
    camvelz#=ctz#-camerapositionz
    if jumpactionnorepeat=0
     jumpmotionx#=0 : jumpmotionz#=0 : jumpaction=0
    endif
    if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
     rem underwater ascent okay
    else
     if camvely#>0 then camvely#=0
    endif
    rem wipe out flyforce too as hit something to stop hero
    camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
   endif
  endif
 endif
 rem if underwater, perform upward ray cast, and prevent upward movement if hit geometry
 if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
  tdst#=static raycast(ctx#,cty#-5.0,ctz#,ctx#,cty#+15.0,ctz#)
  if tdst#<>0.0
   camvolumecollisioncausingdownwardadjust=1
   if tdst#<10.0
    camvely#=camvely#-5.0
   endif
  endif
 endif
 rem V118 - 070211 - if jumping, ray cast up to ensure we never penetrate the ceiling
 if jumpaction=1
  tdst#=static raycast(ctx#,cty#-5.0,ctz#,ctx#,cty#+15.0,ctz#)

  if tdst#<>0.0
   if tdst#<10.0
    if camvely#>0.0
     camvely#=(camvely#*0.5)*-1
     jumpactionnorepeat=0
     jumpaction=0
    endif
   endif
  endif
 endif
 `
 if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
  rem In water or on surface (but in water really)
 else
  rem If gravity defeated by player
  if tgravitydefeatedbyphy<>0
   rem if object entity driven, player can be moved by it
   if entityelement(tgravitydefeatedbyphye).eleprof.physics=2
    if camerastoodonphyobj=0
    lcamerastoodonphyobjmovingx#=object position x(tgravitydefeatedbyphy)
   lcamerastoodonphyobjmovingz#=object position z(tgravitydefeatedbyphy)
    endif
    camerastoodonphyobj=tgravitydefeatedbyphy
   else
    camerastoodonphyobj=0
   endif
   rem record stood on phy obj
   if jumpactionnorepeat>1
    rem when in jump mode, and touching phyobj, do not interfere with a defeat flag
   else
    tgravitydefeated=1
   endif
  else
   rem when not detect phy obj, keep record until
   if tgravitydefeated=1
    rem stood on static floor (must have walked off phy obj)
    camerastoodonphyobj=0
   endif
  endif
  remstart
  if camerastoodonphyobj<>0
   camerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)-lcamerastoodonphyobjmovingx#
   camerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)-lcamerastoodonphyobjmovingz#
   rem only influence of object beneath player borble
   if object position y(camerastoodonphyobj)<object position y(physicsplayerborble)
   Rem Scene Commnader, fix for new fps cap -  thanks to Terry for testing for tweaks - Still WIP
    `camvelx#=camvelx#+(camerastoodonphyobjmovingx#*80.0*timeelapsed#)
    `camvelz#=camvelz#+(camerastoodonphyobjmovingz#*80.0*timeelapsed#)

   `camvelx#=camvelx#+(camerastoodonphyobjmovingx#*(screen fps()*1.35)*timeelapsed#)
   `camvelz#=camvelz#+(camerastoodonphyobjmovingz#*(screen fps()*1.35)*timeelapsed#)

   camvelx#=camvelx#+(camerastoodonphyobjmovingx#*timeelapsed#)
   camvelz#=camvelz#+(camerastoodonphyobjmovingz#*timeelapsed#)
   endif
   lcamerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)
   lcamerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)
  endif
 endif

 remend

if camerastoodonphyobj<>0
    if object exist(camerastoodonphyobj)=0 then camerastoodonphyobj=0
   endif
   if camerastoodonphyobj<>0

    rem only influence of object beneath player borble
    if object position y(camerastoodonphyobj)<object position y(physicsplayerborble)

     if camerastoodrelativecoordinatex#=-1 or jumpaction<>0 or movement<>0
      camerastoodrelativecoordinatex#=mex#-object position x(camerastoodonphyobj)
      camerastoodrelativecoordinatez#=mez#-object position z(camerastoodonphyobj)
     else
      rem work out drift from original stood coordinate to where me is now
      tshouldbex#=object position x(camerastoodonphyobj)+camerastoodrelativecoordinatex#
      tshouldbez#=object position z(camerastoodonphyobj)+camerastoodrelativecoordinatez#
      camvelx#=camvelx#+((tshouldbex#-mex#)*10)
      camvelz#=camvelz#+((tshouldbez#-mez#)*10)
     endif
    endif

   else
    camerastoodrelativecoordinatex#=-1
   endif
  endif
 if tgravitydefeated=1
  if physicsdebug=1 then print "andgravitydefeated"
  rem a few cycles grace at start of level (avoid urg sound when retstart)
  if newlevelobjectivevoid=0
   rem player lands after a jump
   if (grav#<-60.0 and jumpaction=0) or (grav#<-40.0 and jumpaction<>0)

    rem player urg sound
    if playersound(plrid,11)>0 and playerunderwater=0 and tnearsurfaceofwater>=15
     broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0,-1)
     play sound playersound(plrid,11)
    endif
    rem deck plate sound too
    leapedlanded=1
   endif
   rem determine if fall hurt player
   if playerhurtfall>0 and playerunderwater=0 and tnearsurfaceofwater>=15
    if cty#<gravlasty#-playerhurtfall
     rem avoid hurt when using stairs
     tokayhurt=0
     if (abs(camvelx#)+abs(camvelz#)/2.0)<15.0
      tokayhurt=1
     else
      rem raycast behind plr (stairs would be there)
      tpmb#=-100.0
      tppx#=newxvalue(camerapositionx,camera angle y(),tpmb#)
      tppz#=newzvalue(camerapositionz,camera angle y(),tpmb#)
      tdst#=static raycast(camerapositionx,camerapositiony-phyeyeheight#,camerapositionz,tppx#,camerapositiony-phyeyeheight#,tppz#)
      if tdst#=0 then tokayhurt=1
     endif
     if playerunderwater=1 or tnearsurfaceofwater<15 then tokayhurt=0
     if gmultiplayergame=0 and playerunderwater=0 and tnearsurfaceofwater>=15
      rem cannot hurt by falling in arena game
      if tokayhurt=1
       rem level substantial different from last stood on ground
       tdamage=1+((abs(cty#-gravlasty#)-playerhurtfall)/5.0)
       gosub _player_takedamage
      endif
     endif
    endif
   endif
  endif
  rem record last ground player stood on
  gravlasty#=cty#
  rem landing sound
  jumpaction=0
 else
  if movement<>0 then onladder=0
 endif
 `
 rem Jump ends when camera starts decending
 rem V119 - this can freeze the player in mid-air
 `if jumpactionnorepeat=0 and camvel<0.0 then jumpaction=0


 `
 rem debug object
 if physicsdebug=1
  if object exist(98789)=0
   make object sphere 98789,20
   set object cull 98789,0
   set object wireframe 98789,1
   set object collision off 98789
  else
   position object 98789,ctx#,cty#-ellipsecentery#,ctz#
   scale object 98789,100,300*ellipsevolumesize#,100
  endif
 endif
 `
endif

rem new barrier code using physics force
if ctx#<25.0 then camvelx#=10.0
if ctz#>-25.0 then camvelz#=-10.0
if ctx#>(maxx*100.0)-25 then camvelx#=-10.0
if ctz#<(maxy*-100.0)+25 then camvelz#=10.0

rem Camera rotation speeds
if showgamemenu=0
 rem V110 - new freeze mode (PLRDISABLE) which stops player moving with mouselook
 `
 rem Mouse Input
 cammovex#=mousemovex() : cammovey#=mousemovey()
 if gmousesensitivity>0 and gmousesensitivity<100
  cammovex#=cammovex#/100.0 : cammovex#=cammovex#*gmousesensitivity
  cammovey#=cammovey#/100.0 : cammovey#=cammovey#*gmousesensitivity
 endif
 `
 rem U71 - Contoller
 if gxbox=1 : rem define in a config later
  jtx#=0 : jty#=0
  if gxboxcontrollertype=0
   jtx#=(joystick twist x()-32767.0)/(327.67*0.5)
   jty#=(joystick twist y()-32767.0)/327.67
  endif
  if gxboxcontrollertype=1
   jtx#=(joystick z()/10.0)
   jty#=(joystick twist z()-32767.0)/327.67
  endif
  if gxboxinvert=1 then jty#=jty#*-1.0
  rem FPGC - 280610 - infact, use flag to control it (XBOXMAG=200)
  `if abs(jtx#)>50.0 then cammovex#=jtx#/10.0
  if abs(jtx#)>50.0 then cammovex#=(jtx#*gxboxmag)/5.0
  `if abs(jty#)>50.0 then cammovey#=jty#/10.0 FPGC - 100310 - speed it up a bit
  if abs(jty#)>50.0 then cammovey#=jty#/2.0
 endif
 `
 if mefrozen>0 and mefrozentype=2 then cammovex#=0 : cammovey#=0
  dcamx#=cammovex# : dcamy#=cammovey#
else
 cammovex#=0 : cammovey#=0
endif
t=abs(cammovex#)+abs(cammovey#)
if t=1 then camrotspeed#=0.05
if t=2 then camrotspeed#=0.1
if t=3 then camrotspeed#=0.15
if t=4 then camrotspeed#=0.2
if t>=5 then camrotspeed#=0.25
`if plrzoomin#>0 then camrotspeed#=camrotspeed#/plrzoomin#
if plrzoomin#>0 then camrotspeed#=camrotspeed#/(plrzoomin#*firemode(gunid,firemode).settings.zoomturnspeed)

rem AirMod - Added for Weapon Recoil >>
gunRecoilAngleY# = curvevalue(gunRecoilY#,gunRecoilAngleY#,2)
gunRecoilY# = curvevalue(0,gunRecoilY#,1.5)
gunRecoilAngleX# = curvevalue(gunRecoilX#,gunRecoilAngleX#,2)
gunRecoilX# = curvevalue(0,gunRecoilX#,1.5)

gunRecoilCorrectY# = curvevalue(0,gunRecoilCorrectY#,3)
gunRecoilCorrectX# = curvevalue(0,gunRecoilCorrectX#,3)
gunRecoilCorrectAngleY# = curvevalue(gunRecoilCorrectY#,gunRecoilCorrectAngleY#,4)
gunRecoilCorrectAngleX# = curvevalue(gunRecoilCorrectX#,gunRecoilCorrectAngleX#,4)
rem AirMod - Done <<

rem GRAB VR920 tracker info once
if gvrmode<>0
 rem mode 2 = device driver filtering
 vrmodetrackerx#=get tracking pitch(2)
 vrmodetrackery#=get tracking yaw(2)
 vrmodetrackerz#=get tracking roll(2)
 if vrmodemag>0
  vrmodemagnifier#=vrmodemag : vrmodemagnifier#=vrmodemagnifier#/100.0
  vrmodetrackerx#=vrmodetrackerx#*vrmodemagnifier#
  vrmodetrackery#=vrmodetrackery#*vrmodemagnifier#
  vrmodetrackerz#=vrmodetrackerz#*vrmodemagnifier#
 endif
endif
if gvrmode>0
 rem VR920
 if scancode()=86 or inkey$()="\" then reset tracking
endif
if gvrmode=2 or gvrmode=3
 rem VR920
 rem VRMODE 2 and 3 turn player
 if gvrmode=2
  rem delta based turning
  ttrackerturn#=0
  if vrmodetrackery#>1 and vrmodetrackery#>lastttrackerturn#
   ttrackerturn#=vrmodetrackery#-lastttrackerturn#
  endif
  if vrmodetrackery#<-1 and vrmodetrackery#<lastttrackerturn#
   ttrackerturn#=abs(vrmodetrackery#-lastttrackerturn#)*-1
  endif
  lastttrackerturn#=vrmodetrackery#
  lastcamangy#=wrapvalue(lastcamangy#-ttrackerturn#)
 endif
 if gvrmode=3
  rem extreme head turning
  ttrackerturn#=vrmodetrackery#
  if abs(ttrackerturn#)>10
   if ttrackerturn#<-25 then ttrackerturn#=-25
   if ttrackerturn#>25 then ttrackerturn#=25
   ttrackerturn#=ttrackerturn#/5.0
   if ttrackerturn#<0 then ttrackerturn#=ttrackerturn#+2
   if ttrackerturn#>0 then ttrackerturn#=ttrackerturn#-2
   rem dampening when stop turning head
   if abs(vrmodetrackery#)<(abs(lastttrackerturn#)-4)
    ttrackerturn#=0 : rem ttrackerturn#/2
   endif
   lastttrackerturn#=vrmodetrackery#
   lastcamangy#=wrapvalue(lastcamangy#-ttrackerturn#)
  endif
 endif
 camangx#=0
 camangy#=lastcamangy#
else
 `
 rem FPGC - 220909 - Direct control replaced with interia control (for smoothing off at end) and halved the sensitivity
 `camangx#=camera angle x()+((cammovey#*camrotspeed#))
 `camangy#=camera angle y()+((cammovex#*camrotspeed#))
 camrotspeed#=camrotspeed#/2.0
 dcaminertiax#=(cammovey#*camrotspeed#)
 dcaminertiay#=(cammovex#*camrotspeed#)
 if abs(dcaminertiax#)>abs(caminertiax#) then caminertiax#=dcaminertiax#
 if abs(dcaminertiay#)>abs(caminertiay#) then caminertiay#=dcaminertiay#
 if abs(dcaminertiax#)<abs(caminertiax#) then caminertiax#=caminertiax#/1.9
 if abs(dcaminertiay#)<abs(caminertiay#) then caminertiay#=caminertiay#/1.9
 rem V118 - 130810 - knxrb - Invert Mouse
 if gminvert = 1
  camangx#=camera angle x()-caminertiax# - gunRecoilAngleY# + gunRecoilCorrectAngleY# : rem AirMod - Line Modified for Recoil
 else
  camangx#=camera angle x()+caminertiax# - gunRecoilAngleY# + gunRecoilCorrectAngleY# : rem AirMod - Line Modified for Recoil
 endif
 camangy#=camera angle y()+caminertiay# - gunRecoilAngleX# + gunRecoilCorrectAngleX# : rem AirMod - Line Modified for Recoil
 `
endif

rem Scene Commander, player wobbling

if wobble#<>0.0 and player(1).health>0
 wobbleangle#=wrapvalue(wobbleangle#+((2+rnd(4)+(11-wobble#))/10.0))
 camangx#=camangx#+cos(wobbleangle#*2.0)*wobble#*0.008*(sin(wobbleangle#)*1.2)
 camangy#=camangy#+sin(wobbleangle#*4.0)*wobble#*0.005
endif

rem Scene Commander end

rem FPSXCV104RC5 - zoom mode wobble based on accuracy

if plrzoomin#<>0.0
 plrzoomaccuracyangle#=wrapvalue(plrzoomaccuracyangle#+((2+rnd(4)+(11-plrzoomin#))/10.0))
 camangx#=camangx#+cos(plrzoomaccuracyangle#*2.0)*plrzoomaccuracy#*plrzoomin#*0.008*(sin(plrzoomaccuracyangle#)*1.2)
 camangy#=camangy#+sin(plrzoomaccuracyangle#*4.0)*plrzoomaccuracy#*plrzoomin#*0.005
endif
if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
 rem V118 - 270111 - mouselook view angles restricted when swimming, cannot swim directly UP or DOWN (collision issue)
 camangxweight#=55*cameradampen#
 if wrapvalue(camangx#)>55 and wrapvalue(camangx#)<180 then camangx#=55.0
 if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<360-camangxweight# then camangx#=camangxweight#*-1
else
 camangxweight#=85*cameradampen#
 if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
 if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<360-camangxweight# then camangx#=camangxweight#*-1
endif

rem used to swoosh to an angle (picking up object off-center)
if camturntofacemode>0
 camangy#=curveangle(camturntoface#,camangy#,10.0)
 dec camturntofacemode
endif

rem FINAL camera rotation update (not including VRMODE camera adjustment)
rotate camera camangx#,camangy#,camera angle z()

rem Mark player position in viscolmap
gosub _ode_mark

rem leave a trial for any enemies to follow
trailaction=0 : trailx#=camerapositionx : traily#=camerapositiony-phyeyeheight# : trailz#=camerapositionz
gosub _player_leavetrail

rem apply a visual adjustment to camera
if (player(plrid).health>0 or playerstartstrength=0) and peeklean#<>0.0
 peekadjx#=newxvalue(0,camera angle y(0)+90,peeklean#)
 peekadjz#=newzvalue(0,camera angle y(0)+90,peeklean#)
 if static raycast(camerapositionx,camerapositiony,camerapositionz,camerapositionx+peekadjx#,camerapositiony,camerapositionz+peekadjz#)=0
  camerapositionx=camerapositionx+peekadjx#
  camerapositionz=camerapositionz+peekadjz#
 else
  peekfreeze=1
 endif
endif

rem if sharp upward velocity (20+), and not jump
if jumpaction=0 and tnearsurfaceofwater>=15 and playerunderwater=0
 if camvely#>10
  rem ensure it is dampened so small floor features not send player high (window/door sills,etc)
  camvely#=10.0
 endif
endif

rem if borble ever leaves camera vicinity (ODE bug) restore
if physicsplayerborble>0
 if physicsdebug=1
  print "camera"
  print "x=";camerapositionx
  print "y=";camerapositiony
  print "z=";camerapositionz
  print
 endif
 if object exist(physicsplayerborble)=1
  `if physicsdebug=1
  ` print "borble"
  ` print "x=";object position x(physicsplayerborble)
  ` print "y=";object position y(physicsplayerborble)
  ` print "z=";object position z(physicsplayerborble)
  ` print
  ` print "volume"
  ` print "x=";ctx#
  ` print "y=";cty#
  ` print "z=";ctz#
  ` print
  `endif
  tborbdistx#=abs(object position x(physicsplayerborble)-camerapositionx)
  tborbdisty#=abs(object position y(physicsplayerborble)-camerapositiony)
  tborbdistz#=abs(object position z(physicsplayerborble)-camerapositionz)
  tborbdist1#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  `if physicsdebug=1
  ` print "borble distance=";tborbdist1#
  `endif
  tborbdistx#=abs(ctx#-camerapositionx)
  tborbdisty#=abs(cty#-camerapositiony)
  tborbdistz#=abs(ctz#-camerapositionz)
  tborbdist2#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  `if physicsdebug=1
  ` print "volume distance=";tborbdist2#
  `endif
  if tborbdist1#>100 or tborbdist2#>100
   `if physicsdebug=1
   ` print "Camera seperated from collision system"
   `endif
  endif
 endif
endif

Rem Scene Commander, moved for clarity and altered to allow for user adjustment
if watercurrent<>0
   if playerunderwater=1
      moveplrx#=moveplrx#+sin(watercurrent)*waterflow
      moveplrz#=moveplrz#+cos(watercurrent)*waterflow
   endif
endif

rem apply new velocities for future movement
if (player(plrid).health>0 or playerstartstrength=0) and mefrozen=0
 rem V109 BETA3 - remove fall velocity cap to create realistic gravity fall
  rem Scene Commander, add player velocity from moveplr commands
camvelx#=camvelx#+moveplrx#:moveplrx#=0
camvely#=camvely#+moveplry#:moveplry#=0
camvelz#=camvelz#+moveplrz#:moveplrz#=0
 rem cap these velocities to prevent borble fling away
 if camvelx#<-60 then camvelx#=-60
 if camvelx#>60 then camvelx#=60
 if camvelz#<-60 then camvelz#=-60
 if camvelz#>60 then camvelz#=60


 ode set linear velocity physicsplayerborble,camvelx#,camvely#,camvelz#

 ode set angular velocity physicsplayerborble,0,0,0
else
 rem ensures player does not slide away after died
 ode set linear velocity physicsplayerborble,0,0,0
 ode set angular velocity physicsplayerborble,0,0,0
endif

rem calculate some simply shake movement
camshakey#=0.0
if abs(camshake#)<>0
 camshakedir=1-camshakedir
 if camshakedir=0
  camshakey#=camshakey#+camshake#
 else
  camshakey#=camshakey#-camshake#
 endif
 if abs(camshake#)<1.0
  camshake#=0.0
 else
  camshake#=camshake#*0.9
 endif
endif

rem arena-eyes adjustment
if gmultiplayergame=1
 if crouchmode=0
  arenaadjustd#=-5.0
 else
  arenaadjustd#=2.0
 endif
else
 arenaadjustd#=0
endif
if movement<>0
 if playerunderwater=1 or (playerunderwater=0 and tnearsurfaceofwater<15)
  camerawobble#=wrapvalue(camerawobble#+(15.0*timeelapsed#))*deactivatecollision=1
 else
  camerawobble#=wrapvalue(camerawobble#+(30.0*timeelapsed#))*deactivatecollision=1
 endif
 if (plrkeySHIFT)=1 or (plrkeySHIFT2)=1
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.60)
 else
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.35)
 endif
else
 arenaadjust#=curvevalue(arenaadjustd#,arenaadjust#,5.0)
 camerawobble#=0.0
endif



rem finally update camera with smoothing (cty# is absolute staticvolume camypos)
finalcamy#=curvevalue(camerapositiony,camera position y(),2.0)
if finalcamy#>cty#-8 then finalcamy#=cty#-8
if playersystemdisabled=0
 position camera curvevalue(camerapositionx,camera position x(),2.0),finalcamy#+arenaadjust#+(camshakey#/10.0),curvevalue(camerapositionz,camera position z(),2.0)
endif

Rem Hockeykid - 250210 - DarkAI Set Player Container
for y=0 to 19
 if finalcamy# > container(y).y#-50.0 and finalcamy# < container(y).y#+50.0
  k=y
  ai set player container k : pcontainer=k : playercontain=k : exit
 endif
next y

rem update listener
gosub _ode_listener

return

_ode_listener:
 `
 rem handle player with affecting listener properties (full CPU intense)
 if 0
  position listener camera position x(0)/10.0,camera position y(0)/3.0,camera position z(0)/10.0
  rotate listener 0,camera angle y(0),0
 else
  rem quick approx. of listener position (CPU friendly)
  roughx=camera position x(0)/10.0 : roughx=(roughx/2)*2
  roughy=camera position y(0)/3.0 : roughy=(roughy/2)*2
  roughz=camera position z(0)/10.0 : roughz=(roughz/2)*2
  if roughx<>lastroughx or roughy<>lastroughy or roughz<>lastroughz
   lastroughx=roughx : lastroughy=roughy : lastroughz=roughz
   position listener roughx,roughy-5,roughz
  endif
  `rotate listener 0,camera angle y(0),0  `want my rotspeed back!
  roughaa=camera angle y(0)/22.0
  if roughaa<>lastroughaa
   rotate listener 0,roughaa*22,0
   lastroughaa=roughaa
  endif
 endif
 `
return

_ode_playerpickup:

rem Track which object closest
tclosestpickable=0
tcountclosestpickables=0
if tclosestpickable=0
 bestdst#=99999.9 : bestay#=360 : beste=0
 for e=1 to entityelementmax
  `if entityelement(e).eleprof.physics=1 and entityelement(e).active=1 100+=on lift!
  if (entityelement(e).eleprof.physics=1 or entityelement(e).eleprof.physics=101) and entityelement(e).active=1
   tobj=entityelement(e).obj
   if tobj>0
    if object exist(tobj)=1
     tdx#=object position x(tobj)-camerapositionx
     tdy#=(object position y(tobj)+(object size(tobj)/2))-camerapositiony
     tdz#=object position z(tobj)-camerapositionz
     td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     tda#=wrapvalue(atanfull(tdx#,tdz#)-camera angle y())
     tday#=wrapvalue(atanfull(tdy#,td#)+camera angle x())
     if tda#>180 then tda#=360-tda#
     if tday#>180 then tday#=360-tday#
     if tda#<15 and tday#<70
     rem Scene Commander gravity gun edit
      camerareachmax#=pickrange#
     if gunid<>0 and firemode(gunid,firemode).settings.gravitygun<>0
     camerareachmax#=firemode(gunid,firemode).settings.gravitygun
     endif

     Rem Scene commanders, gravity gun/magnet strength
     cameracarryweight#=laststrength#
     camerathrow#=lastthrow#
       if gunid<>0 and firemode(gunid,firemode).settings.gravitystrength<>0
      cameracarryweight#=(temp#/100.0)*firemode(gunid,firemode).settings.gravitystrength
      camerathrow#=firemode(gunid,firemode).settings.gravitystrength
      endif

      Rem Magnet strength supercedes gravity strength if in magnet mode.

      if gunid<>0 and firemode(gunid,firemode).settings.magnetstrength<>0
      cameracarryweight#=(temp#/100.0)*firemode(gunid,firemode).settings.magnetstrength
      camerathrow#=firemode(gunid,firemode).settings.magnetstrength
      endif

      if td#<camerareachmax#
       if entityelement(e).eleprof.phyweight<cameracarryweight#
        inc tcountclosestpickables
        if tday#<bestay#
         bestdst#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
         minsize#=25.0+(object size(tobj)/2)
         if bestdst#<minsize# then bestdst#=minsize#
         bestay#=tday# : beste=e : bestang#=atanfull(tdx#,tdz#)
        endif
       endif
      endif
     endif
    endif
   endif
  endif
 next e
 if beste>0
  tclosestpickable=beste
 endif
endif

rem AirMod - Make sure we are looking directly at object, so we don't pickup little things lying on ground >>>
if tclosestpickable > 0
 rem FPGC - 020810 - too accurate, causes difficulties locking on object right in front of user
 rem so only use this airmod enhancemement if there is more than one object to choose between
 rem and even then the best might not be the one in the center (so you end up not picking anything up), so..
 `tpickobject = pick object(screen width()/2,screen height()/2,entityelement(beste).obj,entityelement(beste).obj)
 if tcountclosestpickables>1
  for e=1 to entityelementmax
   if (entityelement(e).eleprof.physics=1 or entityelement(e).eleprof.physics=101) and entityelement(e).active=1
    tobj=entityelement(e).obj
    if tobj>0
     if object exist(tobj)=1
      tdx#=object position x(tobj)-camerapositionx
      tdy#=(object position y(tobj)+(object size(tobj)/2))-camerapositiony
      tdz#=object position z(tobj)-camerapositionz
      td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
      tda#=wrapvalue(atanfull(tdx#,tdz#)-camera angle y())
      tday#=wrapvalue(atanfull(tdy#,td#)+camera angle x())
      if tda#>180 then tda#=360-tda#
      if tday#>180 then tday#=360-tday#
      if tda#<15 and tday#<70
      Rem Scene Commander gravity gun edit
      if gunid<>0 and firemode(gunid,firemode).settings.gravitygun<>0
      camerareachmax#=firemode(gunid,firemode).settings.gravitygun
      else
      camerareachmax#=pickrange#
      endif
       if td#<camerareachmax#
        if entityelement(e).eleprof.phyweight<cameracarryweight#
         tpickobject = pick object(screen width()/2,screen height()/2,tobj,tobj)
         if tpickobject <> 0 then tclosestpickable=e : e=entityelementmax+1 : exit
        endif
       endif
      endif
     endif
    endif
   endif
  next e
 endif
endif
rem AirMod - Done <<<

rem PLR pickup/drop/throw
if camerapickup=1
 `
 tpickupkeystate=0
 `if keystate(20)=1 then tpickupkeystate=1
 if keystate(20)=1 and gunzoommode=0 then tpickupkeystate=1
 ``Rem Scene Commander gravity gun check
 if control_mouseclick_mode(1)=1 and gunzoommode=0 and firemode(gunid,firemode).settings.gravitygun<>0 then tpickupkeystate=2

 rem FPGC - 150310 - allow controller button B only as a possible right click
 if control_mouseclick_mode(1)=2 and gunzoommode=0 then tpickupkeystate=1
 `
 rem U71 - Contoller
 if gxbox=1 : rem define in a config later
  if joystick fire b()=1 then tpickupkeystate=1
 endif
 `
 if tpickupkeystate=1
  if camerapickupkeyrelease=0
   camerapickupkeyrelease=1
   if camerapicked=0
    if tclosestpickable>0
     `
     rem if object being stood on
     bendarm#=0 : armretract#=0
     if camerastoodonphyobj=entityelement(beste).obj
      rem try to push object away - can eventually pick it up
      thx#=newxvalue(0,camera angle y(),10.0)
      thy#=ode get body linear velocity y(entityelement(beste).obj)
      thz#=newzvalue(0,camera angle y(),10.0)
      ode set linear velocity entityelement(beste).obj,thx#,thy#,thz#
      rem this kicks the object forward to grab it again
      camerapickupkeyrelease=0
      rem realise player might fall - use gravity again
      physuspendgravity=0 : camforcey#=5.0
     else
      rem if not, pick up the object
      camerareach#=bestdst#
      camturntofacemode=5 : camturntoface#=bestang#
      camerapickedangle#=camturntoface#
      camerapickede=beste : camerapicked=entityelement(camerapickede).obj
      if entityelement(camerapickede).eleprof.physics>=100
       rem FPGC - 170610 - special physics flag when ent rides lift, but can pick it up by re-activating here
       if entityelement(camerapickede).collisionactive=0
        entityelement(camerapickede).collisionactive=1
        rem activate object collision
        if entityelement(camerapickede).eleprof.physics<>0
         tttobj=ttobj : ttte=e : tttentid=entid
         e=camerapickede
         gosub _ode_setupewithphysics
         gosub _ode_ensureeisnotpenetrated
         ttobj=tttobj : e=ttte : entid=tttentid
        else
         set object collision on camerapicked
        endif
       endif
       entityelement(camerapickede).eleprof.physics=entityelement(camerapickede).eleprof.physics-100
      endif
      ode set body rotation camerapicked,-1,-1,-1 : rem special hack to reset GRAB rotation matrix feature
      ode set body rotation camerapicked,0,0,0
      if cameradampenactive=1
       rem if player must slow down when carrying, dampen is the factor
       cameradampen#=cameracarryweight#/entityelement(camerapickede).eleprof.phyweight
       if cameradampen#<0.1 then cameradampen#=0.1
       if cameradampen#>1.0 then cameradampen#=1.0
      endif
      rem put weapon away - Scene commander edit
      if gunid<>0 and firemode(gunid,firemode).settings.gravitygun=0 and  firemode(gunid,firemode).settings.magnet=0 then gunmode=31 : gunselectionafterhide=0
      rem object reduces mess so not pushing other objects around (inc player)
      ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight/10.0
      rem player takes on mass of object
      ode set body mass physicsplayerborble,physicsplayerweight#+entityelement(camerapickede).eleprof.phyweight
      rem ensure new shadow depth created for object that needs to cast 75.depth area
      shadowobj(camerapicked)=2
     endif
     `
    endif
   else
    rem FPGC - 150310 - prevent the drop if FPGC mode and within range of
    rem something that is requesting a [ENTER] key press
    if fpgcgenre=0
     if gplayercanpressenterhere=0
      camerapickeddrop=1
     endif
    else
     camerapickeddrop=1
    endif
   endif
  endif
 else
  camerapickupkeyrelease=0
 endif
endif
rem if anything hides it, drop it
if camerapicked>0
 if object visible(camerapicked)=0 or static raycast(object position x(camerapicked),object position y(camerapicked),object position z(camerapicked),object position x(camerapicked),object position y(camerapicked)+(object size y(camerapicked)/2)+20,object position z(camerapicked))
  camerapickedthrown=0
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif
if camerapicked>0
 rem work out difference between actual and ideal position
 tdx#=holdx#-object position x(camerapicked)
 tdy#=(holdy#-object position y(camerapicked))-0.75
 tdz#=holdz#-object position z(camerapicked)
 tdd1#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
 rem and work out movement of item by mouse
 tdx#=abs(holdx#-lastholdx#)
 tdy#=abs(holdy#-lastholdy#)
 tdz#=abs(holdz#-lastholdz#)
 tdd2#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
 tmv#=curvevalue(tdd2#,tmv#,10.0)
 if cameraholding=1
  rem if confirmed as carrying
  tdx1#=holdx#-camera position x()
  tdy1#=holdy#-camera position y()
  tdz1#=holdz#-camera position z()
  tdx2#=object position x(camerapicked)-camera position x()
  tdy2#=object position y(camerapicked)-camera position y()
  tdz2#=object position z(camerapicked)-camera position z()
  rem work out difference in angles
  tbendarm1#=atanfull(tdx1#,tdz1#)
  tbendarm#=(atanfull(tdx2#,tdz2#)-tbendarm1#)
  if tdd1#>=2.0
   rem bend arm if resistance between actual and ideal
   if tmv#<1.0 then bendarm#=bendarm#+tbendarm#
   rem retract arm if stress greater than retraction value
   if tdd1#>armretract# then armretract#=tdd1#
  endif
  rem only once held, see if head inside item
  tamountinside#=object size(camerapicked)-sqrt(abs(tdx2#*tdx2#)+abs(tdy2#*tdy2#)+abs(tdz2#*tdz2#))
  if tamountinside#>0
   if tamountinside#>5 then tamountinside#=5
   if bendarm#<0.0
    bendarm#=bendarm#-(tamountinside#*2)
   else
    bendarm#=bendarm#+(tamountinside#*2)
   endif
  endif
 else
  rem confirm carrying?
  if tdd1#<8.0 then cameraholding=1
 endif
 rem retract arm if carry item into wall/obstacle
 bendreduce#=50.0
 if bendarm#<0 and cammovex#<0 then bendreduce#=50.0+(cammovex#*3)
 if bendarm#>0 and cammovex#>0 then bendreduce#=50.0-(cammovex#*3)
 if bendreduce#<1.0 then bendreduce#=1.0
 bendarm#=curvevalue(0,bendarm#,bendreduce#)
 armretract#=curvevalue(0,armretract#,50.0)
 rem carry
 holdangley#=camera angle y()+bendarm#
 lastholdx#=holdx# : lastholdy#=holdy# : lastholdz#=holdz#
 holdx#=newxvalue(camerapositionx,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
 holdy#=newxvalue(camerapositiony-(object size(camerapicked)/3.0),0-camera angle x(),(camerareach#+camerareachatrun#)-armretract#)-((entityelement(camerapickede).eleprof.phyweight/100.0)*(1.0-cameradampen#))
 holdz#=newzvalue(camerapositionz,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
 tangle#=wrapvalue(camera angle y()-camerapickedangle#)
 ode set body rotation camerapicked,0,tangle#,0
 bendspeed#=4.0
 tholdforcex#=(holdx#-object position x(camerapicked))*bendspeed#
 tholdforcey#=(holdy#-object position y(camerapicked))*bendspeed#
 tholdforcez#=(holdz#-object position z(camerapicked))*bendspeed#
 rem if arm is bend to far, drop item with zero velocity
 if abs(bendarm#)>50 then camerapickeddrop=1 : tholdforcex#=0 : tholdforcey#=0 : tholdforcez#=0
 ode set linear velocity camerapicked,tholdforcex#,tholdforcey#,tholdforcez#
 rem set shadow on carried object
 entityelement(camerapickede).floorposy=camerapositiony-(object size(camerapicked)*3)
 `
 rem FPGC - 150310 - throw handles by controller aware function
 if control_mouseclick_mode(1)=1 then camerapickeddrop=1 : camerapickedthrown=1
 `
 rem U71 - Contoller
 if gxbox=1 : rem define in a config later
  if gxboxcontrollertype=0
   if joystick z()>500 then camerapickeddrop=1 : camerapickedthrown=1
  endif
  if gxboxcontrollertype=1
   if joystick fire x(4)=1 or joystick fire x(6)=1 then camerapickeddrop=1 : camerapickedthrown=1
  endif
 endif
 `
 rem drop
 if camerapickeddrop=1
  rem restore object and pickup states
  camerapickeddrop=0
  if camerapickedthrown=1
   rem calc throw distance, elevation and final velocity
   throwdistance#=(entityelement(camerapickede).eleprof.phyweight/1000.0)
   tthrowheight#=((camerathrowelev#+sin(camera angle x())*-100)/throwdistance#)
   throwdistance#=camerathrow#/throwdistance#

   taddx#=camvelx# : taddy#=camvely# : taddz#=camvelz#


   rem scene commander edit -

   if firemode(gunid,firemode).settings.gravitygun=0 or firemode(gunid,firemode).settings.magnet=0
   ode set linear velocity camerapicked, taddx#+sin(camera angle y())*throwdistance#,taddy#+tthrowheight#,taddz#+cos(camera angle y())*throwdistance#
   endif

   if firemode(gunid,firemode).settings.magnet=1
   ode set linear velocity camerapicked, taddx#+sin(wrapvalue(camera angle y()+180))*throwdistance#,taddy#+tthrowheight#,taddz#+cos(wrapvalue(camera angle y()+180))*throwdistance#
   endif

   if entityelement(camerapickede).eleprof.rotatethrow<>0
    trotate#=entityelement(camerapickede).eleprof.rotatethrow
    ode set angular velocity camerapicked, ((rnd(1)*2.0)-1.0)*trotate#, 0, ((rnd(1)*2.0)-1.0)*trotate#
   endif
   rem reset throw
   camerapickedthrown=0
  endif
  rem restore object max
  ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight
  rem player restores mass
  ode set body mass physicsplayerborble,physicsplayerweight#
  rem reset final values for camera pickup
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif

return

_ode_sounds:
 `
 rem Collision with objects causes borble to change player position
 tgravitydefeatedbyphy=0
 while ODE COLLISION MESSAGE EXISTS()
  `
  rem collision event
  ODE COLLISION GET MESSAGE
  phya=ODE GET OBJECT A() : phyb=ODE GET OBJECT B()

  if (phya=physicsplayerborble or phyb=physicsplayerborble)
  rem player phyobject stood on another phy object
  tdownward#=0.0 : ttouchedobj=0 : toverallveldiff#=0
  if (phya=physicsplayerborble and phyb<>0) then tdownward#=ODE GET OBJECT A VELOCITY Y() : ttouchedobj=phyb : toverallveldiff#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y())+abs(ODE GET OBJECT B VELOCITY Z())
  if (phyb=physicsplayerborble and phya<>0) then tdownward#=ODE GET OBJECT B VELOCITY Y() : ttouchedobj=phya : toverallveldiff#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y())+abs(ODE GET OBJECT A VELOCITY Z())
  if ttouchedobj<>0 and ttouchedobj=camerapicked then lastttouchede=ttouchede
  if ttouchedobj<>0 and ttouchedobj<>camerapicked
   ttouchede=phyobjele(ttouchedobj)
   if ttouchede>0
    entid=entityelement(ttouchede).bankindex
    colmaterialtype=entityprofile(entid).materialindex-1
    if tdownward#<2.0
     rem player landed on physics object, so register this and use gravity again
     tgravitydefeatedbyphy=ttouchedobj
     tgravitydefeatedbyphye=ttouchede
     physuspendgravity=0
    endif
    ttspeedatwhichurt#=120.0
    if toverallveldiff#>ttspeedatwhichurt#
     if ttouchede<>lastttouchede
      rem player damage if entity moving at force (uses phyforcedamage)
      tdamage=((toverallveldiff#-ttspeedatwhichurt#)/10.0) : if tdamage<1 then tdamage=1
      magnifydamage#=entityelement(ttouchede).eleprof.phyforcedamage/100.0
      tdamage=tdamage*magnifydamage# : gosub _player_takedamage
      lastttouchede=ttouchede
     endif
    else
     rem object not hitting player any more
     if lastttouchede=ttouchede
      lastttouchede=0
     endif
    endif
   endif
  endif

  rem sounds processd here too
  bangobj=0
  bangcontact=0
  phyvelocity#=0
  phytotalvelocity#=0
  phyhorizontalscrape=0
  if phya<>0
   bangobj=phya : bangotherobj=phyb
   phyvelocity#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y()/4)+abs(ODE GET OBJECT A VELOCITY Z())
   phyvelocity#=phyvelocity#+abs(ODE GET OBJECT A ANGULAR VELOCITY X())+abs(ODE GET OBJECT A ANGULAR VELOCITY Y())+abs(ODE GET OBJECT A ANGULAR VELOCITY Z())
   if bangobj<>physicsplayerborble
    bangcontact=ODE GET OBJECT A CONTACT()
    if bangcontact<>0
     phyfloorstop#=ODE GET OBJECT A VELOCITY Y()
     if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
      phyhorizontalscrape=1
     endif
     phylastfloorstop#(bangobj)=phyfloorstop#
    endif
   endif
   phyvelocitya#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocitya#=0
  endif
  if phyb<>0
   bangobj=phyb : bangotherobj=phya
   phyvelocity#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y()/4)+abs(ODE GET OBJECT B VELOCITY Z())
   phyvelocity#=phyvelocity#+abs(ODE GET OBJECT B ANGULAR VELOCITY X())+abs(ODE GET OBJECT B ANGULAR VELOCITY Y())+abs(ODE GET OBJECT B ANGULAR VELOCITY Z())
   if bangobj<>physicsplayerborble
    bangcontact=ODE GET OBJECT B CONTACT()
    if bangcontact<>0
     phyfloorstop#=ODE GET OBJECT B VELOCITY Y()
     if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
      phyhorizontalscrape=1
     endif
     phylastfloorstop#(bangobj)=phyfloorstop#
    endif
   endif
   phyvelocityb#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocityb#=0
  endif
  if bangobj<>0 and bangobj<>physicsplayerborble and bangobj<>camerapicked
   phyimpact#=abs(phyvelocity#-phyobjvelocity#(bangobj))
   phyimpactstop#=phyobjvelocity#(bangobj)-phyvelocity#
   phyobjvelocity#(bangobj)=phyvelocity#
   rem deal with damage of colliding objects
   phymagnitude#=0
   rem ensure player is not a damaging physics object (as stealth may require sliding along windows)
   e1=0 : e1m#=0
   if bangobj>0 and bangobj<>physicsplayerborble
    e1=phyobjele(bangobj) : if e>0 then e1m#=entityelement(e1).health*5
   endif
   e2=0 : e2m#=0
   if bangotherobj>0 and bangotherobj<>physicsplayerborble
    e2=phyobjele(bangotherobj) : if e2>0 then e2m#=entityelement(e2).health*5
   endif
   rem or very weak objects that will break under duress (duress caused by size and speed of fragile object)
   if e1m#>20 then e1m#=20
   if e2m#>20 then e2m#=20
   if bangcontact=1
    if phyvelocitya#>e1m# and e1>0 and entityelement(e1).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
    if phyvelocityb#>e2m# and e2>0 and entityelement(e2).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
   endif
   rem collision with raised velocity
   if phytotalvelocity#>20.0
    if phya<>0 and phyb<>0
     if bangobj=physicsplayerborble or bangotherobj=physicsplayerborble
      rem if window strength 1-4, player CAN smash it through by running into it
      if e1>0 and entityelement(e1).health>=5 then e1=0
      if e2>0 and entityelement(e2).health>=5 then e2=0
     endif
     rem only deal damage to immobile objects (as movable ones can get out the way before damage)
`     if e1>0 and entityelement(e1).eleprof.isimmobile=1 then e2=0 : phymagnitude#=object size(bangotherobj)
 `    if e2>0 and entityelement(e2).eleprof.isimmobile=1 then e1=0 : phymagnitude#=object size(bangobj)
     rem FPSCV104RC7 - moving entities CAN cause damage if damage force high enough
     if e1>0
      magnifydamage#=entityelement(e1).eleprof.phyforcedamage/12.0
      phymagnitude#=magnifydamage#
     endif
     if e2>0
      magnifydamage#=entityelement(e2).eleprof.phyforcedamage/12.0
      if magnifydamage#>phymagnitude#
       phymagnitude#=magnifydamage#
      endif
     endif
    endif
   endif
   `
   rem bangobj e
   e=phyobjele(bangobj)
   if e>0
    rem entity profile id
    entid=entityelement(e).bankindex
    rem only deal damage if neither object part of player-carry-collisio n
    if camerapicked>0 and (bangobj=camerapicked or bangotherobj=camerapicked)
     phymagnitude#=0.0
    endif
    rem only allow damage if other object is NOT a debris fragment
    if bangotherobj>0 and bangotherobj<=array count(phyobjele())
     if phyobjele(bangotherobj)=0 then phymagnitude#=0.0
    endif
    rem if magnitude high enough, cause damage
    if phymagnitude#>10.0
     rem damage both objects involved in impact
     tdamage=(phymagnitude#-10.0) : tdamagesource=0 : timpacttype=1
     if tdamage>2 and tdamagebybangcount=0
      rem entity damage here
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
      if e1>0 then e=e1 :entityelement(e).shotby=993: entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
      if e2>0 then e=e2 :entityelement(e).shotby=993: entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
     endif
     rem bangobj e refresh
     e=phyobjele(bangobj)
     entid=entityelement(e).bankindex
    endif
    rem deal with sound
    matindex=entityprofile(entid).materialindex-1
    if matindex>=0 and matindex<=gmaterialmax
     rem monitor travelling value
     ttravelled#=0.0
     if phyhorizontalscrape=1
      rem as long as no sudden stopping, continue travel value for scrape
      if bangobj=phya then ttravelled#=phyvelocitya#
      if bangobj=phyb then ttravelled#=phyvelocityb#
     endif
     rem impact controls volume
     tvol#=100 : rem (phyimpact#-1.0)*10.0 : if tvol#>100.0 then tvol#=100.0
     tspd#=material(matindex).freq+rnd(material(matindex).freq/10.0)
     sbase=0
     rem only play impact if slowed/stopped and was
     if phyimpactstop#>0 and phyimpact#>4.0
      sbase=material(matindex).impactid
     endif
     if ttravelled#>10.0
      if phylasttravelled#(bangobj)>10.0
       rem continuation of travel, switch to scrape
       sbase=material(matindex).scrapeid
       tvol#=ttravelled#*2.0 : if tvol#>100.0 then tvol#=100.0
      endif
     endif
     phylasttravelled#(bangobj)=ttravelled#
     rem play sound of material impact
     if sbase>0
      for tchannels=0 to 4
       s=sbase+tchannels
       if sound exist(s)=1
        if sound playing(s)=0 and phyobjsounding(bangobj)=0
         playinternalBC3dsound(s,object position x(bangobj),object position y(bangobj),object position z(bangobj),25.0)
         phyobjsounding(bangobj)=5
         set sound volume s,80.0+(tvol#*0.2)
         if tspd#>2000 then set sound speed s,tspd#+soundfrequencymodifier
         exit
        endif
       endif
      next tchannels
     endif
    endif
    if phyimpact#>2.0
     rem adjust entity floor position (for shadow calc)
     entityelement(e).floorposy=object position y(bangobj)-(object size y(bangobj)/2)
     rem recalc adjustment for objects that must find the floor perfectly
     if entityelement(e).eleprof.physics=1
      centx#=ODE GET BODY ADJUSTMENT X(bangobj)
      centy#=ODE GET BODY ADJUSTMENT Y(bangobj)
      centz#=ODE GET BODY ADJUSTMENT Z(bangobj)
      tprofileobj=entityelement(e).profileobj
      offset limb bangobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
     endif
    endif
    if phyobjsounding(bangobj)>0 then phyobjsounding(bangobj)=phyobjsounding(bangobj)-1
   else
    rem physics object has no entity (can only be debris particle)
    if phya>0 and phya<physicsuniverseobj
     if object in screen(phya)=0
      rem remove from simulation if not in screen
      ode destroy object phya
      hide object phya
     endif
    endif

   if phyb>0 and phyb<physicsuniverseobj
     if object in screen(phyb)=0
      rem remove from simulation if not in screen
      ode destroy object phyb
     hide object phyb
    endif
   endif
    `
   endif
   `
  endif

  endif
  `
 endwhile
 `
 rem Reduce bang damage counter (so bang damage does not machine gun and drain all entity health)
 if tdamagebybangcount>0
  dec tdamagebybangcount
 endif


 `

 rem also handle shadows
 gosub _ode_shadowcontrol
 `
 rem now go through all objects to see how they react in water out of water
 gosub _ode_waterandgravity
 `
return

_ode_shadowcontrol:
 `
 rem for out of universe error if no debug cursor reset
 if physicsdebug=0 then set cursor 0,0
 `
 rem adjust shadows of all physics objects
 for e=1 to entityelementmax
  tobj=entityelement(e).obj
  tflag=0
  tentid=entityelement(e).bankindex
  if entityelement(e).eleprof.physics=1 and tobj>0 then tflag=1
`  if gdynamicshadowsstate=1 and entityelement(e).eleprof.castshadow=1
  if tflag=1
   `
   rem activate object shadow (if camera can see its floor)
   if entityprofile(tentid).ischaracter=1 then tflag=0
   if tflag=1
    if gdynamicshadowsstate>0
     if shadowobj(tobj)=2
      rem reset shadow for carrying
      shadowobj(tobj)=0
     endif
     if shadowobj(tobj)=0
      if camerapositiony>entityelement(e).floorposy
       if object size z(tobj)<0.1
        rem ultra thin objects (glass) cannot cast shadow yet
       else
        tobjshadowreach#=ode get body height(tobj)
        if camerapicked=tobj
         rem the 75 is for when carrying the object
         tobjshadowreach#=tobjshadowreach#+75
        else
         rem the 4.5 is for the very top of objects to find and penetrate the floor (min thickness 5.0 units)
         tobjshadowreach#=tobjshadowreach#+4.5
        endif
        set shadow shading off tobj
        set shadow shading on tobj,-1,tobjshadowreach#,gdynamicshadowsstate-1
        shadowobj(tobj)=1
       endif
      endif
     endif
     if shadowobj(tobj)=1
      if camerapositiony<entityelement(e).floorposy
       rem keep self-shadow by switching off, then on but with small non-intrusive range
       set shadow shading off tobj
       set shadow shading on tobj,-1,1.0,gdynamicshadowsstate-1
       shadowobj(tobj)=0
      endif
     endif
    endif
   endif
   `
   rem if object needs destroying, do it here
   if phyobjremove(tobj)<>0
    rem used when want to disturb another phy obj (ie move up slightly, then remove on next pass)
    if phyobjremove(tobj)=1
     rem this will nudge anything sitting on obj
     ode set linear velocity phyobjremove(tobj),0,10,0
     phyobjremove(tobj)=2
    else
     if phyobjremove(tobj)=2
      rem this will nudge anything sitting on obj further
      ode set linear velocity phyobjremove(tobj),0,5,0
      phyobjremove(tobj)=3
     else
      rem this finally removes the phy obj from the simulation
      gosub _ode_switchoffe
      phyobjremove(tobj)=0
      rem and then hide the object if not already hidden
      hide object tobj
     endif
    endif
   endif
   `
   rem serious error, object has left the universe (through hole in geom!)
   if showfpsinrealgame=2
    if object position y(tobj)<-20
     position object tobj,object position x(tobj),-25,object position z(tobj)
     print "Object ";e;entityelement(e).eleprof.name$;" has left the universe at ";str$(int(object position x(tobj)));",";str$(int(object position z(tobj)))
    endif
   endif
   `
  endif
 next e
 `
return

_ode_waterandgravity_item:
 `
 rem obj is twaterobj, optional e
 rem if have associated entity
 twatere=phyobjele(twaterobj)
 rem depth of surface resistance
 depth#=40.0
 rem if deep enough to cover entity, switch gravity off
 tactualtopofobject#=object position y(twaterobj)+(object size y(twaterobj)/2.0)
 if twatere>0
  rem if character, test higher
  if entityprofile(entityelement(twatere).bankindex).ischaracter=1
   tactualtopofobject#=tactualtopofobject#+25.0
  endif
 endif
 rem object's origin is centered
 if object position y(twaterobj)<waterheight#
  rem no gravity
  `if physxedition=1
   `entityelement(twatere).nogravity=1
   `ttobj=twaterobj : ode set gravity ttobj,0
 ` else
   ode set gravity twaterobj,0
  `endif
  rem current velocity of entity (natural damping)
  tvelokay=1
  if tvelokay=1
   rem regular underwater handling
   oldvelx#=ODE GET BODY LINEAR VELOCITY X(twaterobj)*0.97
   oldvely#=ODE GET BODY LINEAR VELOCITY Y(twaterobj)*0.97
   oldvelz#=ODE GET BODY LINEAR VELOCITY Z(twaterobj)*0.97
   rem resist zero gravity and entity leaves surface of water (very subtle!)
   if object position y(twaterobj)>waterheight#-depth#
    `resistby#=depth#-abs(object position y(twaterobj)-waterheight#)
    `oldvely#=oldvely#-(resistby#*0.0005)
   endif
   rem raise/lower entity based on weight (750 = 10x10x10 cube) (based on depth)
   depthfactor#=abs(object position y(twaterobj)-waterheight#)/100.0
   if twatere>0
    depthdecent#=((entityelement(twatere).eleprof.phyweight-2000)/5000.0)*depthfactor#
    oldvely#=oldvely#-depthdecent#
   else
    rem if not entity (debris or ragdoll) sink
    depthdecent#=0.0001
    oldvely#=oldvely#-0.0001
   endif
  endif
  rem 220707 - random chaos in water based on water speed
  hudwaterspeed=waterbump#
  if hudwaterspeed>0
   rem nudge in X and Z randomly factored by water speed
   tnudge#=((depthdecent#/25.0)*(hudwaterspeed+0.1))
   cyclicchaos#=cyclicchaos#+0.03
   if rnd(5)<>1 then tnudge#=0.0
   oldvelx#=oldvelx#+(cos(cyclicchaos#)*tnudge#)
   oldvelz#=oldvelz#+(sin(cyclicchaos#)*tnudge#)
  endif
  rem finally apply new velocity
  ode set linear velocity twaterobj,oldvelx#,oldvely#,oldvelz#
 else
  rem gravity on
  ode set gravity twaterobj,1
 endif
 `
return

_ode_waterandgravity:
 `
 if wateron=0 then return
 rem go through all entities
 for e=1 to entityelementmax
  twaterobj=entityelement(e).obj
  if twaterobj>0
   if entityelement(e).eleprof.physics=1
    rem only physics objects that are subject to ODE gravity
    twatere=e : gosub _ode_waterandgravity_item
   endif
  endif
 next e
 `
 rem go through all debris
 for twaterobj=fragmentobjectoffset to fragmentobjectoffsetmax
  if object exist(twaterobj)=1
   if object visible(twaterobj)=1
    if twaterobj>0
     twatere=0 : gosub _ode_waterandgravity_item
    endif
   endif
  endif
 next twaterobj
 `
return

_ode_applyforce:
 `
 rem takes todee,tdx#,tdy#,tdz#,todeforce#,todefalloff#,tpx#,tpy#,tpz#
 tobj=entityelement(todee).obj
 if tobj>0
  td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
  tdx#=tdx#/td# : tdy#=tdy#/td# : tdz#=tdz#/td#
  todeforce#=todeforce#*10.0 : rem equate to non-physics force
  tbulletforce#=(todeforce#/500.0)*(500.0-td#)*todefalloff#
  tbulletforce#=tbulletforce#+(todeforce#*(1.0-todefalloff#))
  massconsideration#=entityelement(todee).eleprof.phyweight/200.0
  if massconsideration#<1.0 then massconsideration#=1.0
  tbulletforce#=tbulletforce#/massconsideration#
  tdx#=tdx#*tbulletforce#
  tdy#=tdy#*tbulletforce#
  tdz#=tdz#*tbulletforce#
  rem limit force to size of object units of velocity (max)
  if object size(tobj)<21
   tmax#=20.0+((object size(tobj)/21.0)*40.0)
  else
   tmax#=60.0
  endif
  ttt#=(abs(tdx#)+abs(tdy#)+abs(tdz#))/3.0
  if ttt#>tmax# then ttt#=ttt#/tmax# else ttt#=1.0
  tdx#=tdx#/ttt# : tdy#=tdy#/ttt# : tdz#=tdz#/ttt#
  if twithpointforce=1
   ode add force tobj,tdx#,tdy#,tdz#,tpx#,tpy#,tpz#
  else
   tda#=atanfull(tdx#,tdz#)
   ode set linear velocity tobj,tdx#,tdy#,tdz#
   tspinforce#=tbulletforce#/50.0
   ode set angular velocity tobj,sin(tda#)*(10*tspinforce#),0,cos(tda#)*(10*tspinforce#)
  endif
 endif

 `
return

_ode_applypointforce:
 `
 rem apply point force (tpx#,tpy#,tpz#)
 twithpointforce=1
 gosub _ode_applyforce
 `
return

_ode_entitydrivenphysics:
 `
 rem use entity data to drive object via physics (character)
 todeobj=entityelement(todee).obj
 tmvx#=entityelement(todee).x-object position x(todeobj)
 todeentid=entityelement(todee).bankindex
 tmvszy#=(object size y(todeobj)/2)*(entityprofile(todeentid).scale/100.0)
 rem X9 V109 BETA1 - 140308 - some models are centered differently and so need to be raised to meet the floor 'raisefactor'
 `tmvy#=(entityelement(todee).y+tmvszy#+thover#)-object position y(todeobj)
 tmvy#=(entityelement(todee).y+entityprofile(todeentid).raisefactor+tmvszy#+thover#)-object position y(todeobj)
 tmvz#=entityelement(todee).z-object position z(todeobj)
 tstress#=sqrt(abs(tmvx#)+abs(tmvy#)+abs(tmvz#))
 ode set linear velocity todeobj,tmvx#*4,tmvy#*4,tmvz#*4
 if entityelement(todee).norotate=0
  ode set body rotation todeobj,0,entityelement(todee).ry,0
 else
  ode set body rotation todeobj,0,0,0
 endif
 `
return

_ode_entitydrivenstaticphysics:
 `
 rem as above but for the pseudo-static objects (door/window)
 todeobj=entityelement(todee).obj
 if entityelement(todee).norotate=0
  ode set body rotation todeobj,0,entityelement(todee).ry,0
 else
  ode set body rotation todeobj,0,0,0
 endif
 `
return

_ode_update:
 `
 rem debug info on entities
 if physicsdebug=1
  for e=1 to entityelementmax
   if entityelement(e).active=1
    if entityelement(e).eleprof.physics<>0
     tobj=entityelement(e).obj
     if tobj>0
      if object exist(tobj)=1
       if object in screen(tobj)=1
        center text object screen x(tobj),object screen y(tobj),"size="+str$(object size(tobj))
        center text object screen x(tobj),object screen y(tobj)+16,"weight="+str$(entityelement(e).eleprof.phyweight)
        if e=tclosestpickable
         center text object screen x(tobj),object screen y(tobj)-16,"CLOSEST="+str$(camerareach#)
        endif
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 `
 rem update physics (FPGC - 210210 - new ODE requires only one timer based update call)
 `for phy=1 to 2 : ode update : next phy

 ode update
 `
 rem for next run - debug readouts
 if physicsdebug=1 then set cursor 0,80
 `
return

_physics_setvelocity:
 ode set linear velocity ttobj,ttx#,tty#,ttz#
return

rem
rem Particles (debris, fragments, particles, damage)
rem

_part_init:

rem Setup particles
gosub _part_initexploders

rem Setup fragment objects

rem SCIFI
rem Crate
debrisshapeindex=1
i=debrisshapeindex
bitdetails(debrisshapeindex).max=6
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cratec\crate_c"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=-15
bitoffset(i,3).x#=15 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=0
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=15
bitoffset(i,5).x#=-15 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=0
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=30 : bitoffset(i,6).z#=0
rem Gas Canister
debrisshapeindex=2
i=debrisshapeindex
bitdetails(debrisshapeindex).max=2
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cylindera\cylinder_a"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=24 : bitoffset(i,2).z#=0
rem Cylinder
debrisshapeindex=3
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cylinderb\cylinder_b"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=3 : bitoffset(i,2).y#=17 : bitoffset(i,2).z#=6
bitoffset(i,3).x#=-8 : bitoffset(i,3).y#=17 : bitoffset(i,3).z#=3
bitoffset(i,4).x#=-3 : bitoffset(i,4).y#=17 : bitoffset(i,4).z#=-8
bitoffset(i,5).x#=8 : bitoffset(i,5).y#=17 : bitoffset(i,5).z#=-5
`
rem WW2
rem Bottle
debrisshapeindex=4
i=debrisshapeindex
bitdetails(debrisshapeindex).max=3
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\itemb\item_b"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=7 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=14 : bitoffset(i,3).z#=0
rem CrateC
debrisshapeindex=5
i=debrisshapeindex
bitdetails(debrisshapeindex).max=7
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratec\crate_c"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=-15 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=-15
bitoffset(i,4).x#=15 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=0
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=15
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=15 : bitoffset(i,6).z#=15
bitoffset(i,7).x#=0 : bitoffset(i,7).y#=30 : bitoffset(i,7).z#=0
rem CrateE
debrisshapeindex=6
i=debrisshapeindex
bitdetails(debrisshapeindex).max=6
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratee\crate_e"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=-15 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=-15
bitoffset(i,4).x#=15 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=0
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=15
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=30 : bitoffset(i,6).z#=0
rem CrateF
debrisshapeindex=7
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratef\crate_f"
bitoffset(i,1).x#=-16 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=-11
bitoffset(i,2).x#=-16 : bitoffset(i,2).y#=2 : bitoffset(i,2).z#=6
bitoffset(i,3).x#=16 : bitoffset(i,3).y#=1 : bitoffset(i,3).z#=0
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=10 : bitoffset(i,4).z#=2
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=5 : bitoffset(i,5).z#=-4
rem CylinderF
debrisshapeindex=8
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cylinderf\cylinder_f"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=12 : bitoffset(i,2).z#=-6
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=13 : bitoffset(i,3).z#=5
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=24 : bitoffset(i,4).z#=-10
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=24 : bitoffset(i,5).z#=8

rem Load the fragment objects (three sets of each)
fragmento=fragmentobjectoffset
for debrisshapeindex=1 to 8
 `
 rem V109 BETA5 - 250408 - load if used in game
 if debrisshapeindexused(debrisshapeindex)=0
  `
  rem not used in game
  bitdetails(debrisshapeindex).fragmentobjstart=0
  `
 else
  `
  rem use original to get fragment complete size
  o$=bitdetails(debrisshapeindex).file$+".x"

  rem V109 BETA6 - replaced X file load with optional DBO convert/load
  `addfiletocollection(o$)
  `load object o$,fragmento
  if lower$(right$(o$,2))=".x" then tdbofile$=left$(o$,len(o$)-2)+".dbo" else tdbofile$=""
  if file exist(o$)=1 or file exist(tdbofile$)=1
   if file exist(tdbofile$)=1
    o$=tdbofile$
    tdbofile$=""
   endif
   load object o$,fragmento
   set object filter fragmento,2
   if len(tdbofile$)>1
    save object tdbofile$,fragmento
    if file exist(tdbofile$)=1
     delete object fragmento
     load object tdbofile$,fragmento
     set object filter fragmento,2
     o$=tdbofile$
    endif
   endif
   addfiletocollection(o$)
  endif
  `
  bitdetails(debrisshapeindex).sizex=object size x(fragmento)
  bitdetails(debrisshapeindex).sizey=object size y(fragmento)
  bitdetails(debrisshapeindex).sizez=object size z(fragmento)
  delete object fragmento
  objecteffect(fragmento)=0
  `
  rem mark start of fragment objects sequence (seeder,3xallfragments)
  bitdetails(debrisshapeindex).fragmentobjstart=fragmento
  `
  rem create object seeder
  make object cone fragmento,10
  make mesh from object fragmento,fragmento
  for o=1 to 8 : add limb fragmento,o,fragmento : next o
  delete mesh fragmento
  hide object fragmento
  inc fragmento
  `
  rem load original
  for o=1 to bitdetails(debrisshapeindex).max
   o$=bitdetails(debrisshapeindex).file$+"_chunk"+str$(o)+".x"
   `
   rem V109 BETA6 - replaced X file load with optional DBO convert/load
   `addfiletocollection(o$)
   `load object o$,fragmento
   if lower$(right$(o$,2))=".x" then tdbofile$=left$(o$,len(o$)-2)+".dbo" else tdbofile$=""
   if file exist(o$)=1 or file exist(tdbofile$)=1
    if file exist(tdbofile$)=1
     o$=tdbofile$
     tdbofile$=""
    endif
    load object o$,fragmento
    set object filter fragmento,2
    if len(tdbofile$)>1
     save object tdbofile$,fragmento
     if file exist(tdbofile$)=1
      delete object fragmento
      load object tdbofile$,fragmento
      set object filter fragmento,2
      o$=tdbofile$
     endif
    endif
    addfiletocollection(o$)
   endif
   `
   hide object fragmento
   inc fragmento
  next o
  `
  rem instance two more sets
  for n=1 to 2
   for o=1 to bitdetails(debrisshapeindex).max
    fragmentorig=bitdetails(debrisshapeindex).fragmentobjstart+1+(o-1)
    clone object fragmento,fragmentorig
    hide object fragmento
    inc fragmento
   next o
  next n
  `
 endif
 `
next debrisshapeindex
fragmentobjectoffsetmax=fragmento-1

return

_part_free:
 `
 rem Delete particles and fragments
 for o=fragmentobjectoffset to fragmentobjectoffsetmax
  if object exist(o)=1
   ode destroy object o
   rem V105 delete object o
  endif
 next o
 `
 rem V106 RC3 quicker this way
 delete objects fragmentobjectoffset,fragmentobjectoffsetmax
 `
 rem FPGC - 250310 - ensure objecteffect array is cleared after any object delete
 for o=1 to 65535
  if object exist(o)=0 then objecteffect(o)=0
 next o
 `
 rem Delete explosion objects
 gosub _part_freeexploders
 `
return

_part_movedebrisifinray:
 `
 rem ray is x1#,y1#,z1#,wallhitx#,wallhity#,wallhitz#
 for o=fragmentobjectoffset to fragmentobjectoffsetmax
  if object visible(o)=1
   if intersect object(o,x1#,y1#,z1#,wallhitx#,wallhity#,wallhitz#)<>0
    tix#=wallhitx#-x1# : tiy#=wallhity#-y1# : tiz#=wallhitz#-z1#
    tnorm#=(abs(tix#)+abs(tiy#)+abs(tiz#))/3.0
    tix#=tix#/tnorm# : tiy#=tiy#/tnorm# : tiz#=tiz#/tnorm#
    ode set linear velocity o,tix#*tforce#,tiy#*tforce#,tiz#*tforce#
   endif
  endif
 next o
 `
return

_part_createfragment:
 `
 rem takes debrisshapeindex,frox,y,z,a#,debrissize,x,y,z# (and new froobjtocopy)
 debrisscalex#=(debrissizex#/bitdetails(debrisshapeindex).sizex)*100.0
 debrisscaley#=(debrissizey#/bitdetails(debrisshapeindex).sizey)*100.0
 debrisscalez#=(debrissizez#/bitdetails(debrisshapeindex).sizez)*100.0
 `
 rem seeder obj placement
 frbo=bitdetails(debrisshapeindex).fragmentobjstart
 if frbo>0
  `
  rem V2109BETA5 - 250408 - no fragment if not initialised (not used in game)
  position object frbo,frox#,froy#,froz#
  set object to object orientation frbo,frocopyorientfrom
  scale object frbo,debrisscalex#,debrisscaley#,debrisscalez#
  `
  rem cycle through fragment instances (3 copies avail)
  fragmentchoose=bitdetails(debrisshapeindex).choice+1
  if fragmentchoose>2 then fragmentchoose=0
  bitdetails(debrisshapeindex).choice=fragmentchoose
  fragmentchoose=fragmentchoose*bitdetails(debrisshapeindex).max
  `
  rem place fragments using seeder limbs
  frchi=bitdetails(debrisshapeindex).choice
  stparte=e : stparttobj=tobj
  for o=1 to bitdetails(debrisshapeindex).max
   fragmento=bitdetails(debrisshapeindex).fragmentobjstart+1+(o-1)+fragmentchoose
   ode destroy object fragmento
   tfx#=bitoffset(debrisshapeindex,o).x#
   tfy#=bitoffset(debrisshapeindex,o).y#
   tfz#=bitoffset(debrisshapeindex,o).z#
   offset limb frbo,o,tfx#,tfy#,tfz#
   position object fragmento,limb position x(frbo,o),limb position y(frbo,o),limb position z(frbo,o)
   rotate object fragmento,limb direction x(frbo,o),limb direction y(frbo,o),limb direction z(frbo,o)
   rem maybe a scale of *0.9 will reduce fling-away effect
   scale object fragmento,debrisscalex#*0.8,debrisscaley#*0.8,debrisscalez#*0.8
   select bitdetails(debrisshapeindex).collisionmode
    case 2 : ode create dynamic box fragmento : endcase
    case 3 : ode create dynamic cylinder fragmento : endcase
    case 4 : ode create dynamic sphere fragmento : endcase
   endselect
   ode set contact fdir1 fragmento,50
   ode set body mass fragmento,10
   if debrisexplodable=1
    ode add force fragmento,0,-1,0,object position x(fragmento),object position y(fragmento)+object size y(fragmento),object position z(fragmento)
    ode set angular velocity fragmento,2.5+rnd(10)/10.0,1.5+rnd(5)/10.0,rnd(2)/10.0
   else
    ode set linear velocity fragmento,0,-20,0
    ode set angular velocity fragmento,0,0,0
   endif
   texture object fragmento,debristextureused
   rem FPGC - 040710 - make debris same lighting as entity that produced it (avlightcog passed in from prev call to _lighting_managegloballightingreciever)
   set object emissive fragmento,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)
   if debrisexplodable=1
    set blend mapping on fragmento, 1, explosionscorch, 3, 6
   else
    set blend mapping on fragmento, 1, explosionstressed, 3, 7
   endif
   tobj=fragmento : e=0
   gosub _ode_ensurephysicsobjvalid
   show object fragmento
  next o
  e=stparte : tobj=stparttobj
 endif
 `
return

_part_initexploders:
 `
 rem Load spark, fire and smoke
 tfile$="gamecore\debris\spark.tga" : explodedecalspark=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\fire.tga" : explodedecalfire=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\smoke.tga" : explodedecalsmoke=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\scorched.tga" : explosionscorch=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\stressed.tga" : explosionstressed=loadinternalimagecompressquality(tfile$,5,1)
 `
 rem Create Explosion Decals
 texplodersnd=1
 o=explodedecalobjstart
 tsndid=explodesoundoffset
 for exploderindex=1 to explodermax
  `
  rem Set vars and load sound
  exploder(exploderindex).obj=o
  exploder(exploderindex).explode=0
  tfile$="gamecore\debris\explosionfuel"+str$(texplodersnd)+".wav" : addfiletocollection(tfile$)
  inc texplodersnd : if texplodersnd>5 then texplodersnd=1
  load sound tfile$,tsndid
  exploder(exploderindex).explodesound=tsndid
  inc tsndid
  `
  for oi=0 to 16
   make object plain o,100,100
   if oi=0 then texture object o,explodedecalspark
   if oi>=1 and oi<=3 then texture object o,explodedecalfire
   if oi>=4 then texture object o,explodedecalsmoke
   set object transparency o,2
   disable object zwrite o
   hide object o
   inc o
  next oi
 next exploderindex
 explodedecalobjmax=o-1
 explodesoundmax=tsndid-1
 `
return

_part_freeexploders:
 `
 rem Delete Explosion Decals
 for o=explodedecalobjstart to explodedecalobjmax
  if object exist(o)=1
   ode destroy object o
   rem V105 delete object o
  endif
 next o
 `
 rem V106 RC3 quicker this way
 delete objects explodedecalobjstart,explodedecalobjmax
 `
 rem FPGC - 250310 - ensure objecteffect array is cleared after any object delete
 for o=1 to 65535
  if object exist(o)=0 then objecteffect(o)=0
 next o
 `
 rem Delete sounds
 for tsndid=explodesoundoffset to explodesoundmax
  if sound exist(tsndid)=1
   delete sound tsndid
  endif
 next tsndid
 `
return

_part_triggerexplosion:
 `
 rem Find free exploder
 for exploderindex=1 to explodermax
  if exploder(exploderindex).explode=0 then exit
 next exploderindex
 if exploderindex<explodermax
  rem visual
  exploder(exploderindex).explode=1
  exploder(exploderindex).x=frox#
  exploder(exploderindex).y=froy#
  exploder(exploderindex).z=froz#
  rem audio
  ts=exploder(exploderindex).explodesound
  if sound exist(ts)=1
   rem make explosion X times larger (ie closer)
   tscamx#=camera position x(0)
   tscamy#=camera position y(0)
   tscamz#=camera position z(0)
   tscamx#=(frox#-tscamx#)
   tscamy#=(froy#-tscamy#)
   tscamz#=(froz#-tscamz#)
   tvol=100-(sqrt(abs(tscamx#*tscamx#)+abs(tscamy#*tscamy#)+abs(tscamz#*tscamz#))/200.0)
   if tvol<0 then tvol=0
   if tvol>100 then tvol=100
   broadcast3dsound(frox#,froy#,froz#,100.0,-1)
   set sound volume ts,tvol
   play sound ts
  endif
 endif
 `
return

_part_controlexploders:
 `
 rem Handle all explosions in progress
 for exploderindex=1 to explodermax
  select exploder(exploderindex).explode
   case 1:
    o=exploder(exploderindex).obj
    show object o+0 : position object o+0,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+1 : position object o+1,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+2 : position object o+2,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+3 : position object o+3,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    for oi=4 to 13
     o=exploder(exploderindex).obj+oi
     position object o,exploder(exploderindex).x+(cos(((o-5)*20)-180)*50),exploder(exploderindex).y+((sin(((o-5)*20)-180)*20)),exploder(exploderindex).z
     scale object o,25+rnd(25),25+rnd(25),25+rnd(25)
     zrotate object o,rnd(360)
     show object o
    next oi
    for oi=14 to 16
     o=exploder(exploderindex).obj+oi
     position object o,exploder(exploderindex).x+(cos(((o-15)*20)-180)*25),exploder(exploderindex).y+rnd(10),exploder(exploderindex).z
     scale object o,50+rnd(50),50+rnd(50),50+rnd(50)
     zrotate object o,rnd(360)
     show object o
    next oi
    for oi=0 to 16
     o=exploder(exploderindex).obj+oi
     point object o,camera position x(),camera position y(),camera position z()
     move object o,20 : rem get out of flat wall
    next oi
    exploder(exploderindex).explode=2
    exploder(exploderindex).dist#=15
    exploder(exploderindex).smoke#=0
    exploder(exploderindex).fade#=100
   endcase
  endselect
  if exploder(exploderindex).explode>0
   rem flash
   exploder(exploderindex).fade#=exploder(exploderindex).fade#-10
   if exploder(exploderindex).fade#<1 then exploder(exploderindex).fade#=0
   sparkfade#=100-((90-exploder(exploderindex).fade#)*40)
   if sparkfade#<0 then sparkfade#=0
   if sparkfade#>100 then sparkfade#=100
   set alpha mapping on exploder(exploderindex).obj+0,sparkfade#
   set alpha mapping on exploder(exploderindex).obj+1,exploder(exploderindex).fade#/1.1 : s#=120+(25-(exploder(exploderindex).fade#/4))
   scale object exploder(exploderindex).obj+1,s#,s#,s#
   set alpha mapping on exploder(exploderindex).obj+2,exploder(exploderindex).fade#/1.5 : s#=100+(25-(exploder(exploderindex).fade#/4))
   scale object exploder(exploderindex).obj+2,s#,s#,s#
   set alpha mapping on exploder(exploderindex).obj+3,exploder(exploderindex).fade#/2.0 : s#=80+(25-(exploder(exploderindex).fade#/4))
   scale object exploder(exploderindex).obj+3,s#,s#,s#
   rem smoke
   exploder(exploderindex).dist#=exploder(exploderindex).dist#+0.1
   exploder(exploderindex).smoke#=exploder(exploderindex).smoke#+2.0
   if exploder(exploderindex).smoke#>=100
    for oi=0 to 16
     o=exploder(exploderindex).obj+oi
     hide object o
    next oi
    exploder(exploderindex).explode=0
   else
    for oi=4 to 16
     o=exploder(exploderindex).obj+oi
     if oi>=14 then up#=0.3 else up#=0.05
     position object o,object position x(o),object position y(o)+up#,object position z(o)
     set alpha mapping on o,100.0-exploder(exploderindex).smoke#
    next oi
   endif
  endif
 next exploderindex
 `
return

rem
rem MULTIPLAYER
rem

`
` Init
`
_multi_earlyinit:
 `
 rem Validate playername here
 for c=1 to len(playername$)
  if c>1 and asc(mid$(playername$,c))=10 or asc(mid$(playername$,c))=13
   playername$=left$(playername$,c-1)
   exit
  endif
 next c
 `
 rem Used to get Network Detect and Firewall permission as soon as possible
 if createorjoin=1
  rem create a tcp server
  MULTIPLAYER CREATE TCP SERVER servername$
  if glocalserveroverride$=""
   rem FPSCV105RC2 - use already validated server IP address
   `ipaddress$=MULTIPLAYER GET IP ADDRESS() ` sometimes returned local or router IP (no good)
   `for c=1 to len(ipaddress$)
   ` if mid$(ipaddress$,c)=":" then ipaddress$=left$(ipaddress$,c-1) : exit
   `next c
   ipaddress$=serveripaddress$
  else
   ipaddress$=glocalserveroverride$
  endif
  rem add to gamelist
  addip$=ipaddress$
  addname$=playername$
  gosub _ai_gamelist_add
 else
  rem join a tcp server
  MULTIPLAYER CONNECT TO TCP SERVER playername$, ipaddress$
 endif
 `
 rem Create Deadreckoning vectors (FPGC - 280610 - moved from 10+ to 20+ allows vectors for stereoscopics)
 for t=20+0 to 20+(16*5) : r=make vector3(t) : next t
 `
 rem Memblock allocations for vary-byte tranfser
 mb_move=101 : make memblock mb_move, 93
 mb_write=102 : make memblock mb_write, 93
 `
return

_multi_assetloader:
 `
 rem Load talk sound ping
 talkpingsound=loadinternalsoundcore("audiobank\misc\talkping.wav",0)
 lastplayedtalkindex=talkindex
 `
return

_multi_start:
 `
 rem optional visuals
 if createorjoin=1
  if left$(ipaddress$,8)="192.168."
   set window title strarr$(632)+" ["+ipaddress$+"] "+strarr$(633)
  else
   set window title strarr$(632)+" ["+ipaddress$+"] "+strarr$(634)
  endif
 else
  set window title playername$+" ["+ipaddress$+"]"
 endif
 `
 rem Scan all start positions of characters (these will be the respawn points)
 gosub _multi_initrespawnarray
 `
 rem parts that are re-called if game session is repeated
 gosub _multi_restart
 `
return

_multi_restartprepare:
 `
 rem hide all characters initially in MP game
 for e=1 to entityelementmax
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1
   entityelement(e).active=0
   entityelement(e).dormant=1
   entityelement(e).eleprof.cantakeweapon=0
   obj=entityelement(e).profileobj
   if obj>0
    if object exist(obj)=1
     hide object obj
    endif
   endif
   obj=entityelement(e).obj
   if obj>0
    if object exist(obj)=1
     hide object obj
    endif
   endif
   tobj2=entityelement(e).attachmentobj
   if tobj2>0
    if object exist(tobj2)=1
     hide object tobj2
    endif
   endif
  endif
 next e
 `
return

_multi_restart:
 `
 rem called after start and any restarting of game session
 rem Init var
 lagmon#=200
 dwLocalPlayerID=0
 iLocalEL=0
 PlayerCanStart=0
 PlayerCanStartStage=0
 Servergameisfull=0
 gtalkytoaster=0
 gterminationcountdown=0
 `
 rem Wipe out talk array
 talkindex=0 : for ti=0 to 10 : talkscript$(ti)="" : talkscriptcount(ti)=0 : next ti
 `
 rem Clear multiplayer link list
 for el=1 to 16 : multiplayeridlink(el)=1 : next el
 for el=1 to 16 : multiplayerplrindex(el)=0 : next el
 for el=1 to 16 : characterchosen(el)=0 : characterchoiceentityindex(el)=0 : next el
 `
 rem Clear out all STATE data (as old game if any might mess new game)
 for el=1 to 16
  stategetready(el)=0
  statex(el)=0
  statey(el)=0
  statez(el)=0
  statea(el)=0
  stateanim(el)=0
  stateanimdir(el)=0
  statecolmaterialtype(el)=0
  stateanimwait(el)=0
  statewhodidit(el)=0
  stateplayagain(el)=0
  stateviewy(el)=0
  statesviewdy(el)=0
  stateweapon(el)=0
  stateannounce(el)=0
  statesx(el)=0
  statesy(el)=0
  statesz(el)=0
  statesa(el)=0
  statesvel(el)=0
  statetx(el)=0
  statety(el)=0
  statetz(el)=0
  statedx(el)=0
  statedy(el)=0
  statedz(el)=0
  statemove(el)=0
  statelag(el)=0
  statemsgap(el)=0
  statemytimer(el)=0
  statecodeupdate(el,0)=0
  statecodeupdate(el,1)=0
  statecodeupdate(el,2)=0
  statecodeupdate(el,3)=0
  statecodeupdate(el,4)=0
  stateraycastpace(el)=0
 next el
 `
 rem Reset frag and laststore counts
 for el=1 to multiplayermax
  frags(el)=0 : for ti=0 to 4 : statecodeupdate(el,ti)=-1 : next ti
 next el
 `
 rem begin the multiplayer game INIT
 if createorjoin=1
  rem setup server player
  multiplayeridlinkmax=1 : iLocalEL=1
  multiplayeridlink(iLocalEL)=0
  multiplayername$(iLocalEL)=playername$
  multiplayerplrindex(iLocalEL)=1
  gosub _multi_identifycharactersinentities
  gosub _multi_andwho
  characterchosen(iLocalEL)=characterchoice
  characterchoiceentityindex(iLocalEL)=characterlistentity(characterchoice)
  rem player position and angle from player() data
  gosub _multi_setlocalstart
  rem set new server players health on server
  plrindex=multiplayerplrindex(iLocalEL) : te=characterchoiceentityindex(iLocalEL)
  player(plrindex).health=entityelement(te).eleprof.strength
  rem if test game, give a fake health in case no character to use
  if gtestgamemodefromeditor=1 then player(plrindex).health=100
  rem hoster can be part of game now
  PlayerCanStart=1 : dwStartTime=timer()
 else
  rem join a tcp server
  setupvoicechat=0
 endif
 `
 rem init burst time (lagmon# bursts)
 dwBurstTime=timer()
 `
 rem set as initialised
 multiplayerinitialised=1
 `
return

_multi_initrespawnarray:
 `
 rem init
 respawnmax=0
 for e=1 to entityelementmax
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1
   rem record psosition
   inc respawnmax
   respawn(respawnmax).e=e
   respawn(respawnmax).x=entityelement(e).x
   respawn(respawnmax).y=entityelement(e).y
   respawn(respawnmax).z=entityelement(e).z
   respawn(respawnmax).ry=entityelement(e).ry
  endif
 next e
 `
return

_multi_playertorespawnpos:
 `
 rem if no respawn data, use an available place to start from
 if respawnmax=0
  rem Find player start location
  playerstartx#=0 : gosub _player_setstartposonly
 else
  rem uses TE, return to origin, or random
  ttries=9
  rsiadd=0
  while ttries>0
   rsi=0
   if gspawnrandom=0 or randomposnotworkatlocalstart=1
    for rsi=1 to respawnmax
     if respawn(rsi).e=te then exit
    next rsi
   else
    rsi=trandomvalue
   endif
   if rsi>0
    rem start pos
    rsi=rsi+rsiadd : rsi=1+((rsi-1) mod respawnmax)
    if rsi<1 then rsi=1
    if rsi>respawnmax then rsi=respawnmax
    playerstartx#=respawn(rsi).x
    playerstarty#=respawn(rsi).y
    playerstartz#=respawn(rsi).z
    playerstartrx#=0
    playerstartry#=respawn(rsi).ry
    rem ensure it is not filled, exclude self from check
    tokay=1
    for ttel=1 to multiplayermax
     if ttel<>iLocalEL
      if multiplayeridlink(ttel)<>1
       tte=characterchoiceentityindex(ttel)
       ttdx#=abs(entityelement(tte).x-playerstartx#)
       ttdy#=abs(entityelement(tte).y-playerstarty#)
       ttdz#=abs(entityelement(tte).z-playerstartz#)
       ttdd#=sqrt((ttdx#*ttdx#)+(ttdy#*ttdy#)+(ttdz#*ttdz#))
       if ttdd#<100 then tokay=0 : exit
      endif
     endif
    next ttel
    if tokay=1
     ttries=0
    else
     inc rsiadd
    endif
   endif
   dec ttries
  endwhile
 endif
 `
return

_multi_setlocalstart:
 `
 rem have characterchoiceentityindex(iLocalEL)
 te=characterchoiceentityindex(iLocalEL)
 if te>0
  rem assign weapon to player
  tentid=entityelement(te).bankindex
  weaponindex=entityprofile(tentid).hasweapon
  tqty=10 : pint=0
  gosub _player_obtainaweapon
  autoloadgun=weaponindex
 endif
 `
 rem Copy again to make sure the weapon is given back after repos (die and spawn)
 tcopyorrestart=0 : gosub _gun_resetgunsettings
 `
 rem Place player at start position (randomize and lifecode using TE ensures identical LOCALSTARTs)
 randomize te
 trandomvalue=1+rnd(respawnmax-1)
 tlifecode=te
 randomposnotworkatlocalstart=1
 el=iLocalEL : gosub _multi_resetplrpos
 randomposnotworkatlocalstart=0
 camerapositionx=statex(iLocalEL)
 camerapositiony=statey(iLocalEL)+phyeyeheight#+21.0
 camerapositionz=statez(iLocalEL)
 position camera camerapositionx,camerapositiony,camerapositionz
 `
return

_multi_free:
 `
 rem Free Deadreckoning vectors
 for t=20+0 to 20+(16*5) : r=delete vector3(t) : next t
 `
 rem Delet memblocks
 if mb_move>0
  if memblock exist(mb_move)=1
   delete memblock mb_move
  endif
  mb_move=0
 endif
 if mb_write>0
  if memblock exist(mb_write)=1
   delete memblock mb_write
  endif
  mb_write=0
 endif
 `
 rem terminate connection session
 MULTIPLAYER DISCONNECT
 multiplayerinitialised=0
 `
 rem delete from gamelist
 if createorjoin=1
  gosub _ai_gamelist_delete
 endif
 createorjoin=0
 `
 rem Restore normal text
 set text to normal
 `
return

_multiplayer_repeatresetgame:
 `
 rem remove weapon from characters of previous game
 for el=1 to multiplayermax
  if multiplayeridlink(el)<>1
   rem Remove old weapon from model
   e=characterchoiceentityindex(el)
   entityelement(e).eleprof.hasweapon$=""
   gosub _entity_switchattachment
   rem Hide characters initially
   tobj=entityelement(e).obj
   if tobj>0
    if object exist(tobj)=1
     hide object tobj
    endif
   endif
  endif
 next el
 `
 rem clear viscolmap
 gosub _entity_fillviscolmap
 `
 rem Game has been repeated, so reset some small elements to reproduce exact restart (quicker than reload)
 gosub _player_resetobjectives
 gosub _player_startpos
 `
 rem Reset weapons
 tcopyorrestart=1 : gosub _gun_resetgunsettings
 `
 rem Reset entities
 tcopyorrestart=1 : gosub _entity_resetentitiestorestartstates
 `
 rem Restart multiplayer game session (causes all players to reselect characters)
 gosub _multi_restart
 `
 rem restore text to in-game style and size
 set text size 16 : set text to normal
 `
return


`
` Control
`

_multi_control:
 `
 if gterminationcountdown=0
  `
  rem unmark
  gosub _multi_unmark
  `
  rem Feed local data into states
  if multiplayerprototest=0
   if iLocalEL>0
    plrindex=multiplayerplrindex(iLocalEL)
    if weaponammoindex>0
     stateweapon(iLocalEL)=gunid
    else
     stateweapon(iLocalEL)=0
    endif
    if stateanimwait(iLocalEL)>0
     rem and wait for click to respawn
     player(plrindex).health=0
     if control_mouseclick()<>0 or (spacekey()=1 and gtalkytoaster=0)
      stateplayagain(iLocalEL)=1
      if createorjoin=2
       rem if client, send this click to server
       MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
       write memblock byte 102, 0, 212
       write memblock byte 102, 2, stateplayagain(iLocalEL)
       write memblock dword 102, 4, multiplayeridlink(iLocalEL)
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
      endif
     endif
    else
     if stategetready(iLocalEL)>0
      rem regular activity frozen until player touches ground
      stategetready(iLocalEL)=stategetready(iLocalEL)-1
     else
      statex(iLocalEL)=camerapositionx
      statey(iLocalEL)=(camerapositiony-phyeyeheight#)-20.0
      statez(iLocalEL)=camerapositionz
      statedx(iLocalEL)=statex(iLocalEL)
      statedy(iLocalEL)=statey(iLocalEL)
      statedz(iLocalEL)=statez(iLocalEL)
      stateviewy(iLocalEL)=wrapvalue(camera angle y())
     endif
     rem 1-spanw,2-idle,3-walk,4-strafeL,5-strafeR,6-run,32-crouchidle,33-crouchmove,12-'a' death,92-freeformidle,7-reload
     te=characterchoiceentityindex(iLocalEL)
     stateanimdir(iLocalEL)=0
     if player(plrindex).health>0
      if jumpaction<>0
       stateanim(iLocalEL)=92
      else
       statecolmaterialtype(iLocalEL)=colmaterialtype
       if crouchmode<>0
        if movement=1
         stateanim(iLocalEL)=33
         if (plrkeyS)=1 then stateanimdir(iLocalEL)=1
        else
         stateanim(iLocalEL)=32
        endif
       else
        if movement=1
         if (plrkeyA)=1
          stateanim(iLocalEL)=4
         else
          if (plrkeyD)=1
           stateanim(iLocalEL)=5
          else
           if (plrkeySHIFT)=1 or (plrkeySHIFT2)=1
            stateanim(iLocalEL)=6
           else
            stateanim(iLocalEL)=3
           endif
           if (plrkeyS)=1 then stateanimdir(iLocalEL)=1
          endif
         endif
        else
         if gunmode>=121 and gunmode<131
          stateanim(iLocalEL)=7
         else
          stateanim(iLocalEL)=2
         endif
        endif
       endif
      endif
     endif
    endif
   endif
  endif
  `
  rem Can detect NEW PLAYER here
  dwid as DWORD
  for i = 0 to MULTIPLAYER GET PLAYER COUNT()
   if i>0
    dwid=MULTIPLAYER GET PLAYER ID( i-1 )
   else
    dwid=0
   endif
   gotel=0 : freeel=0
   for el=1 to 16
    if multiplayeridlink(el)=1 and freeel=0 then freeel=el
    if multiplayeridlink(el)=dwid
     gotel=el : exit
    endif
   next el
   if gotel=0
    if freeel>0
     rem New Player for multiplayer-server-player list
     multiplayeridlink(freeel)=dwid
     multiplayeri(freeel)=i-1
     multiplayerisnew(freeel)=3
     rem FPGC - 200710 - solves a join crash
     if i>0
      tname$=MULTIPLAYER GET PLAYER NAME( i-1 )
     else
      tname$="---"
     endif
     for c=1 to len(tname$)
      if asc(mid$(tname$,c))=10 or asc(mid$(tname$,c))=13
       tname$=left$(tname$,c-1)
       exit
      endif
     next c
     multiplayername$(freeel)=tname$
     if freeel>multiplayeridlinkmax then multiplayeridlinkmax=freeel
     rem add player() and update multiplayerplrindex
     el=freeel : gosub _multi_addplayer
     rem joining prompt, only if later in game
     if PlayerCanStart=1
      stateannounce(el)=500
     endif
     rem reset frag for new plr
     frags(el)=0
    else
     rem a 17th DP-plr tried to get into my 16 plr max session
    endif
   else
    rem continually refresh internal index reference
    if i>0
     rem when a client leave and reenters, the playerlist() list is changed!
     multiplayeri(gotel)=i-1
    endif
   endif
  next i
  rem clean up players no longer in game
  for el=1 to multiplayeridlinkmax
   if multiplayeridlink(el)<>1
    if el>1 and getindexfromid(multiplayeridlink(el))=0
     rem this player EL left the game or was kicked out
     multiplayeridlink(el)=1
     multiplayeri(el)=-1
     rem leaving prompt
     stateannounce(el)=-500
     rem remove visual player from game
     te=characterchoiceentityindex(el)
     rem ensure cannot shoot entity after plr gone from game
     entityelement(te).collisionactive=0
     tobj=entityelement(te).obj
     if tobj>0 then hide object tobj
     tobj2=entityelement(te).attachmentobj
     if tobj2>0 then hide object tobj2
     tobj3=entityelement(te).attachmentblobobj
     if tobj3>0 then hide object tobj3
     rem remove players identity from character list and allow the slot to be reused
     if characterchosen(el)>0
      characterchosen(el)=0 : Servergameisfull=0
      characterchoiceentityindex(el)=0
     endif
    endif
   endif
  next el
  `
  rem server or client
  gosub _common
  if createorjoin=1
   gosub _server
  else
   gosub _client
  endif
  gosub _playersend
  `
  rem Handle dead reckoning
  for el=1 to multiplayeridlinkmax
   if el<>iLocalEL
    if multiplayeridlink(el)<>1
     if statelag(el)>0 then gosub _packet_move_dedrec
     gosub _packet_rotate_dedrec
    endif
   endif
  next el
  `
  rem this is where we assign server-controlled EL data to actual entity drones
  if multiplayerprototest=0 and showgamemenu=0
   if showfpsinrealgame=1 or showfpsinrealgame=2 then set cursor 0,100
   for el=1 to multiplayeridlinkmax
    if showfpsinrealgame=2 then print el;" - ISNEW:";multiplayerisnew(el);" - ";
    if multiplayerisnew(el)=0 or el=iLocalEL
     te=characterchoiceentityindex(el)
     tentid=entityelement(te).bankindex
     if showfpsinrealgame=2 then print "ID:";multiplayeridlink(el);
     if multiplayeridlink(el)<>1 and te>0
      plrindex=multiplayerplrindex(el)
      tobj=entityelement(te).obj
     if showfpsinrealgame=1 and multi_match_type > 0 then print multiplayername$(el);" Team: ";characterlist$(characterchosen(el));" Frags: ";str$(frags(el));" Ping: ";statelag(el)
     if showfpsinrealgame=1 and multi_match_type = 0 then print multiplayername$(el);" Frags: ";str$(frags(el));" Ping: ";statelag(el)

      if showfpsinrealgame=2 then print " - H:";player(plrindex).health;" - TE:";te;" ";tobj;" ";multiplayername$(el);
      if tobj>0
       entityelement(te).x=statex(el)
       entityelement(te).y=statey(el)
       entityelement(te).z=statez(el)
       if showfpsinrealgame=2 then print " X:";statex(el);" Y:";statey(el);" Z:";statez(el)
       entityelement(te).mover.da=stateviewy(el)
       if stateanim(el)<>1+entityelement(te).animdo
        entityelement(te).animonce=0
        entityelement(te).animset=stateanim(el)
        entityelement(te).animdir=stateanimdir(el)
        if stateanimwait(el)>0 then entityelement(te).animonce=1
       endif
       if el=iLocalEL
        hide object tobj
        set object collision off tobj
        entityelement(te).active=0
        entityelement(te).dormant=1
        entityelement(te).collisionactive=0
        te=characterchoiceentityindex(el)
        tobj2=entityelement(te).attachmentobj
        if tobj2>0 then hide object tobj2
       else
        show object tobj
        entityelement(te).active=1
        entityelement(te).dormant=0
        if player(plrindex).health>0
         entityelement(te).collisionactive=1
        else
         entityelement(te).collisionactive=0
        endif
        rem if this plr entity is dead, make sure the corpse finds the floor
        if player(plrindex).health=0
         rem pause dead character
         stte=e : stentid=entid
         e=te : entid=entityelement(e).bankindex
         tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
         e=stte : entid=stentid
         if object frame(tobj)>=tffinish-2.0 and object frame(tobj)<=tffinish
          stop object tobj
         endif
         rem set dead guy final resting pose
         tppy#=entityelement(te).y
         tppa#=entityelement(te).ry
         if entityelement(te).animdo=14
          tpmb#=55.0
         else
          tpmb#=-55.0
         endif
         tppx#=newxvalue(entityelement(te).x,tppa#,tpmb#)
         tppz#=newzvalue(entityelement(te).z,tppa#,tpmb#)
         tdst#=static raycast(tppx#,tppy#+70.0,tppz#,tppx#,tppy#-505.0,tppz#)
         tlowestmove=0
         if abs(tdst#-70.0)>5.0
          if tdst#<70
           rem head through slope - push away
           tlowestmove=1
          else
           rem head hovering in thin air - push fore
           tlowestmove=2
          endif
         endif
         if tlowestmove<>0
          if tlowestmove=1
           entityelement(te).x=newxvalue(entityelement(te).x,tppa#,(tpmb#/15.0)*-1)
           entityelement(te).z=newzvalue(entityelement(te).z,tppa#,(tpmb#/15.0)*-1)
          else
           entityelement(te).x=newxvalue(entityelement(te).x,tppa#,(tpmb#/15.0))
           entityelement(te).z=newzvalue(entityelement(te).z,tppa#,(tpmb#/15.0))
          endif
          tppx#=entityelement(te).x : tppz#=entityelement(te).z
          tdst#=static raycast(tppx#,tppy#+5.0,tppz#,tppx#,tppy#-505.0,tppz#)
          tthisy#=tppy#-(tdst#-5.0)
          if tthisy#<entityelement(te).y
           entityelement(te).y=entityelement(te).y-6
           if entityelement(te).y<tthisy#
            entityelement(te).y=tthisy#
           endif
          endif
          statex(el)=entityelement(te).x
          statey(el)=entityelement(te).y
          statez(el)=entityelement(te).z
         endif
        endif
        if showfpsinrealgame=2
         if object in screen(tobj)=1
          center text object screen x(tobj),object screen y(tobj)-40,multiplayername$(el)+"["+str$(stateanim(el))+"] "+characterlist$(characterchosen(el))+"("+str$(characterchoiceentityindex(el))+")"
          if createorjoin=1
           center text object screen x(tobj),object screen y(tobj)-10,"HEALTH="+str$(player(plrindex).health)+"FRAGS="+str$(frags(el))
          endif
         endif
        else
         if object in screen(tobj)=1 and object visible(tobj)=1
          if stateraycastpace(el)=0
           tokay=1 : gosub _multi_caniseeplr
           if tokay=1 then stateraycastpace(el)=1
          endif
          if stateraycastpace(el)>=1
           stateraycastpace(el)=stateraycastpace(el)+1
           if stateraycastpace(el)>10
            tokay=1 : gosub _multi_caniseeplr
            if tokay=1
             stateraycastpace(el)=1
            else
             stateraycastpace(el)=0
            endif
           endif
          endif
          if stateraycastpace(el)>0
         if characterlist$(characterchosen(el)) = characterlist$(characterchosen(iLocalEL)) and multi_match_type > 0
            ink rgb(0,255,0),0
           else
            ink rgb(255,0,0),0
           endif
           center text object screen x(tobj),object screen y(tobj),multiplayername$(el)+"   Team: "+characterlist$(characterchosen(el))
          endif
         else
          stateraycastpace(el)=0
         endif
        endif
        remstart was here but moved to entity visual code
        rem blob shadow control (all other non local plrs)
        if entityelement(te).attachmentblobobj>0
         if object exist(entityelement(te).attachmentblobobj)=1
          tplrindex=multiplayerplrindex(el)
          if player(tplrindex).health>0
           dst#=static raycast(entityelement(te).x,entityelement(te).y+5,entityelement(te).z,entityelement(te).x,entityelement(te).y-50,entityelement(te).z)
          else
           dst#=0.0
          endif
          if dst#>0
           dst#=dst#-5.0
           position object entityelement(te).attachmentblobobj,entityelement(te).x,(entityelement(te).y-dst#)+0.5,entityelement(te).z
           show object entityelement(te).attachmentblobobj
           tsc#=(100.0-dst#) : scale object entityelement(te).attachmentblobobj,tsc#,tsc#,tsc#
          else
           hide object entityelement(te).attachmentblobobj
          endif
         endif
        endif
        remend
       endif
      endif
     endif
    endif
    if showfpsinrealgame=2 then print
   next el
   if showfpsinrealgame=2
    el=iLocalEL : center text screen width()/2,screen height()-40,multiplayername$(el)+"["+str$(stateanim(el))+"] "+str$(characterchosen(el))+":"+characterlist$(characterchosen(el))+"("+str$(characterchoiceentityindex(el))+")"+" FRAGS="+str$(frags(el))
   endif
   `
  endif
  `
  rem mark positions in viscolmap
  gosub _multi_mark
  `
 endif
 `
 rem announcements
 anngap=25
 if showgamemenu=0
  tylinevalue=screen height()-(anngap*2)
  if gterminationcountdown>0
   set cursor 0,tylinevalue
   print strarr$(635);
   dec gterminationcountdown
   if gterminationcountdown<2
    tserverendsreason=1
    gosub _multi_serverendedgame
    mpgameinprogress=0
    continueokay=1
   endif
  else
   if PlayerCanStart=0
    set cursor 0,tylinevalue
    print strarr$(636);
`    if gmultiplayergame=1 and multiplayerinitialised=1 and multiplayersystemdisabled=0 then print "OK..";
`    print "(";str$(PlayerCanStartStage);","+str$(MULTIPLAYER GET PLAYER COUNT())+","+str$(dwLocalPlayerID)+","+str$(gterminationcountdown)+")";
   else
    for el=1 to multiplayeridlinkmax
     if multiplayeridlink(el)=1
      if stateannounce(el)<0
       set cursor 0,tylinevalue
       stateannounce(el)=stateannounce(el)+1
       print multiplayername$(el)+" "+strarr$(637)+" (";stateannounce(el);")";
       dec tylinevalue,anngap
      endif
     else
      if stateannounce(el)=0
       rem X killed Y (Y represents this)
       if stateanimwait(el)>=10
        set cursor 0,tylinevalue
        sourceel=statewhodidit(el)
        print multiplayername$(sourceel)+" "+strarr$(638)+" "+multiplayername$(el);
        dec tylinevalue,anngap
       endif
      else
       if el<>iLocalEL
        rem slowly joining game
        if stateannounce(el)>0
         set cursor 0,tylinevalue
         stateannounce(el)=stateannounce(el)-1
         print multiplayername$(el)+" "+strarr$(639);
         dec tylinevalue,anngap
        endif
       else
        stateannounce(el)=0
       endif
      endif
     endif
    next el
    rem Click to restart
    if stateanimwait(iLocalEL)>0
     set cursor 0,tylinevalue
     print strarr$(640);str$(stateanimwait(iLocalEL));
     dec tylinevalue,anngap
    endif
    rem Talk scripts (going backwards)
    if talkindex>0
     for ti=talkindex-1 to 0 step -1
      if talkscriptcount(ti)>0
       talkscriptcount(ti)=talkscriptcount(ti)-1
       set cursor 0,tylinevalue
       print multiplayername$(talkscriptwho(ti))+talkscript$(ti);
       dec tylinevalue,anngap
      endif
     next ti
    endif
    for ti=10 to talkindex step -1
     if talkscriptcount(ti)>0
      talkscriptcount(ti)=talkscriptcount(ti)-1
      set cursor 0,tylinevalue
      print multiplayername$(talkscriptwho(ti))+talkscript$(ti);
      dec tylinevalue,anngap
     endif
    next ti
    rem Monitor for ping
    if talkpingsound>0
     if talkindex<>lastplayedtalkindex
      lastplayedtalkindex=talkindex
      if sound exist(talkpingsound)=1
       play sound talkpingsound
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem capture and kill local player if they fall out of universe MP style
 if camerapositiony<-200
  tdamage=65535 : e=characterchoiceentityindex(iLocalEL)
  if entityelement(e).health>0
   gosub _multi_dealentityedamage
  endif
 endif
 `
return

_multi_caniseeplr:
 `
 rem can i see the plr to write their name on screen (tokay=0=no)
 if static raycast(camerapositionx,camerapositiony,camerapositionz,entityelement(te).x,entityelement(te).y+5.0,entityelement(te).z)=0
  tokay=1
  for tte=1 to entityelementlist
   if entityelement(tte).active=1
    if entityelement(tte).eleprof.isimmobile=1
     if entityelement(tte).collisionactive=1
      ttentid=entityelement(tte).bankindex
      if entityprofile(ttentid).isweapon=0 and entityprofile(ttentid).isammo=0 and entityprofile(ttentid).ischaracter=0
       ttobj=entityelement(tte).obj
       if ttobj>0
        tdst#=intersect object(ttobj,camerapositionx,camerapositiony,camerapositionz,entityelement(te).x,entityelement(te).y+5.0,entityelement(te).z)
        if tdst#<>0 then tokay=0 : exit
       else
        rem some entities are zero OBJ value
       endif
      endif
     endif
    endif
   endif
  next tte
 else
  tokay=0
 endif
 `
return

_multi_unmark:
 `
 rem remove old marker from viscolmap
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   tx=statetx(el) : ty=statety(el) : tz=statetz(el)
   if viscolmap(tx,ty,tz)=-1 then viscolmap(tx,ty,tz)=0
  endif
 next el
 `
return

_multi_mark:
 `
 rem write new marker to viscolmap
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   tx=statedx(el)/25 : ty=statedy(el)/100 : tz=statedz(el)/-25
   if ty>=0 and ty<=viscoly
    if tx>=0 and tz>=0
     if tx<=viscolx and tz<=viscolz
      if viscolmap(tx,ty,tz)=0
       statetx(el)=tx : statety(el)=ty : statetz(el)=tz
       viscolmap(tx,ty,tz)=-1
      endif
     endif
    endif
   endif
  endif
 next el
 `
return

`
` MP Subroutines
`

_common:
 `
 rem update MSgap counts
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   `
   rem keep tabs on players lag
   statemsgap(el)=timer()-statemytimer(el)
   `
   rem when looping sound too old, stop it
   e=characterchoiceentityindex(el)
   if entityelement(e).firesoundloopremote<>0
    if timer()-entityelement(e).firesoundlooptime>500
     stop sound entityelement(e).firesoundloopremote
     entityelement(e).firesoundloopremote=0
    endif
   endif
   `
   rem auto-footfalls when players in motion
   if (stateanim(el)>=3 and stateanim(el)<=6) or (stateanim(el)>=33 and stateanim(el)<=36)
    movement=1
    if stateanim(el)=6 then basespeed#=70 else basespeed#=50
    if stateanim(el)>=33 and stateanim(el)<=36 then basespeed#=15 : movement=2
    colmaterialtype=statecolmaterialtype(el) : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
    if plrid>1 then gosub _player_playfootfall
   endif
   `
   rem reduce invincibility counter
   if entityelement(e).invincibleactive>0
    entityelement(e).invincibleactive=entityelement(e).invincibleactive-1
   endif
   `
  endif
 next el
 `
 rem CAPTURE for debug purposes CONTROLS
 if showfpsinrealgame=2
  set cursor 0,0
  print "startlogging=";startlogging;" (";loginfoindex;")"
  if inkey$()="#" and startlogging=0 then startlogging=1
  if inkey$()="'" and startlogging=2 then startlogging=3
  if startlogging=1
   dim loginfo$(1001)
   loginfoindex=0
   startofrecording=timer()
   startlogging=2
  endif
  rem startlogging=2 inside message loop reporting activity
  if startlogging=3
   if file exist("multiplayerlogfile.txt")=1 then delete file "multiplayerlogfile.txt"
   save array "multiplayerlogfile.txt",loginfo$(0)
   undim loginfo$(0)
   startlogging=0
  endif
 endif
 `
 rem CAPTURE FORMATTING
 if startlogging=2
  if MULTIPLAYER MESSAGE EXISTS ( )
   loginfo$(loginfoindex)="["+str$((timer()-startofrecording)/1000)+"s]"
   inc loginfoindex : if loginfoindex>=1000 then startlogging=3
  endif
 endif
 `
 rem Reset so server will always send to ALL clients
 MULTIPLAYER SEND MESSAGE TO 0
 `
 rem get messages (clientplayers(createorjoin=0) also accepts server messages)
 while MULTIPLAYER MESSAGE EXISTS ( )
  `
  rem One message at a time
  MULTIPLAYER GET MESSAGE
  dwPlayerID = MULTIPLAYER GET MESSAGE PLAYER FROM( )
  `
  rem Message memblock slice up
  dwMessageCode=0
  if MULTIPLAYER GET MESSAGE TYPE( ) = 3
   MULTIPLAYER GET MESSAGE MEMBLOCK mb_move
   dwCode = memblock byte( mb_move, 0 )
   dwMessageCode=3
  endif
  `
  rem CAPTURE for debug purposes
  treportonmessage=0
  if startlogging=2
   if treportonmessage=0
    el=getelfromid(dwPlayerID) : tt$=" from "+multiplayername$(el)
    loginfo$(loginfoindex)=str$(dwMessageCode)+" "+right$(str$(1000+dwCode),3)+" "+tt$
    inc loginfoindex
    if loginfoindex>=1000
     startlogging=3
    endif
   endif
  endif
  `
  rem Handle both server and client comms here
  if (createorjoin=1 and dwPlayerID<>0) or createorjoin=2
   `
   rem message from server to client only
   if createorjoin=2
    if MULTIPLAYER GET MESSAGE TYPE( ) = 2
     tname$=MULTIPLAYER GET MESSAGE STRING()
     if left$(tname$,2)<>">>"
      el=getelfromid(0)
      for c=1 to len(tname$)
       if asc(mid$(tname$,c))=10 or asc(mid$(tname$,c))=13
        tname$=left$(tname$,c-1)
        exit
       endif
      next c
      multiplayername$(el)=tname$
     endif
    endif
   endif
   `
   rem string can also be a talkytoaster message
   if MULTIPLAYER GET MESSAGE TYPE( ) = 2
    ttalk$=MULTIPLAYER GET MESSAGE STRING()
    if left$(ttalk$,2)=">>"
     for c=1 to len(ttalk$)
      if asc(mid$(ttalk$,c))=10 or asc(mid$(ttalk$,c))=13
       ttalk$=left$(ttalk$,c-1)
       exit
      endif
     next c
     rem copy rest of talk to string
     talkscript$(talkindex)=ttalk$
     talkscriptcount(talkindex)=200
     el=getelfromid(dwPlayerID) : talkscriptwho(talkindex)=el
     inc talkindex : if talkindex>10 then talkindex=0
     if createorjoin=1
      rem if server receives talkmessage, must send out to all clients
      el=getelfromid(dwPlayerID)
      MULTIPLAYER SEND FROM PLAYER dwPlayerID
      MULTIPLAYER SEND MESSAGE STRING ttalk$,0x0080
     endif
    endif
   endif
   `
   rem message changes states on server
   if dwMessageCode=3 and (dwCode=0 or dwCode=4 or dwCode=5 or dwCode=9)
    el=getelfromid(dwPlayerID)
    if el>0
     if createorjoin=2 and dwPlayerID=dwLocalPlayerID
      rem a quick and easy report on received packet times
      locallagtime=timer()-timestampforlagtest
      timestampforlagtest=timer()
     else
      `
      rem MESSAGE FROM OTHER CLIENTS/SERVER
      ttransmitpos=0 : ttransmitanim=0 : ttransmitshot=0
      `
      rem Take new data and update state data
      if dwCode=0
       rem movement
       a = memblock byte( mb_move, 1 )*2
       x = memblock word( mb_move, 2 )
       y = memblock word( mb_move, 4 )
       z = memblock word( mb_move, 6 )*-1
       rem movement
       if multiplayeridlink(el)<>1
        statelag(el)=statemsgap(el)
        statemytimer(el)=timer()
        px#=x : py#=y : pa#=a : pz#=z
        rem If this plr is newly joined, reset to this new position coming in
        if multiplayerisnew(el)=3 then multiplayerisnew(el)=2
        gosub _packet_move
        ttransmitpos=1
       endif
      endif
      if dwCode=4
       rem anim and viewy and colmaterialtype
       viewy = memblock byte( mb_move, 1 )*2
       anim = memblock byte( mb_move, 2 )
       tcolmattype = memblock byte( mb_move, 3 )
       animdir = memblock byte( mb_move, 4 )
       statecolmaterialtype(el)=tcolmattype-1
       stateanim(el)=anim : pviewy#=viewy
       stateanimdir(el)=animdir
       gosub _packet_viewyanim
       ttransmitanim=1
      endif
      if dwCode=5
       rem player shot gun event
       ttransmitshot=1
       rem discharge sound (single fire, or automatic loop sound)
       e=characterchoiceentityindex(el)
       tgunid=entityelement(e).currentweapon
       tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
       if tsndid>0
        if gun(tgunid).action.automatic.s>0
         if entityelement(e).firesoundloopremote>0
          if entityelement(e).firesoundloopremote<>tsndid
           stop sound entityelement(e).firesoundloopremote
           entityelement(e).firesoundloopremote=0
          endif
         endif
         if entityelement(e).firesoundloopremote=0
          play sound tsndid,firemode(tgunid,0).sound.fireloopend
          loop sound tsndid,0,firemode(tgunid,0).sound.fireloopend
          entityelement(e).firesoundloopremote=tsndid
         endif
         entityelement(e).firesoundlooptime=timer()
        else
         play sound tsndid
        endif
        posinternal3dsound(tsndid,entityelement(e).x,entityelement(e).y,entityelement(e).z)
        broadcast3dsound(entityelement(e).x,entityelement(e).y,entityelement(e).z,25.0,entityelement(e).obj)
       endif
       rem visual decal
       tdecalmode=6
       entityelement(e).decalindex=1
       entityelement(e).decalmode=tdecalmode
       if entityelement(e).currentweapon>0
        rem override decal if gun specifies non-fire-flare
        tgunid=entityelement(e).currentweapon
        if firemode(tgunid,0).decalid>0
         entityelement(e).decalindex=firemode(tgunid,0).decalid*-1
        endif
       else
        entityelement(e).decalindex=0
       endif
      endif
      if dwCode=9
       rem movement
       if multiplayeridlink(el)<>1
        a = memblock byte( mb_move, 1 )*2
        x = memblock word( mb_move, 2 )
        y = memblock word( mb_move, 4 )
        z = memblock word( mb_move, 6 )*-1
        statelag(el)=statemsgap(el)
        statemytimer(el)=timer()
        px#=x : py#=y : pa#=a : pz#=z
        rem If this plr is newly joined, reset to this new position coming in
        if multiplayerisnew(el)=3 then multiplayerisnew(el)=2
        gosub _packet_move
        ttransmitpos=1
        rem and anim
        viewy = memblock byte( mb_move, 8 )*2
        anim = memblock byte( mb_move, 9 )
        tcolmattype = memblock byte( mb_move, 10 )
        animdir = memblock byte( mb_move, 11 )
        statecolmaterialtype(el)=tcolmattype-1
        stateanim(el)=anim : pviewy#=viewy
        stateanimdir(el)=animdir
        gosub _packet_viewyanim
        ttransmitanim=1
       endif
      endif
      `
      rem If server intercepts this, send new client data out to other clients
      if createorjoin=1
       if ttransmitpos=1 or ttransmitanim=1 or ttransmitshot=1
        MULTIPLAYER SEND FROM PLAYER dwPlayerID
        MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
        gosub _multi_transmitplayerdata
        MULTIPLAYER SEND MESSAGE TO 0
        rem ensure this non-prioritystuff gets sent at least one in five
        if guarenteedloadonmove>4 then guarenteedloadonmove=0
       endif
      endif
      `
     endif
    endif
   endif
   `
  endif
  `
  rem
  rem MEMBLOCK COMMUNICATIONS
  rem
  if dwMessageCode=3
   `
   rem
   rem SERVER Only Actions
   rem
   if createorjoin=1
    `
    rem INIT - server inits everything to requesting client
    if dwCode=1
     rem server will reject init immediately if game is FULL
     MULTIPLAYER SEND FROM PLAYER dwPlayerID
     if Servergameisfull=0
      rem name of server player (priority)
      MULTIPLAYER SEND MESSAGE STRING multiplayername$(1),0x0080
      rem show client list of available characters
      gosub _multi_showlistofavailchars
     else
      rem server game is full
      rem no more slots, max players reached (copied from below)
      write memblock byte 102, 0, 103
      write memblock dword 102, 4, 1
      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
      inc guarenteedbytes,8 : inc unreliablebytes,0
     endif
    endif
    rem REQUEST CHARACTER - server sends permission to client to use requested character
    if dwCode=3
     rem server says yes you can use that character
     tokay=1 : tfreeslot=0
     tcl = memblock dword( mb_move, 4 )
     for tcc=0 to numberofplayers-1
      if characterchosen(1+tcc)=tcl
       tokay=0
      endif
      if characterchosen(1+tcc)=0 then tfreeslot=1
     next tcc
     MULTIPLAYER SEND FROM PLAYER dwPlayerID
     if tfreeslot=1
      if tokay=1
       rem record clients choice on the server
       el=getelfromid(dwPlayerID) : characterchosen(el)=tcl
       rem V119 - Hockeukid - Make sure the server knows who our client is or his health won't be sent!
       multiplayeridlink(el)=dwPlayerID
       gosub _multi_identifycharactersinentities
       characterchoiceentityindex(el)=characterlistentity(tcl)
       rem set new joiner players health on server
       te=characterchoiceentityindex(el)
       plrindex=multiplayerplrindex(el) : player(plrindex).health=entityelement(te).eleprof.strength
       rem if test game, give a fake health in case no character to use
       if gtestgamemodefromeditor=1 then player(plrindex).health=100
       rem go ahead and start clients game
       write memblock byte 102, 0, 102
       write memblock dword 102, 4, tcl
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
       rem transmit health values of all players too
       for tel=1 to multiplayeridlinkmax
        if multiplayeridlink(tel)<>1
         plrindex=multiplayerplrindex(tel) : tvalue=player(plrindex).health
         MULTIPLAYER SEND FROM PLAYER multiplayeridlink(tel)
         write memblock byte 102, 0, 201
         write memblock dword 102, 4, multiplayeridlink(tel)
         write memblock dword 102, 8, tvalue
         rem priority communication
         MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
         inc guarenteedbytes,12 : inc unreliablebytes,0
        endif
       next tel
       rem transmit positions and other player details as they are right now
       for el=1 to multiplayeridlinkmax
        if multiplayeridlink(el)<>1
         rem transmit position and anim (playercode specifies the WHO)
         for tfourtimes=1 to 4
          guarenteedloadonmove=5 : rem ensure inital positions guarenteed
          ttransmitpos=1 : ttransmitanim=0
          MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
          gosub _multi_transmitplayerdata
         next tfourtimes
         guarenteedloadonmove=5 : rem ensure inital positions guarenteed
         ttransmitpos=0 : ttransmitanim=1
         MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
         gosub _multi_transmitplayerdata
         te=characterchoiceentityindex(el)
         rem update all clients with this change (sneak lifecode in as well) (send from server)
         MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
         write memblock byte 102, 0, 211
         write memblock byte 102, 1, entityelement(te).lifecode
         write memblock dword 102, 4, multiplayeridlink(el)
         write memblock dword 102, 8, stateweapon(el)
         MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
         inc guarenteedbytes,12 : inc unreliablebytes,0
        endif
       next el
       rem restore EL just in case
       el=getelfromid(dwPlayerID)
       rem update Servergameisfull flag
       tfreeslot=0
       for tcc=0 to numberofplayers-1
        if characterchosen(1+tcc)=0 then tfreeslot=1
       next tcc
       if tfreeslot=0 then Servergameisfull=1
      else
       rem client cannot have this character, ask client to choose another
       gosub _multi_showlistofavailchars
      endif
     else
      rem no more slots, max players reached
      write memblock byte 102, 0, 103
      write memblock dword 102, 4, 1
      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
      inc guarenteedbytes,8 : inc unreliablebytes,0
     endif
    endif
    rem REQUEST A HIT
    if dwCode=21
     rem shot and damage
     tlifecode = memblock byte( mb_move, 1 )
     te = memblock word( mb_move, 2 )
     tdamage = memblock word( mb_move, 4 )
     sourcee = memblock word( mb_move, 6 )
     rem only deal remote damage if lifecode of current entity and shot-id is same
     if entityelement(te).lifecode=tlifecode
      gosub _multi_dealdamagedirect
     else
      el=getelfromid(dwPlayerID)
      tlifecodenotmatch=el
      tlifecodenotmatcha=entityelement(te).lifecode : tlifecodenotmatchb=tlifecode
     endif
    endif
    rem FINISHEDGAME - server is informed of client winning by local mission AI
    if dwCode=105
     rem broadcast to clients
     winnerel=getelfromid(memblock dword(mb_move, 4))
     tbroadcastresult=winnerel
     gosub _multi_informallplayersofcomplete
     rem declare winner/loser
     gosub _multi_declarewinorlose
    endif
    rem HEALTHUPDATE (also handled below for all)
    if dwCode=201
     rem newcode - server can never be told the players health is subzero
     tplayerhealth=memblock dword(mb_move, 8)
     if tplayerhealth<=0
      rem Server was informed by Client that its health was subzero
      el=getelfromid(memblock dword(mb_move, 4))
      tclientinformedhealthsubzero=el
     else
      rem get for benefit of server
      gosub _get_playerhealth
     endif

` other clients do NOT need to know their fellows health values
`     rem from server so do not need to broadcast back out
`     if dwPlayerID<>dwLocalPlayerID
`      rem update all clients with this players new health
`      MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
`      rem Update client player health
`      write memblock byte 102, 0, 201
`      write memblock dword 102, 4, multiplayeridlink(el)
`      write memblock dword 102, 8, player(plrindex).health
`      MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
`      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
`      MULTIPLAYER SEND MESSAGE TO 0
`      inc guarenteedbytes,12 : inc unreliablebytes,0
`     endif

    endif
    rem WEAPONCHANGED - client changed weapon
    if dwCode=211
     rem get plr affected and store in state (on server)
     tlifecode=memblock byte(mb_move, 1)
     el=getelfromid(memblock dword(mb_move, 4))
     stateweapon(el)=memblock dword(mb_move, 8)
     te=characterchoiceentityindex(el)
     entityelement(te).lifecode=tlifecode
     rem update all clients with this change
     MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
     write memblock byte 102, 0, 211
     write memblock byte 102, 1, entityelement(te).lifecode
     write memblock dword 102, 4, multiplayeridlink(el)
     write memblock dword 102, 8, stateweapon(el)
     MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
     MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
     MULTIPLAYER SEND MESSAGE TO 0
     inc guarenteedbytes,12 : inc unreliablebytes,0
     rem handle weapon change in game
     gosub _multi_changeweapon
    endif
    if dwCode=212
     rem get plr affected and store in state (on server)
     el=getelfromid(memblock dword(mb_move, 4))
     stateplayagain(el)=memblock byte(mb_move, 2)
    endif
    rem REQUEST TRIGGER SEND - client used an mptrigger
    if dwCode=251
     rem get trigger and perform on server first
     mptrigger=memblock byte(mb_move,1)
     mptriggervalue1=memblock word(mb_move, 2)
     rem server performs directly (for server player)
     gosub _multi_performtrigger
     rem server sends all triggers to clients (using dwPlayerID to show who did triggering)
     gosub _multi_serversendtriggers
    endif
    `
   endif
   `
   rem
   rem CLIENT
   rem
   if createorjoin=2
    `
    rem Messages JUST for this one client (or all clients)
    if dwPlayerID=dwLocalPlayerID
     rem POPULATE - client updates entities with server-controlled-entities
     if dwCode=2
      PlayerCanStartStage=3
      x = memblock dword( mb_move,  4 )
      y = memblock dword( mb_move,  8 )
      z = memblock dword( mb_move, 12 )
      e = memblock dword( mb_move, 16 )
      entityelement(e).servercontrolled=1
      entityelement(e).x=x
      entityelement(e).y=y
      entityelement(e).z=z
     endif
     rem ASKIFCANUSECHARACTER - client chooses character
     if dwCode=101
      rem Choose which character you want to be
      numberofplayers=memblock byte( mb_move, 4 )
      if numberofplayers>0
       tdwplr as DWORD
       for tcc=0 to numberofplayers-1
        tdwplr=memblock dword( mb_move, 5+(tcc*5) )
        tcl=memblock byte( mb_move, 9+(tcc*5) )
        el=getelfromid(tdwplr) : characterchosen(el)=tcl
        gosub _multi_identifycharactersinentities
        characterchoiceentityindex(el)=characterlistentity(tcl)
       next tcc
       rem select from character selection screen
       gosub _multi_andwho
       rem client asks server if can use this character
       MULTIPLAYER SEND FROM PLAYER dwPlayerID
       write memblock byte 102, 0, 3
       write memblock dword 102, 4, characterchoice
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
      else
       rem odd error server has a game of zero players
       exit prompt "MPError","Zero Players" : end
      endif
     endif
     rem READY - client is told if it can use the selected character
     if dwCode=102
      rem JOIN PLAYER STARTS - create space in player array
      characterchosen(iLocalEL)=characterchoice
      te=characterlistentity(characterchoice)
      characterchoiceentityindex(iLocalEL)=te
      multiplayerplrindex(iLocalEL)=1
      multiplayername$(iLocalEL)=playername$
      rem start position of this local dude
      gosub _multi_setlocalstart
      rem start joiners game
      PlayerCanStartStage=4
      PlayerCanStart=1
     endif
     rem CANNOT PLAY - client is told they cannot play for some reason
     if dwCode=103
      tcannotplayreason=memblock byte( mb_move, 4 )
      gosub _multi_cannotplay
      mpgameinprogress=0
      continueokay=1
     endif
     rem FINISHEDGAME - client is told a winner has been found (and pass in final frag count too)
     if dwCode=104
      el=getelfromid(dwPlayerID)
      frags(el)=memblock word(mb_move, 2)
      winnerel=getelfromid(memblock dword(mb_move, 4))
      gosub _multi_declarewinorlose
     endif
    else
     rem Messages for all clients (not original client sender though)
     rem CHARACTER CONFIRM - intercept character confirmation, so other clients know what identity the player uses
     if dwCode=102
      el=getelfromid(dwPlayerID)
      tcharacterchoice=memblock byte( mb_move, 4 )
      characterchosen(el)=tcharacterchoice
      characterchoiceentityindex(el)=characterlistentity(tcharacterchoice)
     endif
     if dwCode=252
      rem TRIGGER EVENT - using trigger code and value(s)
      mptrigger=memblock byte(mb_move,1)
      mptriggervalue1=memblock word(mb_move, 2)
      gosub _multi_performtrigger
     endif
    endif
    `
    rem PLAYER DETAIL CHANGE - player health change
    if dwCode=201
     rem simply update health (also handled above for broadcast by server)
     gosub _get_playerhealth
    endif
    if dwCode=202
     rem PLAYDIEANIM - usually from being killed
     el=getelfromid(memblock dword(mb_move, 4))
     sourceel=getelfromid(memblock dword(mb_move, 8))
     gosub _multi_dieanim
    endif
    if dwCode=203
     rem update health negatively, and if local player, arg and redhud
     gosub _get_playerhurt
    endif
    if dwCode=204
     rem REPOSIITON - usually after die anim
     trandomvalue=memblock byte(mb_move, 1)
     tlifecode=memblock byte(mb_move, 2)
     el=getelfromid(dwPlayerID)
     gosub _multi_resetplrpos
     rem restart weapon inventory
     if el=iLocalEL
      tcopyorrestart=1 : gosub _gun_resetgunsettings
     endif
     rem update entities locally around player
     tupdatelocalentities=el
    endif
    if dwCode=205
     rem NEWFRAGVALUE - informs who has new frag value and who they killed to get the update
     tnewfrag=memblock byte(mb_move,1)
     killerel=getelfromid(memblock dword(mb_move, 4))
     victimel=getelfromid(memblock dword(mb_move, 8))
     frags(killerel)=tnewfrag
    endif
    if dwCode=211
     rem simply update weapon used by plr (also handled above for broadcast by server)
     tlifecode=memblock byte(mb_move,1)
     el=getelfromid(memblock dword(mb_move, 4))
     stateweapon(el)=memblock dword(mb_move, 8)
     rem also lifecode piggy backs a ride
     te=characterchoiceentityindex(el)
     entityelement(te).lifecode=tlifecode
     rem handle weapon change in game
     gosub _multi_changeweapon
    endif
    `
   endif
   `
   rem
   rem BOTH
   rem
`   rem Messages JUST for this one client (or all clients)
`   if dwPlayerID=dwLocalPlayerID
`    rem From itself - ignore
`   else
`    rem ROCKET FIRED - client updates FLAK with rocket event
`    if dwCode=11
`     a = memblock byte( mb_move, 1 ) * 2
`     x = memblock word( mb_move, 2 )
`     y = memblock word( mb_move, 4 )
`     riaplr = memblock dword( mb_move, 6 )
`     rix#=x : riy#=y : ria#=a : rii=memblock byte( mb_move, 10 )
`     rem do not remote-fire own rockets!!
`     if riaplr<>dwLocalPlayerID
``      gosub _proto_fire
`     endif
`     rem if server intercepts a fire, send to other clients
`     if createorjoin=1
`      iLocalELAction=ri
`     endif
`    endif
`   endif
`   rem ROCKET COLLIDED - so trigger explosion
`   if dwCode=12
`    rii = memblock dword( mb_move, 4 )
`    for ri=1 to rocketmax
`     if rocket(ri).owner=dwPlayerID
`      if rocket(ri).rii=rii
`       rocket(ri).rocketmode=2 : rocket(ri).exploderadius=2 : exit
`      endif
`     endif
`    next ri
`   endif
   `
  endif
  `
  rem update entities locally around player
  if tupdatelocalentities>0
   el=tupdatelocalentities
   if el=iLocalEL
    mex#=statex(el) : mey#=statey(el) : mez#=statez(el)
    gosub _entity_blastinitentities
   endif
   tupdatelocalentities=0
  endif
  `
 endwhile
 `
 if showfpsinrealgame=2
  set cursor 0,250
  if tlifecodenotmatch<>0
   print "lifecodenotmatch(el=";tlifecodenotmatch;") ";multiplayername$(tlifecodenotmatch)
   print "entis:";tlifecodenotmatcha
   print "asked:";tlifecodenotmatchb
  endif
  if tclientinformedhealthsubzero<>0
   print "tclientinformedhealthsubzero(el=";tclientinformedhealthsubzero;") ";multiplayername$(tclientinformedhealthsubzero)
  endif
 endif
 `
 rem Restore all server sends (so no client is excluded)
 MULTIPLAYER SEND MESSAGE TO 0
 `
return

_multi_changeweapon:
 `
 rem uses el
 tgunid=stateweapon(el)
 e=characterchoiceentityindex(el)
 tweap$=gun(tgunid).name$
 tobj=entityelement(e).obj
 entid=entityelement(e).bankindex
 if entityprofile(entid).ischaracter=1
  if object exist(tobj)=1
   if entityprofile(entid).firespotlimb>-1
    rem switch weapon carried and force reset of animation account for possible weapon
    entityelement(e).eleprof.hasweapon$=tweap$
    gosub _entity_switchattachment
    entityelement(e).animset=entityelement(e).animdo+1
   endif
  endif
 endif
 `
return

_multi_transmitplayerdata:
 `
 rem prepare
 if ttransmitpos=1
  a=wrapvalue(statea(el))/2
  x=statedx(el) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
  y=statedy(el) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
  z=statedz(el)*-1 : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
 endif
 if ttransmitanim=1
  viewy=wrapvalue(stateviewy(el))/2
  anim=stateanim(el)
  tcolmat=1+statecolmaterialtype(el)
  animdir=stateanimdir(el)
 endif
 `
 rem if both pos and anim/viewy, ship as single packet
 if ttransmitpos=1 and ttransmitanim=1
  `
  rem Both POS+ANIM message
  write memblock byte mb_move, 0, 9
  write memblock byte mb_move, 1, a
  write memblock word mb_move, 2, x
  write memblock word mb_move, 4, y
  write memblock word mb_move, 6, z
  write memblock byte mb_move, 8, viewy
  write memblock byte mb_move, 9, anim
  write memblock byte mb_move, 10, tcolmat
  write memblock byte mb_move, 11, animdir
  if guarenteedloadonmove>4
   MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,12
   inc guarenteedbytes,12 : inc unreliablebytes,0
  else
   MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,12
   inc guarenteedbytes,0 : inc unreliablebytes,12
  endif
  `
 else
  `
  rem send out position (non-priority)
  if ttransmitpos=1
   write memblock byte mb_move, 0, 0
   write memblock byte mb_move, 1, a
   write memblock word mb_move, 2, x
   write memblock word mb_move, 4, y
   write memblock word mb_move, 6, z
   if guarenteedloadonmove>4
    rem ensure at least one out of five move messages will be guarenteed if bombed with priority traffic
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,8
    inc guarenteedbytes,8 : inc unreliablebytes,0
   else
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
    inc guarenteedbytes,0 : inc unreliablebytes,8
   endif
  endif
  `
  rem send out viewy and animation (non-priority)
  if ttransmitanim=1
   write memblock byte mb_move, 0, 4
   write memblock byte mb_move, 1, viewy
   write memblock byte mb_move, 2, anim
   write memblock byte mb_move, 3, tcolmat
   if guarenteedloadonmove>4
    rem ensure at least one out of five move messages will be guarenteed if bombed with priority traffic
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,8
    inc guarenteedbytes,8 : inc unreliablebytes,0
   else
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
    inc guarenteedbytes,0 : inc unreliablebytes,8
   endif
  endif
  `
 endif
 `
 rem send out the shot-event (non-priority)
 if ttransmitshot=1
  write memblock byte mb_move, 0, 5
  MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
  inc guarenteedbytes,0 : inc unreliablebytes,8
 endif
 `
return

_multi_showlistofavailchars:
 `
 rem send list of chars to client from server
 MULTIPLAYER SEND FROM PLAYER dwPlayerID
 write memblock byte 102, 0, 101
 rem server also sends who client has picked as their character
 write memblock byte 102, 4, numberofplayers
 for tcc=0 to numberofplayers-1
  write memblock dword 102, 5+(tcc*5), multiplayeridlink(1+tcc)
  write memblock byte 102, 9+(tcc*5), characterchosen(1+tcc)
 next tcc
 amount=4+4+(numberofplayers*5)
 MULTIPLAYER SEND MESSAGE memblock 102,0x0080,amount
 inc guarenteedbytes,amount : inc unreliablebytes,0
 `
return

_multi_addplayer:
 `
 rem find free 'used' server player slot
 plrindex=0
 for ti=1 to playermax
  if player(ti).serverplayer=2
   plrindex=ti
  endif
 next ti
 if plrindex=0
  rem add player to array (use el)
  playermax=playermax+1
  dim player(playermax) as playertype
  dim playersound(playermax,220) as integer
  dim playersoundset$(playermax) as string
  dim playermovementstep(playermax) as integer
  dim playerinventory(playermax,100) as inventorytype
  rem FPGC - 020909 - new sound management
  dim playersoundsetindex(playermax) as integer
  plrindex=playermax
 endif
 rem set new player and slot
 multiplayerplrindex(el)=plrindex
 player(plrindex).serverplayer=1
 `
return

_server:
 `
 rem pretent FPI script tailoed for arena logic
 for e=1 to entityelementmax
  if entityelement(e).servercontrolled=1
   rem go through server-linked-players
   for mel=1 to multiplayeridlinkmax
    if multiplayeridlink(mel)<>1
     `
     rem Entity Info
     entid=entityelement(e).bankindex
     `
     rem pause while death/respawn happens (animwait set when death occurs)
     if entityprofile(entid).ischaracter=1
      if stateanimwait(mel)>0
       stateanimwait(mel)=stateanimwait(mel)-1
       if stateplayagain(mel)<>1 and stateanimwait(mel)=0 then stateanimwait(mel)=1
       if stateanimwait(mel)=0
        stateplayagain(mel)=0
        el=mel : plrindex=multiplayerplrindex(el)
        player(plrindex).health=100
        trandomvalue=1+rnd(respawnmax-1)
        tlifecode=rnd(255)
        gosub _multi_resetplrpos
        rem restart weapon inventory
        if el=iLocalEL
         tcopyorrestart=1 : gosub _gun_resetgunsettings
        endif
        rem update entities locally around player
        tupdatelocalentities=el
        rem server sends out 204 (to trigger respawn of dead player)
        MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
        write memblock byte 102, 0, 204
        write memblock byte 102, 1, trandomvalue
        write memblock byte 102, 2, tlifecode
        write memblock dword 102, 4, multiplayeridlink(el)
        MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
        inc guarenteedbytes,8 : inc unreliablebytes,0
        rem update all clients with this players new health
        tvalue=player(plrindex).health
        for tel=1 to multiplayeridlinkmax
         if multiplayeridlink(tel)<>1
          MULTIPLAYER SEND FROM PLAYER multiplayeridlink(tel)
          rem Update client player health
          write memblock byte 102, 0, 201
          write memblock dword 102, 4, multiplayeridlink(el)
          write memblock dword 102, 8, tvalue
          MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
          inc guarenteedbytes,12 : inc unreliablebytes,0
         endif
        next tel
       endif
      endif
     endif
     `
    endif
   next mel
  endif
 next e
 `
 rem update entities locally around player
 if tupdatelocalentities>0
  el=tupdatelocalentities
  if el=iLocalEL
   mex#=statex(el) : mey#=statey(el) : mez#=statez(el)
   gosub _entity_blastinitentities
  endif
  tupdatelocalentities=0
 endif
 `
 rem Server Monitors for objective completion
 tnumberofcurrentplayers=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   inc tnumberofcurrentplayers
  endif
 next el
 `
 tbroadcastresult=0
 if ggameobjectivetype=1
  rem any client/serverplayer can signal they have completed the mission (local AI message)
 endif
 if ggameobjectivetype=2
  rem server ends game when a player reaches desired frags
rem Altered below section of code to allow Team based match frags to total up team frags and not individual frags
 if tnumberofcurrentplayers>1
if multi_match_type <> 0
     empty array team_frags(0)
     array insert at top team_frags(0)
   endif
   for el=1 to multiplayeridlinkmax
    if multiplayeridlink(el)<>1
 rem check "multi_match_type" to determine if single player or team needs to get to designated
     rem frag limit
     if multi_match_type = 0
        rem Free For All match, count individual frags
        if frags(el)>=ggameobjectivevalue
         tbroadcastresult=el
         exit
        endif
     else
        rem Team based match, check all players and tally up "team" score
           tfound = 0
           for i = 0 to array count(team_frags(0))
              if characterlist$(characterchosen(el)) = team_frags(i).teamname
                 inc team_frags(i).teamscore, frags(el)
                 tfound = 1
                 exit
              endif
           next i
           if tfound = 0
               rem create an array spot for this team
               array insert at top team_frags(0)
               team_frags(0).teamname = characterlist$(characterchosen(el))
               team_frags(0).teamscore = frags(el)
           endif
     endif
    endif
   next el
if multi_match_type <> 0
      twinnerfound = 0
      for i = 0 to array count(team_frags(0))
          if team_frags(i).teamscore >= ggameobjectivevalue
             for el1 = 1 to multiplayeridlinkmax
               if multiplayeridlink(el1) <> 1
                  if characterlist$(characterchosen(el1)) = team_frags(i).teamname
                     tbroadcastresult = el1
                     twinnerfound = 1
                     exit
                  endif
               endif
             next el1
          endif
          if twinnerfound = 1 then exit
      next i
   endif
  endif
 endif
 if ggameobjectivetype=3
  rem server monitors time and ends game when time expired
  if ((timer()-dwStartTime)/1024)>=ggameobjectivevalue
   highestel=1
   if tnumberofcurrentplayers>1
    for el=2 to multiplayeridlinkmax
     if multiplayeridlink(el)<>1
      if frags(el)>frags(highestel) then highestel=el
     endif
    next el
   endif
   tbroadcastresult=highestel
  endif
 endif
 if tbroadcastresult>0
  rem and then broadcast to clients
  winnerel=tbroadcastresult
 mvpel = winnerel
  for tel = 0 to multiplayeridlinkmax
   if frags(tel) > frags(mvpel) then mvpel = tel
  next
  gosub _multi_informallplayersofcomplete
  rem announce as winner/loser directly
  gosub _multi_declarewinorlose
 endif
 `
 rem Send a keepalive trigger to master database every 10 minutes
 if (timer()-tenminutetimer)>600000
  gosub _ai_gamelist_keepalive
  tenminutetimer=timer()
 endif
 `
return

_multi_mptrigger:
 `
 if createorjoin=1
  rem if server player does trigger, direct do and send triggers out
  dwPlayerID=multiplayeridlink(iLocalEL)
  gosub _multi_serversendtriggers
 else
  rem send trigger message to server
  MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
  write memblock byte 102, 0, 251
  write memblock byte 102, 1, mptrigger
  write memblock word 102, 2, mptriggervalue1
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
return

_multi_serversendtriggers:
 `
 rem uses mptrigger, mptriggervalue1
 rem send trigger message to all clients (from server)
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   MULTIPLAYER SEND FROM PLAYER dwPlayerID
   write memblock byte 102, 0, 252
   write memblock byte 102, 1, mptrigger
   write memblock word 102, 2, mptriggervalue1
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
   inc guarenteedbytes,8 : inc unreliablebytes,0
  endif
 next el
 `
return

_multi_performtrigger:
 `
 rem perform locally, immediately
 `
 rem 1 - plrtake
 if mptrigger=1
  te=mptriggervalue1
  if te>0
   rem hide object
   tobj=entityelement(te).obj
   if tobj>0
    if object exist(tobj)=1 then hide object tobj : set object collision off tobj
   endif
   rem if child of spawn leader, reset spawn count
   tspawne=entityelement(te).spawn.leaderid
   if tspawne=0 then tspawne=te
   entityelement(tspawne).spawn.leadercount=entityelement(tspawne).spawn.delay
   rem remove entity
   entityelement(te).beenkilled=1
   entityelement(te).active=0
   rem clear entity from col map
   tx=entityelement(te).x/25
   ty=entityelement(te).y/100
   tz=entityelement(te).z/-25
   if tx>=0 and ty>=0 and tz>=0
    if tx<=viscolx and ty<=viscoly and tz<=viscolz
     if viscolmap(tx,ty,tz)=te then viscolmap(tx,ty,tz)=0
    endif
   endif
  endif
 endif
 `
 rem 2 - process logic instantly (colon/coloff)
 if mptrigger=2
  rem Command entity to process logic immediately (open doors/close doors/etc)
  te=mptriggervalue1
  if te>0
   entityelement(te).active=1
   entityelement(te).dormant=0
   entityelement(te).logiccount=0
   entityelement(te).logictimestamp=timer()
   ste=e : e=te : gosub _entity_addetoprioritylist : e=ste
  endif
 endif
 `
return

_client:
 `
 rem go through server-linked-players
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   te=characterchoiceentityindex(el)
   entid=entityelement(te).bankindex
   if entityprofile(entid).ischaracter=1
    if stateanimwait(el)>10
     stateanimwait(el)=stateanimwait(el)-1
    endif
   endif
  endif
 next mel
 `
 rem Handle local ID assignment when client comes online
 if MULTIPLAYER GET PLAYER COUNT()>=1
  if dwLocalPlayerID=0
   rem AT VERY START OF JOINING STAGE
   PlayerCanStartStage=1
   rem establish local player ID
   dwLocalPlayerID=MULTIPLAYER GET PLAYER ID(0)
   dwStartJoinTime=timer()
   rem Trigger server to send all init states (priority)
   MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID : rem 080512 - V120 - Thanks to Hockeykid for this fix!
   write memblock byte 102, 0, 1
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,4
   inc guarenteedbytes,4 : inc unreliablebytes,0
  else
   rem find and fill local player index
   PlayerCanStartStage=2
   if iLocalEL=0
    for el=1 to multiplayeridlinkmax
     if multiplayeridlink(el)=dwLocalPlayerID
      iLocalEL=el : statemytimer(el)=timer() : exit
     endif
    next el
   endif
`  rem server ends (only when actually started game) - also wanted if host gone when joiner arrives
`  if PlayerCanStart=1
   rem server ends 5 second after started the join phase (or could have never been there)
   if timer()-dwStartJoinTime>5000
    if MULTIPLAYER GET CONNECTION()=0
     rem Terminate game if server player leaves
     gterminationcountdown=10
    endif
   endif
  endif
  rem if not voice setup, do it now
  if setupvoicechat=0
   setupvoicechat=1
  endif
 endif
 `
return

_playersend:
 `
 rem player sends data to server (only sends if client data changed since last send)
 if PlayerCanStart=1 or createorjoin=1
  `
  rem Regular burst of moveanim info
  if timer()-dwBurstTime>lagmon#
   rem reset bursttime counter (non-priority)
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
   dwBurstTime=timer()
   rem movement (if changed)
   tsendpos=0
   tcodesignaturex=(statex(iLocalEL)-(int(statex(iLocalEL)/500)*500))*1
   tcodesignaturey=(statey(iLocalEL)-(int(statey(iLocalEL)/500)*500))*500
   tcodesignaturez=(statez(iLocalEL)-(int(statez(iLocalEL)/500)*500))*25000
   tcodesignature=tcodesignaturex+tcodesignaturey+tcodesignaturez
   if statecodeupdate(iLocalEL,0)<>tcodesignature
    statecodeupdate(iLocalEL,0)=tcodesignature : tsendpos=1
   endif
   rem angle and animation and materialstoodon (if changed)
   tsendanim=0
   tcodesignature=stateviewy(iLocalEL)+(statecolmaterialtype(iLocalEL)*256)+(stateanim(iLocalEL)*(256*256))+(stateanimdir(iLocalEL)*123)
   if statecodeupdate(iLocalEL,4)<>tcodesignature
    statecodeupdate(iLocalEL,4)=tcodesignature : tsendanim=1
   endif
   if tsendpos=1 and tsendanim=1
    rem send both in one packet
    write memblock byte mb_move, 0, 9
    write memblock byte mb_move, 1, wrapvalue(statea(iLocalEL))/2
    x=statex(iLocalEL) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
    y=statey(iLocalEL) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
    z=abs(statez(iLocalEL)) : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
    write memblock word mb_move, 2, x
    write memblock word mb_move, 4, y
    write memblock word mb_move, 6, z
    write memblock byte mb_move, 8, wrapvalue(stateviewy(iLocalEL))/2
    write memblock byte mb_move, 9, stateanim(iLocalEL)
    write memblock byte mb_move, 10, 1+statecolmaterialtype(iLocalEL)
    write memblock byte mb_move, 11, stateanimdir(iLocalEL)
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,12
    inc guarenteedbytes,0 : inc unreliablebytes,12
   else
    rem one or the other
    if tsendpos=1
     write memblock byte mb_move, 0, 0
     write memblock byte mb_move, 1, wrapvalue(statea(iLocalEL))/2
     x=statex(iLocalEL) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
     y=statey(iLocalEL) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
     z=abs(statez(iLocalEL)) : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
     write memblock word mb_move, 2, x
     write memblock word mb_move, 4, y
     write memblock word mb_move, 6, z
     MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
     inc guarenteedbytes,0 : inc unreliablebytes,8
    endif
    if tsendanim=1
     write memblock byte mb_move, 0, 4
     write memblock byte mb_move, 1, wrapvalue(stateviewy(iLocalEL))/2
     write memblock byte mb_move, 2, stateanim(iLocalEL)
     write memblock byte mb_move, 3, 1+statecolmaterialtype(iLocalEL)
     write memblock byte mb_move, 4, stateanimdir(iLocalEL)
     MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
     inc guarenteedbytes,0 : inc unreliablebytes,8
    endif
   endif
   rem current health (if changed locally - if changed by server, update() is also updated)
   plrindex=multiplayerplrindex(iLocalEL)
   tcodesignature=player(plrindex).health
   if statecodeupdate(iLocalEL,2)<>tcodesignature
    statecodeupdate(iLocalEL,2)=tcodesignature
    rem client cannot send a health of zero (it could interfere with respawn)
    if player(plrindex).health>0
     write memblock byte 102, 0, 201
     write memblock dword 102, 4, multiplayeridlink(iLocalEL)
     write memblock dword 102, 8, player(plrindex).health
     MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
     inc guarenteedbytes,12 : inc unreliablebytes,0
    endif
   endif
   rem current weapon (if changed)
   plrindex=multiplayerplrindex(iLocalEL)
   tcodesignature=stateweapon(iLocalEL)
   if statecodeupdate(iLocalEL,3)<>tcodesignature
    statecodeupdate(iLocalEL,3)=tcodesignature
    te=characterchoiceentityindex(iLocalEL)
    write memblock byte 102, 0, 211
    write memblock byte 102, 1, entityelement(te).lifecode
    write memblock dword 102, 4, multiplayeridlink(iLocalEL)
    write memblock dword 102, 8, stateweapon(iLocalEL)
    MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
    inc guarenteedbytes,12 : inc unreliablebytes,0
   endif
   `
  endif
  `
 endif
 `
return

_multi_playershoots:
 `
 rem Trigger a shot flash and sound on other clients
 MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
 write memblock byte mb_move, 0, 5
 MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
 inc guarenteedbytes,0 : inc unreliablebytes,8
 `
return

_multi_dieanim:
 rem work out relative direction to throw entity from entity angle
 sourcete=characterchoiceentityindex(sourceel)
 brayx1#=entityelement(sourcete).x
 brayz1#=entityelement(sourcete).z
 tdir=0
 te=characterchoiceentityindex(el)
 distx#=entityelement(te).x-brayx1# : distz#=entityelement(te).z-brayz1#
 tentitya#=wrapvalue(atanfull(distx#,distz#))-wrapvalue(stateviewy(el))
 if tentitya#<0.0 then tentitya#=tentitya#+360.0
 if tentitya#>=360.0 then tentitya#=tentitya#-360.0
 if tentitya#>180-45 and tentitya#<180+45
  tdir=1
 else
  if tentitya#>315 or tentitya#<45
   tdir=2
  else
   if tentitya#>45 and tentitya#<180-45
    tdir=4
   else
    tdir=3
   endif
  endif
 endif
 rem Choose a good die anim (based on direction of shooter)
 stateanim(el)=12 : stateanimdir(el)=0
 if tdir=1 then stateanim(el)=12
 if tdir=2 then stateanim(el)=15
 if tdir=3 then stateanim(el)=21
 if tdir=4 then stateanim(el)=18
 rem Wipe out local health (so corpose can switch off radial collision)
 tplrindex=multiplayerplrindex(el) : player(tplrindex).health=0
 rem EL play die animation, timing it to end before a restart
 stateanimwait(el)=200
 rem ensure cannot respawn until plr has clicked to respawn
 stateplayagain(el)=0
 rem store who did it
 statewhodidit(el)=sourceel
 rem and freeze activity of states (which counts down after animwait is zero)
 stategetready(el)=50
 rem trigger sound for death-froan (excluded from regular takedamage subroutine)
 tplrid=entityelement(te).fakeplayerid : tsnd=15
 tplrid=changeplrforsound(tplrid,tsnd)
 if playersound(tplrid,tsnd)>0
  if tplrid=1
   broadcast3dsound(camera position x(),camera position y(),camera position z(),10.0,-1)
   play sound playersound(tplrid,tsnd)
  else
   playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(te).x,entityelement(te).y,entityelement(te).z,10.0)
  endif
 endif
return

_multi_resetplrpos:
 `
 rem find spawn points from multiplayer spawn array (uses trandomvalue) (uses randomposnotworkatlocalstart=1)
 te=characterchoiceentityindex(el)
 gosub _multi_playertorespawnpos
 `
 rem give lifecode to plr
 entityelement(te).lifecode=tlifecode
 `
 rem make plr invincible at start for a while
 entityelement(te).invincibleactive=150
 `
 rem Spawn sound (using real entity plr index (for sound))
 plrindex=entityelement(te).fakeplrindex
 gosub _player_spawnsound
 `
 rem uses el
 statex(el)=playerstartx#
 statey(el)=playerstarty#
 statez(el)=playerstartz#
 statea(el)=playerstartry#
 stateanim(el)=2
 stateanimdir(el)=0
 stateanimwait(el)=0
 stateweapon(el)=0
 statesx(el)=statex(el)
 statesy(el)=statey(el)
 statesz(el)=statez(el)
 statesa(el)=statea(el)
 statedx(el)=statex(el)
 statedy(el)=statey(el)
 statedz(el)=statez(el)
 multiplayerisnew(el)=1
 px#=statex(el)
 py#=statey(el)
 pz#=statez(el)
 pa#=statea(el)
 gosub _packet_move
 if el=iLocalEL
  rem local plr - remove old plr marker and restart to new position
  gosub _player_unmark
  gosub _player_restart
 else
  rem non-local plr repositioning, ensure object is updated here (to defeat universe cull)
  tobj=entityelement(te).obj
  if tobj>0
   if object exist(tobj)=1
    position object tobj,statex(el),statey(el),statez(el)
   endif
  endif
 endif
 `
 rem Fill updates with blanks to repeat playersend info (fixes firing with no gun bug)
 for ti=0 to 4 : statecodeupdate(el,ti)=-1 : next ti
 `
return

_multi_dealdamagedirect:
 `
 rem find out which player was hit (TE) (takes sourcee)
 plrindex=0 : plrel=0 : tplrcntmax=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   if characterchoiceentityindex(el)=te and plrel=0 then plrindex=multiplayerplrindex(el) : plrel=el
   inc tplrcntmax
  endif
 next el
 el=plrel
 rem no damage needed if being respawned (so do not get killed twice in close proximity)
 if plrel>0 and stateanimwait(plrel)>0 then plrindex=0
 rem update all clients with new health reading
 if plrindex>0
  player(plrindex).health=player(plrindex).health-tdamage
  if player(plrindex).health<=0 or (goneshotkills=1 and tdamage>0)
   `
   rem Server Registers a Kill
   sourceel=0
   if sourcee>0
    rem increment frag count
    for sourceel=1 to multiplayeridlinkmax
     if characterchoiceentityindex(sourceel)=sourcee then exit
    next sourceel
    rem only if you did not kill yourself
    if sourceel<>el then frags(sourceel)=frags(sourceel)+1
    `
    if characterlist$(characterchosen(sourceel))= characterlist$(characterchosen(el)) then frags(sourceel)=frags(sourceel)-2
    if frags(sourceel) < 0 then frags(sourceel) = 0
        rem only need to send frag to the guy who wants to know what he has
    MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
    write memblock byte 102, 0, 205
    write memblock byte 102, 1, frags(sourceel)
    write memblock dword 102, 4, multiplayeridlink(sourceel)
    write memblock dword 102, 8, multiplayeridlink(el)
    MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
    inc guarenteedbytes,12 : inc unreliablebytes,0
    `
   endif
   `
   rem Play die animation
   player(plrindex).health=0
   gosub _multi_dieanim
   rem inform player that they have been killed (who triggers dieanim)
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
   write memblock byte 102, 0, 202
   write memblock dword 102, 4, multiplayeridlink(el)
   write memblock dword 102, 8, multiplayeridlink(sourceel)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
   inc guarenteedbytes,12 : inc unreliablebytes,0
   `
  endif
  `
  rem Update client player health
  if tplrcntmax>1
   tvalue=player(plrindex).health
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
   write memblock byte 102, 0, 203
   write memblock dword 102, 4, multiplayeridlink(el)
   write memblock dword 102, 8, tvalue
   MULTIPLAYER SEND MESSAGE TO 2+multiplayeri(el)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
   MULTIPLAYER SEND MESSAGE TO 0
   inc guarenteedbytes,12 : inc unreliablebytes,0
  endif
  `
  rem if EL was hit, and is local, show damage by visual and sound
  if el=iLocalEL then gosub _multi_showplrdamage
  `
 endif
 `
return

_multi_dealentityedamage:
 `
 rem damage comes from caller of this subroutine
 sourcee=characterchoiceentityindex(iLocalEL)
 `
 rem replaces direct entity damage, by sending message to server (which will deduct the health)
 if createorjoin=1
  rem server player can deal damage direct, and then inform clients
  te=e : gosub _multi_dealdamagedirect
 else
  rem uses E which is the entity that has been damaged (client tells server to deal damage)
  MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
  write memblock byte 102, 0, 21
  write memblock byte 102, 1, entityelement(e).lifecode
  write memblock word 102, 2, e
  write memblock word 102, 4, tdamage
  write memblock word 102, 6, sourcee
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
return

_get_playerhealth:
 rem can be assigned high and low (any value)
 el=getelfromid(memblock dword(mb_move, 4))
 plrindex=multiplayerplrindex(el)
 tplayerhealth=memblock dword(mb_move, 8)
 player(plrindex).health=tplayerhealth
 if el=iLocalEL
  rem when own health adjusted remotely, ensure now sent BACK to server
  statecodeupdate(iLocalEL,2)=tplayerhealth
 endif
return

_multi_showplrdamage:
 rem hurt sound and visual
 tpe=characterchoiceentityindex(el)
 plrindex=entityelement(tpe).fakeplrindex
 tdamage=0 : gosub _player_takedamage
 rem no lives (multiplayer)
 if player(plrindex).lives<1 then player(plrindex).lives=1
return

_get_playerhurt:
 rem can only be assigned lower (as though shot)
 el=getelfromid(memblock dword(mb_move, 4))
 plrindex=multiplayerplrindex(el)
 tplayerhealth=memblock dword(mb_move, 8)
 if tplayerhealth>player(plrindex).health and memblock dword(mb_move, 4)=dwLocalPlayerID
  rem damage dealt by server to affected player cannot go UP
  rem fixes health value glitch where server messages are higher than latest local value
 else
  player(plrindex).health=tplayerhealth
  if el=iLocalEL
   rem when own health adjusted remotely, ensure now sent BACK to server
   statecodeupdate(iLocalEL,2)=tplayerhealth
  endif
 endif
 if el=iLocalEL then gosub _multi_showplrdamage
return

_multi_plrradial:
 `
 if multiplayerinitialised=1
  raddmin#=30
  for radel=1 to multiplayermax
   if radel<>iLocalEL
    if multiplayeridlink(radel)<>1
     tplrindex=multiplayerplrindex(radel)
     if tplrindex>0
      if player(tplrindex).health>0
       tte=characterchoiceentityindex(radel)
       if entityelement(tte).invincibleactive=0
        radx#=statedx(radel)-camerapositionx
        rady#=statedy(radel)-(camerapositiony-phyeyeheight#)
        radz#=statedz(radel)-camerapositionz
        if abs(rady#)<75
         radd#=sqrt(abs(radx#*radx#)+abs(radz#*radz#))
         if radd#<raddmin#
          rada#=atanfull(radx#,radz#)
          camvelx#=newxvalue(0,rada#,-5.0)
          camvelz#=newzvalue(0,rada#,-5.0)
          exit
         endif
        endif
       endif
      endif
     endif
    endif
   endif
  next radel
 endif
 `
return

_packet_move:
 `
 rem if newly joined, no history to curve from (avoids crazy rush across universe from 0,0,0)
 if multiplayerisnew(el)>0 and multiplayerisnew(el)<3
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz#
  statedx(el)=px# : statedy(el)=py# : statedz(el)=pz#
  multiplayerisnew(el)=multiplayerisnew(el)-1
 endif
 `
 rem move or no move
 if abs(statex(el)-px#)>1.0 or abs(statey(el)-py#)>1.0 or abs(statez(el)-pz#)>1.0
  eloff=((el-1)*5) : debugel=el
  statedx(el)=px# : statedy(el)=py# : statedz(el)=pz#
  statex(el)=statesx(el) : statey(el)=statesy(el) : statez(el)=statesz(el)
  cpx#(1)=statex(el) : cpy#(1)=statey(el) : cpz#(1)=statez(el) : set vector3 20+eloff,cpx#(1),cpy#(1),cpz#(1)
  tdx#=px#-statex(el)
  tdz#=statez(el)-pz#
  td#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))/2.0
  if statesvel(el)=0.0 then statesa(el)=atanfull(tdx#,tdz#)
  ix#=newxvalue(statex(el),statesa(el),td#)
  iy#=statey(el)
  iz#=newzvalue(statez(el),statesa(el)+180,td#)
  cpx#(2)=ix# : cpy#(2)=iy# : cpz#(2)=iz# : set vector3 21+eloff,cpx#(2),cpy#(2),cpz#(2)
  cpx#(3)=px# : cpy#(3)=py# : cpz#(3)=pz# : set vector3 22+eloff,cpx#(3),cpy#(3),cpz#(3)
  ix#=newxvalue(px#,pa#,td#)
  iy#=py#
  iz#=newzvalue(pz#,pa#+180,td#)
  cpx#(4)=ix# : cpy#(4)=iy# : cpz#(4)=iz# : set vector3 23+eloff,cpx#(4),cpy#(4),cpz#(4)
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz# : statesa(el)=pa#
  statesvel(el)=1.0
  statemsgap(el)=0
  statemove(el)=1
 else
  rem no movement, but update direction from static pose
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz# : statesa(el)=pa#
  statesvel(el)=0.0
  statemsgap(el)=0
  statemove(el)=0
 endif
 `
return

_packet_viewyanim:
 `
 rem turn or no turn
 statesviewdy(el)=pviewy#
 `
return

_packet_move_dedrec:
 `
 rem move position to follow spline based on time
 if statemove(el)=1
  if 1
   rem direct point to point
   timespan#=(1.0/200.0)*statemsgap(el)
   if timespan#>1.0 then timespan#=1.0 : statemove(el)=0
   eloff=((el-1)*5)
   cpx#=x vector3(20+eloff)
   cpy#=y vector3(20+eloff)
   cpz#=z vector3(20+eloff)
   rem move position of plr
   statex(el)=cpx#+((statesx(el)-cpx#)*timespan#)
   statey(el)=cpy#+((statesy(el)-cpy#)*timespan#)
   statez(el)=cpz#+((statesz(el)-cpz#)*timespan#)
  else
   rem catmulrom spline (changed vector numbers since)
`   lastx#=statex(el) : lasty#=statez(el)
`   timespan#=(2.0/statelag(el))*statemsgap(el)
`   eloff=((el-1)*5)
`   if timespan#>=0.0 and timespan#<1.0
`    CATMULLROM VECTOR3 5+eloff,1+eloff,1+eloff,2+eloff,3+eloff,timespan#
`    statex(el)=x vector3(5+eloff)
`    statey(el)=y vector3(5+eloff)
`    statez(el)=z vector3(5+eloff)
`    dfx#=statex(el)-lastx#
`    dfy#=lasty#-statez(el)
`    if abs(dfx#)+abs(dfy#)>0.01
`     statea(el)=wrapvalue(atanfull(dfx#,dfy#))
`    endif
`   else
`    if timespan#>=1.0 and timespan#<2.0
`     CATMULLROM VECTOR3 5+eloff,1+eloff,2+eloff,3+eloff,4+eloff,timespan#-1.0
`     statex(el)=x vector3(5+eloff)
`     statey(el)=y vector3(5+eloff)
`     statez(el)=z vector3(5+eloff)
`     dfx#=statex(el)-lastx#
`     dfy#=lasty#-statez(el)
`     if abs(dfx#)+abs(dfy#)>0.01
 `     statea(el)=wrapvalue(atanfull(dfx#,dfy#))
 `    endif
 `   endif
 `  endif
  endif
 endif
 `
return

_packet_rotate_dedrec:
 rem turn angle over time
 stateviewy(el)=curveangle(statesviewdy(el),stateviewy(el),8.0)
return

`
` User Interface Subroutines (screens/prompts)

_multi_identifycharactersinentities:
 `
 rem fill characters with names from characters in level
 tcharid=0
 characterlistentity(0)=0
 for te=1 to entityelementmax
  tentid=entityelement(te).bankindex
  if entityprofile(tentid).ischaracter=1
   inc tcharid : characterlist$(tcharid)=entityelement(te).eleprof.name$
   characterlistentity(tcharid)=te
  endif
 next te
 rem and adjust max players if not enough characters in level
 if numberofplayers>tcharid then numberofplayers=tcharid
 if tcharid>=2 and numberofplayers<2 then numberofplayers=2
 `
return

_multi_andwho:
 `
 rem first determine which entities the characters are
 gosub _multi_identifycharactersinentities
 `
 rem who is left
 characterlist(0)=0
 for tcl=1 to multiplayermax
  characterlist(tcl)=0
  for tcc=0 to numberofplayers-1
   if characterchosen(1+tcc)=tcl
    characterlist(tcl)=1
   endif
  next tcc
 next tcl
 `
 rem set text for choice
 set text size 12+((screen width()-320.0)/320.0)*6.0
 set text to normal
 `
 rem offer choice
 gap#=screen height()/20
 characterchoice=0
 clear entry buffer
 if numberofplayers>=2
  repeat
   t$=strarr$(641)
   ink rgb(0,0,0),0 : center text screen width()/2,(gap#*2),t$
   ink rgb(255,255,255),0 : center text (screen width()/2)-1,(gap#*2)-1,t$
   for tcl=1 to numberofplayers
    t$=str$(tcl)+". "+characterlist$(tcl)
    ink rgb(0,0,0),0 : center text screen width()/2,(gap#*5)+((tcl-1)*gap#),t$
    if characterlist(tcl)=0 then ink rgb(255,255,255),0 else ink rgb(64,64,64),0
    center text (screen width()/2)-1,(gap#*5)+((tcl-1)*gap#)-1,t$
   next tcl
   Rem Scene Commander - changed for TDM - Plystire
 set cursor 0,tylinevalue
   print "Choose a Character> ";entry$(1);
k$=entry$(1): if val(k$)>=1 and val(k$)<=16 and returnkey()=1 then characterchoice=(val(k$))
   sync
  until characterchoice>=1 and characterchoice<=numberofplayers
 else
  rem choose only character (if any)
  if numberofplayers=1
   characterchoice=1
  else
   characterchoice=0
  endif
 endif
 `
 rem restore text to in-game style and size
 set text size 16 : set text to normal
 `
return

_multi_cannotplay:
 `
 rem input tcannotplayreason
 repeat
  if tcannotplayreason=1 then t$=strarr$(642)
  if tcannotplayreason=2 then t$=strarr$(643)
  cls 0 : center text screen width()/2,(screen height()/2)-20,t$
  center text screen width()/2,(screen height()/2)+20,strarr$(644)
  sync
 until spacekey()=1
 `
return

_multi_missioncomplete:
 `
 rem announce as winner/loser directly
 winnerel=iLocalEL
 tbroadcastresult=iLocalEL
 if createorjoin=1
  rem broadcast that server has won to other players
  gosub _multi_informallplayersofcomplete
 else
  rem client must tell server to tell other players
  MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
  write memblock byte 102, 0, 105
  write memblock dword 102, 4, multiplayeridlink(tbroadcastresult)
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
 rem declare last after broascast(s)
 gosub _multi_declarewinorlose
 `
return

_multi_informallplayersofcomplete:
 `
 rem takes tbroadcastresult as EL winner
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
   write memblock byte 102, 0, 104
   write memblock word 102, 2, frags(el)
   write memblock dword 102, 4, multiplayeridlink(tbroadcastresult)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
   inc guarenteedbytes,8 : inc unreliablebytes,0
  endif
 next el
 `
return

_multi_declarewinorlose:
 `
 rem uses winnerel to determine winner identity
rem changed below line so teammates of player with winning kill will also get "YOU WIN" hud
rem changed for TDM
if multi_match_type > 0
    if characterlist$(characterchosen(winnerel))=characterlist$(characterchosen(iLocalEL))
     tserverendsreason=2
    else
     tserverendsreason=3
    endif
 else
    if winnerel=iLocalEL
     tserverendsreason=2
    else
     tserverendsreason=3
    endif
    endif
 gosub _multi_serverendedgame
 mpgameinprogress=0
 continueokay=1
 `
return

_multi_serverendedgame:
 `
 rem setup vars for win/lose channel (0-lost,1-skip,2-won)
 if tserverendsreason=1
  levelwon=2 : rem skip
 else
  if tserverendsreason=2
   levelwon=1 : rem won
  else
   if tserverendsreason=3
    levelwon=0 : rem lost
   else
    levelwon=2 : rem skip
   endif
  endif
 endif
 `
return

`
` MP Functions
`

function getindexfromid(idin as dword)
 index=0
 for i = 1 to MULTIPLAYER GET PLAYER COUNT( )
  if MULTIPLAYER GET PLAYER ID( i-1 )=idin
   index=i : exit
  endif
 next i
endfunction index

function getelfromid(idin as dword)
 gotel=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)=idin
   gotel=el : exit
  endif
 next el
endfunction gotel
`
` SAVE LOAD SUBROUTINES
`
_saveload_maindialogloop:
 `
 rem Ensure save/load stays on left side (where text is)
 if vrsidebysidestereo=1
  rem VR clears redundant side
  gosub _vrstereotogglescreen
  cls 0 : sync
  gosub _vrstereotogglescreen
  cls 0 : sync
  rem Ensure we render to the left
  set camera view 0,0,screen width()/2,screen height()
  set sprite resize 0,0,0.5
 endif
 `
 rem loop to control save/load dialog
 gosub _saveload_savebox_load
 saveload.slotselected=0
 saveloadmousex=(screen width()/4)*3
 saveloadmousey=screen height()/2
 cleardelta#=mousemovex() : cleardelta#=mousemovey()
 while saveload.slotselected=0
  `
  rem FPGC - 220210 - Contoller
  ttmouseclick=0 : ttcontrolofmousepos=0 : gosub _ai_hud_controller
  if abs(tjtx#)>50 or abs(tjty#)>50
   inc saveloadmousex,tjtx#/10.0 : inc saveloadmousey,tjty#/10.0
  endif
  `
  gosub _saveload_savebox_run
  mcammovex#=mousemovex() : mcammovey#=mousemovey()
  if gmousesensitivity>0 and gmousesensitivity<100
   mcammovex#=mcammovex#/200.0 : mcammovex#=mcammovex#*gmousesensitivity
   mcammovey#=mcammovey#/200.0 : mcammovey#=mcammovey#*gmousesensitivity
  endif
  inc saveloadmousex,mcammovex# : inc saveloadmousey,mcammovey#
  if saveloadmousex<saveload.saveloadx then saveloadmousex=saveload.saveloadx
  if saveloadmousex>saveload.saveloadx+560 then saveloadmousex=saveload.saveloadx+560
  if saveloadmousey<saveload.saveloady then saveloadmousey=saveload.saveloady
  if saveloadmousey>saveload.saveloady+310 then saveloadmousey=saveload.saveloady+310
  rem GUI-X9 (knxrb) >>>
  if aihudpointerimagestore > 0
    if image exist(aihudpointerimagestore)=1
      paste image aihudpointerimagestore,saveloadmousex,saveloadmousey,1
    else
      if sprite exist(MouseSprite)=1 then paste sprite MouseSprite,saveloadmousex,saveloadmousey
    endif
  else
    if sprite exist(MouseSprite)=1 then paste sprite MouseSprite,saveloadmousex,saveloadmousey
  endif
  rem GUI-X9 (knxrb) <<<
  sync
 endwhile
 aifreezemouseclicks=0
 if saveload.loadswitch=1
  if saveload.slotselected>0 then gosub _saveload_savebox_doload
 else
  if saveload.slotselected>0 then gosub _saveload_savebox_dosave
 endif
 gosub _saveload_savebox_free
 `
return

_saveload_savebox_init:
 `
 rem Setup at veru start of game
 saveload.saveloadimg=530 : rem between muzzle flash and image bank
 saveload.saveloadx=(screen width()-600)/2
 saveload.saveloady=(screen height()-350)/2
 `
return

_saveload_savebox_earlygrab:
 `
 rem Grab screen and reduce to JPG file
 `get image saveload.saveloadimg+3,(screen width()/2)-128,(screen height()/2)-128,(screen width()/2)+128,(screen height()/2)+128
 rem FPGC - 020909 - full screen grab for better saveload previewing (cropped at save)
 get image saveload.saveloadimg+3,0,0,screen width(),screen height()
 `
return

_saveload_savebox_initlist:
 `
 rem Create folder if not exist
 if path exist("gamesaves")=0 then make directory "gamesaves"
 `
 rem Load screen previews
 ttfile$="gamesaves\saveload.arr"
 if file exist(ttfile$)=1
  load array ttfile$,saveloadslot$()
 else
  for tclr=1 to 9 : saveloadslot$(tclr)=strarr$(645) : next tclr
 endif
 `
return

_saveload_savebox_load:
 `
 rem Load interface gfx
 saveload.saveloaddir$="languagebank\"+language$+"\gamecore\huds\saveload\"
 load image saveload.saveloaddir$+"saveload-base.tga",saveload.saveloadimg+1
 load image saveload.saveloaddir$+"areyousure.tga",saveload.saveloadimg+2
 `
 rem Create folder if not exist and init the list
 gosub _saveload_savebox_initlist
 `
 rem Load screen previews
 for sloti=1 to 9
  ttfile$="gamesaves\scrshot"+str$(sloti)+".jpg"
  if file exist(ttfile$)=1
   load image ttfile$,saveload.saveloadimg+10+sloti
  else
   if image exist(saveload.saveloadimg+10+sloti)=1 then delete image saveload.saveloadimg+10+sloti
  endif
 next sloti
 `
 rem Text for saveload box
 set text size 18 : set text font "arial"
 `
 rem Reset
 saveload.areyousure=0
 `
return

_saveload_savebox_free:
 `
 rem Free usages
 delete image saveload.saveloadimg+1
 delete image saveload.saveloadimg+2
 for sloti=1 to 9
  if image exist(saveload.saveloadimg+10+sloti)=1 then delete image saveload.saveloadimg+10+sloti
 next sloti
 `
return

_saveload_savebox_run:
 `
 rem Mouse coords
 tmmx=saveloadmousex : tmmy=saveloadmousey
 `
 rem Refresh saveload box
 paste image saveload.saveloadimg+1,saveload.saveloadx,saveload.saveloady
 `
 rem Slot names
 ink rgb(32,32,32),0
 if saveload.areyousure=0 then saveload.slothighlight=0
 for sloti=1 to 9
  thoverhighlight=0
  saveload.liney=saveload.saveloady+20+(sloti*27)
  if tmmx>=saveload.saveloadx+20 and tmmx<=saveload.saveloadx+300
   if tmmy>=saveload.liney and tmmy<saveload.liney+26
    if saveload.areyousure=0 then thoverhighlight=1
   endif
  endif
  if thoverhighlight=1
   if saveload.loadswitch=0 or saveloadslot$(sloti)<>strarr$(645)
    saveload.slothighlight=sloti
    ink rgb(255,255,255),0
   endif
  else
   ink rgb(32,32,32),0
  endif
  sltttx=saveload.saveloadx+25 : if vrsidebysidestereo=1 then sltttx=sltttx/2
  text sltttx,saveload.liney+4,str$(sloti)+"  "+saveloadslot$(sloti)
 next sloti
 `
 rem Preview
 if saveload.slothighlight>0
  slotimg=saveload.saveloadimg+10+saveload.slothighlight
  if image exist(slotimg)=1 then paste image slotimg,saveload.saveloadx+320,saveload.saveloady+40,1
 endif
 `
 rem Title of box
 ink rgb(255,255,255),0
 sltttx=saveload.saveloadx+300 : if vrsidebysidestereo=1 then sltttx=sltttx/2
 if saveload.loadswitch=1
  center text sltttx,saveload.saveloady+6,strarr$(646)
 else
  center text sltttx,saveload.saveloady+6,strarr$(647)
 endif
 `
 rem Are You Sure prompt
 if saveload.areyousure=1
  tareyousurex=saveload.saveloadx+50
  tareyousurey=saveload.saveloady+130
  paste image saveload.saveloadimg+2,tareyousurex,tareyousurey
  rem choice detection
  tyesnochoice1=0 : tyesnochoice2=0
  if tmmy>=tareyousurey+15 and tmmy<tareyousurey+45
   if tmmx>=tareyousurex+400 and tmmx<=tareyousurex+450 then tyesnochoice1=1 : tyesnochoice2=0
   if tmmx>=tareyousurex+450 and tmmx<=tareyousurex+500 then tyesnochoice1=0 : tyesnochoice2=1
  endif
  if saveload.loadswitch=1 then suretext$=strarr$(648)+" "+saveloadslot$(saveload.slothighlight)+"?" else suretext$=strarr$(649)+" "+saveloadslot$(saveload.slothighlight)+"?"
  sltttx=tareyousurex+30 : if vrsidebysidestereo=1 then sltttx=sltttx/2
  ink rgb(32,32,32),0 : text sltttx,tareyousurey+22,suretext$
  sltttx=tareyousurex+400 : if vrsidebysidestereo=1 then sltttx=sltttx/2
  ink rgb(tyesnochoice1*255,tyesnochoice1*255,tyesnochoice1*255),0 : text sltttx,tareyousurey+22,strarr$(650)
  sltttx=tareyousurex+450 : if vrsidebysidestereo=1 then sltttx=sltttx/2
  ink rgb(tyesnochoice2*255,tyesnochoice2*255,tyesnochoice2*255),0 : text sltttx,tareyousurey+22,strarr$(651)
  rem select one
  if control_mouseclick()<>0 and (tyesnochoice1=1 or tyesnochoice2=1)
   saveload.areyousure=0 : while control_mouseclick()<>0 : endwhile
   if tyesnochoice1=1 then saveload.slotselected=saveload.slothighlight
  endif
  rem Escape from confirmer box
  if control_escapekey()=1 then saveload.areyousure=0 : while control_escapekey()=1 : endwhile
 else
  rem Select slot
  if control_mouseclick()<>0 and saveload.slothighlight>0
   rem Slot X selected
   sloti=saveload.slothighlight
   if saveloadslot$(sloti)=strarr$(645)
    if saveload.loadswitch=0
     saveload.slotselected=saveload.slothighlight
    endif
   else
    rem overwrite?
    saveload.areyousure=1
   endif
  endif
  if control_escapekey()=1
   saveload.slotselected=-1
   while control_escapekey()=1 : endwhile
  endif
 endif
 `
return

_saveload_savebox_dosave:
 `
 rem Fill details
 tname$=strarr$(652)+" "+str$(level)
 rem GUI-X9 (knxrb)
 if guiUsed=0
     tdate$=left$(get time$(),5)+"-"+left$(get date$(),5)
     tnameanddate$=tname$+" "+tdate$
 else
     tdate$=left$(get time$(),5)+" - "+left$(get date$(),10)
     tnameanddate$=tname$+"  ("+tdate$+")"
 endif
 `
 rem Make entry in slot list and save
 ttfile$="gamesaves\saveload.arr"
 if file exist(ttfile$)=1 then delete file ttfile$
 saveloadslot$(saveload.slotselected)=tnameanddate$
 save array ttfile$,saveloadslot$()

 rem - if image doesn't exist then get image - Terry Fix
 if image exist(saveload.saveloadimg+3)=0 then get image saveload.saveloadimg+3,0,0,screen width(),screen height()

 rem FPGC - 020909 - crop if larger than 256x256
 if image exist(saveload.saveloadimg+3)=1
  if image width(saveload.saveloadimg+3)>256
   create bitmap 30,image width(saveload.saveloadimg+3),image height(saveload.saveloadimg+3)
   create bitmap 31,256,256
   set current bitmap 30
   paste image saveload.saveloadimg+3,0,0
   copy bitmap 30,0,0,image width(saveload.saveloadimg+3),image height(saveload.saveloadimg+3),31,0,0,256,256
   delete bitmap 30
   set current bitmap 31
   delete image saveload.saveloadimg+3
   get image saveload.saveloadimg+3,0,0,256,256
   delete bitmap 31
  endif
 endif
 `
 rem Save JPG to slot
 ttfile$="gamesaves\scrshot"+str$(saveload.slotselected)+".jpg"
 if file exist(ttfile$)=1 then delete file ttfile$
 save image ttfile$,saveload.saveloadimg+3,1
 `
 rem Actual slot filename
 saveloadfile$="gamesaves\slot"+str$(saveload.slotselected)+".dat"
 `Terry Fix to ensure image isn't duplicated
 if image exist(saveload.saveloadimg+3)=1 then delete image saveload.saveloadimg+3
 `
return

_saveload_savebox_doload:
 `
 rem Actual slot filename
 saveloadfile$="gamesaves\slot"+str$(saveload.slotselected)+".dat"

return


`
` SAVELOAD Actual Save and Load Game
`



_saveload_savegame:
 `
 rem CREATE SAVEGAMEDATA FROM GAME DATA
 gosub _saveload_storesavedata
 `
 rem SAVE
 if file exist(saveloadfile$)=1 then delete file saveloadfile$
 open to write 1,saveloadfile$
 version=120 : write file 1,version
 if version>=104
  rem V104
  rem Player
  a#=saveloadgameposition.level : write float 1,a#
  a#=saveloadgameposition.playerx : write float 1,a#
  a#=saveloadgameposition.playery : write float 1,a#
  a#=saveloadgameposition.playerz : write float 1,a#
  a#=saveloadgameposition.playerry : write float 1,a#
  a#=saveloadgameposition.playerhealth : write float 1,a#
  a#=saveloadgameposition.playerlives : write float 1,a#
  a#=saveloadgameposition.playerinventorymax : write float 1,a#
  a#=saveloadgameposition.missiongoaltotal : write float 1,a#
  rem Inventory
  for lsi=0 to 100
   a#=saveloadgamepositionplayerinventory(lsi).new : write float 1,a#
   a#=saveloadgamepositionplayerinventory(lsi).drop : write float 1,a#
   a#=saveloadgamepositionplayerinventory(lsi).index : write float 1,a#
  next lsi
  rem Objectives
  for lsi=0 to 99
   a#=saveloadgamepositionplayerobjective(lsi) : write float 1,a#
  next lsi
  rem Entities
  a#=entityelementmax : write float 1,a#
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).spawnleaderid : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ailibindex : write float 1,a#
   a$=saveloadgamepositionentity(lsi).aistate$ : write string 1,a$ rem GUI-X9 (String States)
   a$=saveloadgamepositionentity(lsi).aioldstate$ : write string 1,a$ rem GUI-X9 (String States)
   a#=saveloadgamepositionentity(lsi).active : write float 1,a#
   a#=saveloadgamepositionentity(lsi).dormant : write float 1,a#
   a#=saveloadgamepositionentity(lsi).beenkilled : write float 1,a#
   a#=saveloadgamepositionentity(lsi).x : write float 1,a#
   a#=saveloadgamepositionentity(lsi).y : write float 1,a#
   a#=saveloadgamepositionentity(lsi).z : write float 1,a#
   a#=saveloadgamepositionentity(lsi).rx : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ry : write float 1,a#
   a#=saveloadgamepositionentity(lsi).rz : write float 1,a#
   a#=saveloadgamepositionentity(lsi).floorposy : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animset : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animdo : write float 1,a#
   a#=saveloadgamepositionentity(lsi).currentammo : write float 1,a#
   a#=saveloadgamepositionentity(lsi).health : write float 1,a#
   a#=saveloadgamepositionentity(lsi).collected : write float 1,a#
   a#=saveloadgamepositionentity(lsi).activated : write float 1,a#
   a#=saveloadgamepositionentity(lsi).collisionactive : write float 1,a#
   rem V118 - 120810 - knxrb - etimer fix from Scene Commander
   a#=saveloadgamepositionentity(lsi).etimer : write float 1,a#
   a#=saveloadgamepositionentity(lsi).lastdamagetimer : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animatespeed : write float 1,a#  rem (markblosser)
   a#=saveloadgamepositionentity(lsi).entitydammult#: write float 1,a# rem Scene commander
   a#=saveloadgamepositionentity(lsi).ishidden: write float 1,a# rem Scene commander
   a#=saveloadgamepositionentity(lsi).cullstate: write float 1,a# rem Scene commander
   a#=saveloadgamepositionentity(lsi).usefade: write float 1,a# rem Scene commander
   a#=saveloadgamepositionentity(lsi).isimmune: write float 1,a# rem Scene commander
   a#=saveloadgamepositionentity(lsi).isanobjective: write float 1,a# rem Scene commander
   a#=saveloadgamepositionentity(lsi).objectiveradarrange: write float 1,a# rem Scene commander
   a#=saveloadgamepositionentity(lsi).entityacc: write float 1,a# rem Scene commander
  next lsi
  rem Weapons
  for lsi=0 to 20
   a#=saveloadgamepositionweaponslot(lsi).pref : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).got : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).invpos : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponammo : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponclipammo : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponhud : write float 1,a#
  next lsi
 endif
 if version>=109
  rem V109BETA4
  rem Global values from FPI scripting
  for lsi=0 to 99
   a#=aiglobals(lsi) : write float 1,a#
  next lsi
 endif
 if version>=113
  rem V113BETA4
  rem Local values from FPI scripting
  for lsi=0 to entityelementmax
   for lsii=0 to 99
    a#=ailocals(lsi,lsii) : write float 1,a#
   next lsii
  next lsi
 endif
 if version>=115
  rem V115BETA1
  rem Restore all waypoint and spawn states of entity
  rem to correct invisible spawns and wrong direction of waypoint users
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).actualtarget : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointstate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointcurrent : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointtracker : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointdirection : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointxstart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointystart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointzstart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointxinc : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointyinc : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointzinc : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aiusinginternalai : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aioldwaypointstate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aioldanimframe : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aiolddestanimframe : write float 1,a#
   a#=saveloadgamepositionentity(lsi).spawnatstart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).spawnupto : write float 1,a#
  next lsi
 endif
 if version>=116
  rem V116
  rem The orientation of the camera
  a#=saveloadgameposition.playerrx : write float 1,a#
  rem What gun is being carried
  a#=saveloadgameposition.playerholdinggun : write float 1,a#
  rem 091009 - Object angles fiffer from RX RY RZ


  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).orx : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ory : write float 1,a#
   a#=saveloadgamepositionentity(lsi).orz : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animframe : write float 1,a#
  next lsi
  rem FPGC - 191009 - add HUD data to save data
  a#=saveloadgamehudmax : write float 1,a#
  for thudid=1 to saveloadgamehudmax
   a$=saveloadgamehud(thudid).name$ : write string 1,a$
   a#=saveloadgamehud(thudid).maintype : write float 1,a#
   a#=saveloadgamehud(thudid).typemode : write float 1,a#
   a#=saveloadgamehud(thudid).posx : write float 1,a#
   a#=saveloadgamehud(thudid).posy : write float 1,a#
   a#=saveloadgamehud(thudid).posz : write float 1,a#
   a#=saveloadgamehud(thudid).sizex : write float 1,a#
   a#=saveloadgamehud(thudid).sizey : write float 1,a#
   a#=saveloadgamehud(thudid).sizez : write float 1,a#
   a#=saveloadgamehud(thudid).red : write float 1,a#
   a#=saveloadgamehud(thudid).green : write float 1,a#
   a#=saveloadgamehud(thudid).blue : write float 1,a#
   a#=saveloadgamehud(thudid).fadeout : write float 1,a#
   a#=saveloadgamehud(thudid).baseanim : write float 1,a#
   a#=saveloadgamehud(thudid).image : write float 1,a#
   a$=saveloadgamehud(thudid).font$ : write string 1,a$
   a#=saveloadgamehud(thudid).fontsize : write float 1,a#
   a$=saveloadgamehud(thudid).text$ : write string 1,a$
   a#=saveloadgamehud(thudid).hide : write float 1,a#
   a#=saveloadgamehud(thudid).hidedelay : write float 1,a#
   a#=saveloadgamehud(thudid).highlighted : write float 1,a#
   a#=saveloadgamehud(thudid).width : write float 1,a#
   a#=saveloadgamehud(thudid).height : write float 1,a#
   a$=saveloadgamehud(thudid).imagefile$ : write string 1,a$
      Rem Scene Commander
   a#=saveloadgamehud(thudid).scalex : write float 1,a#
   a#=saveloadgamehud(thudid).scaley : write float 1,a#
   a#=saveloadgamehud(thudid).alpha : write float 1,a#
  next thudid
 endif
 if version>=117
  rem FPGC - 100610 - save decal state, sound state and lift state (so player can save mid-lift ride)
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).decalindex : write float 1,a#
   a#=saveloadgamepositionentity(lsi).decalmode : write float 1,a#
   a#=saveloadgamepositionentity(lsi).tsoundset0state : write float 1,a#
   a#=saveloadgamepositionentity(lsi).tsoundset1state : write float 1,a#
   a#=saveloadgamepositionentity(lsi).physics : write float 1,a#
   a#=saveloadgamepositionentity(lsi).alttextureused : write float 1,a#
   Rem Dark AI
   a#=saveloadgamepositionentity(lsi).daistate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).daidestx : write float 1,a#
   a#=saveloadgamepositionentity(lsi).daidestz : write float 1,a#
   a#=saveloadgamepositionentity(lsi).daihasdest : write float 1,a#
   a#=saveloadgamepositionentity(lsi).isdai : write float 1,a#
   a#=saveloadgamepositionentity(lsi).daiteam : write float 1,a#
  next lsi
  rem lift (plr associations)
  a#=saveloadgameposition.meridinglift : write float 1,a#
  `
  Rem Save Dark AI points() array
  array=array count(saveloadgamepositionpoints())
  a#=array : write float 1,a#
  for i=1 to array
   a#=saveloadgamepositionpoints(i).id : write float 1,a#
   a#=saveloadgamepositionpoints(i).x : write float 1,a#
   a#=saveloadgamepositionpoints(i).y : write float 1,a#
   a#=saveloadgamepositionpoints(i).z : write float 1,a#
  next i
  `
  Rem Save Dark AI factions
  for x=1 to FactionArrayMax
   a#=saveloadgamepositionfactions(x,1).team : write float 1,a#
   for i=1 to FactionArrayMax
    a#=saveloadgamepositionfactions(x,i).neutral : write float 1,a#
    a#=saveloadgamepositionfactions(x,i).ally : write float 1,a#
    a#=saveloadgamepositionfactions(x,i).enemy : write float 1,a#
   next i
  next x
  `
  rem - Save user variables
  a#=array count(uservars()) : write float 1,a#
  for i=0 to array count(uservars())
   a$=uservars(i).name : write string 1,a$
   a#=uservars(i).value : write float 1,a#
  next i
  `
 endif
 if version>=118
  `
  rem 310311- TerryFix - save ambience that is currently used
  a#=guivisualsettings.ambience : write float 1,a#
  `
  rem Local values from FPI scripting
  for lsi=0 to entityelementmax
   for lsii=0 to 99
    a#=aiuserlocals(lsi,lsii).value : write float 1,a#
    a#=aiuserlocals(lsi,lsii).newsystem : write float 1,a#
    a$=aiuserlocals(lsi,lsii).name : write string 1,a$
    a#=aiuserlocals(lsi,lsii).used : write float 1,a#
   next lsii
  next lsi
  `
 endif

if version>=119
a#=wobble#: write float 1,a#
rem new deaths
a#=tiltondeath: write float 1,a#
a#=tilton: write float 1,a#
a#=tiltspeed#: write float 1,a#
a#=temptilt: write float 1,a#
a#=thud: write float 1,a#
a#=tiltbounce: write float 1,a#
a#=justdone: write float 1,a#
rem video
a#=unskip: write float 1,a#
rem player forced actiona
a#=playeraction: write float 1,a#
a#=forcemove: write float 1,a#
rem allow force damage
a#=forcedamageon: write float 1,a#
rem guns
a#=crosshairon: write float 1,a#
a#=forcedslot: write float 1,a#
rem armour
a#=armour: write float 1,a#
a#=armouron: write float 1,a#
a#=armx: write float 1,a#
a#=army: write float 1,a#
a#=bodyon: write float 1,a#
rem air
a#=airon: write float 1,a#
a#=airleft: write float 1,a#
a#=airmax: write float 1,a#
a#=drowntime: write float 1,a#
a#=airtime: write float 1,a#
a#=airtimer: write float 1,a#
a#=drowntimer: write float 1,a#
a#=airx: write float 1,a#
a#=airy: write float 1,a#
a#=instantdrown: write float 1,a#
a#=lastsetair: write float 1,a#
a#=drowned: write float 1,a#
rem god mode
a#=isimmune: write float 1,a#
rem control keys
a#=arrowkeyson: write float 1,a#
a#=jumponkey: write float 1,a#
a#=crouchonkey: write float 1,a#
a#=peekonkeys: write float 1,a#
a#=walkonkeys: write float 1,a#
a#=runkeys: write float 1,a#
rem compass - knxrb
a#=compassOn: write float 1,a#
a#=compassX: write float 1,a#
a#=compassY: write float 1,a#
a#=spritesPasted: write float 1,a#
a#=gameStarted: write float 1,a#
a#=madeCompass: write float 1,a#
a#=needleSpin: write float 1,a#
a#=compassSpin: write float 1,a#
rem dark ai radar
a#=darkradar: write float 1,a#
a#=radarx: write float 1,a#
a#=radary: write float 1,a#
a#=maderadar: write float 1,a#
a#=rotateblip: write float 1,a#
a#=radarrange: write float 1,a#
rem player speed mod
a#=speedmod#: write float 1,a#
rem radar/compass object as objective
a#=objectivemode: write float 1,a#
a#=istheobjective: write float 1,a#
a#=objectivex: write float 1,a#
a#=objectivey: write float 1,a#
a#=madeobjective: write float 1,a#
a#=maxslots: write float 1,a#
a#=cameracarryweight#: write float 1,a#
a#=camerathrow#: write float 1,a#
a#=waterflec: write float 1,a#
rem Scene Commander culling
a#=cullmode: write float 1,a#
a#=cullmodi: write float 1,a#
rem additional Scene Commander
a#=plrfootfall: write float 1,a#
a#=lastfired: write float 1,a#
a#=noholster: write float 1,a#
a#=noairon: write float 1,a#
a#=drowndamage: write float 1,a#
a#=lastpickrange#: write float 1,a#
a#=pickrange#: write float 1,a#
a#=laststrength#: write float 1,a#
a#=lastthrow#: write float 1,a#
a#=flashr: write float 1,a#
a#=flashg: write float 1,a#
a#=flashb: write float 1,a#
a#=flashrange: write float 1,a#
a#=playerdammult#: write float 1,a#
a#=resetonreload: write float 1,a#
a#=ecam: write float 1,a#
a#=lastcam: write float 1,a#
a#=custstart: write float 1,a#
a#=custend: write float 1,a#
a#=lockangle: write float 1,a#
a#=fieldoffire: write float 1,a#
a#=playeraccmult#: write float 1,a#
a#=plrcamoffsetx#:write float 1,a#
a#=plrcamoffsety#:write float 1,a#
a#=plrcamoffsetz#:write float 1,a#
a#=plrcamoffseton:write float 1,a#
a#=waterheight#:write float 1,a#
a#=oldwaterheight#:write float 1,a#
a#=watercurrent:write float 1,a#
a#=waterflow:write float 1,a#
a#=showflak:write float 1,a#
a#=syncrate:write float 1,a#

for f=1 to 10
a#=animations(f).paused
write float 1,a#
next f

for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).soundplaying : write float 1,a#
next lsi

for f=1 to 100
   a$=ammopool(f).name$: write string 1,a$
   a#=ammopool(f).ammo: write float 1,a#
   a#=ammopool(f).used: write float 1,a#
next f

endif

 close file 1
 `
 rem GUI-X9 (knxrb)
 GUISave = 0
return

_saveload_loadgame:
 `
 undim uservars()
 dim uservars() as uservar
 `
 rem LOAD
 open to read 1,saveloadfile$
 read file 1,version
 if version>=104
  rem V104
  rem Player
  read float 1,a# : saveloadgameposition.level=a#
  read float 1,a# : saveloadgameposition.playerx=a#
  read float 1,a# : saveloadgameposition.playery=a#
  read float 1,a# : saveloadgameposition.playerz=a#
  read float 1,a# : saveloadgameposition.playerry=a#
  read float 1,a# : saveloadgameposition.playerhealth=a#
  read float 1,a# : saveloadgameposition.playerlives=a#
  read float 1,a# : saveloadgameposition.playerinventorymax=a#
  read float 1,a# : saveloadgameposition.missiongoaltotal=a#
  rem Inventory
  dim saveloadgamepositionplayerinventory(100) as inventorytype
  for lsi=0 to 100
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).new=a#
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).drop=a#
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).index=a#
  next lsi
  rem Objectives
  dim saveloadgamepositionplayerobjective(99)
  for lsi=0 to 99
   read float 1,a# : saveloadgamepositionplayerobjective(lsi)=a#
  next lsi
  rem Entities
  read float 1,a# : entityelementmax=a#
  dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).spawnleaderid=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ailibindex=a#
   read string 1,a$ : saveloadgamepositionentity(lsi).aistate$=a$ rem GUI-X9 (String States)
   read string 1,a$ : saveloadgamepositionentity(lsi).aioldstate$=a$ rem GUI-X9 (String States)
   read float 1,a# : saveloadgamepositionentity(lsi).active=a#
   read float 1,a# : saveloadgamepositionentity(lsi).dormant=a#
   read float 1,a# : saveloadgamepositionentity(lsi).beenkilled=a#
   read float 1,a# : saveloadgamepositionentity(lsi).x=a#
   read float 1,a# : saveloadgamepositionentity(lsi).y=a#
   read float 1,a# : saveloadgamepositionentity(lsi).z=a#
   read float 1,a# : saveloadgamepositionentity(lsi).rx=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ry=a#
   read float 1,a# : saveloadgamepositionentity(lsi).rz=a#
   read float 1,a# : saveloadgamepositionentity(lsi).floorposy=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animset=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animdo=a#
   read float 1,a# : saveloadgamepositionentity(lsi).currentammo=a#
   read float 1,a# : saveloadgamepositionentity(lsi).health=a#
   read float 1,a# : saveloadgamepositionentity(lsi).collected=a#
   read float 1,a# : saveloadgamepositionentity(lsi).activated=a#
   read float 1,a# : saveloadgamepositionentity(lsi).collisionactive=a#
   rem V118 - 120810 - knxrb - etimer fix from Scene Commander
   read float 1,a# : saveloadgamepositionentity(lsi).etimer=a#
   read float 1,a# : saveloadgamepositionentity(lsi).lastdamagetimer=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animatespeed=a#  rem (markblosser)
   read float 1,a# : saveloadgamepositionentity(lsi).entitydammult#=a# rem Scene commander
   read float 1,a# : saveloadgamepositionentity(lsi).ishidden=a# rem Scene commander
   read float 1,a# : saveloadgamepositionentity(lsi).cullstate=a# rem Scene commander
   read float 1,a# : saveloadgamepositionentity(lsi).usefade=a# rem Scene commander
   read float 1,a# : saveloadgamepositionentity(lsi).isimmune=a# rem Scene commander
   read float 1,a# : saveloadgamepositionentity(lsi).isanobjective=a# rem Scene commander
   read float 1,a# : saveloadgamepositionentity(lsi).objectiveradarrange=a# rem Scene commander
   read float 1,a# : saveloadgamepositionentity(lsi).entityacc=a# rem Scene commander
  next lsi
  rem Weapons
  dim saveloadgamepositionweaponslot(20) as saveloadgamepositionweaponslottype
  for lsi=0 to 20
   read float 1,a# : saveloadgamepositionweaponslot(lsi).pref=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).got=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).invpos=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponammo=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponclipammo=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponhud=a#
  next lsi
 endif
 if version>=109
  rem V109BETA4
  rem Global values from FPI scripting
  for lsi=0 to 99
   read float 1,a# : aiglobals(lsi)=a#
  next lsi
 endif
 if version>=113
  rem V113BETA4
  rem Local values from FPI scripting
  rem V113BETA5 - ensure DIM the array before try to write to it
  dim ailocals(entityelementmax,99)
  for lsi=0 to entityelementmax
   for lsii=0 to 99
    read float 1,a# : ailocals(lsi,lsii)=a#
   next lsii
  next lsi
 endif
 if version>=115
  rem V115BETA1
  rem Restore all waypoint and spawn states of entity
  rem to correct invisible spawns and wrong direction of waypoint users
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).actualtarget=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointstate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointcurrent=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointtracker=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointdirection=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointxstart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointystart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointzstart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointxinc=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointyinc=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointzinc=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aiusinginternalai=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aioldwaypointstate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aioldanimframe=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aiolddestanimframe=a#
   read float 1,a# : saveloadgamepositionentity(lsi).spawnatstart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).spawnupto=a#
  next lsi
 endif
 if version>=116
  rem V116
  read float 1,a# : saveloadgameposition.playerrx=a#
  read float 1,a# : saveloadgameposition.playerholdinggun=a#
  rem 091009 - object otation seperated from entity element rotatyion

  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).orx=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ory=a#
   read float 1,a# : saveloadgamepositionentity(lsi).orz=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animframe=a#
  next lsi
  rem FPGC - 191009 - add HUD data to save/restore
  read float 1,a# : saveloadgamehudmax=a#
  dim saveloadgamehud(saveloadgamehudmax) as hudtype
  for thudid=1 to saveloadgamehudmax
   read string 1,a$ : saveloadgamehud(thudid).name$=a$
   read float 1,a# : saveloadgamehud(thudid).maintype=a#
   read float 1,a# : saveloadgamehud(thudid).typemode=a#
   read float 1,a# : saveloadgamehud(thudid).posx=a#
   read float 1,a# : saveloadgamehud(thudid).posy=a#
   read float 1,a# : saveloadgamehud(thudid).posz=a#
   read float 1,a# : saveloadgamehud(thudid).sizex=a#
   read float 1,a# : saveloadgamehud(thudid).sizey=a#
   read float 1,a# : saveloadgamehud(thudid).sizez=a#
   read float 1,a# : saveloadgamehud(thudid).red=a#
   read float 1,a# : saveloadgamehud(thudid).green=a#
   read float 1,a# : saveloadgamehud(thudid).blue=a#
   read float 1,a# : saveloadgamehud(thudid).fadeout=a#
   read float 1,a# : saveloadgamehud(thudid).baseanim=a#
   read float 1,a# : saveloadgamehud(thudid).image=a#
   read string 1,a$ : saveloadgamehud(thudid).font$=a$
   read float 1,a# : saveloadgamehud(thudid).fontsize=a#
   read string 1,a$ : saveloadgamehud(thudid).text$=a$
   read float 1,a# : saveloadgamehud(thudid).hide=a#
   read float 1,a# : saveloadgamehud(thudid).hidedelay=a#
   read float 1,a# : saveloadgamehud(thudid).highlighted=a#
   read float 1,a# : saveloadgamehud(thudid).width=a#
   read float 1,a# : saveloadgamehud(thudid).height=a#
   read string 1,a$ : saveloadgamehud(thudid).imagefile$=a$
   rem scene commander
   read float 1,a# : saveloadgamehud(thudid).scalex=a#
   read float 1,a# : saveloadgamehud(thudid).scaley=a#
   read float 1,a# : saveloadgamehud(thudid).alpha=a#
  next thudid
 endif
 if version>=117
  rem FPGC - 100610 - save decal state, sound state and lift state (so player can save mid-lift ride)
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).decalindex=a#
   read float 1,a# : saveloadgamepositionentity(lsi).decalmode=a#
   read float 1,a# : saveloadgamepositionentity(lsi).tsoundset0state=a#
   read float 1,a# : saveloadgamepositionentity(lsi).tsoundset1state=a#
   read float 1,a# : saveloadgamepositionentity(lsi).physics=a#
   read float 1,a# : saveloadgamepositionentity(lsi).alttextureused=a#
   Rem Dark AI
   read float 1,a# : saveloadgamepositionentity(lsi).daistate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).daidestx=a#
   read float 1,a# : saveloadgamepositionentity(lsi).daidestz=a#
   read float 1,a# : saveloadgamepositionentity(lsi).daihasdest=a#
   read float 1,a# : saveloadgamepositionentity(lsi).isdai=a#
   read float 1,a# : saveloadgamepositionentity(lsi).daiteam=a#
  next lsi
  rem lift (plr associations)
  read float 1,a# : saveloadgameposition.meridinglift=a#
  `
  Rem Load Dark AI points() array
  read float 1,a# : array=a#
  dim saveloadgamepositionpoints(array) as pathtype
  dim points(array) as pathtype
  for i=1 to array
   read float 1,a# : saveloadgamepositionpoints(i).id=a#
   read float 1,a# : saveloadgamepositionpoints(i).x=a#
   read float 1,a# : saveloadgamepositionpoints(i).y=a#
   read float 1,a# : saveloadgamepositionpoints(i).z=a#
  next i
  `
  Rem Load Dark AI faction array
  dim saveloadgamepositionfactions(FactionArrayMax,FactionArrayMax) as aifactiontype
  for x=1 to FactionArrayMax
   read float 1,a# : saveloadgamepositionfactions(x,1).team=a#
   for i=1 to FactionArrayMax
    read float 1,a# : saveloadgamepositionfactions(x,i).neutral=a#
    read float 1,a# : saveloadgamepositionfactions(x,i).ally=a#
    read float 1,a# : saveloadgamepositionfactions(x,i).enemy=a#
   next i
  next x
  `
  rem - Load user variables
  read float 1,max#
  for i=0 to max#
   array insert at bottom uservars(0)
   uservars(i).used=1
   read string 1,a$ : uservars(i).name=a$
   read float 1,a# : uservars(i).value=a#
  next i
  `
 endif
 if version>=118
  `
  rem 310311- TerryFix - load ambience that was previously saved
  read float 1,a# : saveloadgameposition.ambience=a#
  `
  rem Local values from FPI scripting
  dim aiuserlocals(entityelementmax,99) as uservar
  for lsi=0 to entityelementmax
   for lsii=0 to 99
    read float 1,a# : aiuserlocals(lsi,lsii).value=a#
    read float 1,a# : aiuserlocals(lsi,lsii).newsystem=a#
    read string 1,a$ : aiuserlocals(lsi,lsii).name=a$
    read float 1,a# : aiuserlocals(lsi,lsii).used=a#
   next lsii
  next lsi
 endif

 if version>=119
read float 1,a#:wobble#=a#
rem new deaths
read float 1,a#:tiltondeath=a#
read float 1,a#:tilton=a#
read float 1,a#:tiltspeed#=a#
read float 1,a#:temptilt=a#
read float 1,a#:thud=a#
read float 1,a#:tiltbounce=a#
read float 1,a#:justdone=a#
rem video
read float 1,a#:unskip=a#
rem player forced actiona
read float 1,a#:playeraction=a#
read float 1,a#:forcemove=a#
rem allow force damage
read float 1,a#:forcedamageon=a#
rem guns
read float 1,a#:crosshairon=a#
read float 1,a#:forcedslot=a#
rem armour
read float 1,a#:armour=a#
read float 1,a#:armouron=a#
read float 1,a#:armx=a#
read float 1,a#:army=a#
read float 1,a#:bodyon=a#
rem air
read float 1,a#:airon=a#
read float 1,a#:airleft=a#
read float 1,a#:airmax=a#
read float 1,a#:drowntime=a#
read float 1,a#:airtime=a#
read float 1,a#:airtimer=a#
read float 1,a#:drowntimer=a#
read float 1,a#:airx=a#
read float 1,a#:airy=a#
read float 1,a#:instantdrown=a#
read float 1,a#:lastsetair=a#
read float 1,a#:drowned=a#
rem god mode
read float 1,a#:isimmune=a#
rem control keys
read float 1,a#:arrowkeyson=a#
read float 1,a#:jumponkey=a#
read float 1,a#:crouchonkey=a#
read float 1,a#:peekonkeys=a#
read float 1,a#:walkonkeys=a#
read float 1,a#:runkeys=a#
rem compass - knxrb
read float 1,a#:compassOn=a#
read float 1,a#:compassX=a#
read float 1,a#:compassY=a#
read float 1,a#:spritesPasted=0
read float 1,a#:gameStarted=a#
read float 1,a#:madeCompass=0
read float 1,a#:needleSpin=a#
read float 1,a#:compassSpin=a#
rem dark ai radar
read float 1,a#:darkradar=a#
read float 1,a#:radarx=a#
read float 1,a#:radary=a#
read float 1,a#:maderadar=0
read float 1,a#:rotateblip=a#
read float 1,a#:radarrange=a#
rem player speed mod
read float 1,a#:speedmod#=a#
rem radar/compass object as objective
read float 1,a#:objectivemode=a#
read float 1,a#:istheobjective=a#
read float 1,a#:objectivex=a#
read float 1,a#:objectivey=a#
read float 1,a#:madeobjective=0
rem load max slots
read float 1,a#:maxslots=a#
rem load current strength
read float 1,a#:cameracarryweight#=a#
read float 1,a#:camerathrow#=a#
read float 1,a#:waterflec=a#
rem Scene Commander culling
read float 1,a#:cullmode=a#
read float 1,a#:cullmodi=a#
read float 1,a#:plrfootfall=a#
read float 1,a#:lastfired=a#
read float 1,a#:noholster=a#
read float 1,a#:noairon=a#
read float 1,a#:drowndamage=a#
read float 1,a#:lastpickrange#=a#
read float 1,a#:pickrange#=a#
read float 1,a#:laststrength#=a#
read float 1,a#:lastthrow#=a#
read float 1,a#:flashr=a#
read float 1,a#:flashg=a#
read float 1,a#:flashb=a#
read float 1,a#:flashrange=a#
read float 1,a#:playerdammult#=a#
read float 1,a#:resetonreload=a#
read float 1,a#:ecam=a#
read float 1,a#:lastcam=a#
read float 1,a#:custstart=a#
read float 1,a#:custend=a#
read float 1,a#:lockangle=a#
read float 1,a#:fieldoffire=a#
read float 1,a#:playeraccmult#=a#
read float 1,a#:plrcamoffsetx#=a#
read float 1,a#:plrcamoffsety#=a#
read float 1,a#:plrcamoffsetz#=a#
read float 1,a#:plrcamoffseton=a#
read float 1,a#:waterheight#=a#
read float 1,a#:oldwaterheight#=a#
read float 1,a#:watercurrent=a#
read float 1,a#:waterflow=a#
read float 1,a#:showflak=a#
read float 1,a#:syncrate=a#

for f=1 to 10
read float 1,a#
animations(f).paused=a#
next f

  for lsi=0 to entityelementmax

   read float 1,a# : saveloadgamepositionentity(lsi).soundplaying=a#

   next lsi

for f=1 to 100
read string 1,a$: ammopool(f).name$=a$
  read float 1,a#: ammopool(f).ammo=a#
  read float 1,a#: ammopool(f).used=a#
next f

endif

 close file 1
 `
 rem Immediate data required (prior to level loading) - 'saveload_retrievesavedata' used after level loaded
 level=saveloadgameposition.level
 `
 rem GUI-X9 (knxrb)
 GUILoad = 0
return

_saveload_storesavedata:
 `
 rem Move player data from actual game to the game data structures
 player(1).x=camerapositionx
 player(1).y=camerapositiony-phyeyeheight#
 player(1).z=camerapositionz
 `
 rem Create savedata arrays and copy game data to them
 saveloadgameposition.level=level
 saveloadgameposition.playerx=player(1).x
 saveloadgameposition.playery=player(1).y
 saveloadgameposition.playerz=player(1).z
 saveloadgameposition.playerrx=camera angle x(0)
 saveloadgameposition.playerry=camera angle y(0)
 saveloadgameposition.playerhealth=player(1).health
 saveloadgameposition.playerlives=player(1).lives
 saveloadgameposition.playerinventorymax=player(1).inventorymax
 saveloadgameposition.missiongoaltotal=missiongoaltotal
 saveloadgameposition.playerholdinggun=0 : rem Terry fix - no effect and solves WP artefact (autoloadgun)
 saveloadgameposition.meridinglift=meridinglift
 `
 rem Inventory
 dim saveloadgamepositionplayerinventory(100) as inventorytype
 for lsi=0 to 100
  saveloadgamepositionplayerinventory(lsi).new=playerinventory(1,lsi).new
  saveloadgamepositionplayerinventory(lsi).drop=playerinventory(1,lsi).drop
  saveloadgamepositionplayerinventory(lsi).index=playerinventory(1,lsi).index
 next lsi
 rem Objectives
 dim saveloadgamepositionplayerobjective(99)
 for lsi=0 to 99
  saveloadgamepositionplayerobjective(lsi)=playerobjective(lsi)
 next lsi
 rem Entities
 dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
 for lsi=0 to entityelementmax
  saveloadgamepositionentity(lsi).spawnleaderid=entityelement(lsi).spawn.leaderid
  saveloadgamepositionentity(lsi).ailibindex=entityelement(lsi).ai.libindex
  saveloadgamepositionentity(lsi).aistate$=entityelement(lsi).ai.state$ rem GUI-X9 (String States)
  saveloadgamepositionentity(lsi).aioldstate$=entityelement(lsi).ai.oldstate$ rem GUI-X9 (String States)
  saveloadgamepositionentity(lsi).active=entityelement(lsi).active
  saveloadgamepositionentity(lsi).dormant=entityelement(lsi).dormant
  saveloadgamepositionentity(lsi).beenkilled=entityelement(lsi).beenkilled
  saveloadgamepositionentity(lsi).x=entityelement(lsi).x
  saveloadgamepositionentity(lsi).y=entityelement(lsi).y
  saveloadgamepositionentity(lsi).z=entityelement(lsi).z
  rem V118 - 120810 - knxrb - etimer fix from Scene Commander
  saveloadgamepositionentity(lsi).etimer=entityelement(lsi).etimerpaused
  saveloadgamepositionentity(lsi).lastdamagetimer=entityelement(lsi).lastdamagetimer
  saveloadgamepositionentity(lsi).animatespeed=entityelement(lsi).animatespeed rem (markblosser)
  saveloadgamepositionentity(lsi).entitydammult#=entityelement(lsi).entitydammult# rem Scene commander
  saveloadgamepositionentity(lsi).ishidden=entityelement(lsi).ishidden rem Scene commander
  saveloadgamepositionentity(lsi).cullstate=entityelement(lsi).cullstate rem Scene commander
  saveloadgamepositionentity(lsi).isimmune=entityelement(lsi).isimmune rem Scene commander
  saveloadgamepositionentity(lsi).isanobjective=entityelement(lsi).isanobjective rem Scene commander
  saveloadgamepositionentity(lsi).objectiveradarrange=entityelement(lsi).objectiveradarrange rem Scene commander
  saveloadgamepositionentity(lsi).entityacc=entityelement(lsi).entityacc rem Scene commander

  tttobj=entityelement(lsi).obj
  if tttobj>0
   if object exist(tttobj)=1
    lsientid=entityelement(lsi).bankindex
    if entityprofile(lsientid).ischaracter=1
     saveloadgamepositionentity(lsi).rx=0
     saveloadgamepositionentity(lsi).ry=entityelement(lsi).ry
     saveloadgamepositionentity(lsi).rz=0
    else
     saveloadgamepositionentity(lsi).rx=object angle x(tttobj)
     saveloadgamepositionentity(lsi).ry=object angle y(tttobj)
     saveloadgamepositionentity(lsi).rz=object angle z(tttobj)
     saveloadgamepositionentity(lsi).orx=object angle x(tttobj)
     saveloadgamepositionentity(lsi).ory=object angle y(tttobj)
     saveloadgamepositionentity(lsi).orz=object angle z(tttobj)
    endif
   endif
  endif
  saveloadgamepositionentity(lsi).floorposy=entityelement(lsi).floorposy
  saveloadgamepositionentity(lsi).animset=entityelement(lsi).animset
  saveloadgamepositionentity(lsi).animdo=entityelement(lsi).animdo
  saveloadgamepositionentity(lsi).animframe=entityelement(lsi).animframe
  saveloadgamepositionentity(lsi).currentammo=entityelement(lsi).currentammo
  saveloadgamepositionentity(lsi).health=entityelement(lsi).health
  saveloadgamepositionentity(lsi).collected=entityelement(lsi).collected
  saveloadgamepositionentity(lsi).activated=entityelement(lsi).activated
  saveloadgamepositionentity(lsi).collisionactive=entityelement(lsi).collisionactive
  saveloadgamepositionentity(lsi).decalindex=entityelement(lsi).decalindex
  saveloadgamepositionentity(lsi).decalmode=entityelement(lsi).decalmode
  tsoundset0state=0 : if entityelement(lsi).soundset>0 then tsoundset0state=sound looping(entityelement(lsi).soundset)
  saveloadgamepositionentity(lsi).tsoundset0state=tsoundset0state
  tsoundset1state=0 : if entityelement(lsi).soundset1>0 then tsoundset1state=sound looping(entityelement(lsi).soundset1)
  saveloadgamepositionentity(lsi).tsoundset1state=tsoundset1state
  saveloadgamepositionentity(lsi).physics=entityelement(lsi).eleprof.physics
  saveloadgamepositionentity(lsi).alttextureused=entityelement(lsi).alttextureused
  Rem Dark AI
  saveloadgamepositionentity(lsi).daistate=entityelement(lsi).darkai.state
  saveloadgamepositionentity(lsi).daiteam=entityelement(lsi).darkai.team
  saveloadgamepositionentity(lsi).daihasdest=0
  saveloadgamepositionentity(lsi).daidestx=0
  saveloadgamepositionentity(lsi).daidestz=0
  if tttobj>0
   saveloadgamepositionentity(lsi).isdai=ai entity exist(tttobj)
   if ai entity exist(tttobj)
    if ai get entity x(tttobj)<>ai get entity destination x(tttobj) or ai get entity z(tttobj)<>ai get entity destination z(tttobj)
     saveloadgamepositionentity(lsi).daihasdest=1
     saveloadgamepositionentity(lsi).daidestx=ai get entity destination x(tttobj)
     saveloadgamepositionentity(lsi).daidestz=ai get entity destination z(tttobj)
    endif
   endif
  endif

 next lsi
 Rem Save Dark AI points() array
 array=array count(points())
 dim saveloadgamepositionpoints(array) as pathtype
 for i=1 to array
  saveloadgamepositionpoints(i).id=points(i).id
  saveloadgamepositionpoints(i).x=points(i).x
  saveloadgamepositionpoints(i).y=points(i).y
  saveloadgamepositionpoints(i).z=points(i).z
 next i
 Rem Save Dark AI faction array
 dim saveloadgamepositionfactions(FactionArrayMax,FactionArrayMax) as aifactiontype
 for x=1 to FactionArrayMax
  saveloadgamepositionfactions(x,1).team=aifaction(x,1).team
  for i=1 to FactionArrayMax
   saveloadgamepositionfactions(x,i).neutral=aifaction(x,i).neutral
   saveloadgamepositionfactions(x,i).ally=aifaction(x,i).ally
   saveloadgamepositionfactions(x,i).enemy=aifaction(x,i).enemy
  next i
 next x
 rem Weapons
 rem AirMod - Modfications for Alternate Fire >>>
 dim saveloadgamepositionweaponslot(20) as saveloadgamepositionweaponslottype
 for lsi=0 to 20
  if lsi < 11 then saveloadgamepositionweaponslot(lsi).pref=weaponslot(lsi).pref
  if lsi < 11 then saveloadgamepositionweaponslot(lsi).got=weaponslot(lsi).got
  if lsi < 11 then saveloadgamepositionweaponslot(lsi).invpos=weaponslot(lsi).invpos
  saveloadgamepositionweaponslot(lsi).weaponammo=weaponammo(lsi)
  saveloadgamepositionweaponslot(lsi).weaponclipammo=weaponclipammo(lsi)
  if lsi < 11 then saveloadgamepositionweaponslot(lsi).weaponhud=weaponhud(lsi)
  rem Airmod - Done
 next lsi
 rem Waypoint information
 for lsi=0 to entityelementmax
  saveloadgamepositionentity(lsi).actualtarget=entityelement(lsi).actualtarget
  saveloadgamepositionentity(lsi).waypointstate=entityelement(lsi).ai.waypoint.state
  saveloadgamepositionentity(lsi).waypointcurrent=entityelement(lsi).ai.waypoint.current
  saveloadgamepositionentity(lsi).waypointtracker=entityelement(lsi).ai.waypoint.tracker
  saveloadgamepositionentity(lsi).waypointdirection=entityelement(lsi).ai.waypoint.direction
  saveloadgamepositionentity(lsi).waypointxstart=entityelement(lsi).ai.waypoint.xstart
  saveloadgamepositionentity(lsi).waypointystart=entityelement(lsi).ai.waypoint.ystart
  saveloadgamepositionentity(lsi).waypointzstart=entityelement(lsi).ai.waypoint.zstart
  saveloadgamepositionentity(lsi).waypointxinc=entityelement(lsi).ai.waypoint.xinc
  saveloadgamepositionentity(lsi).waypointyinc=entityelement(lsi).ai.waypoint.yinc
  saveloadgamepositionentity(lsi).waypointzinc=entityelement(lsi).ai.waypoint.zinc
  saveloadgamepositionentity(lsi).aiusinginternalai=entityelement(lsi).ai.usinginternalai
  saveloadgamepositionentity(lsi).aioldwaypointstate=entityelement(lsi).ai.oldwaypointstate
  saveloadgamepositionentity(lsi).aioldanimframe=entityelement(lsi).ai.oldanimframe
  saveloadgamepositionentity(lsi).aiolddestanimframe=entityelement(lsi).ai.olddestanimframe
  saveloadgamepositionentity(lsi).spawnatstart=entityelement(lsi).spawn.atstart
  saveloadgamepositionentity(lsi).spawnupto=entityelement(lsi).spawn.upto
 next lsi
 `
 rem FPGC - 191009 - store all HUD values
 saveloadgamehudmax=hudmax
 dim saveloadgamehud(saveloadgamehudmax) as hudtype
 for thudid=1 to hudmax
  saveloadgamehud(thudid)=hud(thudid)
  saveloadgamehud(thudid).name$=hud(thudid).name$
  saveloadgamehud(thudid).font$=hud(thudid).font$
  saveloadgamehud(thudid).text$=hud(thudid).text$
  saveloadgamehud(thudid).imagefile$=hud(thudid).imagefile$
 next thudid
 `
return

_saveload_retrievesavedata:
 `
 rem FPGC - 090411 - apply ambience from save position
 saveloadambience=saveloadgameposition.ambience
 guivisualsettings.ambience=saveloadambience
 guivisualsettings.ambiencescripted=1
 `
 rem Create savedata arrays and copy game data to them
 `level=saveloadgameposition.level (already done when loaded savedata)
 player(1).x=saveloadgameposition.playerx
 player(1).y=saveloadgameposition.playery
 player(1).z=saveloadgameposition.playerz
 player(1).health=saveloadgameposition.playerhealth
 player(1).lives=saveloadgameposition.playerlives
 player(1).inventorymax=saveloadgameposition.playerinventorymax
` missiongoaltotal=saveloadgameposition.missiongoaltotal
 rem note some player vairables must be set AFTER the call to player_retstart lower down (i.e.  meridinglift)
 rem Inventory
 for lsi=0 to 100
  playerinventory(1,lsi).new=saveloadgamepositionplayerinventory(lsi).new
  playerinventory(1,lsi).drop=saveloadgamepositionplayerinventory(lsi).drop
  playerinventory(1,lsi).index=saveloadgamepositionplayerinventory(lsi).index
 next lsi
 rem Objectives (FPSCV104RC4 - put back for this version)
 rem and also added to to objective countdown which resets objectives
 gsaveloadobjectivesloaded=1
 for lsi=0 to 99
  playerobjective(lsi)=saveloadgamepositionplayerobjective(lsi)
 next lsi
 rem Entities
 if entityelementmax>0
  for lsi=1 to entityelementmax
   `
   entityelement(lsi).spawn.leaderid=saveloadgamepositionentity(lsi).spawnleaderid
   entityelement(lsi).active=saveloadgamepositionentity(lsi).active
   entityelement(lsi).dormant=saveloadgamepositionentity(lsi).dormant
   entityelement(lsi).beenkilled=saveloadgamepositionentity(lsi).beenkilled
   `
   rem V118 - 120810 - knxrb - etimer fix from Scene Commander
  entityelement(lsi).etimer=timer()-saveloadgamepositionentity(lsi).etimerpaused

  entityelement(lsi).lastdamagetimer=saveloadgamepositionentity(lsi).lastdamagetimer
  entityelement(lsi).animatespeed=saveloadgamepositionentity(lsi).animatespeed rem (markblosser)
  entityelement(lsi).entitydammult#=saveloadgamepositionentity(lsi).entitydammult#
    rem Scene commander
  entityelement(lsi).ishidden=saveloadgamepositionentity(lsi).ishidden rem Scene commander
  entityelement(lsi).cullstate=saveloadgamepositionentity(lsi).cullstate rem Scene commander
  entityelement(lsi).isimmune=saveloadgamepositionentity(lsi).isimmune rem Scene commander
  entityelement(lsi).isanobjective= saveloadgamepositionentity(lsi).isanobjective rem Scene commander
  entityelement(lsi).objectiveradarrange=saveloadgamepositionentity(lsi).objectiveradarrange rem Scene commander

  entityelement(lsi).entityacc=saveloadgamepositionentity(lsi).entityacc rem Scene commander

   lsientid=entityelement(lsi).bankindex
   if entityprofile(lsientid).ischaracter=1
    rem leeadd - 111208 - v114b4 - introduce saving character positions and states
    entityelement(lsi).ai.libindex=saveloadgamepositionentity(lsi).ailibindex
    entityelement(lsi).ai.state$=saveloadgamepositionentity(lsi).aistate$ rem GUI-X9 (String States)
    entityelement(lsi).ai.oldstate$=saveloadgamepositionentity(lsi).aioldstate$ rem GUI-X9 (String States)
    entityelement(lsi).active=saveloadgamepositionentity(lsi).active
    entityelement(lsi).dormant=saveloadgamepositionentity(lsi).dormant
    entityelement(lsi).beenkilled=saveloadgamepositionentity(lsi).beenkilled
    rem V109 - 090209 - moved below the VISCOL removal, as it left a viscol marker when moved entities
    `entityelement(lsi).x=saveloadgamepositionentity(lsi).x
    `entityelement(lsi).y=saveloadgamepositionentity(lsi).y
    `entityelement(lsi).z=saveloadgamepositionentity(lsi).z
   else
    rem FPGC - 191009 - ailibindex and oldstate where commented out prior to BETA16?
    entityelement(lsi).ai.libindex=saveloadgamepositionentity(lsi).ailibindex
    entityelement(lsi).ai.state$=saveloadgamepositionentity(lsi).aistate$ rem GUI-X9 (String States)
    entityelement(lsi).ai.oldstate$=saveloadgamepositionentity(lsi).aioldstate$ rem GUI-X9 (String States)
    entityelement(lsi).floorposy=saveloadgamepositionentity(lsi).floorposy
   endif
   rem V109 - 090209 - added ANIM SET AND DO back in so can retain the animating of the entities (and collision)
   entityelement(lsi).animset=saveloadgamepositionentity(lsi).animset
   entityelement(lsi).animdo=saveloadgamepositionentity(lsi).animdo
   entityelement(lsi).animframe=saveloadgamepositionentity(lsi).animframe
   entityelement(lsi).collisionactive=saveloadgamepositionentity(lsi).collisionactive
   entityelement(lsi).currentammo=saveloadgamepositionentity(lsi).currentammo
   entityelement(lsi).health=saveloadgamepositionentity(lsi).health
   entityelement(lsi).collected=saveloadgamepositionentity(lsi).collected
   entityelement(lsi).activated=saveloadgamepositionentity(lsi).activated
   `
   rem FPGC - 191009 - in some cases, built-in scripts DO need to start from state zero
   rem such as weapon and item pickup where the HUD settings need to be set
   remstart - but instead of this, store the entire HUD data to restore instead
   tresetstatetozero=0 : tresetstatetozero$=""
   if entityelement(lsi).ai.libindex>=1 and entityelement(lsi).ai.libindex<=array count(scriptbank$(0))
    tresetstatetozero$=lower$(scriptbank$(entityelement(lsi).ai.libindex))
   endif
   if right$(tresetstatetozero$,14)="weapon.fpi" then tresetstatetozero=1
   if right$(tresetstatetozero$,14)="weaponglow.fpi" then tresetstatetozero=1
   if tresetstatetozero=1
    entityelement(lsi).ai.state=0
    entityelement(lsi).ai.oldstate=0
   endif
   remend
   `
   rem FPGC - 100610 - (117) - restore decal, sound states for entity
   entityelement(lsi).decalindex=saveloadgamepositionentity(lsi).decalindex
   entityelement(lsi).decalmode=saveloadgamepositionentity(lsi).decalmode
   tsoundset0state=saveloadgamepositionentity(lsi).tsoundset0state
   if entityelement(lsi).soundset>0
    if tsoundset0state=0 then stop sound entityelement(lsi).soundset
    if tsoundset0state=1 then loop sound entityelement(lsi).soundset : entityelement(lsi).soundlooping=entityelement(lsi).soundset
   endif
   tsoundset1state=saveloadgamepositionentity(lsi).tsoundset1state
   if entityelement(lsi).soundset1>0
    if tsoundset1state=0 then stop sound entityelement(lsi).soundset1
    if tsoundset1state=1 then loop sound entityelement(lsi).soundset1 : entityelement(lsi).soundlooping=entityelement(lsi).soundset1
   endif
   `
   rem more restores
   entityelement(lsi).eleprof.physics=saveloadgamepositionentity(lsi).physics
   entityelement(lsi).alttextureused=saveloadgamepositionentity(lsi).alttextureused
   `
   Rem Dark AI
   entityelement(lsi).darkai.state=saveloadgamepositionentity(lsi).daistate
   entityelement(lsi).darkai.daihasdest=saveloadgamepositionentity(lsi).daihasdest
   entityelement(lsi).darkai.daidestx=saveloadgamepositionentity(lsi).daidestx
   entityelement(lsi).darkai.daidestz=saveloadgamepositionentity(lsi).daidestz
   entityelement(lsi).darkai.team=saveloadgamepositionentity(lsi).daiteam
   `entityelement(lsi).darkai.isdai=saveloadgamepositionentity(lsi).isdai
   if saveloadgamepositionentity(lsi).isdai=1
    team=entityelement(lsi).darkai.team
    obj=entityelement(lsi).obj
    e=lsi
    Gosub _darkai_addai
   endif
   `
  next lsi
 endif
 Rem Load Dark AI points() array
 array=array count(saveloadgamepositionpoints())
 for i=1 to array
  points(i).id=saveloadgamepositionpoints(i).id
  points(i).x=saveloadgamepositionpoints(i).x
  points(i).y=saveloadgamepositionpoints(i).y
  points(i).z=saveloadgamepositionpoints(i).z
 next i
 Rem Load Dark AI faction array
 for x=1 to FactionArrayMax
  aifaction(x,1).team=saveloadgamepositionfactions(x,1).team
  for i=1 to FactionArrayMax
   aifaction(x,i).neutral=saveloadgamepositionfactions(x,i).neutral
   aifaction(x,i).ally=saveloadgamepositionfactions(x,i).ally
   aifaction(x,i).enemy=saveloadgamepositionfactions(x,i).enemy
  next i
 next x
 rem Weapons
 rem AirMod - Modifications for Alt Fire >>>
 for lsi=0 to 20
  if lsi < 11 then weaponslot(lsi).pref=saveloadgamepositionweaponslot(lsi).pref
  if lsi < 11 then weaponslot(lsi).got=saveloadgamepositionweaponslot(lsi).got
  if lsi < 11 then weaponslot(lsi).invpos=saveloadgamepositionweaponslot(lsi).invpos
  weaponammo(lsi)=saveloadgamepositionweaponslot(lsi).weaponammo
  weaponclipammo(lsi)=saveloadgamepositionweaponslot(lsi).weaponclipammo
  if lsi < 11 then weaponhud(lsi)=saveloadgamepositionweaponslot(lsi).weaponhud
 next lsi
 rem AirMod - Done <<
 rem Waypoint information
 if entityelementmax>0
  for lsi=1 to entityelementmax
   entityelement(lsi).actualtarget=saveloadgamepositionentity(lsi).actualtarget
   entityelement(lsi).ai.waypoint.state=saveloadgamepositionentity(lsi).waypointstate
   entityelement(lsi).ai.waypoint.current=saveloadgamepositionentity(lsi).waypointcurrent
   entityelement(lsi).ai.waypoint.tracker=saveloadgamepositionentity(lsi).waypointtracker
   entityelement(lsi).ai.waypoint.direction=saveloadgamepositionentity(lsi).waypointdirection
   entityelement(lsi).ai.waypoint.xstart=saveloadgamepositionentity(lsi).waypointxstart
   entityelement(lsi).ai.waypoint.ystart=saveloadgamepositionentity(lsi).waypointystart
   entityelement(lsi).ai.waypoint.zstart=saveloadgamepositionentity(lsi).waypointzstart
   entityelement(lsi).ai.waypoint.xinc=saveloadgamepositionentity(lsi).waypointxinc
   entityelement(lsi).ai.waypoint.yinc=saveloadgamepositionentity(lsi).waypointyinc
   entityelement(lsi).ai.waypoint.zinc=saveloadgamepositionentity(lsi).waypointzinc
   entityelement(lsi).ai.usinginternalai=saveloadgamepositionentity(lsi).aiusinginternalai
   entityelement(lsi).ai.oldwaypointstate=saveloadgamepositionentity(lsi).aioldwaypointstate
   entityelement(lsi).ai.oldanimframe=saveloadgamepositionentity(lsi).aioldanimframe
   entityelement(lsi).ai.olddestanimframe=saveloadgamepositionentity(lsi).aiolddestanimframe
   entityelement(lsi).spawn.atstart=saveloadgamepositionentity(lsi).spawnatstart
   entityelement(lsi).spawn.upto=saveloadgamepositionentity(lsi).spawnupto
  next lsi
 endif
 `
 rem Refresh game objects and player with new level states
 playerstartx#=player(1).x
 playerstarty#=player(1).y
 playerstartz#=player(1).z
 playerstartrx#=saveloadgameposition.playerrx
 playerstartry#=saveloadgameposition.playerry
 playerstarthasweapon=saveloadgameposition.playerholdinggun
 gosub _player_restart
 `
 rem FPGC - 100610 - while riding lift, can now save and load
 meridinglift=saveloadgameposition.meridinglift
 `
 rem Now refresh gun
 gosub _gun_loadonlypresent
 `
 rem Go through all entities and remove those which are no longer in level
 for e=1 to entityelementmax
  `
  rem entity identity
  entid=entityelement(e).bankindex
  obj=entityelement(e).obj
  `
  rem if filled, flag it
  tentityhasbeenkilledsoremove=0 : if entityelement(e).beenkilled=1 then tentityhasbeenkilledsoremove=1
  `
  `rem ignore characters (and spawned objects) (complex setups) unless removing them
  `rem ignore spawned objects unless removing them
  `if (entityprofile(entid).ischaracter=0 and entityelement(e).spawn.leaderid=0) or tentityhasbeenkilledsoremove=1
  rem leeadd - 111208 - v114b4 - restore character positions, and corpses, and dropped weapons
  rem ignore spawned objects unless removing them
  rem V109 - 090209 - do NOT ignore spawned objects as they can be restored
  `if entityelement(e).spawn.leaderid=0 or tentityhasbeenkilledsoremove=1
  `
  rem clear entity from col map
  thadcolbit=0
  tx=entityelement(e).x/25
  ty=entityelement(e).y/100
  tz=entityelement(e).z/-25
  if tx>=0 and ty>=0 and tz>=0
   if tx<=viscolx and ty<=viscoly and tz<=viscolz
    if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0 : thadcolbit=1
   endif
  endif
  if obj>0
   if object exist(obj)=1
    if entityelement(e).eleprof.physics<>0
     gosub _ode_switchoffe
    else
     set object collision off obj
    endif
   endif
  endif
  `
  rem rem V109 - 090209 - Move entity to restore position (AFTER viscol removal)
  entityelement(e).x=saveloadgamepositionentity(e).x
  entityelement(e).y=saveloadgamepositionentity(e).y
  entityelement(e).z=saveloadgamepositionentity(e).z
  `
  if entityelement(e).active<>0 and tentityhasbeenkilledsoremove=0
   rem update object in relation to this entity
   if obj>0
    rem object itself
    if object exist(obj)=1
     rem position from entity pos, but rotation direct from savedata
     position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
     rem V114 BETA5 - reversed characters bug, so only apply if character is dead (corpse)
     if entityprofile(entid).ischaracter=1
      if entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
       rotate object obj,saveloadgamepositionentity(e).rx,saveloadgamepositionentity(e).ry,saveloadgamepositionentity(e).rz
      else
       rem must be 0,0,0 before apply physics to the object (for characters)
       rotate object obj,0,0,0
      endif
     else
      if entityelement(e).eleprof.isimmobile=1
       rem FPGC - 030710 - retain by not even changing rotation ( as it messes up rotated entities like switches)
      else
       rem FPGC - 030710 - else rotate for dynamic objects that can move during the simulation
       rotate object obj,saveloadgamepositionentity(e).orx,saveloadgamepositionentity(e).ory,saveloadgamepositionentity(e).orz
      endif
     endif
     rem create the physics body
     rem V109 - 090209 - any active spawned entities should be woken!
     if entityelement(e).spawn.leaderid>0
      if entityelement(e).spawn.leader=0
       entityelement(e).collisionactive=1
       set object collision on obj
       show object obj
      endif
     endif

     rem FPGC - only activate physics for certain OBJs and they are active
     if entityelement(e).spawn.leader=1
      rem spawn master does not need physics object
      tobj=obj : gosub _ode_ensurephysicsobjvalid
     else
      if entityelement(e).collisionactive=1 or entityprofile(entid).ischaracter=1
       if entityelement(e).eleprof.physics<>0
        gosub _ode_setupewithphysics
       else
        set object collision on obj
       endif
      endif
     endif
     if entityelement(e).collisionactive=0 and entityprofile(entid).ischaracter=0
      if entityelement(e).eleprof.physics<>0
       gosub _ode_switchoffe
      else
       set object collision off obj
      endif
     endif

     rem ensure animation is the same
     rem V109 - 090209 - did not work for waypoint following characters
     `entityelement(e).animdo=1+entityelement(e).animset
     rem V115 - 180309 - BETA3 - only set anim for characters, not animating non-character entities
     if entityprofile(entid).ischaracter=1
      rem FPGC - 110809 - only if actually using ANIMATE, not if using SETFRAME, etc
      if entityelement(e).animdo=-1
       rem not animating, but ensure no default anim is playing
       if object exist(obj)=1 then stop object obj
      else
       if entityelement(e).ai.waypoint.state>=99
        entityelement(e).animset=2
       else
        rem FPGC - 110809 - spawn anim and idle one and the same for a reload
        if entityelement(e).animdo=0 then entityelement(e).animdo=1
        entityelement(e).animset=1+entityelement(e).animdo
       endif
       entityelement(e).animdo=0
      endif
     else
      entityelement(e).animset=0
      entityelement(e).animdo=0
     endif
     rem FPGC - 091009 - added animframe to save data, so set it here
     entityelement(e).destanimframe=entityelement(e).animframe
     entityelement(e).animframe=0
     entityelement(e).animtime=0
     rem FPGC - 091009 - inteferes with door and switch rotations
     rem V109 - 090209 - after physics applied, ensure entitydriven and pseudo-static than uses RY for rotation
`     entityelement(e).rx=saveloadgamepositionentity(e).rx
`     entityelement(e).ry=saveloadgamepositionentity(e).ry
     if entityprofile(entid).ischaracter=1
      rem FPGC - 080411 - need to retain the angle the character is standing!!
      entityelement(e).ry=saveloadgamepositionentity(e).ry
      entityelement(e).mover.da=entityelement(e).ry
     endif
`     entityelement(e).rz=saveloadgamepositionentity(e).rz
     `entityelement(e).mover.da=saveloadgamepositionentity(e).ry
     rem ensure entitydriven and pseudo-static than uses RY for rotation
`     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
 `     ode set body rotation obj,0,0,0
 `     ode set body rotation obj,0,entityelement(e).ry,0
`     endif
    endif
   endif
   `
   rem replace in colmap
   if thadcolbit=1
    tx=entityelement(e).x/25
    ty=entityelement(e).y/100
    tz=entityelement(e).z/-25
    if tx>=0 and ty>=0 and tz>=0
     if tx<=viscolx and ty<=viscoly and tz<=viscolz
      viscolmap(tx,ty,tz)=e
     endif
    endif
   endif
   `
  else
   `
   rem V109 - 090209 - Move entity to restore position (AFTER viscol removal)
   entityelement(e).x=saveloadgamepositionentity(e).x
   entityelement(e).y=saveloadgamepositionentity(e).y
   entityelement(e).z=saveloadgamepositionentity(e).z
   `
   rem destroy this entity for good
   entityelement(e).active=0
   entityelement(e).dormant=0
   rem hide the object
   if obj>0
    if object exist(obj)=1
     `
     rem leeadd - 111208 - v114 - if character in DESTROY script (may be a left corpse), so treat as active during re-load
     if entityprofile(entid).ischaracter=1 and entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
      `
      rem character as corpse should use last frame of fall over animation, and de-activate (and drop weapon)
      entityelement(e).animset=0
      entityelement(e).animdo=11
      entityelement(e).animtime=0
      entityelement(e).health=0
      entityelement(e).ai.state$="0" rem GUI-X9 (String States)
      entityelement(e).activated=0
      tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
      rem FPGC - 091009 - new field to store frame
      `tcorpseanim=tffinish : entityelement(e).animframe=tcorpseanim
      tcorpseanim=entityelement(e).animframe
      stop object obj : set object interpolation obj,100
      set object frame obj,tcorpseanim
      rem final object position different
      tmvszy#=(object size y(obj)/2)*(entityprofile(entid).scale/100.0)
      tmvy#=entityelement(e).y+entityprofile(entid).raisefactor+tmvszy#
      position object obj,entityelement(e).x,tmvy#,entityelement(e).z
      rotate object obj,saveloadgamepositionentity(e).rx,saveloadgamepositionentity(e).ry,saveloadgamepositionentity(e).rz
      `
     else
      `
      rem regular entity destroy
      hide object obj
      if tentityhasbeenkilledsoremove=1
       rem if it has been killed - drain health to zero
       entityelement(e).eleprof.cantakeweapon=0
       entityelement(e).health=0
       entityelement(e).ai.state$="0" rem GUI-X9 (String States)
       entityelement(e).activated=0
       entityelement(e).obj=0
      endif
      `
     endif
     `
    endif
   endif
   rem stop any looping sound
   gosub _ai_stopentsounds
   `
  endif
  `
  rem FPGC - 030710 - update alt texture if flagged
  if entityelement(e).alttextureused>0 then gosub _entity_updatealttexture
  `
`  rem ignore spawned objects
`  endif
  `
 next e
 `
 rem FPGC - 150909 - go through all inventory items and hide any entities that are currently held by player
 for pint=1 to player(1).inventorymax
  e=playerinventory(1,pint).index
  if e>0
   rem copied from PLRTAKE code (faithful reproduction of the player collect activity)
   obj=entityelement(e).obj
   rem if child of spawn leader, reset spawn count
   spawne=entityelement(e).spawn.leaderid
   if spawne=0 then spawne=e
   entityelement(spawne).spawn.leadercount=entityelement(spawne).spawn.delay
   rem switch off obj
   if obj>0
    gosub _ode_switchoffe
    hide object obj:entityelement(spawne).ishidden=2
    set object collision off obj
   endif
   if entityelement(e).eleprof.phyalways<>0
    rem do not kill entity, keep it running
   else
    rem stop any looping sound
    gosub _ai_stopentsounds
    rem reset values
    entityelement(e).beenkilled=1
    entityelement(e).active=0
   endif
   rem clear entity from col map
   tx=entityelement(e).x/25
   ty=entityelement(e).y/100
   tz=entityelement(e).z/-25
   if tx>=0 and ty>=0 and tz>=0
    if tx<=viscolx and ty<=viscoly and tz<=viscolz
     if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
    endif
   endif
   rem mission objective counter
   gosub _entity_resolveobjective
  endif
 next pint
 `
 rem FPGC - 191009 - restore all HUD values
 hudmax=saveloadgamehudmax
 dim hud(hudmax) as hudtype
 for thudid=1 to hudmax
  `
  rem Reload original data
  hud(thudid)=saveloadgamehud(thudid)
  hud(thudid).name$=saveloadgamehud(thudid).name$
  hud(thudid).font$=saveloadgamehud(thudid).font$
  hud(thudid).text$=saveloadgamehud(thudid).text$
  hud(thudid).imagefile$=saveloadgamehud(thudid).imagefile$
  `
  rem And re-acquire graphics that may point to different image indices??
  tfile$=hud(thudid).imagefile$
  if tfile$<>""
   hud(thudid).image=loadinternalimagecompressquality(tfile$,5,1)
   if hud(thudid).image=0
    tfile$="languagebank\"+language$+"\"+tfile$
    hud(thudid).image=loadinternalimagecompressquality(tfile$,5,1)
   endif
  endif
  hud(thudid).baseanim=hud(thudid).image
  `
  rem Ensure global hud image value is set
  if hud(thudid).typemode=4 and thudid=internalzoomhud : rem 4zoom
   internalzoomhudimage=hud(thudid).image
  endif
  `
  rem Also ensure that in-game menu items remain hidden (naturally they where shown at the moment save game was clicked)
  ttname$=hud(thudid).name$
  if ttname$="gamemenutitle" or ttname$="loadgame" or ttname$="savegame" or ttname$="quitgame" or ttname$="returngame" or ttname$="pointer"
   hud(thudid).hide=1
  endif
  `
 next thudid
 `
return

rem
rem OBSMAP GENERATION SUBROUTINES
rem

_darkai_createlevel:
 `
 rem Call comprehensive OBSTACLE initialisation for level
 gosub _obs_level
 `
Return

_obs_level:
 `
 rem Take current universe level, and create AI visibility and containers (all level for 3D raycasting)
 phyunimesh$=myownrootdir$+"levelbank\testlevel\universephy.dbo"
 load object phyunimesh$,physicsuniverseobj
 AI Add Alternate Visibility Object physicsuniverseobj,0
 delete object physicsuniverseobj
 `
 rem Perform OBSMAP generation (or quick reload) (or a full compile where level changes with each pass)
 if tperformuniverseconstruction=1 or gcompilestandaloneexe=1
  rem constructing fully, so generate OBS data
  choiceoflayer=0 : choiceoflayerend=19
  gosub _obs_generate
  gosub _obs_processobstacles
  rem generate obstacles for AI
  obsgeneratenow=1 : gosub _obs_generateobstacles : obsgeneratenow=0
  rem save data after obstacle construction
  gosub _obs_save
 else
  rem use OBS data from last construction
  gosub _obs_load
  rem call this to complete obstacle creation (from loaded data)
  AI Complete Obstacles
 endif
 `
 rem Connect containers with a container bridge using waypoint data
 for w=1 to waypointmax
  if waypoint(w).count>0
   for wpci=waypoint(w).start to waypoint(w).finish-1
    wpy#=waypointcoord(wpci).y : clyr=(wpy#+5)/100
    nextwpy#=waypointcoord(wpci+1).y : nextclyr=(nextwpy#+5)/100
    if nextclyr=clyr-1 or nextclyr=clyr+1
     rem waypoint path spans containers, a useful gate
     wpx#=waypointcoord(wpci).x
     wpz#=waypointcoord(wpci).z
     nextwpx#=waypointcoord(wpci+1).x
     nextwpz#=waypointcoord(wpci+1).z
     result = AI connect Containers(clyr, wpx#, wpz#, nextclyr, nextwpx#, nextwpz#)
    endif
   next wpci
  endif
 next w
 `
 rem Create regular AI waypoints (path index matches waypoint index)
 for w=1 to waypointmax
  if waypoint(w).count>0
   AI Make Path w
   for wpci=waypoint(w).start to waypoint(w).finish
    wpx#=waypointcoord(wpci).x
    wpy#=waypointcoord(wpci).y : clyr=(wpy#+5)/100
    wpz#=waypointcoord(wpci).z
    AI Path Add Point w,wpx#,wpz#
   next wpxi
  endif
 next w
 `
return

_obs_generate_pertile:
 `
 gosub _obs_getmapvalues
 if ismapanoverlay=0
    rem BASE SEGMENT
    if mapid=0
     rem void
     maplines(l,x,y,0)=0
    else
     rem something
     maplines(l,x,y,0)=1
     rem no-floor flag
     if mapsymbol=1 then maplines(l,x,y,0)=0
     rem walls
     if maptile=00 then maplines(l,x,y,OBS_NN)=0
     if maptile=01 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1 : maplines(l,x,y,OBS_WW)=1
     if maptile=02 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=1 : maplines(l,x,y,OBS_WW)=1
     if maptile=03 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=1
     if maptile=04 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=1 : maplines(l,x,y,OBS_WW)=0
     if maptile=05 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=06 then maplines(l,x,y,OBS_NN)=0
     if maptile=07 then maplines(l,x,y,OBS_NN)=0
     if maptile=08 then maplines(l,x,y,OBS_NN)=0
     if maptile=09 then maplines(l,x,y,OBS_NN)=0
     if maptile=10 then maplines(l,x,y,OBS_NN)=0
     if maptile=11 then maplines(l,x,y,OBS_NN)=0
     if maptile=12 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=13 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=14 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=15 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=1
     rem 221112 - ensure segment array exists
     if mapselection<=array count(segmentswhichchangeobsdatanowalls())
      rem 280807 - switch off walls if the segment associated with the tile does not have any walls
      if segmentswhichchangeobsdatanowalls(mapselection)=1
       maplines(l,x,y,OBS_NN)=0 : maplines(l,x,y,OBS_EE)=0
       maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
      endif
     endif
     `
     rem LEE - 281110 - some platforms/corridors are NOT overlays, but base map segments, which have
     rem specific walls and edge-guides which the AI system must take account for..
     `if 1
     rem 221112 - ensure segment array exists
     if mapselection<=array count(segmentswhichchangeobsdata())
      if segmentswhichchangeobsdata(mapselection)>=5 and segmentswhichchangeobsdata(mapselection)<=9
       rem add walls based on corridor symbols (segment blueprint MODE)
       rem 3=straight (5)
       if segmentswhichchangeobsdata(mapselection)=5
        if maporient=0 then maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_WW)=1
        if maporient=1 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
        if maporient=2 then maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_WW)=1
        if maporient=3 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
       endif
       rem 4=corner (6)
       if segmentswhichchangeobsdata(mapselection)=6
        if maporient=0 then maplines(l,x,y,OBS_CC)=2
        if maporient=1 then maplines(l,x,y,OBS_CC)=3
        if maporient=2 then maplines(l,x,y,OBS_CC)=4
        if maporient=3 then maplines(l,x,y,OBS_CC)=5
       endif
       rem 5=tjunction (7)
       if segmentswhichchangeobsdata(mapselection)=7
        if maporient=0 then maplines(l,x,y,OBS_NN)=1
        if maporient=1 then maplines(l,x,y,OBS_EE)=1
        if maporient=2 then maplines(l,x,y,OBS_SS)=1
        if maporient=3 then maplines(l,x,y,OBS_WW)=1
       endif
       rem 6=cross (8)
       if segmentswhichchangeobsdata(mapselection)=8
        rem no walls
       endif
       rem 7=deadend (9)
       if segmentswhichchangeobsdata(mapselection)=9
        `if maporient=0 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1
        `if maporient=1 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1
        `if maporient=2 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1
        `if maporient=3 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
        rem completely block off dead ends and blocked corridors (primary segment not overlays)
        maplines(l,x,y,OBS_WW)=1
        maplines(l,x,y,OBS_NN)=1
        maplines(l,x,y,OBS_EE)=1
        maplines(l,x,y,OBS_SS)=1
       endif
      endif
     endif
     `
     if maprotate>0
      rem rotate lines data
      while maprotate>0
       rem rotate once
       ssNN=maplines(l,x,y,OBS_NN)
       ssEE=maplines(l,x,y,OBS_EE)
       ssSS=maplines(l,x,y,OBS_SS)
       ssWW=maplines(l,x,y,OBS_WW)
       maplines(l,x,y,OBS_NN)=ssWW
       maplines(l,x,y,OBS_EE)=ssNN
       maplines(l,x,y,OBS_SS)=ssEE
       maplines(l,x,y,OBS_WW)=ssSS
       dec maprotate
      endwhile
     endif
    endif
 endif
 if ismapanoverlay=1
    rem OVERLAY SEGMENT
    if mapid<>0
     rem something, so fill space so AI can walk on it (platforms, corridors)
     maplines(l,x,y,0)=1
    endif
 endif
 if ismapanoverlay=2
    rem OVERLAY SEGMENT FOR DOORS / PUNCH WALLS OUT
    if mapid<>0
     rem 221112 - ensure segment array exists
     if mapselection>0 and mapselection<=array count(segmentswhichchangeobsdata())
      if segmentswhichchangeobsdata(mapselection)=1
       rem doors punch out walls!
       if maporient=0 then maplines(l,x,y,OBS_NN)=0
       if maporient=1 then maplines(l,x,y,OBS_EE)=0
       if maporient=2 then maplines(l,x,y,OBS_SS)=0
       if maporient=3 then maplines(l,x,y,OBS_WW)=0
       if maporient=0 and y>0 then maplines(l,x,y-1,OBS_SS)=0
       if maporient=1 and x<39 then maplines(l,x+1,y,OBS_WW)=0
       if maporient=2 and y<39 then maplines(l,x,y+1,OBS_NN)=0
       if maporient=3 and x>0 then maplines(l,x-1,y,OBS_EE)=0
       rem add door posts
       maplines(l,x,y,OBS_DR)=1+maporient
      endif
      if segmentswhichchangeobsdata(mapselection)=2
       rem window has no effect here
      endif
      if segmentswhichchangeobsdata(mapselection)=4
       rem these segments are entire blocks (stairs, teleporters, large central blocking things)
       maplines(l,x,y,OBS_CC)=1
      endif
      if segmentswhichchangeobsdata(mapselection)>=5 and segmentswhichchangeobsdata(mapselection)<=9
       rem add walls based on corridor symbols (segment blueprint MODE)
       rem 3=straight (5)
       if segmentswhichchangeobsdata(mapselection)=5
        if maporient=0 then maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_WW)=1
        if maporient=1 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
        if maporient=2 then maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_WW)=1
        if maporient=3 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
       endif
       rem 4=corner (6)
       if segmentswhichchangeobsdata(mapselection)=6
        if maporient=0 then maplines(l,x,y,OBS_CC)=2
        if maporient=1 then maplines(l,x,y,OBS_CC)=3
        if maporient=2 then maplines(l,x,y,OBS_CC)=4
        if maporient=3 then maplines(l,x,y,OBS_CC)=5
       endif
       rem 5=tjunction (7)
       if segmentswhichchangeobsdata(mapselection)=7
        if maporient=0 then maplines(l,x,y,OBS_NN)=1
        if maporient=1 then maplines(l,x,y,OBS_EE)=1
        if maporient=2 then maplines(l,x,y,OBS_SS)=1
        if maporient=3 then maplines(l,x,y,OBS_WW)=1
       endif
       rem 6=cross (8)
       if segmentswhichchangeobsdata(mapselection)=8
        rem no walls
       endif
       rem 7=deadend (9)
       if segmentswhichchangeobsdata(mapselection)=9
        if maporient=0 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1
        if maporient=1 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1
        if maporient=2 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1
        if maporient=3 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
       endif
      endif
      rem FPGC - 190410 - some segment overlays create a single directional wall (instead of a solid block, i.e. [4])
      if segmentswhichchangeobsdata(mapselection)>=21 and segmentswhichchangeobsdata(mapselection)<=22
       if maporient=0 then maplines(l,x,y,OBS_NN)=3
       if maporient=1 then maplines(l,x,y,OBS_EE)=3
       if maporient=2 then maplines(l,x,y,OBS_SS)=3
       if maporient=3 then maplines(l,x,y,OBS_WW)=3
       if maporient=0 and y>0 then maplines(l,x,y-1,OBS_SS)=3
       if maporient=1 and x<39 then maplines(l,x+1,y,OBS_WW)=3
       if maporient=2 and y<39 then maplines(l,x,y+1,OBS_NN)=3
       if maporient=3 and x>0 then maplines(l,x-1,y,OBS_EE)=3
      endif
     endif
    endif
 endif
 `
return

_obs_generate:
 `
 rem OBSMAP Structures and Arrays
 OBS_NN=1 : OBS_EE=2 : OBS_SS=3 : OBS_WW=4 : OBS_CC=5 : OBS_DR=6
 dim maplines(layermax,maxx,maxy,OBS_DR)
 dim obs(1,6) : obsindex=0
 `
 rem mark which segments are doors (as they punch through obs walls)
 dim segmentswhichchangeobsdata(segidmaster)
 dim segmentswhichchangeobsdatanowalls(segidmaster)
 for segid=1 to segidmaster
  `
  rem find DOORS
  segmentswhichchangeobsdata(segid)=0
  for tp=0 to segmentprofileheader(segid).partmax
   rem look for segments with CSG punch
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=lower$(segmentprofile(segid,tp).meshname$)
    for n=len(tmeshname$) to 1 step -1
     if mid$(tmeshname$,n)="\" or mid$(tmeshname$,n)="/"
      tmeshname$=right$(tmeshname$,len(tmeshname$)-n)
      if left$(tmeshname$,4)="door"
       rem ALL FPSC DOORS must have 'door' as the first four characters
       rem in order for the maker to punch the doors out of the walls
       if segmentprofileheader(segid).preventai=1
        rem an exception to this is FAKE doors, and crawlspace doors
        rem which have been flagged as not allowing entities to enter
        segmentswhichchangeobsdata(segid)=2
       else
        segmentswhichchangeobsdata(segid)=1
       endif
      else
       if right$(tmeshname$,7)="punch.x"
        rem any other type of CSG punch should not cause a blocking
        rem fill in the obs map (like windows, portholes)
        segmentswhichchangeobsdata(segid)=2
       endif
      endif
     endif
    next n
   endif
  next tp
  rem find STRAIGHT,CORNERS,TJUNC,CROSS,DEADEND
  if segmentprofile(segid).blueprint.mode>=3 and segmentprofile(segid).blueprint.mode<=7
   rem 3=straight (5)
   rem 4=corner (6)
   rem 5=tjunction (7)
   rem 6=cross (8)
   rem 7=deadend (9)
   if segmentprofile(segid).blueprint.mode=3 then segmentswhichchangeobsdata(segid)=5
   if segmentprofile(segid).blueprint.mode=4 then segmentswhichchangeobsdata(segid)=6
   if segmentprofile(segid).blueprint.mode=5 then segmentswhichchangeobsdata(segid)=7
   if segmentprofile(segid).blueprint.mode=6 then segmentswhichchangeobsdata(segid)=8
   if segmentprofile(segid).blueprint.mode=7 then segmentswhichchangeobsdata(segid)=9
  endif
  rem find full BLOCKERS (not covered by above)
  if segmentswhichchangeobsdata(segid)=0
   rem ALL FPSC overlays that are simply large blocking onstructions to
   rem the current layer such as stairs, teleporters, etc
   tdirectionalwall=0
   if lower$(right$(selectionbank$(segid),14))="wall large.fps" then tdirectionalwall=2
   if lower$(right$(selectionbank$(segid),14))="wall small.fps" then tdirectionalwall=1
   if tdirectionalwall>0
    segmentswhichchangeobsdata(segid)=20+tdirectionalwall : rem directional wall
   else
    segmentswhichchangeobsdata(segid)=4 : rem solid blocker
   endif
  endif
  `
  rem No Walls Check (floors)
  tnowalls=1
  if segmentprofile(segid).vis.ctl<>-1 then tnowalls=0
  if segmentprofile(segid).vis.ctr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.cbr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.cbl<>-1 then tnowalls=0
  if segmentprofile(segid).vis.octl<>-1 then tnowalls=0
  if segmentprofile(segid).vis.octr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.ocbr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.ocbl<>-1 then tnowalls=0
  segmentswhichchangeobsdatanowalls(segid)=tnowalls
  `
 next segid
 `
 rem go through entire level map
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    for olay=0 to 1
     if olay=0 then tolaymax=0
     if olay=1
      tolaymax=0 : olayindex=mapolay(l,x,y)
      while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
      dec tolaymax
     endif
     if tolaymax>=0
      for olayti=0 to tolaymax
       if olay=0 then mapid=map(l,x,y) : ismapanoverlay=0
       if olay=1 then mapid=olaylist(olayindex,olayti) : ismapanoverlay=1
       if mapid<>0
        gosub _obs_generate_pertile
       endif
      next olayti
     endif
    next olay
   next x
  next y
 next l
 `
 rem go through level again for door punching / make blockers / etc
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    olay=1
    tolaymax=0 : olayindex=mapolay(l,x,y)
    while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
    dec tolaymax
    if tolaymax>=0
     for olayti=0 to tolaymax
      mapid=olaylist(olayindex,olayti) : ismapanoverlay=2
      if mapid<>0
       gosub _obs_generate_pertile
      endif
     next olayti
    endif
   next x
  next y
 next l
 `
 rem create natural universe lines to confine all AI
 rem only where there are segments on the border (non-voids)
 for l=0 to layermax-1
  for x=0 to maxx-1
   if maplines(l,x,0,0)=1 then maplines(l,x,0,OBS_NN)=1
   if maplines(l,x,39,0)=1 then maplines(l,x,39,OBS_SS)=1
  next x
  for y=0 to maxy-1
   if maplines(l,0,y,0)=1 then maplines(l,0,y,OBS_WW)=1
   if maplines(l,39,y,0)=1 then maplines(l,39,y,OBS_EE)=1
  next y
 next l
 `
return

_obs_processobstacles:
 `
 rem find gaps, and eat them to make obstacle blocks
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,0)=0
     rem found a gap
     startx=x
     starty=y
     endx=x
     endy=y
     rem expand X and expand Y
     for scanx=startx to 39
      if maplines(l,scanx,y,0)<>0 then exit
     next scanx
     endx=scanx-1
     for scany=starty to 39
      texit=0
      for scanx=startx to endx
       if maplines(l,scanx,scany,0)<>0 then texit=1 : exit
      next scanx
      if texit=1 then exit
     next scany
     endy=scany-1
     rem fill in
     for scany=starty to endy
      for scanx=startx to endx
       maplines(l,scanx,scany,0)=2
      next scanx
     next scany
     rem convert to obstacle block
     inc obsindex : dim obs(obsindex,6)
     obs(obsindex,0)=1
     obs(obsindex,1)=startx*100
     obs(obsindex,2)=starty*100
     obs(obsindex,3)=(endx+1)*100
     obs(obsindex,4)=(endy+1)*100
     obs(obsindex,5)=l
     obs(obsindex,6)=0
     rem cancel maplines
     for scany=starty to endy
      for scanx=startx to endx
       if scany<39 then maplines(l,scanx,scany+1,OBS_NN)=0
       if scany>0 then maplines(l,scanx,scany-1,OBS_SS)=0
       if scanx>0 then maplines(l,scanx-1,scany,OBS_EE)=0
       if scany<39 then maplines(l,scanx+1,scany,OBS_WW)=0
      next scanx
     next scany
    endif
   next x
  next y
 next l
 `
 rem find connecting lines and create obstacle strips from them
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    for sides=OBS_NN to OBS_WW
     for halfheight=0 to 1
      if halfheight=0 then twallmode=1 : rem full wall
      if halfheight=1 then twallmode=3 : rem half wall
      if maplines(l,x,y,sides)=twallmode
       rem found a line
       startx=x
       starty=y
       endx=x
       endy=y
       rem expand along line
       if sides=OBS_NN or sides=OBS_SS
        for scanx=startx to 39
         if maplines(l,scanx,y,sides)=0 then exit
        next scanx
        endx=scanx-1
       endif
       if sides=OBS_EE or sides=OBS_WW
        for scany=starty to 39
         if maplines(l,x,scany,sides)=0 then exit
        next scany
        endy=scany-1
       endif
       rem cancel maplines and convert to obstacle strip
       for scany=starty to endy
        for scanx=startx to endx
         maplines(l,scanx,scany,sides)=2
        next scanx
       next scany
       inc obsindex : dim obs(obsindex,6)
       obs(obsindex,0)=1
       if sides=OBS_NN
        obs(obsindex,1)=(startx*100)
        obs(obsindex,2)=(starty*100)
        obs(obsindex,3)=(endx+1)*100
        obs(obsindex,4)=(endy*100)+20
       endif
       if sides=OBS_SS
        obs(obsindex,1)=(startx*100)
        obs(obsindex,2)=(starty+1)*100
        obs(obsindex,3)=(endx+1)*100
        obs(obsindex,4)=((endy+1)*100)+20
       endif
       if sides=OBS_EE
        obs(obsindex,1)=((startx+1)*100)
        obs(obsindex,2)=(starty*100)
        obs(obsindex,3)=((endx+1)*100)+20
        obs(obsindex,4)=(endy+1)*100
       endif
       if sides=OBS_WW
        obs(obsindex,1)=(startx*100)
        obs(obsindex,2)=(starty*100)
        obs(obsindex,3)=(endx*100)+20
        obs(obsindex,4)=(endy+1)*100
       endif
       obs(obsindex,5)=l
       obs(obsindex,6)=halfheight
      endif
     next halfheight
    next sides
   next x
  next y
 next l
 `
 rem find corners and create obstacle triangles
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,OBS_CC)>=2
     inc obsindex : dim obs(obsindex,6)
     obs(obsindex,0)=maplines(l,x,y,OBS_CC)
     obs(obsindex,1)=(x*100)
     obs(obsindex,2)=(y*100)
     obs(obsindex,3)=(x+1)*100
     obs(obsindex,4)=(y+1)*100
     obs(obsindex,5)=l
     obs(obsindex,6)=0
    endif
   next x
  next y
 next l
 `
 rem find corners and create obstacle blocks
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,OBS_CC)=1
     inc obsindex : dim obs(obsindex,6)
     obs(obsindex,0)=maplines(l,x,y,OBS_CC)
     obs(obsindex,1)=(x*100)
     obs(obsindex,2)=(y*100)
     obs(obsindex,3)=(x+1)*100
     obs(obsindex,4)=(y+1)*100
     obs(obsindex,5)=l
     obs(obsindex,6)=0
    endif
   next x
  next y
 next l
 `
 rem find all doors and create posts
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,OBS_DR)>0
     if maplines(l,x,y,OBS_DR)=1
      rem north
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
      obs(obsindex,6)=0
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
      obs(obsindex,6)=0
     endif
     if maplines(l,x,y,OBS_DR)=2
      rem east
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
      obs(obsindex,6)=0
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
      obs(obsindex,6)=0
     endif
     if maplines(l,x,y,OBS_DR)=3
      rem south
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
      obs(obsindex,6)=0
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
      obs(obsindex,6)=0
     endif
     if maplines(l,x,y,OBS_DR)=4
      rem west
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
      obs(obsindex,6)=0
      inc obsindex : dim obs(obsindex,6)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
      obs(obsindex,6)=0
     endif
    endif
   next x
  next y
 next l
 `
 rem FPGC - 050510 - release MAPLINES array to save a little virtual memory
 undim maplines()
 `
return

_obs_getmapvalues:
 `
 rem mapid in
 mapselection    = ( mapid && %11111111111100000000000000000000 ) >> 20
 mapscaler       = ( mapid && %00000000000011110000000000000000 ) >> 16
 mapground       = ( mapid && %00000000000000001100000000000000 ) >> 14
 maprotate       = ( mapid && %00000000000000000011000000000000 ) >> 12
 maporient       = ( mapid && %00000000000000000000110000000000 ) >> 10
 mapsymbol       = ( mapid && %00000000000000000000001111110000 ) >> 4
 maptile         = ( mapid && %00000000000000000000000000001111 )
 `
return

_obs_save:
 `
 rem FPGC - 280410 - save obstacle data (no need to generate each time)
 for t=0 to 19
  tfile$=myownrootdir$+"levelbank\testlevel\map"+str$(t)+".obs"
  if file exist(tfile$)=1 then delete file tfile$
  AI SAVE OBSTACLE DATA t,tfile$
  addfiletocollection(tfile$)
 next t
 `
return

_obs_load:
 `
 rem FPGC - 280410 - load obstacle data (no need to generate each time)
 for t=0 to 19
  tfile$=myownrootdir$+"levelbank\testlevel\map"+str$(t)+".obs"
  AI LOAD OBSTACLE DATA t,tfile$
  addfiletocollection(tfile$)
 next t
 `
return

_obs_generateobstacles:
 `
 rem create all AI obstacles
 if obsindex>0
  if obsgeneratenow=0 then randomize 42
  for o=1 to obsindex
   if obs(o,0)=1
    if obsgeneratenow=1
     rem create an obstacle to block this hole so entity can avoid it
     ax1#=obs(o,1) : az1#=obs(o,2)*-1 : ax2#=obs(o,3) : az2#=obs(o,4)*-1
     rem it is important to create the obstacle poly in an anti-clockwise direction
     if ax1#>ax2# then sax1#=ax1# : ax1#=ax2# : ax2#=sax1#
     if az1#>az2# then saz1#=az1# : az1#=az2# : az2#=saz1#
     AI Start New Obstacle
     AI Add Obstacle Vertex ax1#,az1#
     AI Add Obstacle Vertex ax1#,az2#
     AI Add Obstacle Vertex ax2#,az2#
     AI Add Obstacle Vertex ax2#,az1#
     AI End New Obstacle obs(o,5),1-obs(o,6),0
    else
     if obs(o,5)=viewobslevel
      ink rgb(rnd(255),rnd(255),rnd(255)),0
      bxx=16 : byy=32
      xx1=bxx+(obs(o,1)/5)
      yy1=byy+(obs(o,2)/5)
      xx2=bxx+(obs(o,3)/5)
      yy2=byy+(obs(o,4)/5)
      box xx1/5,yy1/5,xx2/5,yy2/5
      ink rgb(255,255,255),0
     endif
    endif
   endif
   if obs(o,0)>=2 and obs(o,0)<=5
    xx1=obs(o,1) : yy1=obs(o,2)*-1 : xx2=obs(o,3) : yy2=obs(o,4)*-1
    if obs(o,0)=2 then xxa=xx1 : yya=yy1 : xxb=xx2 : yyb=yy1 : xxc=xx1 : yyc=yy2
    if obs(o,0)=3 then xxa=xx1 : yya=yy1 : xxb=xx2 : yyb=yy1 : xxc=xx2 : yyc=yy2
    if obs(o,0)=4 then xxa=xx2 : yya=yy1 : xxb=xx2 : yyb=yy2 : xxc=xx1 : yyc=yy2
    if obs(o,0)=5 then xxa=xx1 : yya=yy1 : xxb=xx2 : yyb=yy2 : xxc=xx1 : yyc=yy2
    if obsgeneratenow=1
     rem it is important to create the obstacle poly in an anti-clockwise direction
     AI Start New Obstacle
     AI Add Obstacle Vertex xxa,yya
     AI Add Obstacle Vertex xxb,yyb
     AI Add Obstacle Vertex xxc,yyc
     AI End New Obstacle obs(o,5),1-obs(o,6),0
    else
     if obs(o,5)=viewobslevel
      ink rgb(rnd(255),rnd(255),rnd(255)),0
      bxx=16 : byy=32
      xx1=bxx+(obs(o,1)/5)
      yy1=byy+(obs(o,2)/5)
      xx2=bxx+(obs(o,3)/5)
      yy2=byy+(obs(o,4)/5)
      line xxa,yya,xxb,yyb
      line xxb,yyb,xxc,yyc
      line xxc,yyc,xxa,yya
      ink rgb(255,255,255),0
     endif
    endif
   endif
  next o
 endif
 `
 rem FPGC - 050510 - release OBS array to save a little virtual memory
 undim obs()
 `
 rem Generate completed DarkAI obstacles
 AI Complete Obstacles
 `
return

rem
rem
rem
rem FPS CREATOR MAP EDITOR EXECUTABLE CODE (EXECUTES IF EXENAME IS FPSC-MAPEDITOR.EXE)
rem
rem
rem

rem GOTO LABEL (warning: not recommended but useful sometimes!)
_mapeditorexecutable:
rem GOTO LABEL (warning: not recommended but useful sometimes!)

rem Init app
sync on :` sync rate 60
sync rate 80 rem changed to 80 from 140
show window : window to front strarr$(475)+" - [Editor]"
always active off

rem U74 camera aspect ratio adjustment for desktop resolution
aspect#=desktop width() : aspect#=aspect#/desktop height()
set camera aspect aspect#

rem For debugging purposes
if 1 then timestampactivity(2,"FPSC-MapEditor.exe Begin")

rem Setup default paths
levelmapptah$="mapbank\testmap\"
projectfilename$=""

rem Setup segment selection flags for later loading
segnoeffects=1 : segobjusedformapeditor=1 : lastgrideditselect=-1

rem Get list of guns and flak for data
gosub _gun_scaninall_ref
gosub _gun_scaninall_dataonly
gosub _flak_scaninall_ref
gosub _flak_scaninall_dataonly

rem Initialise meshes and editor resources
global gmapeditmode
gmapeditmode=1
gosub _editor_init
gosub _editor_loadhelppage

rem FPGC - 050909 - load resource file which has test game memoru usage data contained
loadresource()

rem Load map editior settings
if grestoreeditorsettings=1
 tfile$="editors\gridedit\cfg.cfg"
 if file exist(tfile$)=1
  rem load settings from CFG (_editor_loadcfg (used inside load_map))
  rem load contents of old testmap
  projectfilename$="editors\gridedit\temp.fpm"
  gosub _mapfile_loadproject_fpm
  rem load FPM data
  skipfpmloading=1
  gosub _gridedit_load_map
  skipfpmloading=0
  rem so any changed data can optionally be saved if try to leave
  projectmodified=1
 endif
else
 rem Start Splash (only one which does not wait for sync-as interface not avail. in debug)
 open file map 2, "FPSSPLASH"
 while get file map dword( 2, 0 ) = 0 : sync : endwhile
 close file map 2
 rem Version Control - Splash Text
 gosub _version_splashtext
endif

window to back

rem Set editor fonts and text style and size
set text font "Verdana"
ink rgb(255,255,0),0
set text size 16

rem Main loop
if 1 then timestampactivity(3,"FPSC-MapEditor.exe Loop Starts")
do

 rem User input calls
 gosub _input_getcontrols
 gosub _input_calculatelocalcursor

 rem Editor Controls and Map Edit handling
 gosub _editor_constructionselection
 if grideditselect=3 or grideditselect=4
  gosub _editor_viewfunctionality
 else
  gosub _editor_gridfunctionality
 endif
 gosub _editor_overallfunctionality
 gosub _gridedit_mapediting

 rem handle visual components
 gosub _editor_detect_invalid_screen
 gosub _editor_visuals
 gosub _editor_fadeeditmarkers

 rem Interface code
 gosub _interface_handlepropertywindow

 rem Handle buildgame (cannot wait after 758 as straight into domodal)
 open file map 3, "FPSEXCHANGE"
 tokay=get file map dword( 3, 758 )
 if tokay=1
  set file map dword 3, 758, 2
  wait for file map event 3
  close file map 3
  rem Version Control - no build EXE in demo
  gosub _version_buildgame
 else
  close file map 3
 endif
 `
 rem Handle prefs (cannot wait after 754 as straight into domodal)
 open file map 3, "FPSEXCHANGE"
 tokay=get file map dword( 3, 754 )
 if tokay=1
  set file map dword 3, 754, 2
  wait for file map event 3
  gosub _interface_openprefs
  if tokay=1 then gosub _interface_handleprefs
  gosub _interface_closeprefs
 else
  close file map 3
 endif

 rem Update screen (if mouse in 3D are)
 if inputsys.activemouse=1
  rem constant update
  sync
 else
  rem check for PAINT message
  open file map 3, "FPSEXCHANGE"
  wait for file map event 3
  if get file map dword( 3, 60 )=1
   set file map dword 3,60,0 : syncthreetimes=3
   wait for file map event 3
  endif
  close file map 3
  if syncthreetimes>0 then dec syncthreetimes : sync
 endif

 rem detect if resolution changed (windows)
 gosub _editor_detect_invalid_screen

rem End loop
loop

_editor_detect_invalid_screen:
 if screen invalid()<>0
  rem recover map editor
  inc recoverplease
  if recoverplease>1
   rem message box - resolution has been changed - must restart - save changes?
   open file map 1, "FPSEXCHANGE"
   set file map dword 1, 900, 1
   set file map string$ 1, 1256, strarr$(622)
   set file map string$ 1, 1000, strarr$(623)
   wait for file map event 1
   while get file map dword(1, 900)=1
    wait for file map event 1
   endwhile
   tokay=get file map dword(1, 904)
   close file map 1
   if tokay=1
    rem no references to 3D objects (all gone now)
    recoverdonotuseany3dreferences=1
    rem save now
    gosub _gridedit_save_map_ask
   endif
   rem call a new map editor
   open file map 2, "FPSEXCHANGE"
   set file map string$ 2, 1000, "FPSC-MapEditor.exe"
   set file map string$ 2, 1256, "-r"
   set file map dword 2, 994, 0
   set file map dword 2, 924, 1
   wait for file map event 2
   close file map 2
   rem end this old mapeditor
   end
  endif
 endif
return

rem
rem MAP EDITOR CODE - SUBROUTINES AND FUNCTIONS
rem

`
` TESTMAP PREVIEW
`

_editor_loadhelppage:
 undim helppage$()
 dim helppage$(32*3)
 tfile$="languagebank\"+language$+"\textfiles\helppage.txt"
 if file exist(tfile$)=1 then load array tfile$,helppage$()
return

_editor_showhelppage:
 ink rgb(255,255,0),0
 set text font strarr$(325)
 set text size 16
 theline=0
 for column=0 to 1
  for l=0 to 32
   text 20+(column*380),20+(l*16),helppage$(theline)
   inc theline
  next l
 next column
 set text font "Verdana"
return

rem FPGC - 260710 - removed map preview for all time (hardly used, not very friendly)
_editor_previewmap:
return

_editor_previewmap_legacy:

rem Hide all objects
for obj=1 to universebuildobjstartoffset-1
 if object exist(obj)=1 then hide object obj
next obj

rem Hide camera while prepare test map
storecx#=camera position x()
storecy#=camera position y()
storecz#=camera position z()
gosub _editor_hideall3d

rem Use large prompt
statusbar$=strarr$(326) : popup_text(statusbar$)

rem Record entity and element max (as universe adds extras from segments)
storeentityelementlist=entityelementlist
storeentidmaster=entidmaster

rem Setup lighting for preview (force bright preview)
gosub _lighting_init
set ambient light 75

rem Construct universe from current data
segobjstart=universebuildobjstartoffset
gosub _universe_construct

rem Create dynamic entities as ghosts in preview
entobjpreview=segobj
for e=1 to entityelementlist
 obj=entobjpreview+e
 if obj>0
  rem add static entities to node tree now
  if entityelement(e).staticflag=0
   entid=entityelement(e).bankindex
   sourceobj=entitybankoffset+entid
   if object exist(obj)=1 then delete object obj
   if object exist(sourceobj)=1
    `
    rem Create a copy and set it up
    clone object obj,sourceobj,1
    gosub _entity_setupelementobject
    set object collision off obj
    show object obj
    `
   endif
  endif
 endif
next e
entobjpreviewlast=obj

rem Setup game view camera (overhead, so just drop down)
taty#=(gridlayer*100)+75
automatic camera collision 0,0,0
position camera storecx#,taty#,storecz#
point camera storecx#,taty#-100.0,storecz#
automatic camera collision 0,10,0
set camera range 1,4000
grav#=-5.0

rem Clear status text
statusbar$="" : popup_text_close()

rem mouselook mode on
open file map 1, "FPSEXCHANGE"
set file map dword 1, 44, 0
set file map dword 1, 48, 1
wait for file map event 1
close file map 1
change mouse 2

rem Preview loop
tescape=0
while tescape=0
 `
 rem Open filemap for input data
` sleep 3 : rem gives time to interface to get mouse deltas
 open file map 1, "FPSEXCHANGE"
 wait for file map event 1
 inputsys.xmousemove=get file map dword( 1, 8 )
 inputsys.ymousemove=get file map dword( 1, 12 )
 set file map dword 1, 8, 0
 set file map dword 1, 12, 0
 inputsys.mclick=get file map dword( 1, 20 )
 inputsys.kscancode=get file map dword( 1, 100 )
 if inputsys.kscancode=27 then tescape=1
 if inputsys.mclick<>0 then tescape=1
 `
 rem Close file map
 close file map 1
 `
 rem Control camera within test map
 gosub _universe_camera
 `
 rem Apply dynamic lighting to preview level
 gosub _lighting_managedynamiclights
 gosub _lighting_managegloballighting
 `
 rem Update screen
 sync
 `
endwhile

rem Restore lighting after preview
gosub _lighting_restore

rem Dim while delete universe
set ambient light 3
set text font "Verdana" : set text size 24 : ink rgb(255,255,255),0
for sss=0 to 1
 center text screen width()/2,screen height()/2,strarr$(327)
 sync
next sss

rem wait until all mouse activity over and escape key released
while tescape=1
 open file map 1, "FPSEXCHANGE"
 set file map dword 1, 44, 1
 set file map dword 1, 48, 0
 wait for file map event 1
 inputsys.mclick=get file map dword( 1, 20 )
 inputsys.kscancode=get file map dword( 1, 100 )
 if inputsys.mclick=0 and inputsys.kscancode=0 then tescape=0
 close file map 1
endwhile
change mouse 0

rem Restore camera
gosub _editor_restoreeditcamera
updatezoom=1

rem Free entity preview objects
for obj=entobjpreview to entobjpreviewlast
 if object exist(obj)=1 then delete object obj
next obj

rem Switch off ghosting in original entity objects
`100205 - never ghosted!
`for e=1 to entityelementlist
` if entityelement(e).staticflag=0
`  sourceobj=entitybankoffset+entityelement(e).bankindex
`  if object exist(sourceobj)=1
`   ghost object off sourceobj
`  endif
` endif
`next e

rem Destruct universe
gosub _universe_destruct

rem Restore ambience for editor when done
set text font "Verdana"
set ambient light 75 : rem FPGC - 270809 - 30
ink rgb(255,255,0),0
set text size 16

rem Restore entity and elements arrays for regular map editing
for entid=storeentidmaster+1 to entidmaster
 entobj=entitybankoffset+entid
 if object exist(entobj)=1 then delete object entobj
 entitybank$(entid)=""
next entid
entidmaster=storeentidmaster
entityelementlist=storeentityelementlist

rem restore object visibilities
gosub _editor_refresheditmarkers

return

`
` INPUT SYSTEM SUBROUTINES
`

rem FPGC - 280610 - created to standardize mouse/controller HUD pointer handling
function inputmousex()
endfunction mymousex
function inputmousey()
endfunction mymousey
function inputpositionmouse(x,y)
 mymousex=x
 mymousey=y
 rem FPGC - 020810 - keep windows mouse center of primary screen (avoids multimonitor issues)
 position mouse mymousex,mymousey
endfunction
function inputupdatemouse()
 mymousex=mymousex+mousemovex()
 mymousey=mymousey+mousemovey()
 if mymousex<0 then mymousex=0
 if mymousex>screen width()-1 then mymousex=screen width()-1
 if mymousey<0 then mymousey=0
 if mymousey>screen height()-1 then mymousey=screen height()-1
endfunction

_input_getdirectcontrols:

rem Direct input
inputsys.activemouse=1
inputsys.xmouse=mousex()
inputsys.ymouse=mousey()
inputsys.xmousemove=mousemovex()
inputsys.ymousemove=mousemovey()
inputsys.wheelmousemove=mousemovez()
inputsys.mclick=mouseclick()
inputsys.k$=lower$(inkey$())
inputsys.kscancode=scancode()

rem Control keys direct from keyboard
inputsys.keyreturn=returnkey()
inputsys.keyshift=shiftkey()
inputsys.keyleft=leftkey()
inputsys.keyright=rightkey()
inputsys.keyup=upkey()
inputsys.keydown=downkey()
inputsys.keycontrol=controlkey()
inputsys.keyspace=spacekey()

`rem debug display
`if debugcommreadoutactive=1
` if inputsys.kscancode<>88
`  set cursor 0,0
`  print "COMMS OUT"
`  print "DXSCANCODE : ";scancode()
`  print "DXCHAR : ";inkey$()
` endif
`endif

return

_input_checkarenaminspec:
 ttcount=0
 for tte=1 to entityelementlist
  ttentid=entityelement(tte).bankindex
  if entityprofile(ttentid).ischaracter=1
   inc ttcount
  endif
 next tte
 if ttcount>=2
  tokay=1
 else
  tokay=0
 endif
return

_input_getfilemapcontrols:

rem Update triggers and issue actions through filemapping system
open file map 1, "FPSEXCHANGE"
wait for file map event 1

rem If signal recieved of file map change
if 1
 `
 rem Obtain values (only if flagged)
 inputsys.xmouse=get file map dword( 1, 0 )
 inputsys.ymouse=get file map dword( 1, 4 )
 inputsys.xmousemove=get file map dword( 1, 8 )
 inputsys.ymousemove=get file map dword( 1, 12 )
 set file map dword 1, 8, 0
 set file map dword 1, 12, 0
 inputsys.wheelmousemove=get file map dword( 1, 16 )
 inputsys.mclick=get file map dword( 1, 20 )
 if get file map dword( 1, 28 )=1 then inputsys.mclick=2
 inputsys.kscancode=get file map dword( 1, 100 )
 `
 rem Control keys direct from keyboard
 inputsys.keyreturn=get file map dword( 1, 108 )
 inputsys.keyshift=get file map dword( 1, 112 )
 inputsys.keyup=get file map dword( 1, 120 )
 inputsys.keydown=get file map dword( 1, 124 )
 inputsys.keyleft=get file map dword( 1, 128 )
 inputsys.keyright=get file map dword( 1, 132 )
 inputsys.keycontrol=get file map dword( 1, 116 )
 if inputsys.kscancode=32 then inputsys.keyspace=1 else inputsys.keyspace=0
 `
 rem V110 BETA4 - 070608 - fake mousemove values for low-response systems (when in zoomed in mode)
 if grideditselect=4
  if inputsys.keyshift=1
   if inputsys.keyleft=1 then inputsys.xmousemove=-10
   if inputsys.keyright=1 then inputsys.xmousemove=10
   if inputsys.keyup=1 then inputsys.ymousemove=-10
   if inputsys.keydown=1 then inputsys.ymousemove=10
   inputsys.mclick=2
   inputsys.keyleft=0
   inputsys.keyright=0
   inputsys.keyup=0
   inputsys.keydown=0
  endif
 endif
 `
 rem special trigger when click LIBRARY TAB, force into respective mode
 if get file map dword( 1, 546 )=1
  ttabindex=get file map dword( 1, 520 )
  if ttabindex=0 then inputsys.domodeselect=1 : inputsys.tseldelete=1
  if ttabindex=1 then inputsys.domodepaint=1
  if ttabindex=2 then inputsys.domodeentity=1
  if ttabindex=3 then inputsys.domodeentity=1
  set file map dword 1, 546, 0
 endif
 `
 rem recent file list
 trecentfilechoice=get file map dword( 1, 442 )
 if trecentfilechoice>0
  rem retain choice for action at end of subroutine
  trecentfilechoice$=get file map string$( 1, 1000 )
  set file map dword 1, 442, 0
 endif
 `
 rem termination trigger
 if get file map dword( 1, 908 )=1
  rem hrere we ask if changes should be saved, etc
  close file map 1
  gosub _gridedit_intercept_savefirst
  open file map 1,"FPSEXCHANGE"
  if editorcanceltask=0
   rem go ahead, confirmed, end interface program
   set file map dword 1, 912, 1
   wait for file map event 1
   rem end editor program
   if 1 then timestampactivity(5,"Terminated because 908=1")
   end
  else
   rem carry on with interface
   set file map dword 1, 908, 0
   wait for file map event 1
   close file map 1
  endif
 endif
 `
 rem EDIT MENU
 if get file map dword( 1, 446 )=1 then inputsys.doundo=1 : set file map dword 1, 446, 0
 if get file map dword( 1, 450 )=1 then inputsys.doredo=1 : set file map dword 1, 450, 0
 if get file map dword( 1, 454 )=1 then inputsys.tselcontrol=1 : inputsys.tselcut=1 : inputsys.tselcopy=1 : set file map dword 1, 454, 0
 if get file map dword( 1, 458 )=1 then inputsys.tselcontrol=1 : inputsys.tselcopy=1 : set file map dword 1, 458, 0
 if get file map dword( 1, 462 )=1 then inputsys.tseldelete=1 : set file map dword 1, 462, 0
 `
 rem Get toolbar triggers
 inputsys.doartresize=0
 toolbarset=get file map dword( 1, 200 )
 toolbarindex=get file map dword( 1, 204 )
 if toolbarindex>0
  if toolbarset=2
   rem map view
   select toolbarindex
    case 1 : inputsys.kscancode=188 : endcase
    case 2 : inputsys.kscancode=190 : endcase
    case 3 : inputsys.doshroudincrease=1 : endcase
    case 4 : inputsys.doshrouddecrease=1 : endcase
    case 5 : inputsys.kscancode=9 : endcase
    case 6 : inputsys.dolayerchange=gridlayer+1 : endcase
    case 7 : inputsys.dolayerchange=gridlayer-1 : endcase
    case 8 : inputsys.kscancode=86 : endcase
    case 9 : inputsys.kscancode=90 : endcase
   endselect
  endif
  if toolbarset=4
   rem segment mode and selection
   inputsys.domodepaint=1
   select toolbarindex
    case 1 : inputsys.kscancode=asc("A") : endcase
    case 2 : inputsys.kscancode=asc("X") : endcase
    case 3 : inputsys.kscancode=asc("M") : endcase
    case 4 : inputsys.kscancode=asc("F") : endcase
    case 5 : inputsys.kscancode=asc("K") : endcase
    case 6 : inputsys.kscancode=asc("E") : endcase
    case 7 : inputsys.kscancode=asc("N") : endcase
    case 8 : inputsys.kscancode=asc("P") : endcase
   endselect
  endif
  if toolbarset=5
   rem clipboard
   inputsys.domodeselect=1
   select toolbarindex
    case 1 : inputsys.kscancode=88 : inputsys.keycontrol=1 : endcase
    case 2 : inputsys.kscancode=67 : inputsys.keycontrol=1 : endcase
    case 3 : inputsys.kscancode=86 : inputsys.keycontrol=1 : endcase
    case 4 : inputsys.kscancode=66 : inputsys.keycontrol=1 : endcase
    case 5 : inputsys.kscancode=78 : inputsys.keycontrol=1 : endcase
    case 6 : inputsys.kscancode=46 : endcase
   endselect
  endif
  inputsys.domodeart=0
  if toolbarset=6
   rem art
   select toolbarindex
    case 1 : inputsys.domodeart=1 : endcase
    case 2 : inputsys.domodeart=2 : endcase
    case 3 : inputsys.domodeart=3 : endcase
    case 4 : inputsys.domodeart=4 : endcase
    case 5 : inputsys.doartresize=2 : endcase
    case 6 : inputsys.doartresize=1 : endcase
   endselect
  endif
  if toolbarset=8
   rem wayppoint
   inputsys.domodewaypoint=1
   select toolbarindex
    case 1 : inputsys.kscancode=115 : endcase
   endselect
  endif
  if toolbarset=9
   rem test panel
   select toolbarindex
    case 1 : rem TEST GAME
     tokay=0
     if gmultiplayergame=0
      tokay=1
     else
      rem only if arena mode elements ready (2 players or more)
      tokay=0 : gosub _input_checkarenaminspec
      if tokay=0
       rem Report need 2+ players for arena test
       set file map dword 1, 900, 1
       set file map string$ 1, 1256, strarr$(602)
       set file map string$ 1, 1000, strarr$(603)
       wait for file map event 1
       while get file map dword(1, 900)=1
        wait for file map event 1
       endwhile
       tokay=get file map dword(1, 904)
       close file map 1
      endif
     endif
     rem V110 - 290508 - if invalid serial code, disable ability to TEST GAME
     if serialcodeinvalid=1 then tokay=0
     if tokay=1
     while ( 1 )
      rem wait for instruction to quit the editor
      wait for file map event 1
      if get file map dword( 1, 916 ) = 1
       `
       rem Save map data
       gosub _gridedit_save_test_map

       rem Save contents of testmap to TEMP (for later restoraion - ie buildexe style thing might overwrite testmap files)
       projectfilename$="editors\gridedit\temp.fpm"
       gosub _mapfile_saveproject_fpm

       rem Also save(resave) prefs (as multiplayer arena mode may have changed, ie NEW ARENA clicked)
       savesetupfile$="setup.ini" : gosub _interface_savesetupfile

       rem Launch Test Game Dialog
       open file map 4, "FPSEXCHANGE"
       set file map dword 4, 970, 1
       wait for file map event 4
       close file map 4
       rem Wait For Test Game Filemap Creation
       tquit=0
       while tquit=0
        open file map 4, "FPSTESTGAMEDIALOG"
        wait for file map event 4
        if get file map dword( 4, 0 ) = 1 then tquit=1
        close file map 4
       endwhile
       `
       rem Add Text To Test Game Dialog
       open file map 4, "FPSTESTGAMEDIALOG"
       set file map string$ 4, 1000, strarr$(328)
       set file map dword 4, 20, 1
       wait for file map event 4
       while get file map dword( 4, 20 ) = 1
        wait for file map event 4
       endwhile
       set file map string$ 4, 1000, strarr$(329)
       set file map dword 4, 24, 1
       wait for file map event 4
       while get file map dword( 4, 24 ) = 1
        wait for file map event 4
       endwhile
       set file map string$ 4, 1000, strarr$(331)
       set file map dword 4, 4, 1
       wait for file map event 4
       while get file map dword( 4, 4 ) = 1
        wait for file map event 4
       endwhile
       close file map 4
       `
       rem Version Control - launch game for test game mode
       gosub _version_permittestgame
       `
       rem Nowhere to go from here (terminated externally)
       if 1 then timestampactivity(4,"FPSC-MapEditor.exe Infinite Loop (wait for GAME.EXE to terminate)")
       do : sync : loop
       `
      endif
     endwhile
     endif
    endcase
    case 2 : inputsys.kscancode=220 : endcase
   endselect
  endif
  if toolbarset=10
   rem mode selector
   select toolbarindex
    case 1 : inputsys.kscancode=80 : endcase
    case 2 : inputsys.kscancode=69 : endcase
    case 3 : inputsys.kscancode=78 : endcase
    case 4 : inputsys.kscancode=79 : endcase
   endselect
  endif
 endif
 `
 rem Clear toolbar index
 set file map dword 1, 200, 0
 set file map dword 1, 204, 0
 `
 rem Clear deltas
 set file map dword 1, 8, 0
 set file map dword 1, 12, 0
 set file map dword 1, 16, 0
 `
 rem Deactivate mouse if leave 3d area
 inputsys.activemouse=1
 if inputsys.xmouse=-1 and inputsys.ymouse=-1
  inputsys.xmouse=screen width()/2
  inputsys.ymouse=screen height()/2
  inputsys.xmousemove=0
  inputsys.ymousemove=0
  inputsys.activemouse=0
  inputsys.mclick=0
  syncthreetimes=2
 endif
 `
 rem handle edit marker fades
 if inputsys.activemouse=0 and grideditselect<>4
  if shroudsize<10
   editmarkerfade#=-1.0
  endif
 else
  if editmarkerfade#=0.0
   editmarkerfade#=1.0
  endif
 endif
 `
 rem Convert FILE MAP COMM VALUES to DX INPUT CODES
 t$="" : tt=0
 select inputsys.kscancode
  case 9 : tt=15 : endcase
  case 32 : tt=57 : t$=" " : endcase
  case 33 : tt=201 : endcase
  case 34 : tt=209 : endcase
  case 37 : tt=203 : endcase
  case 38 : tt=200 : endcase
  case 39 : tt=205 : endcase
  case 40 : tt=208 : endcase
  case 42 : tt=16 : endcase
  case 46 : tt=211 : endcase
  case 54 : tt=16 : endcase
  case 112 : tt=59 : endcase
  case 113 : tt=60 : endcase
  case 114 : tt=61 : endcase
  case 115 : tt=62 : endcase
  case 123 : tt=88 : endcase
  case 187 : t$="=" : endcase
  case 188 : t$="," : endcase
  case 189 : t$="-" : endcase
  case 190 : t$="." : endcase
  case 192 : t$="'" : endcase
  case 219 : t$="[" : endcase
  case 220 : t$="\" : endcase
  case 221 : t$="]" : endcase
  case 222 : t$="#" : endcase
 endselect
 if inputsys.kscancode>=asc("A") and inputsys.kscancode<=asc("Z") then t$=lower$(chr$(inputsys.kscancode))
 if inputsys.kscancode>=asc("0") and inputsys.kscancode<=asc("9") then t$=lower$(chr$(inputsys.kscancode))
 if t$<>"" then tt=1
 `
 rem Get menu triggers
 inputsys.dosave=0 : inputsys.doopen=0 : inputsys.donew=0 : inputsys.donewarena=0 : inputsys.dosaveas=0
 if get file map dword( 1, 400 )=1 then inputsys.doopen=1 : set file map dword 1, 400, 0
 if get file map dword( 1, 404 )=1 then inputsys.dosave=1 : set file map dword 1, 404, 0
 if get file map dword( 1, 408 )=1 then inputsys.donew=1 : set file map dword 1, 408, 0
 if get file map dword( 1, 408 )=2 then inputsys.donewarena=1 : set file map dword 1, 408, 0
 if get file map dword( 1, 434 )=1 then inputsys.dosaveas=1 : set file map dword 1, 434, 0
 `
 rem select items from editing and segment menu to see values
 wait for file map event 1
 tindex1=get file map dword( 1, 712 )
 if tindex1>0
  tt=1 : t$=""
  tindex2=get file map dword( 1, 716 )
  if tindex1=2
   select tindex2
    case 1 : t$="a" : endcase
    case 2 : t$="m" : endcase
    case 3 : t$="f" : endcase
    case 4 : t$="k" : endcase
    case 5 : t$="x" : endcase
    case 6 : t$="a" : endcase
   endselect
  endif
  if tindex1=1
   select tindex2
    case 1 : t$="p" : endcase
    case 2 : t$="n" : endcase
    case 3 : t$="e" : endcase
    case 4 : t$="," : endcase
    case 5 : t$="." : endcase
    case 6 : t$="=" : endcase
    case 7 : t$="-" : endcase
    case 8 : t$="v" : endcase
   endselect
  endif
  set file map dword 1, 712, 0
  set file map dword 1, 716, 0
  wait for file map event 1
 endif
 `
 rem Record final translated key values
 inputsys.k$=t$ : inputsys.kscancode=tt
 `
 rem debug display
 if debugcommreadoutactive=1
  if inputsys.kscancode<>88
   print "COMMS OUT"
   print "MCLICK : ";inputsys.mclick
  endif
 endif
 `
 rem Determine if Library Selection Made
 if get file map dword( 1, 516 )>0
  set file map dword 1, 516, 0
  clickedonworkspace = get file map dword( 1, 520 )
  rem FPGC - 260410 - marks change of internal position of PREFAB (now tab 3 - last in order)
  clickedonworkspace = clickedonworkspace + 1
  if clickedonworkspace=4 then clickedonworkspace=0
  clickeditemonworkspace = get file map dword( 1, 524 )
  if clickeditemonworkspace<>-1
   `
   if clickedonworkspace=3
    `
    rem Selected Marker (playerstart,light,trigger,emission)
    addentityfile$=markerentitybank$(1+clickeditemonworkspace)
    if addentityfile$<>""
     gosub _entity_adduniqueentity
     tasset=entid
     if talreadyloaded=0 then gosub _editor_filllibrary
    endif
    inputsys.constructselection=tasset
    `
   else
    `
    if clickeditemonworkspace=0
     tnewadd=0
     if clickedonworkspace=0
      rem [new prefab]
      gosub _prefab_addtoselection
      tnewadd=prenewloaded
      tasset=preid
     endif
     if clickedonworkspace=1
      rem [new segment]
      gosub _segment_addtoselection
      tnewadd=segnewloaded
      tasset=segid
     endif
     if clickedonworkspace=2
      rem [new entity]
      gosub _entity_addtoselection
      tnewadd=entnewloaded
      tasset=entid
      if gmultiplayergame=1
       rem some entities cannot be used dynamically in arena mode
       if entityprofile(entid).isflak=1
        rem comment on restriction
        open file map 4,"FPSEXCHANGE"
        set file map dword 4, 900, 1
        set file map string$ 4, 1256, strarr$(604)
        if entityprofile(entid).ischaracter=1
         set file map string$ 4, 1000, strarr$(605)
        else
         set file map string$ 4, 1000, strarr$(606)
        endif
        wait for file map event 4
        while get file map dword(4, 900)=1
         wait for file map event 4
        endwhile
        tokay=get file map dword(4, 904)
        wait for file map event 4
        close file map 4
        if tokay=1
         rem wipe out weapon details (not functional in arena mode)
         entityprofile(entid).hasweapon$=""
         entityprofile(entid).hasweapon=0
         entityprofile(entid).isweapon=0
         entityprofile(entid).isammo=0
        else
         rem delete entity just loaded
         gosub _entity_delete : tnewadd=0 : tasset=0
        endif
       endif
      endif
     endif
     `
     rem add asset to library
     if tnewadd=1 then gosub _editor_filllibrary
     `
     rem use as current asset
     inputsys.constructselection=tasset
     `
    else
     `
     rem select existing asset
     if clickedonworkspace=2
      rem entity uses array to indicate the real entity index (to exclude markers - see above)
      inputsys.constructselection=locallibraryent(clickeditemonworkspace)
     else
      rem direct relationship between list index and choice
      inputsys.constructselection=clickeditemonworkspace
     endif
     `
    endif
    `
   endif
   `
   rem Workspace index determines editing mode
   if clickedonworkspace=0 then inputsys.domodeselect=1 : grideditselect=1
   if clickedonworkspace=1 then inputsys.domodepaint=1 : grideditselect=0
   if clickedonworkspace=2 then inputsys.domodeentity=1 : grideditselect=5
   if clickedonworkspace=3 then inputsys.domodeentity=1 : grideditselect=5
   gosub _editor_refresheditmarkers
   `
  endif
 endif
 `
endif

rem Ensure status bar is constantly updated
inc interfacestatusbarupdate
if interfacestatusbarupdate>30
 rem cursor position
 set file map string$ 1, 4256, strarr$(403)+str$(gridlayer)
 set file map string$ 1, 4512, "X:"+str$(inputsys.mmx)+"  "+"Z:"+str$(inputsys.mmy)
 set file map string$ 1, 4768, ""
 wait for file map event 1
 rem editing mode
 if grideditselect=0
  statusbar$=strarr$(332)
  if nogridsmart=-1
   if gridground=0
    statusbar$=statusbar$+strarr$(404)
   else
    statusbar$=statusbar$+strarr$(405)
   endif
  else
   if nogridsmart=0
    statusbar$=statusbar$+strarr$(333)
   else
    statusbar$=statusbar$+strarr$(334)
   endif
  endif
  statusbar$=statusbar$+strarr$(335)
 endif
 if grideditselect=1 then statusbar$=strarr$(336)
 if grideditselect=2
  statusbar$=strarr$(337)
  if grideditartmode=1 then statusbar$=statusbar$+strarr$(338)
  if grideditartmode=2 then statusbar$=statusbar$+strarr$(339)
  if grideditartmode=3 then statusbar$=statusbar$+strarr$(340)
  if grideditartmode=4 then statusbar$=statusbar$+strarr$(341)
 endif
 if grideditselect=3 then statusbar$=strarr$(342)
 if grideditselect=4 then statusbar$=strarr$(343)
 if grideditselect=5
  statusbar$=strarr$(344)
  rem FPGC - 270410 - extra info; static or dynamic entity
  if gridentitystaticmode=1
   statusbar$=statusbar$+"  Static Placement Mode"
  else
   statusbar$=statusbar$+"  Dynamic Placement Mode"
  endif
 endif
 if grideditselect=6
  rem FPGC - 110111 - add waypoint status
  statusbar$="Waypoint Mode (LMB=Drag Point  SHIFT+LMB=Clone Point  SHIFT+RMB=Remove Point)"
 endif
 rem only update infrequently
 interfacestatusbarupdate=0
endif

rem Close communicaion with filmapping system
close file map 1

rem Update status bar out of action subroutines
gosub _gridedit_updatestatusbar

rem Action after filemap activity
if trecentfilechoice>0
 rem save first
 gosub _gridedit_intercept_savefirst
 if editorcanceltask=0
  rem go ahead, load direct (skip the open dialog)
  projectfilename$=trecentfilechoice$
  gosub _gridedit_load_map
 endif
 trecentfilechoice=0
endif

return

_input_getcontrols:

rem Some actions are directly triggered by input subroutine
inputsys.doload=0
inputsys.domodepaint=0
inputsys.domodeselect=0
inputsys.domodeentity=0
inputsys.domodewaypoint=0
inputsys.dolayerchange=-1
inputsys.doundo=0
inputsys.doredo=0
inputsys.tselcontrol=0
inputsys.tselcut=0
inputsys.tselcopy=0
inputsys.tseldelete=0

rem Obtain input data
if gindieditorstate=1
 gosub _input_getdirectcontrols
else
 gosub _input_getfilemapcontrols
endif

rem Flag reset
inputsys.dorotation=0
inputsys.domirror=0
inputsys.doflip=0
inputsys.doentityrotate=0
inputsys.dozoomin=0
inputsys.dozoomout=0
inputsys.doscrollleft=0
inputsys.doscrollright=0
inputsys.doscrollup=0
inputsys.doscrolldown=0
inputsys.domapresize=0
inputsys.dogroundmode=-1
inputsys.domapview=0
inputsys.dozoomview=0
inputsys.dozoomviewmovex=0
inputsys.dozoomviewmovey=0
inputsys.dozoomviewmovez=0
inputsys.dozoomviewrotatex=0
inputsys.dozoomviewrotatey=0
inputsys.dozoomviewrotatez=0
inputsys.dosinglelayer=0
inputsys.tselfloor=0
inputsys.tselpaste=0
inputsys.tselwipe=0
inputsys.tselsaveselection=0
inputsys.dosaveandrun=0

rem Input conditional flags
if inputsys.kscancode=0 then inputsys.keypress=0

rem Construction Keys
if inputsys.keycontrol=0
 `
 if inputsys.k$="p" then inputsys.domodepaint=1
 if inputsys.k$="e" then inputsys.domodeselect=1 : inputsys.tseldelete=1
 if inputsys.k$="t" then inputsys.domodeart=1
 if grideditselect=2
  if inputsys.k$="i" then inputsys.domodeart=1
  if inputsys.k$="b" then inputsys.domodeart=2
  if inputsys.k$="c" then inputsys.domodeart=3
  if inputsys.k$="y" then inputsys.domodeart=4
  if inputsys.k$="[" and inputsys.keypress=0 then inputsys.doartresize=1 : inputsys.keypress=1
  if inputsys.k$="]" and inputsys.keypress=0 then inputsys.doartresize=2 : inputsys.keypress=1
 endif
 if (grideditselect=4 and gridentityinzoomview>0) or grideditselect=5
  if inputsys.k$="b" and inputsys.keypress=0
   inputsys.keypress=1 : gridentitygridlock=gridentitygridlock+1
   if gridentitygridlock>2 then gridentitygridlock=0
  endif
  if inputsys.k$="y" and inputsys.keypress=0 and gentitytogglingoff=0 then inputsys.keypress=1 : gridentitystaticmode=1-gridentitystaticmode
  if inputsys.k$="u" and inputsys.keypress=0 then inputsys.keypress=1 : gridentitydroptoground=1
  if inputsys.k$="i" and inputsys.keypress=0 then inputsys.keypress=1 : gridentitydroptoground=2
  if inputsys.k$="[" and inputsys.keypress=0 then gridentitymodifyelement=1 : inputsys.keypress=1
  if inputsys.k$="]" and inputsys.keypress=0 then gridentitymodifyelement=2 : inputsys.keypress=1
 endif
 if inputsys.k$="n" then inputsys.domodeentity=1 : inputsys.dowaypointview=0
 if inputsys.k$="w" then inputsys.domodewaypoint=1 : inputsys.dowaypointview=0
 if inputsys.keyspace=1 and inputsys.keypress=0 then inputsys.dowaypointview=1-inputsys.dowaypointview : inputsys.keypress=1 : lastgrideditselect=-1 : gosub _editor_refresheditmarkers
 if inputsys.k$="m" and inputsys.keypress=0 then inputsys.domirror=1 : inputsys.keypress=1
 if inputsys.k$="f" and inputsys.keypress=0 then inputsys.doflip=1 : inputsys.keypress=1
 if inputsys.k$="a" then inputsys.dogroundmode=0
 if inputsys.k$="f" then inputsys.dogroundmode=1
 if inputsys.k$="x" then inputsys.dogroundmode=2
 if inputsys.k$="m" then inputsys.dogroundmode=3
 if inputsys.k$="v" and inputsys.keypress=0 then inputsys.domapview=1 : inputsys.keypress=1
 if inputsys.k$="k" then inputsys.domodepaint=1 : inputsys.dopickmapid=1 : gosub _editor_refresheditmarkers
 rem NUM-ROTATE CONTROLS
 if inputsys.k$="r" and inputsys.keypress=0 then inputsys.dorotation=1 : inputsys.keypress=1
 if gridentityinzoomview=0
  if inputsys.k$="z" and inputsys.keypress=0 then inputsys.dozoomview=1 : inputsys.keypress=1
 endif
 if grideditselect<>4
  if inputsys.k$="1" and inputsys.keypress=0 then inputsys.doentityrotate=1 : inputsys.keypress=1
  if inputsys.k$="2" and inputsys.keypress=0 then inputsys.doentityrotate=2 : inputsys.keypress=1
  if inputsys.k$="3" and inputsys.keypress=0 then inputsys.doentityrotate=3 : inputsys.keypress=1
  if inputsys.k$="4" and inputsys.keypress=0 then inputsys.doentityrotate=4 : inputsys.keypress=1
  if inputsys.k$="5" and inputsys.keypress=0 then inputsys.doentityrotate=5 : inputsys.keypress=1
  if inputsys.k$="6" and inputsys.keypress=0 then inputsys.doentityrotate=6 : inputsys.keypress=1
 endif
 `
 rem TEST Game
 if inputsys.k$="\" then inputsys.dosaveandrun=1
 `
 rem Editing of Map
 if inputsys.k$="," then inputsys.dozoomin=1
 if inputsys.k$="." then inputsys.dozoomout=1
 if inputsys.k$="'" then inputsys.doshrouddecrease=1
 if inputsys.k$="#" then inputsys.doshroudincrease=1
 `
 rem TAB Key causes layer edit view control
 if inputsys.kscancode=15 and inputsys.keypress=0 then inputsys.dosinglelayer=1 : inputsys.keypress=1
 `
 rem F1 for help page
 if inputsys.kscancode=59 then gosub _editor_showhelppage
 `
else
 `
 rem keys that also use CTRL
 if inputsys.k$="r" then inputsys.dorotation=1
 `
endif

rem Key Map Scroll and Resize
if inputsys.keyshift=0
 if inputsys.keycontrol=0
  if inputsys.keyleft=1 then inputsys.doscrollleft=1
  if inputsys.keyright=1 then inputsys.doscrollright=1
  if inputsys.keyup=1 then inputsys.doscrollup=1
  if inputsys.keydown=1 then inputsys.doscrolldown=1
 else
  if inputsys.keyleft=1 then inputsys.doscrollleft=100
  if inputsys.keyright=1 then inputsys.doscrollright=100
  if inputsys.keyup=1 then inputsys.doscrollup=100
  if inputsys.keydown=1 then inputsys.doscrolldown=100
 endif
else
 if inputsys.keyleft=1 then inputsys.doscrollleft=10
 if inputsys.keyright=1 then inputsys.doscrollright=10
 if inputsys.keyup=1 then inputsys.doscrollup=10
 if inputsys.keydown=1 then inputsys.doscrolldown=10
endif

rem Change Edit Layer
if inputsys.k$="-" and inputsys.keypress=0 then inputsys.dolayerchange=gridlayer-1 : inputsys.keypress=1
if inputsys.k$="=" and inputsys.keypress=0 then inputsys.dolayerchange=gridlayer+1 : inputsys.keypress=1

rem Mouse Wheel control
if grideditselect=4
 rem Zoomed in View
 dec zoomviewcamerarange#,(inputsys.wheelmousemove/10.0)
else
 rem Non-Zoomed in View
 if inputsys.keyshift=1
  if inputsys.wheelmousemove<0 then inputsys.dolayerchange=gridlayer+1
  if inputsys.wheelmousemove>0 then inputsys.dolayerchange=gridlayer-1
 else
  if inputsys.keycontrol=1
   if inputsys.wheelmousemove<0 then inputsys.doshrouddecrease=1
   if inputsys.wheelmousemove>0 then inputsys.doshroudincrease=1
  else
   if inputsys.wheelmousemove<0 then inputsys.dozoomout=1
   if inputsys.wheelmousemove>0 then inputsys.dozoomin=1
  endif
 endif
endif

rem CTRL Cut/Copy/Paste Keys
if inputsys.keycontrol=1
 inputsys.tselcontrol=1
 if inputsys.k$="x" then inputsys.tselcut=1 : inputsys.tselcopy=1
 if inputsys.k$="c" then inputsys.tselcopy=1
 if inputsys.k$="b" then inputsys.tselfloor=1
 if inputsys.k$="n" then inputsys.tselfloor=2
 if inputsys.k$="j" then inputsys.tselsaveselection=1
 if inputsys.k$="k" then gridlayershowall=1-gridlayershowall
endif
if inputsys.kscancode=211 then inputsys.tseldelete=1

rem UndoRedo Keys
if inputsys.keycontrol=1
 if inputsys.k$="" then inputsys.undokeypress=0
 if inputsys.k$="z" and inputsys.undokeypress=0 then inputsys.doundo=1 : inputsys.undokeypress=1
 if inputsys.k$="y" and inputsys.undokeypress=0 then inputsys.doredo=1 : inputsys.undokeypress=1
endif

rem Seperate undo events with nulls
if inputsys.undoredoevent<>0
 `
 rem Conditions for terminating event set
 tokay=0
 select inputsys.undoredoevent
  case 1
   if inputsys.mclick=0 then tokay=1
  endcase
 endselect
 `
 rem End event set
 if tokay=1
  gridevent=0 : gosub _editor_undoredoadd
  inputsys.undoredoevent=0
 endif
 `
endif

rem Controls only when in zoomview
if grideditselect=4
 rem orient arrowkey movement to camera angle
 tca#=wrapvalue(camera angle y())
 if tca#>=360-45 or tca#<=45
  txa=1 : txb=2 : txc=0 : txd=0
  tza=0 : tzb=0 : tzc=2 : tzd=1
 else
  if tca#>=180-45 and tca#<=180+45
   txa=2 : txb=1 : txc=0 : txd=0
   tza=0 : tzb=0 : tzc=1 : tzd=2
  else
   if tca#<=180
    txa=0 : txb=0 : txc=2 : txd=1
    tza=2 : tzb=1 : tzc=0 : tzd=0
   else
    txa=0 : txb=0 : txc=1 : txd=2
    tza=1 : tzb=2 : tzc=0 : tzd=0
   endif
  endif
 endif
 inputsys.dozoomviewmovex=0 : inputsys.dozoomviewmovez=0
 if inputsys.keyleft=1 then inc inputsys.dozoomviewmovex,txa : inc inputsys.dozoomviewmovez,tza
 if inputsys.keyright=1 then inc inputsys.dozoomviewmovex,txb : inc inputsys.dozoomviewmovez,tzb
 if inputsys.keyup=1 then inc inputsys.dozoomviewmovex,txc : inc inputsys.dozoomviewmovez,tzc
 if inputsys.keydown=1 then inc inputsys.dozoomviewmovex,txd : inc inputsys.dozoomviewmovez,tzd
 rem control rotation
 if inputsys.k$="1" and inputsys.keypress=0 then inputsys.dozoomviewrotatex=1 : inputsys.keypress=1
 if inputsys.k$="2" and inputsys.keypress=0 then inputsys.dozoomviewrotatex=2 : inputsys.keypress=1
 if inputsys.k$="3" and inputsys.keypress=0 then inputsys.dozoomviewrotatey=1 : inputsys.keypress=1
 if inputsys.k$="4" and inputsys.keypress=0 then inputsys.dozoomviewrotatey=2 : inputsys.keypress=1
 if inputsys.k$="5" and inputsys.keypress=0 then inputsys.dozoomviewrotatez=1 : inputsys.keypress=1
 if inputsys.k$="6" and inputsys.keypress=0 then inputsys.dozoomviewrotatez=2 : inputsys.keypress=1
endif
if grideditselect=4 or grideditselect=5
 rem control finder
 if inputsys.keyreturn=1 and gridentity>0
  gridentitydroptoground=1+entityprofile(gridentity).forwardfacing
 endif
 rem control height
 if grideditselect=4
  if inputsys.kscancode=201 then inputsys.dozoomviewmovey=2
  if inputsys.kscancode=209 then inputsys.dozoomviewmovey=1
 else
  if inputsys.kscancode=201 then inc gridentityposy#,1.0
  if inputsys.kscancode=209 then dec gridentityposy#,1.0
 endif
endif

rem Create a waypoint when instructed to
if inputsys.kscancode=62 and inputsys.keypress=0
 inputsys.keypress=1 : inputsys.domodewaypoint=1 : grideditselect=6
 rem FPGC - 280410 - new waypoint created in center of view
 `mx#=inputsys.localx# : mz#=inputsys.localy#
 mx#=cx# : mz#=cy#*-1
 gosub _waypoint_createnew
endif

return

_input_calculatelocalcursor:

rem Layer height based on mode
if grideditselect=6
 layerheight#=curvevalue((gridlayer*100.0)+15.0,layerheight#,5.0)
else
 layerheight#=curvevalue(gridlayer*100.0,layerheight#,5.0)
endif

rem Local cursor calculation
if grideditselect<>4
 rem do not change these values if in zoom mode (unnecessary recalc of shroud)
 tx#=(inputsys.xmouse-(workareax/2))/gridscale#
 ty#=(inputsys.ymouse-(workareay/2))/gridscale#
 rem X9 - 050208 - account of aspect ratio
 bkwidth=desktop width()-(800-652) : bkheight=desktop height()-(600-480)
 tdesktopwidth#=bkwidth : tdesktopheight#=bkheight
 taspectio#=tdesktopwidth#/tdesktopheight#
 `\if taspectio#>=1.4
 `\ if taspectio#>=1.7
 `\  tx#=tx#*1.39
 `\ else
 `\  tx#=tx#*1.30
 `\ endif
 `\endif
 rem 1360 x 768
 tx#=tx#*taspectio#*0.7
 tilex#=tx#
 tiley#=ty#
else
 tx#=tilex#
 ty#=tiley#
endif
`if grideditselect<>4
` rem do not change these values if in zoom mode (unnecessary recalc of shroud)
` tx#=(inputsys.xmouse-(workareax/2))/gridscale#
` ty#=(inputsys.ymouse-(workareay/2))/gridscale#
` tilex#=tx#
` tiley#=ty#
`else
` tx#=tilex#
` ty#=tiley#
`endif
tx=tx#+(cx#/100.0)
ty=ty#+(cy#/100.0)
if tx<0 then tx=0
if ty<0 then ty=0
if tx>maxx-1 then tx=maxx-1
if ty>maxy-1 then ty=maxy-1
inputsys.mmx=tx : inputsys.mmy=ty

rem World cursor position
otx#=tx#+(cx#/100.0)
oty#=ty#+(cy#/100.0)
dec otx#,(tx+0.5)
dec oty#,(ty+0.5)
otx#=otx#*100
oty#=oty#*100
inputsys.localx#=((tx*100)+50)+otx#
inputsys.localy#=((ty*-100)-50)-oty#

return

_editor_disableforzoom:
 `
 open file map 2, "FPSEXCHANGE"
 set file map dword 2, 850, 1
 wait for file map event 2
 close file map 2
 `
return

_editor_enableafterzoom:
 `
 open file map 2, "FPSEXCHANGE"
 set file map dword 2, 850, 0
 wait for file map event 2
 close file map 2
 gosub _editor_cutcopyclearstate
 `
return

_editor_init:

rem Prepare grid edit meshes
gosub _gridedit_createmeshes

rem Load editor images for blueprint mesh sets
load image "editors\gfx\1.bmp",editorimagesoffset+0
load image "editors\gfx\7.bmp",editorimagesoffset+1

rem Load editor images
`load image "editors\gfx\3.bmp",editorimagesoffset+2 now 14,15,16,17
load image "editors\gfx\0B.bmp",editorimagesoffset+2
load image "editors\gfx\4.bmp",editorimagesoffset+3
load image "editors\gfx\5.bmp",editorimagesoffset+4
load image "editors\gfx\6.bmp",editorimagesoffset+5
load image "editors\gfx\0.bmp",editorimagesoffset+6

rem Cursor for segment highlighting
load image "editors\gfx\14.bmp",editorimagesoffset+14
load image "editors\gfx\15.bmp",editorimagesoffset+15
load image "editors\gfx\16.bmp",editorimagesoffset+16
load image "editors\gfx\17.bmp",editorimagesoffset+17
load image "editors\gfx\19.bmp",editorimagesoffset+19
load image "editors\gfx\25.bmp",editorimagesoffset+25

rem Additional segment cursors (KINDOF icons)
load image "editors\gfx\20.bmp",editorimagesoffset+20
load image "editors\gfx\21.bmp",editorimagesoffset+21
load image "editors\gfx\22.bmp",editorimagesoffset+22
load image "editors\gfx\23.bmp",editorimagesoffset+23
load image "editors\gfx\24.bmp",editorimagesoffset+24
rem RESERVE FOR +32 ie editorimagesoffset+20+(32-1)
load image "editors\gfx\24.bmp",editorimagesoffset+20+(32-1)

rem Cursor for entity highlighting
load image "editors\gfx\9.bmp",editorimagesoffset+7
load image "editors\gfx\18.bmp",editorimagesoffset+18
load image "editors\gfx\26.bmp",editorimagesoffset+26

rem Load last-to-draw images for editor
if file exist("editors\gfx\8.dds")=1
 load image "editors\gfx\8.dds",editorimagesoffset+8
else
 load image "editors\gfx\8.tga",editorimagesoffset+8
 save image "editors\gfx\8.dds",editorimagesoffset+8
endif

rem Load texture used by waypoint to draw-over-realview polys
load image "editors\gfx\13.bmp",editorimagesoffset+13

rem FPGC - 020909 - for overlays on map editor view
if file exist("editors\gfx\resources.png")=1
 load image "editors\gfx\resources.png",editordrawlastimagesoffset+1
endif
if file exist("editors\gfx\resourceslow.png")=1
 load image "editors\gfx\resourceslow.png",editordrawlastimagesoffset+2
endif

rem Work area paint cursor
make object box 2,100,100,100
position object 2,1*50,50,1*-50
texture object 2,editorimagesoffset+15 : ghost object on 2
set object collision off 2
disable object zdepth 2
set object light 2,0

rem Work area boundbox cursor
make object box 3,102,102,102
texture object 3,editorimagesoffset+3 : ghost object on 3 : set object light 3,0
set object collision off 3
disable object zdepth 3
make object box 4,102,102,102 : set object cull 4,0
texture object 4,editorimagesoffset+4 : ghost object on 4 : set object light 4,0
hide object 3 : hide object 4
set object collision off 4
disable object zdepth 4

rem Work area entity cursor
make object plain 5,150,150 : xrotate object 5,90
texture object 5,editorimagesoffset+7
ghost object on 5
modifyplaneimagestrip(5,8,1)
set object collision off 5
disable object zdepth 5
set object light 5,0
hide object 5
rem FPGC - 270809 - raise highlighter one unit to avoid Z clash
offset limb 5,0,0,0,-1

rem Work arrow for direction indicator (i.e. clipboard prefab orientation)
make object plain 6,150,150 : xrotate object 6,90
texture object 6,editorimagesoffset+15
ghost object on 6
set object collision off 6
disable object zdepth 6
set object light 6,0
hide object 6

rem FPGC - 020909 - cylinder to indicate resources in editor used (and warning)
if fpgcgenre<>1
 make object cylinder 7,50
 set object collision off 7
 set object light 7,0
 disable object zdepth 7
 disable object zread 7
 texture object 7,editordrawlastimagesoffset+1
 lock object on 7
 scale object 7,2,0,2
 rotate object 7,0,0,90
 position object 7,0,-115,200
endif

rem Work area art highlighters
obj=editormarkeroffset
make object box obj,100,102,100 : texture object obj,editorimagesoffset+3
ghost object on obj : set object light obj,0
scale object texture obj,5,5
set object collision off obj
disable object zdepth obj
hide object obj
for o=obj+1 to editormarkeroffsetmax
 instance object o,obj
 set object collision off o
 disable object zdepth o
 hide object o
next o

rem Setup camera
color backdrop rgb(32,32,32)
set camera range 10,10000
set light range 0,10000
set ambient light 75
set camera fov 90
autocam off

rem Position camera
cx#=800*gridzoom# : cy#=600*gridzoom#
gridscale#=((800/2)/8)/gridzoom#
workareax=800 : workareay=600
gosub _editor_restoreeditcamera

rem Reset statu bar text
statusbar$="" : laststatusbar$=""

return

_editor_hideall3d:
 position camera 199999,99999,99999
 point camera 199999,100999,99999
 sync : sync
return

_editor_restoreeditcamera:
 position camera cx#,600*gridzoom#,cy#
 point camera cx#,0,cy#
return

_editor_clearlibrary:

rem Delete all library
for tabs=0 to 3
 set file map dword 1, 534, tabs
 set file map dword 1, 542, 1
 wait for file map event 1
 while get file map dword(1, 542)=1
  wait for file map event 1
 endwhile
next tabs

rem And create default NEW icons
for tadd=1 to 4
 if tadd<>3
  if tadd=1 then t1$=strarr$(346) : t2$="files\editors\host\res\newseg.bmp"
  if tadd=2 then t1$=strarr$(347) : t2$="files\editors\host\res\newent.bmp"
  if tadd=4 then t1$=strarr$(345) : t2$="files\editors\host\res\newpre.bmp"
  set file map dword 1, 508, tadd-1
  set file map string$ 1, 1000, t2$
  set file map string$ 1, 1256, t1$
  set file map dword 1, 500, 1
  wait for file map event 1
  while get file map dword(1, 500)=1
   wait for file map event 1
  endwhile
 endif
next tadd

rem Default markers
tadd=3
for tt=0 to 14
 if tt=0 then t1$=strarr$(349) : t2$="files\entitybank\_markers\player start.bmp"
 if tt=1 then t1$=strarr$(350) : t2$="files\entitybank\_markers\player checkpoint.bmp"
 if tt=2 then t1$=strarr$(351) : t2$="files\entitybank\_markers\white light.bmp"
 if tt=3 then t1$=strarr$(352) : t2$="files\entitybank\_markers\red light.bmp"
 if tt=4 then t1$=strarr$(353) : t2$="files\entitybank\_markers\green light.bmp"
 if tt=5 then t1$=strarr$(354) : t2$="files\entitybank\_markers\blue light.bmp"
 if tt=6 then t1$=strarr$(355) : t2$="files\entitybank\_markers\yellow light.bmp"
 if tt=7 then t1$=strarr$(356) : t2$="files\entitybank\_markers\purple light.bmp"
 if tt=8 then t1$=strarr$(357) : t2$="files\entitybank\_markers\cyan light.bmp"
 if tt=9 then t1$=strarr$(358) : t2$="files\entitybank\_markers\heal zone.bmp"
 if tt=10 then t1$=strarr$(359) : t2$="files\entitybank\_markers\hurt zone.bmp"
 if tt=11 then t1$=strarr$(360) : t2$="files\entitybank\_markers\win zone.bmp"
 if tt=12 then t1$=strarr$(361) : t2$="files\entitybank\_markers\trigger zone.bmp"
 if tt=13 then t1$=strarr$(362) : t2$="files\entitybank\_markers\sound zone.bmp"
 if fpgcgenre=1
  if tt=14 then t1$=strarr$(607) : t2$="files\entitybank\_markers\story zone.bmp"
 else
  if tt=14 then t1$=strarr$(607) : t2$="files\entitybank\_markers\media zone.bmp"
 endif
 set file map dword 1, 508, tadd-1
 set file map string$ 1, 1000, t2$
 set file map string$ 1, 1256, t1$
 set file map dword 1, 500, 1
 wait for file map event 1
 while get file map dword(1, 500)=1
  wait for file map event 1
 endwhile
next tt
`
rem actual entity names of the markers
dim markerentitybank$(15)
markerentitybank$(1)="_markers\player start.fpe"
markerentitybank$(2)="_markers\player checkpoint.fpe"
markerentitybank$(3)="_markers\white light.fpe"
markerentitybank$(4)="_markers\red light.fpe"
markerentitybank$(5)="_markers\green light.fpe"
markerentitybank$(6)="_markers\blue light.fpe"
markerentitybank$(7)="_markers\yellow light.fpe"
markerentitybank$(8)="_markers\purple light.fpe"
markerentitybank$(9)="_markers\cyan light.fpe"
markerentitybank$(10)="_markers\heal zone.fpe"
markerentitybank$(11)="_markers\hurt zone.fpe"
markerentitybank$(12)="_markers\win zone.fpe"
markerentitybank$(13)="_markers\trigger zone.fpe"
markerentitybank$(14)="_markers\sound zone.fpe"
if fpgcgenre=1
 markerentitybank$(15)="_markers\story zone.fpe"
else
 markerentitybank$(15)="_markers\media zone.fpe"
endif

rem clear counters
locallibrarypreidmaster=0
locallibrarysegidmaster=0
locallibraryentidmaster=0
locallibraryentindex=0
preidmaster=0

return

_editor_filllibrary:

rem Store place before adds
wait for file map event 1
tstoredtabindex=get file map dword( 1, 520 )

rem Ensure segment list is up to date in library (ignore first one)
while locallibrarysegidmaster<segidmaster
 inc locallibrarysegidmaster
 if selectionbanklocal$(locallibrarysegidmaster)=""
  rem Localization for segment local name
  tflocalfilename$="languagebank\"+language$+"\textfiles\library\segments\"+selectionbank$(locallibrarysegidmaster)
  tflocalfilename$=left$(tflocalfilename$,len(tflocalfilename$)-4)+".loc"
  if file exist(tflocalfilename$)=1
   dim tflocal$(1)
   load array tflocalfilename$,tflocal$()
   selectionbanklocal$(locallibrarysegidmaster)=tflocal$(0)
   undim tflocal$()
  endif
 endif
 t2$=selectionbanklocal$(locallibrarysegidmaster)
 ttext$=selectionbank$(locallibrarysegidmaster)
 tbitmap$="files\segments\"+ttext$
 t1$=left$(tbitmap$,len(tbitmap$)-4)+".bmp"
 if file exist("..\"+t1$)=0 then t1$="files\editors\host\res\newseg.bmp"
 set file map dword 1, 508, 0
 set file map string$ 1, 1000, left$(t1$,254)
 set file map string$ 1, 1256, left$(t2$,254)
 set file map dword 1, 500, 1
 wait for file map event 1
 while get file map dword(1, 500)=1
  wait for file map event 1
 endwhile
endwhile

rem Ensure entity list is up to date in library
while locallibraryentidmaster<entidmaster
 inc locallibraryentidmaster
 rem only if not marker
 if entityprofile(locallibraryentidmaster).ismarker=0 or entityprofile(locallibraryentidmaster).ismarker=4

  rem add to actual list
  t2$=entityprofileheader(locallibraryentidmaster).desc$
  ttext$=entitybank$(locallibraryentidmaster)
  tbitmap$="files\entitybank\"+ttext$
  t1$=left$(tbitmap$,len(tbitmap$)-4)+".bmp"
  if file exist("..\"+t1$)=0 then t1$="files\editors\host\res\newent.bmp"
  set file map dword 1, 508, 1
  set file map string$ 1, 1000, left$(t1$,254)
  set file map string$ 1, 1256, left$(t2$,254)
  set file map dword 1, 500, 1
  wait for file map event 1
  while get file map dword(1, 500)=1
   wait for file map event 1
  endwhile
  rem add to internal list array
  inc locallibraryentindex
  dim locallibraryent(locallibraryentindex)
  locallibraryent(locallibraryentindex)=locallibraryentidmaster
 endif
endwhile

rem Ensure prefab list is up to date in library
while locallibrarypreidmaster<preidmaster
 inc locallibrarypreidmaster
 if prefabbanklocal$(locallibrarypreidmaster)=""
  t2$=getfile(prefabbank$(locallibrarypreidmaster))
 else
  t2$=prefabbanklocal$(locallibrarypreidmaster)
 endif
 ttext$=prefabbank$(locallibrarypreidmaster)
 tbitmap$="files\prefabs\"+ttext$
 t1$=left$(tbitmap$,len(tbitmap$)-4)+".bmp"
 if file exist("..\"+t1$)=0 then t1$="files\editors\host\res\newpre.bmp"
 set file map dword 1, 508, 3
 set file map string$ 1, 1000, left$(t1$,254)
 set file map string$ 1, 1256, left$(t2$,254)
 set file map dword 1, 500, 1
 wait for file map event 1
 while get file map dword(1, 500)=1
  wait for file map event 1
 endwhile
endwhile

rem Restore place after adds
set file map dword 1, 534, 1+tstoredtabindex
wait for file map event 1

return

_editor_filemapdefaultinitfornew:

rem Open for some Defaults for Editor
open file map 1, "FPSEXCHANGE"

rem Marker Defaults
entidmaster=0

rem filllibrary with segments and entities from default prefabs (temp as is above)
gosub _editor_filllibrary

rem Default is prefabs
set file map dword 1, 534, 1
wait for file map event 1

rem Close when set all defaults
close file map 1

return

_editor_filemapinit:

rem Open for some Defaults for Editor
open file map 1, "FPSEXCHANGE"

rem Set default mouse position and visibility
set file map dword 1, 0, 400
set file map dword 1, 4, 300
wait for file map event 1

rem Each selection tab needs a NEW icon
gosub _editor_clearlibrary
gosub _editor_filllibrary

rem Default is prefabs
set file map dword 1, 534, 1
wait for file map event 1

rem Close when set all defaults
close file map 1

return

_editor_loadcfg:

rem Load existing config file
if file exist("editors\gridedit\cfg.cfg")=1
 open to read 1,"editors\gridedit\cfg.cfg"
  `
  rem Current Camera Position
  `if skipfpmloading=1
   read float 1,cx#
   read float 1,cy#
   read float 1,gridzoom#
   read file 1,gridlayer
  `else
  ` read float 1,a#
  ` read float 1,a#
  ` read float 1,a#
  ` read file 1,a
  `endif
  `
  rem Edit Vars
  `if skipfpmloading=1
   read file 1,nogridsmart
   read file 1,grideditartmode
   read file 1,grideditselect
  `else
  ` read file 1,a
  ` read file 1,a
  ` read file 1,a
  `endif
  `
  rem Project (only need project name if skipping FPM=using temp.fpm)
  read string 1,temp$ : if skipfpmloading=1 then projectfilename$=temp$
  read string 1,currentFPG$
  `
  rem Shroud Settings
  `if skipfpmloading=1
   read file 1,a : rem ignore shroudsize
   read file 1,gridlayershowsingle
  `else
  ` read file 1,a
  ` read file 1,a
  `endif
  `
 close file 1
endif

rem If projectname has changed, this config will not match the new level
remstart
FPGC - 110610 - completely disable this auto-positioning of starting position
rem as it comes from CFG.CFG every time (from current level working on or loaded)
if projectfilename$<>currentprojectfilename$ and skipfpmloading=0
 rem first reset config
 gosub _gridedit_clear_configsettings
 rem then find the left-top-lowest most segment to focus on
 for tlayer=0 to layermax
  for ty=0 to maxy
   for tx=0 to maxx
    tmapid=map(tlayer,tx,ty)
    if tmapid<>0
     cx#=tx*100 : cy#=ty*100 : gridlayer=tlayer
     tx=maxx : ty=maxy
     tlayer=layermax
     exit
    endif
   next tx
  next ty
 next tlayer
 shroudrefresh=1 : gosub _gridedit_updatelayershades
endif
remend

rem Update editor settings
gosub _editor_refresheditmarkers
shroudrefresh=1
updatezoom=1

rem Current project name stored for next time
currentprojectfilename$=projectfilename$

return

_editor_savecfg:

rem Delete config file
if file exist("editors\gridedit\cfg.cfg")=1 then delete file "editors\gridedit\cfg.cfg"

rem Save config file
open to write 1,"editors\gridedit\cfg.cfg"
 `
 rem Current Camera Position
 write float 1,cx#
 write float 1,cy#
 write float 1,gridzoom#
 write file 1,gridlayer
 `
 rem Edit Vars
 write file 1,nogridsmart
 write file 1,grideditartmode
 write file 1,grideditselect
 `
 rem Project
 write string 1,projectfilename$
 write string 1,currentFPG$
 `
 rem Shroud Settings
 write file 1,shroudsize
 write file 1,gridlayershowsingle
 `
close file 1

return

_editor_saveselectionasprefab:

rem if segments and selection exists
if segidmaster>0 and bufferlayer<>-1
 `
 rem get filename
 open file map 1, "FPSEXCHANGE"
 set file map string$ 1, 1000, rootdir$+"prefabs\"
 set file map string$ 1, 1256, "FPP (*.fpp)"
 set file map string$ 1, 1512, strarr$(363)
 set file map dword 1, 428, 1
 wait for file map event 1
 while get file map dword(1,428)=1
  wait for file map event 1
 endwhile
 tfile$=get file map string$(1,1000)
 close file map 1
 if tfile$<>""
  `
  pfile$=right$(tfile$,len(tfile$)-len(rootdir$))
  pfile$=left$(pfile$,len(pfile$)-4)
  prefab$=pfile$+".fpmb"
  prefabbmp$=pfile$+".bmp"
  prefabolay$=pfile$+".fpmo"
  prefabsegs$=pfile$+".fpp"
  prefaboverlaylist$=pfile$+".fpol"
  `
  rem delete if exists
  if file exist(prefab$)=1 then delete file prefab$
  if file exist(prefabbmp$)=1 then delete file prefabbmp$
  if file exist(prefabolay$)=1 then delete file prefabolay$
  if file exist(prefabsegs$)=1 then delete file prefabsegs$
  if file exist(prefaboverlaylist$)=1 then delete file prefaboverlaylist$
  `
  rem ensure buffer arrays match buffersizevars
  undim storebuffermap()
  undim storebuffermapolay()
  dim storebuffermap(bufferlayer+1,buffermaxx+1,buffermaxy+1)
  dim storebuffermapolay(bufferlayer+1,buffermaxx+1,buffermaxy+1)
  for layer=0 to bufferlayer
   for my=0 to buffermaxy
    for mx=0 to buffermaxx
     storebuffermap(layer,mx,my)=buffermap(layer,mx,my)
     storebuffermapolay(layer,mx,my)=buffermapolay(layer,mx,my)
    next mx
   next my
  next layer
  rem save array data for this prefab
  save array prefab$,storebuffermap()
  save array prefabolay$,storebuffermapolay()
  save array prefaboverlaylist$,olaylist()
  rem free usages
  undim storebuffermap()
  undim storebuffermapolay()
  `
  rem save out header to describe prefab
  open to write 1,prefabsegs$
   write file 1,bufferlayer
   write file 1,buffermaxx
   write file 1,buffermaxy
   write file 1,segidmaster
   write file 1,olaylistmax
   if segidmaster>0
    for segid=1 to segidmaster
     write string 1,selectionbank$(segid)
    next segid
   endif
  close file 1
  `
  rem do not need any more
  gosub _gridedit_deleteclipboard
  `
  rem prepare screen for screenshot
  color backdrop rgb(255,255,255)
  for obj=1 to 6
   if object exist(obj)=1 then hide object obj
  next obj
  if object exist(realviewobjectoffset)=1 then hide object realviewobjectoffset
  gosub _editor_hideblueprint
  `
  rem mouselook mode on
  open file map 1, "FPSEXCHANGE"
  set file map dword 1, 48, 1
  wait for file map event 1
  close file map 1
  `
  rem show preview
  position camera 0,(gridlayer*100)+200,0
  point camera 150,gridlayer*100,-150
  set camera aspect 1.0
  rem adjust camera to suit good shot
  snapshotloop=1
  while snapshotloop=1
   rem input data
   open file map 1, "FPSEXCHANGE"
   wait for file map event 1
   inputsys.xmousemove=get file map dword( 1, 8 )
   inputsys.ymousemove=get file map dword( 1, 12 )
   set file map dword 1, 8, 0
   set file map dword 1, 12, 0
   inputsys.mclick=get file map dword( 1, 20 )
   inputsys.kscancode=get file map dword( 1, 100 )
   close file map 1
   rem move around
   rotate camera camera angle x()+inputsys.ymousemove/2.0,camera angle y()+inputsys.xmousemove/2.0,0
   if inputsys.kscancode=asc("W") then move camera 4.0
   if inputsys.kscancode=asc("S") then move camera -4.0
   pcx#=camera angle x() : pcz#=camera angle z()
   if inputsys.kscancode=asc("A") then rotate camera 0,camera angle y()-90,0 : move camera 4.0 : yrotate camera camera angle y()+90
   if inputsys.kscancode=asc("D") then rotate camera 0,camera angle y()-90,0 : move camera -4.0 : yrotate camera camera angle y()+90
   rotate camera pcx#,camera angle y(),pcz#
   if inputsys.mclick=1 then snapshotloop=0
   rem update screen
   sync
  endwhile
  tclicking=1
  while tclicking=1
   open file map 1, "FPSEXCHANGE"
   set file map dword 1, 48, 0
   wait for file map event 1
   inputsys.mclick=get file map dword( 1, 20 )
   close file map 1
   if inputsys.mclick=0 then tclicking=0
  endwhile
  if snapshotloop=0
   rem take the shot
   set camera view 0,0,64,64 : sync : sync
   get image editorimagesoffset-1,0,0,64,64
   save image prefabbmp$,editorimagesoffset-1
   delete image editorimagesoffset-1
  endif
  `
  rem restore
  set camera view 0,0,screen width(),screen height()
  set camera aspect 640.0/480.0
  color backdrop rgb(32,32,32)
  gosub _editor_refresheditmarkers
  if object exist(realviewobjectoffset)=1 then show object realviewobjectoffset
  `
 endif
endif

return

_editor_constructionselection:

if inputsys.constructselection>0
 `
 rem SINGLE SEGMENT
 if grideditselect=0
  if inputsys.constructselection<=segidmaster
   gridselection=inputsys.constructselection
   gridsymbol=segmentprofile(gridselection).blueprint.symbol
   gridground=segmentprofile(gridselection).properties.groundmode
   gridkindof=segmentprofile(gridselection).properties.kindof
   nogridsmart=-1 : rem AUTO BY DEFAULT FROM SELECTION
   gosub _editor_refresheditmarkers
  endif
 endif
 `
 rem PRE-FAB SEGMENTS
 if grideditselect=1
  `
  rem Loading and making prefab
  statusbar$=strarr$(364) : gosub _gridedit_updatestatusbar
  `
  rem if prefab in range
  if inputsys.constructselection<=preidmaster
  `
  rem load in local segs list for prefab
  prefab$="prefabs\"+prefabbank$(inputsys.constructselection)
  prefab$=left$(prefab$,len(prefab$)-4)
  prefabsegs$=prefab$+".fpp"
  open to read 1,prefabsegs$
   read file 1,bufferlayer
   read file 1,buffermaxx
   read file 1,buffermaxy
   read file 1,locasegslistmaster
   read file 1,localolaylistmax
   dim localsegslist$(locasegslistmaster)
   if locasegslistmaster>0
    for tsegid=1 to locasegslistmaster
     read string 1,localsegslist$(tsegid)
    next tsegid
   endif
  close file 1
  `
  rem load prefab mapdata
  undim buffermap(0)
  undim bufferrefmap(0)
  undim buffermapolay(0)
  dim buffermap(1+bufferlayer,1+buffermaxx,1+buffermaxy)
  dim bufferrefmap(1+bufferlayer,1+buffermaxx,1+buffermaxy)
  dim buffermapolay(1+bufferlayer,1+buffermaxx,1+buffermaxy)
  gosub _gridedit_deletebuffermesh
  prefabmap$=prefab$+".fpmb"
  load array prefabmap$,buffermap()
  prefabolay$=prefab$+".fpmo"
  load array prefabolay$,buffermapolay()
  dim localolaylist(localolaylistmax,50) as DWORD
  prefaboverlaylist$=prefab$+".fpol"
  load array prefaboverlaylist$,localolaylist()
  `
  rem orient ciipboard for zero rotation to begin with
  bufferrotationcount=0 : gridorient=0
  `
  rem reorder mapdata to layout of current segment list
  segdir$="segments\"
  for tlayer=0 to bufferlayer
   for ty=0 to buffermaxy
    for tx=0 to buffermaxx
     mapid=buffermap(tlayer,tx,ty)
     if mapid<>0
      rem get map tile, determine what segment it used, and find/load into current
      gosub _gridedit_getmapvalues
      rem re-map to new segment index
      seg$=localsegslist$(mapselection)
      segcategory$=getfirstdir(seg$)
      segpath$=getseconddir(seg$)
      gosub _segment_addtoworkspace
      mapselection=segid
      rem put new segment index back
      writebuffermap(tlayer,tx,ty,mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
     endif
    next tx
   next ty
  next tlayer
  `
  rem reorder map overlay data to layout of current segment list
  for tlayer=0 to bufferlayer
   for ty=0 to buffermaxy
    for tx=0 to buffermaxx
     `
     rem get local olayindex, find a real free one and update buffermapolay
     tolayindex=buffermapolay(tlayer,tx,ty)
     if tolayindex>0
      rem find new overlay index
      gosub _gridedit_addolay_findfree
      rem place overlay in buffer map
      buffermapolay(tlayer,tx,ty)=olayindex
     endif
     `
     rem go through local olaylist, adding to new list as we go
     if tolayindex>0
      for ti=0 to 50
       mapid=localolaylist(tolayindex,ti)
       if mapid<>0
        rem get map tile, determine what segment it used, and find/load into current
        gosub _gridedit_getmapvalues
        rem re-map to new segment index
        seg$=localsegslist$(mapselection)
        segcategory$=getfirstdir(seg$)
        segpath$=getseconddir(seg$)
        gosub _segment_addtoworkspace
        mapselection=segid
        rem put new mapid in the new olaylist
        mapid=getmapid(mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
        olaylist(olayindex,ti)=mapid
        rem place any related entities in buffer ref
        storetlayer=tlayer : storetx=tx : storety=ty
        layer=tlayer : mx=tx : my=ty : gridorient=maporient
        seg=mapselection : gridaddtobufferref=1 : gosub _gridedit_addsegmententities
        tlayer=storetlayer : tx=storetx : ty=storety
       endif
      next ti
     endif
     `
    next tx
   next ty
  next tlayer
  `
  rem free usages
  undim localsegslist$()
  undim localolaylist()
  `
  rem flag the entities we used here to hold entity data are removed when done!
  bufferholdscutdata=1
  `
  rem may have added segments/entities so update library
  open file map 1,"FPSEXCHANGE"
  gosub _editor_filllibrary
  close file map 1
  `
  rem build clipboard from buffer data
  gosub _gridedit_createbuffermesh
  shroudrefresh=1
  `
  rem Prefab uses automatic segment connections
  nogridsmart=-2 : rem DIRECT PASTE NO MODIFICATION OF WALLS
  gosub _editor_refresheditmarkers
  `
  rem Clear status text
  statusbar$="" : gosub _gridedit_updatestatusbar
  `
  endif
  `
 endif
 `
 rem SINGLE ENTITY
 if grideditselect=5
  if inputsys.constructselection<=entidmaster
   rem select entity profile and start orientation
   gridentity=inputsys.constructselection
   gridentityeditorfixed=0
   gridentityrotatex#=entityprofile(gridentity).rotx
   gridentityrotatey#=entityprofile(gridentity).roty
   gridentityrotatez#=entityprofile(gridentity).rotz
   gridentityposy#=(gridlayer*100.0)+2.5
   inc gridentityposy#,entityprofile(gridentity).defaultheight
   inc gridentityposx#,entityprofile(gridentity).offx
   inc gridentityposy#,entityprofile(gridentity).offy
   inc gridentityposz#,entityprofile(gridentity).offz
   gridentitystaticmode=entityprofile(gridentity).defaultstatic
   if entityprofile(gridentity).ismarker=2 then gridentityrotatex#=180
   rem fill new selection with defaults
   sentid=entid : entid=gridentity : gosub _entity_fillgrideleproffromprofile : entid=sentid
   grideleproflastname$=grideleprof.name$
  endif
 endif
 `
 rem Construction complete
 inputsys.constructselection=0
 `
endif

rem AUTO/FLAT/DIRECT DRAW MODE
if inputsys.dogroundmode<>-1
 `
 rem new system uses AUTO, WALL amd FLOOR modes (internal and external)
 if inputsys.dogroundmode=0
  nogridsmart=-1 : rem AUTO
  gridground=0 : rem INTERNAL
 endif
 if inputsys.dogroundmode=2
  nogridsmart=-1 : rem AUTO
  gridground=2 : rem EXTERNAL
 endif
 if inputsys.dogroundmode=1
  nogridsmart=1 : rem FLOOR
 endif
 if inputsys.dogroundmode=3
  nogridsmart=0 : rem WALL
 endif
 `
 rem update cursor
 gosub _editor_refresheditmarkers
 `
endif

return

_editor_overallfunctionality:

rem show state of edit mode by work grid colour
if object exist(1)=1
 if gmultiplayergame=0
  texture object 1,editorimagesoffset+6
 else
  texture object 1,editorimagesoffset+2
 endif
endif

rem Restore current grid view
if inputsys.doautozoomview=1 then inputsys.doautozoomview=0 : inputsys.dozoomview=1
if inputsys.domapview=1 or inputsys.dozoomview=1
 if cameraviewmode=1
  cx#=stcx# : cy#=stcy# : gridzoom#=stgridzoom#
  grideditselect=stgrideditselect : gosub _editor_refresheditmarkers
  inputsys.domapview=0
  cameraviewmode=0
  updatezoom=1
 endif
 if cameraviewmode=2
  rem mouselook mode off
  open file map 1, "FPSEXCHANGE"
  set file map dword 1, 48, 0
  wait for file map event 1
  close file map 1
  rem re-enable icons
  gosub _editor_enableafterzoom
  rem end zoom mode
  grideditselect=stgrideditselect : gosub _editor_refresheditmarkers
  inputsys.dozoomview=0
  cameraviewmode=0
 endif
endif

rem Switch to map view
if inputsys.domapview=1
 if cameraviewmode=0
  `
  rem Store current grid view
  stcx#=cx# : stcy#=cy# : stgridzoom#=gridzoom#
  stgrideditselect=grideditselect
  `
  rem Set camera view for entire map
  borderx#=(maxx*100.0) : cx#=borderx#/2.0
  bordery#=(maxy*100.0) : cy#=bordery#/2.0
  tsize=maxx : if tsize<maxy then tsize=maxy
  gridzoom#=tsize/10.0
  cameraviewmode=1
  updatezoom=1
  `
  rem Mode - Map View
  grideditselect=3 : gosub _editor_refresheditmarkers
  `
 endif
endif

rem Switch to zoom view
if inputsys.dozoomview=1
 if cameraviewmode=0
  `
  rem Set camera to track with close-up
  stgrideditselect=grideditselect
  cameraviewmode=2
  `
  rem reset some variables
  zoomviewcameraangle#=0
  zoomviewcameraheight#=75.0
  `
  rem Fix shroud position for realview
  shroudmmx=cx#/100.0 : shroudmmy=cy#/100.0
  `
  rem Mode - ZoomIn View
  grideditselect=4 : gosub _editor_refresheditmarkers
  updatezoom=1
  `
 endif
endif

rem Recalculate zoom scale for editing
if updatezoom=1
 `
 rem grid scale for camera cursor location and zoom
 gridscale#=((800/2)/8)/gridzoom#
 inputsys.keypress=1
 updatezoom=0
 `
 rem single layer edit clips the camera near plane
 if gridlayershowsingle=2 and grideditselect<>4
  gridnearcameraclip=(600.0*gridzoom#)-50
 else
  gridnearcameraclip=0
 endif
 `
 rem adjust clipping range of camera to match
 set camera range 1+gridnearcameraclip,((600.0*gridzoom#)+1000)
 `
endif

rem use intersect test to find ground/wall and drop entity onto it
if gridentitydroptoground>=1 and gridentitydroptoground<=2
 gosub _editor_findentityground
 gridentitydroptoground=0
endif

rem Change editing layer
if inputsys.dolayerchange<>-1
 tokay=1
 if inputsys.dolayerchange<0 or inputsys.dolayerchange>layermax-1 then tokay=0
 if gridentity>0 and tokay=1
  gridentityposy#=gridentityposy#+((inputsys.dolayerchange-gridlayer)*100.0)
 endif
 gridlayer=inputsys.dolayerchange
 if gridlayer<0 then gridlayer=0
 if gridlayer>layermax-1 then gridlayer=layermax-1
 shroudrefresh=1 : gosub _gridedit_updatelayershades
endif

rem Change layer show mode
if inputsys.dosinglelayer=1
 gridlayershowsingle=gridlayershowsingle+1
 if gridlayershowsingle>2 then gridlayershowsingle=0
 shroudrefresh=1 : gosub _gridedit_updatelayershades
 updatezoom=1
endif

rem If editing trigger marker, shift allows selection of area
if grideditselect=5
 if gridentity>0
  if entityprofile(gridentity).ismarker=3
   if inputsys.keyshift=1
    gridentitytriggerareaselect=1
   endif
  endif
 endif
endif

return

_editor_gridfunctionality:

rem Rotation of segment or buffer
if grideditselect=0
 if inputsys.dorotation=1
  inc gridorient
  if gridorient>3
   gridorient=0
  endif
  inputsys.keypress=1
  yrotate object 2,wrapvalue(gridorient*90)
 endif
endif
if grideditselect=1
 if inputsys.dorotation=1 or inputsys.domirror=1 or inputsys.doflip=1
  gosub _gridedit_deletebuffermesh
  if inputsys.dorotation=1 then gosub _gridedit_rotatebuffermap
  gosub _gridedit_createbuffermesh
  shroudrefresh=1
 endif
endif

rem Rotation of entity
if grideditselect=5
 rem do not rotate light or trigger entity
 if entityprofile(gridentity).ismarker<>2 and entityprofile(gridentity).ismarker<>3
  if inputsys.keyshift=1
   tspeedofrot#=1.0 : inputsys.keypress=0
  else
   if inputsys.keycontrol=1
    tspeedofrot#=10.0
   else
    tspeedofrot#=45.0
   endif
  endif
  if inputsys.dorotation=1 then inc gridentityrotatey#,tspeedofrot#
  if inputsys.doentityrotate=1 then dec gridentityrotatex#,tspeedofrot#
  if inputsys.doentityrotate=2 then inc gridentityrotatex#,tspeedofrot#
  if inputsys.doentityrotate=3 then dec gridentityrotatey#,tspeedofrot#
  if inputsys.doentityrotate=4 then inc gridentityrotatey#,tspeedofrot#
  if inputsys.doentityrotate=5 then dec gridentityrotatez#,tspeedofrot#
  if inputsys.doentityrotate=6 then inc gridentityrotatez#,tspeedofrot#
  gridentityrotatex#=wrapvalue(gridentityrotatex#)
  gridentityrotatey#=wrapvalue(gridentityrotatey#)
  gridentityrotatez#=wrapvalue(gridentityrotatez#)
 endif
endif

rem Load and Save
if inputsys.doload=1 then gosub _gridedit_load_map
if inputsys.dosave=1
 if galwaysconfirmsave=1
  gosub _gridedit_saveas_map
 else
  gosub _gridedit_save_map_ask
 endif
endif
if inputsys.doopen=1 then gosub _gridedit_open_map_ask
if inputsys.donew=1 or inputsys.donewarena=1 then gosub _gridedit_new_map_ask
if inputsys.dosaveas=1 then gosub _gridedit_saveas_map
if inputsys.dosaveandrun=1 then inputsys.dosaveandrun=0 : gosub _editor_previewmap

rem Undo \ Redo
if inputsys.doundo=1 then gosub _editor_undoredobackwards
if inputsys.doredo=1 then gosub _editor_undoredoforwards

rem Paint Select or Art Mode
if inputsys.domodepaint=1 then grideditselect=0 : gosub _editor_refresheditmarkers
if inputsys.domodeselect=1 then grideditselect=1 : gosub _editor_refresheditmarkers
if inputsys.tselsaveselection=1 then inputsys.tselsaveselection=0 : gosub _editor_saveselectionasprefab
if inputsys.domodeart>0 then grideditselect=2 : grideditartmode=inputsys.domodeart : inputsys.domodeart=0 : gosub _editor_refresheditmarkers
if inputsys.domodeentity=1 then grideditselect=5 : gosub _editor_refresheditmarkers
if inputsys.domodewaypoint=1 then grideditselect=6 : gosub _editor_refresheditmarkers
if inputsys.doartresize>0
 if inputsys.doartresize=1 and grideditartwidth>1 then dec grideditartwidth : inputsys.domodeart=0
 if inputsys.doartresize=2 and grideditartwidth<6 then inc grideditartwidth : inputsys.domodeart=0
 if grideditartwidth=1 then grideditartwidthx=1 : grideditartwidthy=1
 if grideditartwidth=2 then grideditartwidthx=2 : grideditartwidthy=1
 if grideditartwidth=3 then grideditartwidthx=1 : grideditartwidthy=2
 if grideditartwidth=4 then grideditartwidthx=2 : grideditartwidthy=2
 if grideditartwidth=5 then grideditartwidthx=3 : grideditartwidthy=3
 if grideditartwidth=6 then grideditartwidthx=4 : grideditartwidthy=4
endif

rem Manage waypoints on map
if grideditselect=6
 mx#=inputsys.localx# : mz#=inputsys.localy# : mclick=inputsys.mclick
 waypointeditheight#=(gridlayer*100.0)+5
 gosub _waypoint_mousemanage
endif

rem Zoom factor
if inputsys.dozoomin=1 and gridzoom#>0.3 and inputsys.keypress=0 then updatezoom=1 : dec gridzoom#,0.1
if inputsys.dozoomout=1 and gridzoom#<5.0 and inputsys.keypress=0 then updatezoom=1 : inc gridzoom#,0.1

rem Shroud Resize
if inputsys.doshroudfull=1 then shroudsize=10 : inputsys.doshroudfull=0 : editmarkerfade#=1.0 : shroudrefresh=1
if inputsys.doshroudfull=2 then shroudsize=5 : inputsys.doshroudfull=0 : editmarkerfade#=1.0 : shroudrefresh=1
if inputsys.doshroudincrease=1 and shroudsize<10 then inc shroudsize : inputsys.doshroudincrease=0 : shroudrefresh=1
if inputsys.doshrouddecrease=1 and shroudsize>2 then dec shroudsize : inputsys.doshrouddecrease=0 : shroudrefresh=1

rem Scroll Map
borderx#=(maxx*100.0)
bordery#=(maxy*100.0)
if inputsys.doscrollleft<>0
 if inputsys.doscrollleft=1 then dec cx#,gridzoom#*20
 if inputsys.doscrollleft=10 then dec cx#,gridzoom#*200
 if inputsys.doscrollleft=100 then cx#=0
endif
if inputsys.doscrollright<>0
 if inputsys.doscrollright=1 then inc cx#,gridzoom#*20
 if inputsys.doscrollright=10 then inc cx#,gridzoom#*200
 if inputsys.doscrollright=100 then cx#=borderx#
endif
if inputsys.doscrollup<>0
 if inputsys.doscrollup=1 then dec cy#,gridzoom#*20
 if inputsys.doscrollup=10 then dec cy#,gridzoom#*200
 if inputsys.doscrollup=100 then cy#=0
endif
if inputsys.doscrolldown<>0
 if inputsys.doscrolldown=1 then inc cy#,gridzoom#*20
 if inputsys.doscrolldown=10 then inc cy#,gridzoom#*200
 if inputsys.doscrolldown=100 then cy#=bordery#
endif

rem Scroll boundaries
if cx#<0 then cx#=0
if cy#<0 then cy#=0
if cx#>borderx# then cx#=borderx#
if cy#>bordery# then cy#=bordery#

return

_editor_viewfunctionality:

rem map view controls
if grideditselect=3
 if inputsys.mclick=1
  stcx#=inputsys.mmx*100.0
  stcy#=inputsys.mmy*100.0
  cx#=stcx# : cy#=stcy# : gridzoom#=stgridzoom#
  grideditselect=stgrideditselect : gosub _editor_refresheditmarkers
  while inputsys.mclick=1 : gosub _input_getcontrols : sync : endwhile
  cameraviewmode=0
  updatezoom=1
 endif
endif

rem zoom view controls
if grideditselect=4
 `
 rem can repos and rotate non-editor-entities
 if entityelement(gridentityinzoomview).editorfixed=0
  `
  rem position adjustment
  tposadjspeed#=1.0
  if inputsys.keycontrol=1 then tposadjspeed#=0.05
  if inputsys.dozoomviewmovex=1 then dec zoomviewtargetx#,tposadjspeed#
  if inputsys.dozoomviewmovex=2 then inc zoomviewtargetx#,tposadjspeed#
  if inputsys.dozoomviewmovey=1 then dec zoomviewtargety#,tposadjspeed#
  if inputsys.dozoomviewmovey=2 then inc zoomviewtargety#,tposadjspeed#
  if inputsys.dozoomviewmovez=1 then dec zoomviewtargetz#,tposadjspeed#
  if inputsys.dozoomviewmovez=2 then inc zoomviewtargetz#,tposadjspeed#
  `
  rem rotation adjustment
  if entityprofile(gridentity).ismarker<>2 and entityprofile(gridentity).ismarker<>3
   if inputsys.keyshift=1
    tspeedofrot#=1.0 : inputsys.keypress=0
   else
    if inputsys.keycontrol=1
     tspeedofrot#=10.0
    else
     tspeedofrot#=45.0
    endif
   endif
   if inputsys.dorotation=1 then inc zoomviewtargetry#,tspeedofrot#
   if inputsys.dozoomviewrotatex=1 then dec zoomviewtargetrx#,tspeedofrot#
   if inputsys.dozoomviewrotatex=2 then inc zoomviewtargetrx#,tspeedofrot#
   if inputsys.dozoomviewrotatey=1 then dec zoomviewtargetry#,tspeedofrot#
   if inputsys.dozoomviewrotatey=2 then inc zoomviewtargetry#,tspeedofrot#
   if inputsys.dozoomviewrotatez=1 then dec zoomviewtargetrz#,tspeedofrot#
   if inputsys.dozoomviewrotatez=2 then inc zoomviewtargetrz#,tspeedofrot#
  endif
  `
  rem update gridentity vars for visual
  gridentityposx#=zoomviewtargetx#
  gridentityposy#=zoomviewtargety#
  gridentityposz#=zoomviewtargetz#
  gridentityrotatex#=zoomviewtargetrx#
  gridentityrotatey#=zoomviewtargetry#
  gridentityrotatez#=zoomviewtargetrz#
  `
  rem aply grid if 5x5
  if gridentitygridlock=1
   gridentityposx#=(int(gridentityposx#/5)*5)
   gridentityposz#=(int(gridentityposz#/5)*5)
  endif
  `
 endif
 `
 rem mouselook mode on/off RMB
 open file map 1, "FPSEXCHANGE"
 if inputsys.mclick=2
  rem center mouse
  set file map dword 1, 48, 1
  rem camera position
  rem V110 BETA4 - 070608 - double response
  `inc zoomviewcameraangle#,inputsys.xmousemove/4.0
  `dec zoomviewcameraheight#,inputsys.ymousemove/3.0
  inc zoomviewcameraangle#,inputsys.xmousemove/2.0
  dec zoomviewcameraheight#,inputsys.ymousemove/1.5
 else
  set file map dword 1, 48, 0
 endif
 wait for file map event 1
 close file map 1
 `
 rem exit zoom view
 if inputsys.mclick=1 then tpressedtoleavezoommode=1
 if inputsys.mclick=0 and tpressedtoleavezoommode=1 then tpressedtoleavezoommode=2
 if (tpressedtoleavezoommode=2 or inputsys.kscancode=211) or editorinterfaceleave=1
  `
  rem leave zoomview
  inputsys.doautozoomview=1
  `
  rem reset mouse click (must release LMB before zoom mode ends)
  tpressedtoleavezoommode=0
  `
  rem close any property window
  gosub _interface_closepropertywindow
  editorinterfaceleave=0
  `
  rem place entity on the map
  if gridentityinzoomview>0
   `
   rem DELETE key deletes entity no matter what (for fixed entities too)
   if gridentity<>0 and inputsys.kscancode=211
    if gridentityobj=0
     delete object gridentityobj
     gridentityobj=0
    endif
   else
    gosub _gridedit_addentitytomap
    gridentityinzoomview=0
   endif
   shroudrefresh=1
   gridentity=0
   `
  endif
  `
 endif
 `
endif

return

_editor_findentityground:
 `
 rem for entities that can be moved
 if entityelement(gridentityinzoomview).editorfixed=0
  `
  rem finds ground
  if gridentitydroptoground=1
   tbestdist#=99999 : tbesty#=0
   tto#=gridentityposy#-200.0
   if inputsys.keyshift=0
    tfrom#=gridentityposy#+200.0
   else
    tfrom#=gridentityposy#+1.0
   endif
   for obj=realviewobjectoffset+1 to realviewobjectoffsetend
    if obj<>gridentityobj
     if object exist(obj)=1
      if intersect object(obj,gridentityposx#,tfrom#,gridentityposz#,gridentityposx#,tto#,gridentityposz#)<>0
       tdist#=abs(checklist fvalue b(6)-tfrom#)
       if tdist#<tbestdist#
        tbesty#=checklist fvalue b(6)
        tbestdist#=tdist#
       endif
      endif
     endif
    endif
   next obj
   if tbestdist#<99999
    rem found point where our entity will rest vertically, now need entities own thickness from object 0,0,0 to base
    rem grid of ray casts for good base detect resolution
    ttentsizex#=object size x(gridentityobj)/2.0
    ttentsizez#=object size z(gridentityobj)/2.0
    if ttentsizex#<1.0 and ttentsizex#<ttentsizez# then ttentsizex#=ttentsizez#
    if ttentsizez#<1.0 and ttentsizez#<ttentsizex# then ttentsizez#=ttentsizex#
    stepvaluex#=object size x(gridentityobj)/10.0
    stepvaluez#=object size z(gridentityobj)/10.0
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
    make object box entityworkobjectoffset,object size x(gridentityobj),object size y(gridentityobj),object size z(gridentityobj)
    position object entityworkobjectoffset,object position x(gridentityobj)+object collision center z(gridentityobj),object position y(gridentityobj)+object collision center y(gridentityobj),object position z(gridentityobj)+object collision center z(gridentityobj)
    rotate object entityworkobjectoffset,object angle x(gridentityobj),object angle y(gridentityobj),object angle z(gridentityobj)
    hide object entityworkobjectoffset
    tsmallest#=99999
    tscbase#=object position y(entityworkobjectoffset)-(object size y(entityworkobjectoffset)*2)
    for tentscanx#=ttentsizex#*-1 to ttentsizex# step stepvaluex#
     for tentscanz#=ttentsizez#*-1 to ttentsizez# step stepvaluez#
      tgap#=intersect object(entityworkobjectoffset,gridentityposx#+tentscanx#,tscbase#,gridentityposz#+tentscanz#,gridentityposx#+tentscanx#,tscbase#+200.0,gridentityposz#+tentscanz#)
      if tgap#<>0.0
       if tgap#<tsmallest# then tsmallest#=tgap#
      endif
     next tentscanz#
    next tentscanx#
    if tsmallest#<99999
     tthickness#=object position y(gridentityobj)-(tscbase#+tsmallest#)
    else
     tthickness#=0
    endif
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
    gridentityposy#=tbesty#+tthickness# : zoomviewtargety#=tbesty#+tthickness#
    `
    rem FPSCV104RC7 - step up to next layer if crosses threshold
    if gridentityposy# > (gridlayer*100)+100
     inputsys.dolayerchange=gridlayer+1
    endif
    `
   endif
  endif
  `
  rem finds wall
  if gridentitydroptoground=2
   tbestdist#=99999 : tbestx#=0 : tbestz#=0
   tbesty#=gridentityposy#+object collision center y(gridentityobj)
   a=gridentityrotatey#
   tfromx=newxvalue(gridentityposx#,a,-5.0) : ttox=newxvalue(gridentityposx#,a,75.0)
   tfromz=newzvalue(gridentityposz#,a,-5.0) : ttoz=newzvalue(gridentityposz#,a,75.0)
   for obj=realviewobjectoffset+1 to realviewobjectoffsetend
    if obj<>gridentityobj
     if object exist(obj)=1
      tdist#=intersect object(obj,tfromx,tbesty#,tfromz,ttox,tbesty#,ttoz)
      if tdist#<>0
       if tdist#<tbestdist#
        tbestx#=checklist fvalue a(6)
        tbestz#=checklist fvalue c(6)
        tbestdist#=tdist#
       endif
      endif
     endif
    endif
   next obj
   if tbestdist#<99999
    rem found point where our entity will rest on wall
    rem now need entities own thickness from object 0,0,0 to wall-contact
    tbestx#=newxvalue(tbestx#,a+180,-5.0)
    tbestz#=newzvalue(tbestz#,a+180,-5.0)
    ttox=newxvalue(tbestx#,a+180,100.0)
    ttoz=newzvalue(tbestz#,a+180,100.0)
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
    make object box entityworkobjectoffset,object size x(gridentityobj),object size y(gridentityobj),object size z(gridentityobj)
    position object entityworkobjectoffset,object position x(gridentityobj)+object collision center z(gridentityobj),object position y(gridentityobj)+object collision center y(gridentityobj),object position z(gridentityobj)+object collision center z(gridentityobj)
    rotate object entityworkobjectoffset,object angle x(gridentityobj),object angle y(gridentityobj),object angle z(gridentityobj)
    hide object entityworkobjectoffset
    tgap#=intersect object(entityworkobjectoffset,tbestx#,tbesty#,tbestz#,ttox,tbesty#,ttoz)
    if tgap#>=4.9
     tgapx#=checklist fvalue a(6)
     tgapz#=checklist fvalue c(6)
     ttddx#=tgapx#-object position x(gridentityobj)
     ttddz#=tgapz#-object position z(gridentityobj)
     tthickness#=5.0+sqrt(abs(ttddx#*ttddx#)+abs(ttddz#*ttddz#))
    else
     tthickness#=5.0
    endif
    tbestx#=newxvalue(tbestx#,a+180,tthickness#+0.5)
    tbestz#=newzvalue(tbestz#,a+180,tthickness#+0.5)
    gridentityposx#=tbestx# : zoomviewtargetx#=tbestx#
    gridentityposz#=tbestz# : zoomviewtargetz#=tbestz#
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
   endif
  endif
  `
 endif
 `
return

_editor_hideblueprint:

rem Completely hide blueprint objects
for o=firstmeshobject to currentmeshobject
 if object exist(o)=1
  hide object o
 endif
next o

return

_editor_refresheditmarkers:

rem Edit Modes use different edit visual markers
if grideditselect=0
 if object exist(1)=1 then show object 1
 hide object 3 : hide object 4 : show object 2
 rem change cursor image based on segment edit mode (base/overlay/directional/whole)
 if inputsys.dopickmapid=1
  timg=editorimagesoffset+19
 else
  if gridkindof>0 and gridkindof<11
   rem X9 - 120208 - new kindof type (forced SOLID portal for FAKE segments)
   timg=editorimagesoffset+20+(gridkindof-1)
  else
   if segmentprofile(gridselection).vis.overlay=0
    if nogridsmart<>0
     if nogridsmart=1
      timg=editorimagesoffset+25
     else
      timg=editorimagesoffset+14
     endif
    else
     timg=editorimagesoffset+15
    endif
   else
    if segmentprofile(gridselection).vis.overlay=1
     timg=editorimagesoffset+17
    else
     timg=editorimagesoffset+16
    endif
   endif
  endif
 endif
 texture object 2,timg
 yrotate object 2,wrapvalue(gridorient*90)
endif
if grideditselect=1
 if object exist(1)=1 then show object 1
 hide object 2
 if showselectboundbox=0
  hide object 3 : hide object 4
 endif
endif
if grideditselect=2 then hide object 2 : hide object 3 : hide object 4
if grideditselect=3 then hide object 2 : hide object 3 : hide object 4
if grideditselect=4 then hide object 2 : hide object 3 : hide object 4
if grideditselect=5 then hide object 2 : hide object 3 : hide object 4
if grideditselect=6 then hide object 2 : hide object 3 : hide object 4
if grideditselect=4
 if object exist(1)=1 then hide object 1
else
 if object exist(1)=1 then show object 1
endif

rem Deactivate floating selection of entity
if grideditselect<>5 and grideditselect<>4
 if grideditselect<>5 then hide object 5
 gridentity=0
endif

rem Art Markers for art only
for obj=editormarkeroffset to editormarkeroffsetmax
 if grideditselect=2
  if editormarkeroffsethidefrom>0 and obj<editormarkeroffsethidefrom
   show object obj
  endif
 else
  hide object obj
 endif
next o

rem Hide blueprint objects in zoom mode (and blanking shroud)
if object exist(realviewobjectoffset)=1
 if grideditselect=4 then hide object realviewobjectoffset else show object realviewobjectoffset
endif
if grideditselect=4
 for o=firstmeshobject to currentmeshobject
  if object exist(o)=1 then hide object o
 next o
else
 gosub _gridedit_updatelayershades
endif

rem Activate/Deactivate shroud in some modes
if grideditselect=0 then shroudstatic=0
if grideditselect=1 then shroudstatic=0
if grideditselect=2 then shroudstatic=0
if grideditselect=3 then shroudstatic=2
if grideditselect=4 then shroudstatic=1
if grideditselect=5 then shroudstatic=0
if grideditselect=6 then shroudstatic=0
shroudrefresh=1

rem Update clipboard items based on mode
gosub _editor_cutcopyclearstate

rem Waypoint visibility
if grideditselect<>lastgrideditselect
 lastgrideditselect=grideditselect
 if grideditselect=6
  gosub _waypoint_showall
 else
  if inputsys.dowaypointview=0
   gosub _waypoint_showall
  else
   gosub _waypoint_hideall
  endif
 endif
endif

return

_editor_fadeeditmarkers:

rem Used for fading in and out all cursor objects (when mouse leaves/enters edit area)
if editmarkerfade#<0.0
 o=2 : if object exist(o)=1 then hide object o
 o=5 : if object exist(o)=1 then hide object o
 gosub _gridedit_deleterealviewoldshroud
 editmarkerfade#=0
endif
if editmarkerfade#>0.0 and editmarkerfade#<100.0
 editmarkerfade#=editmarkerfade#+10.0
 if editmarkerfade#>=100.0
  gosub _editor_refresheditmarkers
  editmarkerfade#=100.0
 endif
 if object exist(realviewobjectoffset)=1
  set alpha mapping on realviewobjectoffset,editmarkerfade#
 endif
endif

return

_editor_visuals:

rem 3D Clipboard objects
gosub _gridedit_updatebufferobjects

rem Real View Shroud
if shroudsize<10
 rem FPGC - 250809 - only if shroud circle, full shroud does not need to refresh realview (saves performance)
 if oldtx<>inputsys.mmx or oldty<>inputsys.mmy then oldtx=inputsys.mmx : oldty=inputsys.mmy : shroudrefresh=1
else
 rem FPGC - 270809 - instead, use scroll position to trigger refresh
 if cx#<>oldcx# or cy#<>oldcy# then oldcx#=cx# : oldcy#=cy# : shroudrefresh=1
endif
if shroudsize<>oldshroudsize or shroudrefresh=1
 gosub _gridedit_deleterealviewoldshroud
 gosub _gridedit_recreaterealviewshroud
 oldshroudsize=shroudsize
 shroudrefresh=0
endif

rem Real View Shroud - alpha and visibilities
gosub _gridedit_displayrealviewshroud

rem Work Grid
if object exist(1)=0
 make object box 1,100,10,100
 set object collision off 1
 scale object 1,maxx*100,100,maxy*100
 position object 1,maxx*50,-5,maxy*-50
 scale object texture 1,maxx,maxy
 texture object 1,editorimagesoffset+6
 ghost object on 1
endif

rem Work Cursor
if object exist(1)=1
 position object 1,maxx*50,-5+layerheight#,maxy*-50
 if grideditselect=0
  if inputsys.activemouse=0 then hide object 2 else show object 2
 endif
 if map(gridlayer,tx,ty)=0
  position object 2,(tx*100)+50,2+layerheight#,(ty*-100)-50
  scale object 2,100,2,100
 else
  if gridlayershowsingle=2
   position object 2,(tx*100)+50,5+layerheight#,(ty*-100)-50
   scale object 2,100,5,100
  else
   position object 2,(tx*100)+50,50+layerheight#,(ty*-100)-50
   scale object 2,100,100,100
  endif
 endif
endif

rem Update Camera
gosub _editor_camera

rem FPGC - 030909 - update resource bar indicating memory used
if fpgcgenre<>1
 inc editorresourcecounterpacer
 if editorresourcecounterpacer>50
  editorresourcecounterpacer=0
  gamememactuallyused=0
  for e=1 to entityelementmax
   entid=entityelement(e).bankindex
   if entid>0
    name$=entitybank$(entid)
    if name$<>"" then gamememactuallyused=gamememactuallyused+openresource(name$)
   endif
  next e
 endif
 gamememactuallyusedrt=curvevalue(gamememactuallyused,gamememactuallyusedrt,10)
 scale object 7,2,gamememactuallyusedrt/1500,2
 if gamememactuallyused>102400*8
  rem MB exceeds min spec suggestion
  texture object 7,editordrawlastimagesoffset+2
 else
  rem under MB per level is a decent size
  texture object 7,editordrawlastimagesoffset+1
 endif
endif
remstart
if 0
 set cursor 70,70 : print "MEMORYUSED=";gamememactuallyused
 set cursor 70,90 : print "ENTITYELEMENTMAX=";entityelementmax
 set cursor 70,110 : print "COUNT=";array count(gamememtable())
 for n=0 to array count(gamememtable())
  set cursor 70,130+(n*15) : print str$(n)+":"+gamememtable(n).name$+" = "+str$(gamememtable(n).memused)
 next n
endif
remend

return

_editor_camera:

rem Camera Mode
select cameraviewmode
 case 0 : rem Standard grid view
  position camera cx#,(600.0*gridzoom#)+layerheight#,0-cy#
  point camera cx#,0,0-cy#
 endcase
 case 1 : rem Overall map view
  position camera cx#,(600.0*gridzoom#)+layerheight#,0-cy#
  point camera cx#,0,0-cy#
 endcase
 case 2 : rem Tracking zoom view
  `
  rem update camera XZ with entity if editing position
  if gridentityinzoomview>0
   cx#=zoomviewtargetx# : cy#=0-zoomviewtargetz#
  endif
  `
  rem calculate view from position
  daa#=wrapvalue(zoomviewcameraangle#)
  dcx#=cx#+(sin(daa#)*zoomviewcamerarange#)
  dcy#=layerheight#+zoomviewcameraheight#
  dcz#=(0-(cy#+(cos(daa#)*zoomviewcamerarange#)))
  tcx#=curvevalue(dcx#,camera position x(),30.0)
  tcy#=curvevalue(dcy#,camera position y(),5.0)
  tcz#=curvevalue(dcz#,camera position z(),30.0)
  `
  rem if target was entity, view center of it
  if gridentityinzoomview>0
   tobj=entityelement(gridentityinzoomview).profileobj
   if tobj>0
    viewatx#=cx# : viewaty#=zoomviewtargety#+object size y(tobj)/2.0 : viewatz#=0-cy#
   else
    viewatx#=cx# : viewaty#=zoomviewtargety#+5 : viewatz#=0-cy#
   endif
  else
   viewatx#=cx# : viewaty#=zoomviewtargety#+5 : viewatz#=0-cy#
  endif
  `
  rem set smoothed camera view
  position camera tcx#,tcy#,tcz#
  point camera viewatx#,viewaty#,viewatz#
  `
 endcase
endselect

return

_editor_undoredoprojectstate:

rem set as modified
projectmodified=1 : gosub _gridedit_changemodifiedflag

rem FPGC - 100710 - in art mode, this would be called hundreds of times (and it contains an interface 'wait')!
if deferundoredoprojectstatetoend=0
 `
 rem control enabling of UNDO REDO menu items
 open file map 1, "FPSEXCHANGE"
 if currentundoredomarker>0
  set file map dword 1, 466, 1
 else
  set file map dword 1, 466, 0
 endif
 if currentundoredomarker<array count(undoredolist())
  set file map dword 1, 470, 1
 else
  set file map dword 1, 470, 0
 endif
 wait for file map event 1
 close file map 1
 `
endif

return

_editor_cutcopyclearstate:

rem control enabling of UNDO REDO menu items
open file map 1, "FPSEXCHANGE"
if grideditselect=1
 if bufferlayer=-1 and showselectboundbox=1
  set file map dword 1, 474, 1
  set file map dword 1, 478, 1
 else
  set file map dword 1, 474, 0
  set file map dword 1, 478, 0
 endif
 if bufferlayer<>-1
  set file map dword 1, 482, 1
 else
  set file map dword 1, 482, 0
 endif
else
 set file map dword 1, 474, 0
 set file map dword 1, 478, 0
 set file map dword 1, 482, 0
endif
wait for file map event 1
close file map 1

return

_editor_undoredoadd:

rem When we add, we destroy all after the currentundoredomarker
tarraycount=array count(undoredolist())
if currentundoredomarker+1<tarraycount
 for e=currentundoredomarker+1 to tarraycount
  array delete element undoredolist(),currentundoredomarker+1
 next e
endif

rem Add undoredo item to list
array insert at bottom undoredolist()
array index to bottom undoredolist()

rem Fill item with event data
undoredolist().event=gridevent
select gridevent
 case 1 : rem add grid tile
  undoredolist().x=tx
  undoredolist().y=tlayer
  undoredolist().z=ty
  undoredolist().a=wasmapid
  undoredolist().b=tmapid
 endcase
endselect

rem Mark new current list index
currentundoredomarker=array count(undoredolist())

rem If this is called, means we have changed something
gosub _editor_undoredoprojectstate

return

_editor_undoredobackwards:

rem Only if not already at start of the list
if currentundoredomarker>0

 rem Go back through events and reverse
 array index to bottom undoredolist()
 arrayindex=array count(undoredolist())
 while array index valid(undoredolist())
  if arrayindex<currentundoredomarker
   select undoredolist().event
    case 0
     exit
    endcase
    case 1
     `
     rem Undo tile edit
     mx=undoredolist().x : layer=undoredolist().y : my=undoredolist().z
     wasmapid=map(layer,mx,my) : map(layer,mx,my)=undoredolist().a
     gosub _gridedit_refreshtile
     `
     rem Update tile area
     upx=mx : upy=my : uplayer=layer : gosub _gridedit_updatetile
     `
    endcase
   endselect
  endif
  previous array index undoredolist()
  dec arrayindex
 endwhile

 rem Store undoredo list index
 currentundoredomarker=arrayindex
 shroudrefresh=1
 `
 rem If this is called, means we have changed something
 gosub _editor_undoredoprojectstate
 `
endif

return

_editor_undoredoforwards:

rem Only if not already at the end of list
if currentundoredomarker<array count(undoredolist())

 rem Go forward through events and reverse
 for e=currentundoredomarker+1 to array count(undoredolist())
  select undoredolist(e).event
   case 0
    exit
   endcase
   case 1
    `
    rem Redo tile edit
    mx=undoredolist(e).x : layer=undoredolist(e).y : my=undoredolist(e).z
    wasmapid=map(layer,mx,my) : map(layer,mx,my)=undoredolist(e).b
    gosub _gridedit_refreshtile
    `
    rem Update tile area
    upx=mx : upy=my : uplayer=layer : gosub _gridedit_updatetile
    `
   endcase
  endselect
 next e
 `
 rem Store undoredo list index
 currentundoredomarker=e
 shroudrefresh=1
 `
 rem If this is called, means we have changed something
 gosub _editor_undoredoprojectstate
 `
endif

return

_gridedit_addsegmententities:

rem add any entities belonging to this placed segment
for tp=0 to segmentprofileheader(seg).partmax
  if segmentprofile(seg,tp).partmode=3
    `
    rem get entity details
    addentityfile$=segmentprofile(seg,tp).meshname$
    lgx#=segmentprofile(seg,tp).offx
    lgz#=segmentprofile(seg,tp).offz
    if gridorient>0
     for brot=0 to gridorient-1
      lgss#=lgx# : lgx#=lgz# : lgz#=lgss#*-1
     next brot
    endif
    lgx#=lgx#+(50+(mx*100))
    lgz#=lgz#+((my*-100)-50)
    lgy#=segmentprofile(seg,tp).offy+(50+(layer*100))
    if segmentprofile(seg).vis.overlay=1
     if gridorient=0 then lgz#=lgz#-1.0
     if gridorient=1 then lgx#=lgx#-1.0
     if gridorient=2 then lgz#=lgz#+1.0
     if gridorient=3 then lgx#=lgx#+1.0
    endif
    addentityx=lgx# : addentityy=lgy# : addentityz=lgz#
    addentityrx=0 : addentityry=segmentprofile(seg,tp).roty : addentityrz=0
    addentityry=addentityry+(gridorient*90)
    `
    rem if not already place entity here
    tokay=0
    if gridaddtobufferref=1
     rem if creating for bufferref, always create
    else
     if entityelementlist>0
      for te=1 to entityelementlist
       if entityelement(te).maintype>0
        tentid=entityelement(te).bankindex
        if abs((entityelement(te).x)-addentityx)<=2
         if abs((entityelement(te).y)-addentityy)<=2
          if abs((entityelement(te).z)-addentityz)<=2
           tokay=1 : exit
          endif
         endif
        endif
       endif
      next te
     endif
    endif
    if tokay=0
     `
     rem load/add entity profile
     gosub _entity_loadextra
     `
     rem Add entity reference into map
     addtobufferref=gridaddtobufferref : gosub _gridedit_addentityreftomap
     `
     rem special editor flag - cannot move these
     entityelement(e).editorfixed=1
     `
     rem also always dynamic (no point having static entity attachments in segment-selection)
     entityelement(e).staticflag=0
     `
    endif
    `
  endif
next tp

return

_gridedit_drawsingletile:

rem takes in layer,mx,my
addgridselection=gridselection
addgridscaler=0
addgridground=gridground
addgridorient=gridorient
addgridsymbol=gridsymbol

rem depending on kind of segment
if segmentprofile(gridselection).vis.overlay=0
 `
 rem Add new seg and remove old overlays from this tile
 tfreshgridadd=1 : gosub _gridedit_addtogridmap : tfreshgridadd=0
 `
 rem X9 - 070208 - draw a floor above ROOM style segments automatically if above tile is empty
 if strarr$(406)="1"
  rem disabled auto ceiling
 else
  rem auto ceiling active
  if nogridsmart=-1 and gridground=0 : rem only auto and internal modes
   if segmentprofileheader(gridselection).partmax>=16 and segmentprofile(gridselection).vis.f>-1
    rem and is a FULL segment (like a ROOM) with an actual floor
    if layer<20
     rem and the layer exists for this addition
     if map(layer+1,mx,my)=0
      rem and above tile is COMPLETELY un-used
      layer=layer+1
      storednogridsmart=nogridsmart : nogridsmart=1
      storedgridground=addgridground : addgridground=2
      tfreshgridadd=1 : gosub _gridedit_addtogridmap : tfreshgridadd=0
      nogridsmart=storednogridsmart
      addgridground=storedgridground
      layer=layer-1
     endif
    endif
   endif
  endif
 endif
 `
 rem Only affect overlays if FULL mode, not WALL or FLOOR modify
 if nogridsmart=-1 then deleteolaymode=1 : gosub _gridedit_deleteolay_map
 `
else
 gosub _gridedit_addolay_map
endif

rem Stamp paint into undoredo buffer
tmapid=map(layer,mx,my)
tx=mx : ty=my : tlayer=layer
inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd

rem update neighbor tiles if in auto-mode
if segmentprofile(gridselection).vis.overlay=0 and singletilejustfloor=0
 upx=mx : upy=my : uplayer=layer : gosub _gridedit_updatetile
endif

rem add any entities belonging to this placed segment
seg=gridselection : gridaddtobufferref=0
gosub _gridedit_addsegmententities

rem refresh shroud
shroudrefresh=1

return

_gridedit_erasesingletile:

rem remove tile from map
if segmentprofile(gridselection).vis.overlay=0
 `
 rem Delete grid tile
 gosub _gridedit_deletefromgridmap
 `
 rem X9 - 070208 - draw a floor above ROOM style segments automatically if above tile is empty
 if strarr$(406)="1"
  rem disabled auto ceiling
 else
  rem auto ceiling active
  if nogridsmart=-1 and gridground=0 : rem only auto and internal modes
   if segmentprofileheader(gridselection).partmax>=16 and segmentprofile(gridselection).vis.f>-1
    rem and is a FULL segment (like a ROOM) with an actual floor
    if layer<20
     rem and the layer exists for this addition
     storedmapid=mapid
     mapid=map(layer+1,mx,my)
     gosub _gridedit_getmapvalues
     mapid=storedmapid
     rem must match the segment in the cursor
     if mapselection=gridselection
      if maptile=6
       rem and above tile is COMPLETELY un-used
       layer=layer+1
       storednogridsmart=nogridsmart : nogridsmart=1
       gosub _gridedit_deletefromgridmap
       nogridsmart=storednogridsmart
       layer=layer-1
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem Only affect overlays if FULL mode, not WALL or FLOOR modify
 if nogridsmart=-1 then deleteolaymode=1 : gosub _gridedit_deleteolay_map
 `
else
 deleteolaymode=0 : gosub _gridedit_deleteolay_map
endif

rem Stamp delete into undoredo buffer
tx=mx : ty=my : tlayer=layer
tmapid=0 : inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd

rem update neighbor tiles if in auto-mode
if segmentprofile(gridselection).vis.overlay=0 and singletilejustfloor=0
 addremovenotadd=1
 upx=mx : upy=my : uplayer=gridlayer : gosub _gridedit_updatetile
 addremovenotadd=0
endif

rem refresh shroud
shroudrefresh=1

return

_gridedit_deleteclipboard:
 `
 rem delete buffer (clipboard)
 if bufferlayer<>-1
  if bufferholdscutdata=1
   for layer=0 to bufferlayer
    for my=0 to buffermaxy
     for mx=0 to buffermaxx
      rem if holds original ref data, must delete entities associated with it
      ptrbase=bufferrefmap(layer,mx,my)
      gosub _gridedit_deleteallentitiesontile
      rem also delete overlays perminantly (from buffer)
      olayindex=buffermapolay(layer,mx,my)
      gosub _gridedit_removeallolays_olayindex
     next mx
    next my
   next layer
  endif
  gosub _gridedit_deletebuffermesh
  bufferlayer=-1
 endif
 `
return

_gridedit_hideclipboard:
 if bufferlayer<>-1
  if mastermeshmax>0
   for m=1 to mastermeshmax
    for s=0 to mastermeshsets
     if mastermesh(m,s).buffer=1
      obj=mastermesh(m,s).obj
      mastermesh(m,s).buffer=-1
      if object exist(obj)=1 then hide object obj
     endif
    next s
   next m
  endif
 endif
return

_gridedit_showclipboard:
 if bufferlayer<>-1
  if mastermeshmax>0
   for m=1 to mastermeshmax
    for s=0 to mastermeshsets
     if mastermesh(m,s).buffer=1
      obj=mastermesh(m,s).obj
      mastermesh(m,s).buffer=-1
      if object exist(obj)=1 then show object obj
     endif
    next s
   next m
  endif
 endif
return

_gridedit_showtobjlegend:
 if tobj>0
  if object exist(tobj)>0
   if taddstaticlegend=1
    if gmultiplayergame=1 and entityprofile(ttentid).ismarker=1
     rem multiplayer arena mode - start marker
     tname$=tname$+" "+strarr$(621)
    else
     rem static
     tname$=tname$+" "+strarr$(608)
    endif
   else
    rem dynamic
    if gmultiplayergame=1
     rem multiplayer arena mode
     if entityprofile(ttentid).ischaracter=1
      rem any character
      tname$=tname$+" "+strarr$(620)
     else
      tname$=tname$+" "+strarr$(609)
     endif
    else
     tname$=tname$+" "+strarr$(609)
    endif
   endif
   dwbkcol as dword : dwbkcol=128<<24 : ink dwbkcol,dwbkcol
   tdisplayx#=object screen x(tobj)*0.85
   tdisplayy#=object screen y(tobj)*0.85
   box tdisplayx#-text width(tname$)/1.8,tdisplayy#+16,tdisplayx#+text width(tname$)/1.8,tdisplayy#+26+8,dwbkcol,dwbkcol,dwbkcol,dwbkcol
   ink rgb(255,255,0),0
   center text tdisplayx#,tdisplayy#+16,tname$
  endif
 endif
return

_gridedit_mapediting:

rem Only if within map
if inputsys.mmx>=0 and inputsys.mmy>=0 and inputsys.mmx<maxx and inputsys.mmy<maxy
 `
 rem Any click inside 3D area constitues some sort of edit
 if inputsys.mclick<>0 then projectmodified=1 : gosub _gridedit_changemodifiedflag
 `
 rem PAINT MAP Handling
 if grideditselect=0 and segidmaster>0
  if inputsys.dopickmapid>0
   `
   rem pick tile from map
   if inputsys.mclick=1 and inputsys.dopickmapid=1
    layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
    mapid=map(layer,mx,my)
    if mapid<>0
     gosub _gridedit_getmapvalues
     gridselection=mapselection
     gridscaler=mapscaler
     gridground=mapground
     gridorient=maporient
     gridkindof=segmentprofile(mapselection).properties.kindof
    endif
    rem set cursor and deactivate pick
    inputsys.dopickmapid=2 : gosub _editor_refresheditmarkers
   endif
   if inputsys.mclick<>1 and inputsys.dopickmapid=2 then inputsys.dopickmapid=0
   `
  else
   if inputsys.mclick=1
    `
    rem Version Control - stop high resource use
    resourceused=1 : gosub _version_resourcewarning
    `
    rem paint tile to map
    layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
    gosub _gridedit_drawsingletile
    `
   endif
   if inputsys.mclick=2
    `
    rem remove tile from map
    layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
    gosub _gridedit_erasesingletile
    `
   endif
  endif
 endif
 `
 rem Functionality to select an area of the map
 tselectareaofmap=0
 if grideditselect=1 and bufferlayer=-1 then tselectareaofmap=1
 if gridentitytriggerareaselect=1 then tselectareaofmap=2
 `
 rem Select an area of the map
 if tselectareaofmap>0
  if inputsys.mclick=1
   if selstage=0
    sel1mmx=inputsys.mmx : sel1mmy=inputsys.mmy : sel1layer=gridlayer
    show object 3 : show object 4
    showselectboundbox=1
    selstage=1
   endif
   if selstage=1
    sel2mmx=inputsys.mmx : sel2mmy=inputsys.mmy : sel2layer=gridlayer
   endif
   if sel2mmx<sel1mmx then sel1mmx=sel2mmx
   if sel2mmy<sel1mmy then sel1mmy=sel2mmy
   if sel2layer<sel1layer then sel1layer=sel2layer
  endif
  if inputsys.mclick=0
   selstage=0 : gosub _editor_cutcopyclearstate
  endif
 endif
 `
 rem CUT/COPY/PASTE/FLOORONOFF MAP Handling
 if grideditselect=1
  if bufferlayer=-1
   `
   rem cut/copy function
   if inputsys.tselcontrol=1 and selstage<2
    `
    rem copy into buffer
    if inputsys.tselcopy=1
     gosub _gridedit_deletebuffermesh
     bufferholdscutdata=0
     bufferrotationcount=0
     bufferlayer=(sel2layer-sel1layer)
     buffermaxx=(sel2mmx-sel1mmx)
     buffermaxy=(sel2mmy-sel1mmy)
     dim buffermap(bufferlayer+1,buffermaxx+1,buffermaxy+1)
     dim bufferrefmap(bufferlayer+1,buffermaxx+1,buffermaxy+1)
     dim buffermapolay(bufferlayer+1,buffermaxx+1,buffermaxy+1)
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        buffermap(layer,mx,my)=map(sel1layer+layer,sel1mmx+mx,sel1mmy+my)
        bufferrefmap(layer,mx,my)=refmap(sel1layer+layer,sel1mmx+mx,sel1mmy+my)
        buffermapolay(layer,mx,my)=mapolay(sel1layer+layer,sel1mmx+mx,sel1mmy+my)
       next mx
      next my
     next layer
     `
     rem done
     selstage=2
     `
     rem update menu items
     gosub _editor_cutcopyclearstate
     `
    endif
    `
    rem cut from map
    if inputsys.tselcut=1
     `
     rem flag that cut has been used (entity copy control)
     bufferholdscutdata=1
     `
     rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
     deferundoredoprojectstatetoend=1
     `
     rem blank out map data
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        `
        rem Remove tile
        tbuffer=0 : tlayer=sel1layer+layer  : tx=sel1mmx+mx : ty=sel1mmy+my
        wasmapid=map(tlayer,tx,ty)
        gosub _gridedit_removetile
        map(tlayer,tx,ty)=0
        `
        rem Remove entity
        if refmap(tlayer,tx,ty)>0
         gosub _gridedit_removeentity
         refmap(tlayer,tx,ty)=0
        endif
        `
        rem Blank overlays (original data stored in buffer now - deleted later via bufferholdscutdata)
        if mapolay(tlayer,tx,ty)>0
         mapolay(tlayer,tx,ty)=0
        endif
        `
        rem Stamp delete into undoredo buffer
        tmapid=0 : inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd
        `
       next mx
      next my
     next layer
     `
     rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
     deferundoredoprojectstatetoend=0
     gosub _editor_undoredoprojectstate
     `
     rem Update map area
     for ulayer=0 to bufferlayer
      for umy=0 to buffermaxy
       for umx=0 to buffermaxx
        upx=sel1mmx+umx : upy=sel1mmy+umy : uplayer=sel1layer+ulayer : gosub _gridedit_updatetile
       next umx
      next umy
     next ulayer
     `
     rem done
     selstage=2
     `
    endif
    `
    rem end selection and refresh
    if selstage=2
     `
     rem create mesh from buffer data
     gosub _gridedit_createbuffermesh
     shroudrefresh=1
     `
     rem switch to starting layer (for editing convenience)
     if sel1layer<>sel2layer then gridlayer=sel1layer
     `
    endif
    `
   rem cut/copy function endif
   endif
   `
   rem selection control
   if selstage=2
    hide object 3 : hide object 4
    showselectboundbox=0
    selstage=0
   endif
   `
  endif
  if bufferlayer<>-1
   if inputsys.mmx>=0 and inputsys.mmy>=0 and inputsys.mmx+buffermaxx<maxx and inputsys.mmy+buffermaxy<maxy
    `
    rem mouse can also paste and delete
    if inputsys.mclick=1 then inputsys.tselpaste=1
    if inputsys.mclick=2 then inputsys.tselwipe=1
    `
    rem paste clipboard
    if inputsys.tselpaste=1
     `
     rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
     deferundoredoprojectstatetoend=1
     `
     rem Copy buffer to map
     tbuffer=0
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        rem TILE
        tmapid=buffermap(layer,mx,my)
        if tmapid<>0
         tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
         if tlayer<=layermax
          `
          rem Add tile to blue-mesh
          wasmapid=map(tlayer,tx,ty)
          map(tlayer,tx,ty)=tmapid
          gosub _gridedit_removetile
          if tmapid<>0 then gosub _gridedit_addtile
          `
          rem Stamp add into undoredo buffer
          inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd
          `
         endif
        endif
        rem ENTITIY REFS
        refptrbase=bufferrefmap(layer,mx,my)
        if refptrbase<>0
         tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
         if tlayer<=layermax
          `
          rem Add entity (first removing old entities on the tile)
          ptrbase=refmap(tlayer,tx,ty)
          if ptrbase>0
           `
           rem must delete any entity that are on this tile
           gosub _gridedit_deleteallentitiesontile
           gosub _gridedit_removeentity
           refmap(tlayer,tx,ty)=0
           `
          endif
          refptrbase=bufferrefmap(layer,mx,my)
          if refptrbase>0
           `
           rem go through each entity in mapref
           reftmax=*refptrbase : refptr=refptrbase+4
           for reftp=1 to reftmax
            `
            rem for each tile
            tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
            `
            rem get original entity data
            e=*refptr
            adjx#=entityelement(e).x-(int(entityelement(e).x/100.0)*100)
            adjy#=entityelement(e).y-(int(entityelement(e).y/100.0)*100)
            adjz#=entityelement(e).z-(int(entityelement(e).z/100.0)*100)
            adjrx#=0.0
            adjry#=bufferrotationcount*90.0
            adjrz#=0.0
            `
            rem adjust offsets based on rotation
            if bufferrotationcount=1
             stadjx#=adjx# : adjx#=100.0-(adjz#*-1.0) : adjz#=stadjx#*-1.0
            endif
            if bufferrotationcount=2
             adjx#=100.0-adjx# : adjz#=-100.0-adjz#
            endif
            if bufferrotationcount=3
             stadjx#=adjx# : adjx#=adjz#*-1.0 : adjz#=-100.0+stadjx#
            endif
            `
            rem copied selection must be duplicate entity data
            gridentityeditorfixed=entityelement(e).editorfixed
            gridentity=entityelement(e).bankindex
            gridentityposx#=(tx*100)+adjx#
            gridentityposz#=(ty*-100)+adjz#
            gridentityposy#=(tlayer*100)+adjy#
            gridentityrotatex#=entityelement(e).rx+adjrx#
            gridentityrotatey#=entityelement(e).ry+adjry#
            gridentityrotatez#=entityelement(e).rz+adjrz#
            grideleprof=entityelement(e).eleprof
            `
            rem uses layer,mx,my so store values
            storelayer=layer : storemx=mx : storemy=my
            layer=tlayer : mx=tx : my=ty
            gosub _gridedit_addentitytomap
            layer=storelayer : mx=storemx : my=storemy
            gridentity=0
            `
            inc refptr,4
            `
           next reftp
           `
          endif
          `
         endif
        endif
        rem MAP OVERLAYS (add to map as new overlays)
        tolayindex=buffermapolay(layer,mx,my)
        if tolayindex>0
         rem go through overlays and add same to this area of map
         for ti=0 to 50
          buffermapid=olaylist(tolayindex,ti)
          if buffermapid>0
           storelayer=layer : storemx=mx : storemy=my
           tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
           layer=tlayer : mx=tx : my=ty
           gosub _gridedit_addolay_map
           layer=storelayer : mx=storemx : my=storemy
           buffermapid=0
          else
           exit
          endif
         next ti
        endif
       next mx
      next my
     next layer
     `
     rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
     deferundoredoprojectstatetoend=0
     gosub _editor_undoredoprojectstate
     `
     rem Update shroud after paste
     shroudrefresh=1 : gosub _gridedit_updatelayershades
     `
    endif
    `
    rem wipe out map covered by clipbboard selection
    if inputsys.tselwipe=1
     `
     rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
     deferundoredoprojectstatetoend=1
     `
     rem Wipe map of selection-area size
     tbuffer=0
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        tmapid=buffermap(layer,mx,my)
        if tmapid<>0
         tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
         if tlayer<=layermax
          rem remove tile
          wasmapid=map(tlayer,tx,ty)
          map(tlayer,tx,ty)=0
          gosub _gridedit_removetile
          rem remove overlays perminantly
          storelayer=layer : storemx=mx : storemy=my
          layer=tlayer : mx=tx : my=ty
`          gosub _gridedit_removeallolays `this was done before remove-no-touch-ents
          rem in all direction ( ie deleteolaymode=1 )
          deleteolaymode=1 : gosub _gridedit_deleteolay_map
          layer=storelayer : mx=storemx : my=storemy
          rem Stamp add into undoredo buffer
          inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd
         endif
        endif
       next mx
      next my
     next layer
     `
     rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
     deferundoredoprojectstatetoend=0
     gosub _editor_undoredoprojectstate
     `
     rem Update map area
     for ulayer=0 to bufferlayer
      for umy=0 to buffermaxy
       for umx=0 to buffermaxx
        uplayer=gridlayer+ulayer
        if uplayer<=layermax
         upx=inputsys.mmx+umx : upy=inputsys.mmy+umy : gosub _gridedit_updatetile
        endif
       next umx
      next umy
     next ulayer
     `
     rem Update shroud after paste
     shroudrefresh=1 : gosub _gridedit_updatelayershades
     `
    endif
    `
   endif
  endif
 endif
 `
 rem must be able to remove clipboard contents (if switch modes)
 if grideditselect<>1 and bufferlayer<>-1 then inputsys.tseldelete=1
 if inputsys.tseldelete=1
  rem delete clipboard
  gosub _gridedit_deleteclipboard
  rem update menu items
  gosub _editor_cutcopyclearstate
 endif
 `
 rem ART SHAPE Handling
 if grideditselect=2
  `
  rem select area for shape
  if inputsys.mclick>0
   if selstage=0
    if inputsys.mclick=1 then selstagemode=1
    if inputsys.mclick=2 then selstagemode=2
    sel1mmx=inputsys.mmx : sel1mmy=inputsys.mmy : sel1layer=gridlayer
    selstage=1
   endif
   if selstage=1
    sel2mmx=inputsys.mmx : sel2mmy=inputsys.mmy : sel2layer=gridlayer
    if inputsys.kscancode=42 or inputsys.kscancode=54
     sel2mmy=sel1mmy+(inputsys.mmx-sel1mmx)
    endif
   endif
  endif
  if inputsys.mclick=0 and selstage=1 and (sel1mmx<>sel2mmx or sel1mmy<>sel2mmy)
   selstage=2
  endif
  `
  rem show shape area
  tobj=editormarkeroffset
  `
  rem init art shape
  if grideditartmode=1
   rem line
   dx#=sel2mmx-sel1mmx : dy#=sel2mmy-sel1mmy
   if abs(dx#)>abs(dy#)
    l1=sel1mmx : l2=sel2mmx : ll#=sel1mmy
   else
    l1=sel1mmy : l2=sel2mmy : ll#=sel1mmx
   endif
   ll=l1
  endif
  if grideditartmode=2
   rem box
   llx=sel1mmx-1 : lly=sel1mmy
  endif
  if grideditartmode=3
   rem circle
   dx#=sel2mmx-sel1mmx : dy#=sel2mmy-sel1mmy
   ll=0 : l1=2 : l2=-1
  endif
  if grideditartmode=4
   rem spray
   ll=2 : selstage=2 : rem autorelease
  endif
  `
  rem range from width
  if grideditartmode=4
   tgrideditartwidthx=1 : tgrideditartwidthy=1
  else
   tgrideditartwidthx=grideditartwidthx : tgrideditartwidthy=grideditartwidthy
  endif
  `
  rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
  if selstage=2 then deferundoredoprojectstatetoend=1
  `
  rem art preview/draw loop
  llokay=1
  while llokay=1
   `
   rem validatehighlight ensures outline, not complete fill
   tvalidatehighlight=1
   `
   rem calculate coords
   if grideditartmode=1
    rem line
    if abs(dx#)>abs(dy#)
     llx=ll : lly=ll# : if l1<l2 then ll#=ll#+(dy#/dx#) else ll#=ll#-(dy#/dx#)
    else
     llx=ll# : lly=ll : if l1<l2 then ll#=ll#+(dx#/dy#) else ll#=ll#-(dx#/dy#)
    endif
    if l1<l2
     ll=ll+1 : if ll>l2+1 then llokay=0
    else
     ll=ll-1 : if ll<l2-1 then llokay=0
    endif
   endif
   if grideditartmode=2
    rem box
    inc llx
    if llx>sel2mmx
     llx=sel1mmx : inc lly
     if lly>sel2mmy then llokay=0
    endif
    rem validate for outline
    if llx>sel1mmx and llx<sel2mmx and lly>sel1mmy and lly<sel2mmy
     tvalidatehighlight=0
    endif
   endif
   if grideditartmode=3
    rem validate for outline
    tvalidatehighlight=0
    rem circle
    if l1=2
     llx=sel1mmx+(((cos(ll-1)*dx#))+0.5) : l1=0
    endif
    if l1=0
     oldllx=llx
     repeat
      llx=sel1mmx+(((cos(ll)*dx#))+0.5) : lly=sel1mmy+(((sin(ll)*dy#))+0.5)
      inc ll,1
     until oldllx<>llx or ll>180
     if ll>180 then llokay=0
     llx=sel1mmx+(((cos(ll-1)*dx#))+0.5) : l1=1
     tvalidatehighlight=1
    else
     if l1=1
      dec lly
      if lly<=sel1mmy-(((sin(ll)*dy#))+0.5)
       l1=2
       tvalidatehighlight=1
      endif
     endif
    endif
   endif
   if grideditartmode=4
    rem spray
    dd#=rnd(100)/100.0 : rr=rnd(359)
    llx=(sel1mmx+(cos(rr)*(grideditartwidth*dd#)))+0.5
    lly=(sel1mmy+(sin(rr)*(grideditartwidth*dd#)))+0.5
    dec ll : if ll<=0 then llokay=0
   endif
   `
   rem place art object(s)
   if llokay=1
    `
    rem FPGC - thin out highlight if selection is floor tile
    tisfloortile=0
    if gridselection>0
     if segmentprofile(gridselection).vis.f>-1
      if segmentprofile(gridselection).vis.r=-1
       if segmentprofile(gridselection).vis.wb=-1
        if segmentprofile(gridselection).vis.wr=-1
         if segmentprofile(gridselection).vis.wf=-1
          if segmentprofile(gridselection).vis.wl=-1
           if segmentprofile(gridselection).vis.wl=-1
            if segmentprofile(gridselection).vis.owb=-1
             if segmentprofile(gridselection).vis.owr=-1
              if segmentprofile(gridselection).vis.owf=-1
               if segmentprofile(gridselection).vis.owl=-1
                if segmentprofile(gridselection).vis.owl=-1
                 if segmentprofile(gridselection).vis.octl=-1
                  if segmentprofile(gridselection).vis.octr=-1
                   if segmentprofile(gridselection).vis.ocbr=-1
                    if segmentprofile(gridselection).vis.ocbl=-1
                     tisfloortile=1
                    endif
                   endif
                  endif
                 endif
                endif
               endif
              endif
             endif
            endif
           endif
          endif
         endif
        endif
       endif
      endif
     endif
    endif
    `
    rem control width of art draw
    for twidthy=0 to tgrideditartwidthy-1
     for twidthx=0 to tgrideditartwidthx-1
      `
      if tvalidatehighlight=1
       if selstage>0 and grideditartmode<>4
        if tobj<=editormarkeroffsetmax
         `
         rem FPGC can adjust height of art cursor
         if tisfloortile=1
          position object tobj,((llx+twidthx)*100)+50,(sel1layer*100)+6,((lly+twidthy)*-100)-50
          scale object tobj,100,10,100
         else
          position object tobj,((llx+twidthx)*100)+50,(sel1layer*100)+50,((lly+twidthy)*-100)-50
          scale object tobj,100,102,100
         endif
         scroll object texture tobj,0.03,0.0 : show object tobj
         `
         inc tobj
        endif
       endif
      endif
      `
      rem draw at location if flagged
      if selstage=2
       `
       rem FPGC - 100710 - skip area check on pure floor segments, except around edge (where they touch existing segments)
       singletilejustfloor=tisfloortile
       if twidthy=0 or twidthy=tgrideditartwidthy-1 then singletilejustfloor=0
       if twidthx=0 or twidthx=tgrideditartwidthx-1 then singletilejustfloor=0
       `
       if selstagemode=1
        rem paint tile to map
        layer=gridlayer : mx=llx+twidthx : my=lly+twidthy
        if mx>=0 and my>=0 and mx<maxx and my<maxy
         gosub _gridedit_drawsingletile
        endif
       endif
       if selstagemode=2
        rem remove tile from map
        layer=gridlayer : mx=llx+twidthx : my=lly+twidthy
        if mx>=0 and my>=0 and mx<maxx and my<maxy
         gosub _gridedit_erasesingletile
        endif
       endif
       singletilejustfloor=0
      endif
      `
     next twidthx
    next twidthy
    `
   endif
   `
  endwhile
  `
  rem Hide unused art objects
  editormarkeroffsethidefrom=tobj
  while tobj<=editormarkeroffsetmax
   hide object tobj : inc tobj
  endwhile
  `
  rem end draw phase
  if selstage=2
   selstage=0 : selstagemode=0
   rem FPGC - 100710 - in art mode, ensuer interface wait is called once (at end of loop)
   deferundoredoprojectstatetoend=0
   gosub _editor_undoredoprojectstate
  endif
  `
 endif
 `
 rem ENTITY EDIT Handling (can use select area objects 3&4)
 sustainselectareafortrigger=0
 if grideditselect=5
  layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
  if selstage=0
   `
   rem single entity highlight
   tshow=0 : showentityid=0 : tforcegrid=0 : tforcedynamic=0 : tentitytoselect=0
   if gridentity=0
    tentitytoselect=findentitycursorobj()
    if tentitytoselect>0
     position object 5,entityelement(tentitytoselect).x,entityelement(tentitytoselect).y,entityelement(tentitytoselect).z
     showentityid=entityelement(tentitytoselect).bankindex
     if entityprofile(showentityid).ismarker=3
      if gridentitytriggerareaselect=0
       rem Update area coords when not selecting new coords
       sel1mmx=entityelement(tentitytoselect).x/100
       sel1mmy=entityelement(tentitytoselect).z/-100
       sel1layer=entityelement(tentitytoselect).y/100
       sel2mmx=sel1mmx+entityelement(tentitytoselect).eleprof.trigger.areax2
       sel2layer=sel1layer+entityelement(tentitytoselect).eleprof.trigger.areay2
       sel2mmy=sel1mmy+entityelement(tentitytoselect).eleprof.trigger.areaz2
       sel1mmx=sel1mmx+entityelement(tentitytoselect).eleprof.trigger.areax1
       sel1layer=sel1layer+entityelement(tentitytoselect).eleprof.trigger.areay1
       sel1mmy=sel1mmy+entityelement(tentitytoselect).eleprof.trigger.areaz1
      endif
      tscale#=100
     else
      if entityprofile(showentityid).islightmarker=1
       tscale#=(100/3.0)*2*(entityelement(tentitytoselect).eleprof.light.range/50.0)
      else
       tscale#=object size(entityelement(tentitytoselect).obj)*3.0
      endif
     endif
     scale object 5,tscale#,tscale#,tscale#
     tshow=1+entityelement(tentitytoselect).staticflag
    endif
   else
    position object 5,gridentityposx#,gridentityposy#,gridentityposz#
    if object exist(entitybankoffset+gridentity)=1
     if entityprofile(gridentity).ismarker=3
      if gridentitytriggerareaselect=0
       rem Update area coords when not selecting new coords
       sel1mmx=gridentityposx#/100
       sel1mmy=gridentityposz#/-100
       sel1layer=gridentityposy#/100
       sel2mmx=sel1mmx+grideleprof.trigger.areax2
       sel2layer=sel1layer+grideleprof.trigger.areay2
       sel2mmy=sel1mmy+grideleprof.trigger.areaz2
       sel1mmx=sel1mmx+grideleprof.trigger.areax1
       sel1layer=sel1layer+grideleprof.trigger.areay1
       sel1mmy=sel1mmy+grideleprof.trigger.areaz1
      endif
      tscale#=100
     else
      if entityprofile(gridentity).islightmarker=1
       tscale#=(100/3.0)*2*(grideleprof.light.range/50.0)
      else
       tscale#=object size(entitybankoffset+gridentity)*3.0
      endif
     endif
     scale object 5,tscale#,tscale#,tscale#
    endif
    tshow=1+gridentitystaticmode
    showentityid=gridentity
   endif
   if tshow>0 and inputsys.activemouse=1
    if entityprofile(showentityid).ismarker=1 then tforcedynamic=1
    if entityprofile(showentityid).ismarker=4 then tforcedynamic=1
    if entityprofile(showentityid).ismarker=3
     rem trigger area
     show object 3 : show object 4 : hide object 5
     sustainselectareafortrigger=1
     showselectboundbox=1
     tforcegrid=1
     tforcedynamic=1
    else
     hide object 3 : hide object 4 : show object 5
     if entityprofile(showentityid).islightmarker=1
      rem light range visual
      texture object 5,editorimagesoffset+18
      yrotate object 5,0
      if tshow=2
       modifyplaneimagestrip(5,2,0)
      else
       modifyplaneimagestrip(5,2,1)
      endif
     else
      if entityprofile(showentityid).forwardfacing=1
       rem coloured circle blob with arrow
       texture object 5,editorimagesoffset+26
       yrotate object 5,gridentityrotatey#
      else
       rem coloured circle blob
       texture object 5,editorimagesoffset+7
       yrotate object 5,0
      endif
      if tshow=2
       modifyplaneimagestrip(5,8,1)
      else
       if gmultiplayergame=0
        modifyplaneimagestrip(5,8,3)
       else
        if entityprofile(showentityid).isammo<>0 or entityprofile(showentityid).isweapon<>0 or entityprofile(showentityid).ischaracter<>0 or entityprofile(showentityid).ishealth<>0
         modifyplaneimagestrip(5,8,3)
        else
         modifyplaneimagestrip(5,8,1)
        endif
       endif
      endif
     endif
     show object 5
    endif
    rem show legend of entity hovering over (and static legend)
    taddstaticlegend=0
    if tentitytoselect>0
     tstatic=entityelement(tentitytoselect).staticflag
     tentid=entityelement(tentitytoselect).bankindex
    else
     tstatic=gridentitystaticmode
     tentid=gridentity
    endif
    if gmultiplayergame=0
     if tstatic=1
      taddstaticlegend=1
     else
      taddstaticlegend=0
     endif
    else
     if tstatic=1
      taddstaticlegend=1
     else
      if entityprofile(tentid).isammo<>0 or entityprofile(tentid).isweapon<>0 or entityprofile(tentid).ischaracter<>0 or entityprofile(tentid).ishealth<>0
       taddstaticlegend=0
      else
       taddstaticlegend=1
      endif
     endif
    endif
    if tentitytoselect>0
     tobj=entityelement(tentitytoselect).obj
     tname$=entityelement(tentitytoselect).eleprof.name$
     ttentid=entityelement(tentitytoselect).bankindex
     gosub _gridedit_showtobjlegend
    else
     tobj=gridentityobj : tname$=grideleprof.name$
     ttentid=gridentity
     gosub _gridedit_showtobjlegend
    endif
   else
    hide object 5
   endif
   `
   rem Special Entity Edit Mode
   if gridentitytriggerareaselect=1
    `
    rem When placing trigger, SHIFT will allow the area to be specified
    rem SEL1Xetc are set elswhere (shared with segment area selection)
    selXmmx=gridentityposx#/100
    selXlayer=gridentityposy#/100
    selXmmy=gridentityposz#/-100
    grideleprof.trigger.areax1=sel1mmx-selXmmx
    grideleprof.trigger.areay1=sel1layer-selXlayer
    grideleprof.trigger.areaz1=sel1mmy-selXmmy
    grideleprof.trigger.areax2=sel2mmx-selXmmx
    grideleprof.trigger.areay2=sel2layer-selXlayer
    grideleprof.trigger.areaz2=sel2mmy-selXmmy
    `
   else
    `
    rem entity placement update
    gridentityposx#=inputsys.localx#
    gridentityposz#=inputsys.localy#
    `
    rem grid system for entities
    if gridentitygridlock=1
     gridentityposx#=(int(gridentityposx#/5)*5)
     gridentityposz#=(int(gridentityposz#/5)*5)
    endif
    if gridentitygridlock=2 or tforcegrid=1
     gridentityposx#=50+(int(gridentityposx#/100)*100)
     gridentityposz#=(int(gridentityposz#/100)*100)-50
    endif
    if tforcedynamic=1
     gridentitystaticmode=0
    endif
    `
    rem control modification of entity element details
    if gridentitymodifyelement=1
     if grideleprof.light.range>50 then grideleprof.light.range=grideleprof.light.range-50
     gridentitymodifyelement=0
    endif
    if gridentitymodifyelement=2
     if grideleprof.light.range<1000 then grideleprof.light.range=grideleprof.light.range+50
     gridentitymodifyelement=0
    endif
    `
    rem single entity select/deselect
    if inputsys.mclick=1
     if gridentity<>0
      `
      rem Version Control - stop high resource use
      resourceused=2 : gosub _version_resourcewarning
      `
      rem only if in editing area
      if gridentityposx#>=0 and gridentityposy#>=0 and gridentityposz#<=0 and gridentityposx#<(maxx*100.0) and gridentityposy#<(20*100.0) and gridentityposz#>(maxy*-100.0)
       `
       rem after add, adjust so it auto-finds a floor or wall (convenience)
       gridentitydroptoground=1+entityprofile(gridentity).forwardfacing
       if gridentitydroptoground=2
        rem not too convenient for floors, but wall furniture look okay!!
        gosub _editor_findentityground
       endif
       gridentitydroptoground=0
       `
       rem find unique name for this selection (if flagged)
       if guseuniquelynamedentities=0
        rem use same name as original entity
        tbase$=grideleprof.name$
       else
        tokay=0 : tindex=1
        if lower$(left$(grideleprof.name$,len(grideleproflastname$)))=lower$(grideleproflastname$)
         tbase$=grideleproflastname$
        else
         tbase$=grideleprof.name$
        endif
        while tokay=0
         tokay=1 : grideleprof.name$=tbase$ : grideleproflastname$=tbase$
         if tindex>1 then grideleprof.name$=grideleprof.name$+" "+str$(tindex)
         for e=1 to entityelementlist
          if entityelement(e).bankindex>0
           if lower$(entityelement(e).eleprof.name$)=lower$(grideleprof.name$)
            rem this name exists already, try another
            tokay=0 : exit
           endif
          endif
         next e
         inc tindex
        endwhile
       endif
       rem player start markers have exclusivity
       if entityprofile(gridentity).ismarker=1 and entityprofile(gridentity).lives<>-1
        for e=1 to entityelementlist
         if entityelement(e).bankindex>0
          if entityprofile(entityelement(e).bankindex).ismarker=1 and entityprofile(entityelement(e).bankindex).lives<>-1
           tentitytoselect=e
           gosub _gridedit_deleteentityfrommap
          endif
         endif
        next e
       endif
       rem copy entity to map (keep selection for repeat process)
       gosub _gridedit_addentitytomap
       rem update for refresh
       shroudrefresh=1
       selstage=1
      endif
      `
     else
      rem extract entity from the map
      if tentitytoselect>0
       if entityelement(tentitytoselect).editorfixed=0
        gridentitystaticmode=entityelement(tentitytoselect).staticflag
        gridentityeditorfixed=entityelement(tentitytoselect).editorfixed
        gridentity=entityelement(tentitytoselect).bankindex
        gridentityposx#=entityelement(tentitytoselect).x
        gridentityposy#=entityelement(tentitytoselect).y
        gridentityposz#=entityelement(tentitytoselect).z
        gridentityrotatex#=entityelement(tentitytoselect).rx
        gridentityrotatey#=entityelement(tentitytoselect).ry
        gridentityrotatez#=entityelement(tentitytoselect).rz
        grideleprof=entityelement(tentitytoselect).eleprof
        grideleproflastname$=grideleprof.name$
        gosub _gridedit_deleteentityfrommap
        shroudrefresh=1
        `
        rem if entity fom other layer, change relative position of entity Y
        rem and we have a buffer of 25 units above and belo the current edit layer
        if gridentityposy#>(gridlayer*100)-25.0 and gridentityposy#<(gridlayer*100)+125.0
         rem leave entity Y position alone!
        else
         rem change the entity Y position
         tmp=gridentityposy#/100 : tmpy#=gridentityposy#-(tmp*100)
         gridentityposy#=(gridlayer*100)+tmpy#
        endif
        `
       endif
      endif
     endif
     selstage=1
    endif
    `
   endif
   `
   rem zoom into entity properties
   if inputsys.mclick=2 or inputsys.kscancode=211
    if gridentity<>0
     rem delete specified entity if RMB
     gridentitydelete=1
     selstage=1
    else
     if tentitytoselect>0
       `
       rem prepare zoom-in adjustment vars
       e=tentitytoselect
       gridentityinzoomview=e
       zoomviewtargetx#=entityelement(e).x
       zoomviewtargety#=entityelement(e).y
       zoomviewtargetz#=entityelement(e).z
       zoomviewtargetrx#=entityelement(e).rx
       zoomviewtargetry#=entityelement(e).ry
       zoomviewtargetrz#=entityelement(e).rz
       zoomviewcameraangle#=inputsys.xmousemove : zoomviewcameraangle#=0.0
       zoomviewcameraheight#=inputsys.ymousemove : zoomviewcameraheight#=125.0
       zoomviewcamerarange#=75.0
       `
       rem extract entity from the map
       gridentityeditorfixed=entityelement(e).editorfixed
       gridentitystaticmode=entityelement(e).staticflag
       gridentity=entityelement(e).bankindex
       gridentityposx#=entityelement(e).x
       gridentityposy#=entityelement(e).y
       gridentityposz#=entityelement(e).z
       gridentityrotatex#=entityelement(e).rx
       gridentityrotatey#=entityelement(e).ry
       gridentityrotatez#=entityelement(e).rz
       grideleprof=entityelement(e).eleprof
       gosub _gridedit_deleteentityfrommap
       shroudrefresh=1
       `
       rem zoom in to entity for fine detail
       cx#=entityelement(e).x
       cy#=entityelement(e).z*-1.0
       inputsys.doautozoomview=1
       hide object 5
       selstage=1
       `
       rem disable icons that interfere with zoom mode
       gosub _editor_disableforzoom
       `
       rem prepare entity property handler
       gosub _interface_openpropertywindow
       `
     endif
    endif
   endif
   `
   rem gridentity delete
   if gridentitydelete=1
    gridentitydelete=0
    if gridentityobj=0
     delete object gridentityobj
     gridentityobj=0
    endif
    shroudrefresh=1
    gridentity=0
   endif
   `
  endif
  if inputsys.mclick=0 and selstage=1
   selstage=0
  endif
 endif
 if sustainselectareafortrigger=0 and grideditselect<>1
  if showselectboundbox=1 and gridentitytriggerareaselect=0
   hide object 3 : hide object 4
   showselectboundbox=0
  endif
 endif
 `
 rem Select Bound Box 'Stripy Block Highlighter'
 if showselectboundbox=1
  if twid>0 then scale object texture 3,1.0/(twid/25),1.0/(tdep/25)
  twid=((sel2mmx-sel1mmx)+1)*100
  thig=((sel2layer-sel1layer)+1)*100
  tdep=((sel2mmy-sel1mmy)+1)*100
  scale object 3,twid,thig,tdep
  position object 3,(sel1mmx*100)+(twid/2),(thig/2)+(sel1layer*100),(sel1mmy*-100)-(tdep/2)
  scale object texture 3,twid/25,tdep/25
  scroll object texture 3,0.03,0.0
  scale object 4,twid,thig,tdep
  position object 4,(sel1mmx*100)+(twid/2),(thig/2)+(sel1layer*100),(sel1mmy*-100)-(tdep/2)
 endif
 `
 rem end areaslect after range established and mouse released
 if gridentitytriggerareaselect=1
  if inputsys.mclick=0
   gridentitytriggerareaselect=0
  endif
 endif
 `
endif

return

_gridedit_save_test_map:

rem V104RC6 new to remove un-used segments
timestampactivity(0,"SAVETESTMAP: Shuffle bank")
gosub _segment_shufflebank

rem Save map data locally only (not to FPM)
timestampactivity(0,"SAVETESTMAP: Save map")
gosub _mapfile_savemap

rem Save segment bank
timestampactivity(0,"SAVETESTMAP: Save bank")
gosub _segment_savebank

rem Save entity elements
timestampactivity(0,"SAVETESTMAP: Save elements")
gosub _entity_savebank
gosub _entity_saveelementsdata

rem Save waypoints
timestampactivity(0,"SAVETESTMAP: Save waypoints")
gosub _waypoint_savedata

rem Save editor configuration
timestampactivity(0,"SAVETESTMAP: Save config")
gosub _editor_savecfg

rem X9 - 250308 - this ensures change flag does not use filemap port 1 (avoid freeze in build game)
lastprojectmodified=0

rem Set modification flag
timestampactivity(0,"SAVETESTMAP: Change modified flag of level")
projectmodified=0 : gosub _gridedit_changemodifiedflag
timestampactivity(0,"SAVETESTMAP: Complete")

return

_gridedit_save_map:

rem Proper saving message to user
if recoverdonotuseany3dreferences=0
 gosub _editor_hideall3d
endif

rem Use large prompt
statusbar$=strarr$(365) : popup_text(statusbar$)

rem Save only to TESTMAP area (for map testing)
gosub _gridedit_save_test_map

rem Now store all part-files into main FPM project
gosub _mapfile_saveproject_fpm

rem Add Latest project To Recent List
gosub _gridedit_updateprojectname

rem Clear status text
statusbar$="" : popup_text_close()

rem FPSXV104RC6 - refresh as SAVE can remove entities and segments
if entityorsegmententrieschanged=1
 entityorsegmententrieschanged=0
 gosub _gridedit_load_map
endif

return

_gridedit_updatemapbeforeedit:

rem Completely reset filemap (and interface parts ie library)
gosub _editor_filemapinit

rem Clear refmap
undim refmap()
dim refmap(layermax,maxx,maxy)

rem Recreate arrays
mastermeshmax=0
mastermeshsize=1
mastermeshsets=1
currentmeshobject=101
dim mapentries(mastermeshsize,mastermeshsets,40,40) as mapentriestype
dim mastermesh(mastermeshsize,mastermeshsets) as mastermeshtype

rem Add all entity element to map
if entityelementlist>0
 for e=1 to entityelementlist
  if entityelement(e).bankindex>0
   addtobufferref=0 : gosub _gridedit_addentityreftomap
  endif
 next e
endif

rem Delete any segments that no longer exist(segment file moved/deleted)
for layer=0 to layermax
 for my=0 to maxy
  for mx=0 to maxx
   rem Delete any base segments
   mapid=map(layer,mx,my)
   gosub _gridedit_getmapvalues
   sourceobj=selectionbankoffset+mapselection
   if sourceobj>0
    if object exist(sourceobj)=0
     map(layer,mx,my)=0
    endif
   endif
   rem Delete any overlay segments
   olayindex=mapolay(layer,mx,my)
   if olayindex>0
    tiwrite=0
    for tiread=0 to 50
     mapid=olaylist(olayindex,tiread)
     if mapid<>0
      gosub _gridedit_getmapvalues
      sourceobj=selectionbankoffset+mapselection
      if sourceobj>0
       if object exist(sourceobj)=0 then mapid=0
      endif
     endif
     olaylist(olayindex,tiwrite)=mapid
     if mapid>0
      inc tiwrite
     else
      exit
     endif
    next tiread
   endif
   rem Also remove link if eaten ALL list
   if olaylist(olayindex,0)=0
    mapolay(layer,mx,my)=0
   endif
  next mx
 next my
next layer

rem Recreate new map
for layer=0 to layermax
 for my=0 to maxy
  for mx=0 to maxx
   rem setup current tile
   tbuffer=0 : tlayer=layer  : tx=mx : ty=my
   rem add any tile
   tmapid=map(layer,mx,my)
   if tmapid<>0 then gosub _gridedit_addtile
  next mx
 next my
next layer

rem Remove grid (so it is recreated larger if required)
if object exist(1)=1 then delete object 1

rem Newly loaded map starts at layer one
gridlayer=5 : shroudrefresh=1
gosub _gridedit_updatelayershades

return

_gridedit_clear_settings:

rem Default settings
gosub _gridedit_clear_configsettings
gridscale#=((800/2)/8)/gridzoom#
currentprojectfilename$=""
gridground=0
gridselection=1
bufferlayer=-1
gridlayershowsingle=0
grideditartwidth=1
grideditartwidthx=1
grideditartwidthy=1
locallibrarysegidmaster=0
locallibraryentidmaster=0

return

_gridedit_clear_configsettings:
 cx#=800*gridzoom# : cy#=600*gridzoom#
 gridzoom#=1.0
 nogridsmart=-1
 gridlayer=5
 shroudsize=shroudsizedefaultsize
 grideditartmode=1
 grideditselect=0
return

_gridedit_clear_map:

rem Destroy old objects
if mastermeshmax>0
 for m=1 to mastermeshmax
  for s=0 to mastermeshsets
   obj=mastermesh(m,s).obj
   if object exist(obj)=1 then delete object obj
  next s
 next m
endif

rem Destroy old data
undim mapentries()
undim mastermesh()

rem Set modification flag
projectmodified=0 : gosub _gridedit_changemodifiedflag

return

_gridedit_new_map:

rem No project - new map
projectfilename$="" : projectmodified=0 : lastprojectmodified=0
gosub _gridedit_updateprojectname

rem Load map data
gosub _editor_hideall3d
statusbar$=strarr$(366) : gosub _gridedit_updatestatusbar

rem Clear all settings
gosub _gridedit_clear_settings

rem Clear map first
gosub _gridedit_clear_map

rem Delete all assets of map work
gosub _segment_deletebank
gosub _entity_deletebank
gosub _entity_deleteelementsdata
gosub _waypoint_deleteall
gosub _mapfile_newmap

rem Load in 'floor segment' for horizon feature
segidmaster=1
selectionbank$(1)="common\ground.fps"
`
rem Localisation must find desc name of ground
tflocalfilename$="languagebank\"+language$+"\textfiles\library\segments\"+selectionbank$(1)
tflocalfilename$=left$(tflocalfilename$,len(tflocalfilename$)-4)+".loc"
if file exist(tflocalfilename$)=1
 dim tflocal$(1)
 load array tflocalfilename$,tflocal$()
 selectionbanklocal$(1)=tflocal$(0)
 undim tflocal$()
endif
`
rem load the segment in
if segidmaster>0
 segdir$="segments\"
 for segid=1 to segidmaster
  seg$=selectionbank$(segid)
  segcategory$=getfirstdir(seg$)
  segpath$=getseconddir(seg$)
  gosub _segment_load
 next segid
endif

rem Update remaining map data before editing
gosub _gridedit_updatemapbeforeedit

rem Some default setup for new scene (load markers)
gosub _editor_filemapdefaultinitfornew

rem Reset cursor
grideditselect=0 : gosub _editor_refresheditmarkers

rem Clear status text
statusbar$="" : gosub _gridedit_updatestatusbar

return

_gridedit_updatestatusbar:
 if statusbar$<>laststatusbar$
  open file map 1,"FPSEXCHANGE"
  set file map string$ 1, 4000, statusbar$
  wait for file map event 1
  close file map 1
  laststatusbar$=statusbar$
 endif
return

_gridedit_load_map:

rem Load map data
gosub _editor_hideall3d

rem Use large prompt
statusbar$=strarr$(367) : popup_text(statusbar$)

rem Load FPM project into testmap files area
tloadsuccessfully=1
if skipfpmloading=1
 rem replace NEW with RELOAD
 open file map 1,"FPSEXCHANGE"
 set file map DWORD 1, 408, 0
 wait for file map event 1
 close file map 1
else
 rem this setstloadsuccessfully to zero if failed to load FPM (corrupt zipfile)
 gosub _mapfile_loadproject_fpm
endif

rem Loaded successfully
if tloadsuccessfully=1
 `
 rem Clear map first
 gosub _gridedit_clear_map
 `
 rem Load segment bank
 popup_text_change(strarr$(610))
 gosub _segment_loadbank
 `
 rem Load entity bank and elements
 popup_text_change(strarr$(611))
 gosub _entity_loadbank
 gosub _entity_loadelementsdata
 gosub _entity_applyuniquetextureandeffects
 `
 rem Load waypoints
 popup_text_change(strarr$(612))
 gosub _waypoint_loaddata
 gosub _waypoint_recreateobjs
 `
 rem Load data
 popup_text_change(strarr$(613))
 gosub _mapfile_loadmap
 `
 rem Update remaining map data before editing
 gosub _gridedit_updatemapbeforeedit
 `
 rem Load editor configuration
 gosub _editor_loadcfg
 `
 rem Load segments/prefab/entities into window
 open file map 1,"FPSEXCHANGE"
 gosub _editor_filllibrary
 close file map 1
 `
 rem Add Latest project To Recent List
 gosub _gridedit_updateprojectname
 `
else
 `
 rem FPM could not be extracted (likely a corrupt zipfile)
 popup_text_change(strarr$(614))
 sleep 2000
 `
 rem Create blank in this case
 gosub _gridedit_new_map
 `
endif

rem Popup warning if load found some missing files
if timestampactivityflagged=1
 rem message prompt
 statusbar$=strarr$(368)
 popup_text_change(statusbar$) : sleep 2000
 timestampactivityflagged=0
 rem copy time stamp log to mapbank log
 if array count(missingmedia$())>=0
  tmblogfile$=left$(projectfilename$,len(projectfilename$)-4)+".log"
  if file exist(tmblogfile$)=1 then delete file tmblogfile$
  if len(tmblogfile$)>4
   missingmedia$(0)="MISSING MEDIA:"
   save array tmblogfile$,missingmedia$()
  endif
 endif
endif
if array count(missingmedia$())>=0
 undim missingmedia$()
endif
missingmediacounter=0

rem Clear status text
statusbar$="" : popup_text_close()

rem Quick update of cursors and editor graphics
lastgrideditselect=-1 : gosub _editor_refresheditmarkers

return

_gridedit_changemodifiedflag:
 `
 rem project flag changed, update window text
 if lastprojectmodified<>projectmodified
  lastprojectmodified=projectmodified
  gosub _gridedit_updateprojectname
 endif
 `
return

_gridedit_updateprojectname:
 open file map 1,"FPSEXCHANGE"
 rem add to project title
 if lower$(left$(projectfilename$,len(rootdir$)))=lower$(rootdir$)
  tprojname$=right$(projectfilename$,len(projectfilename$)-len(rootdir$))
 else
  tprojname$=projectfilename$
 endif
 if projectmodified<>0 then tprojname$=tprojname$+"*"
 set file map string$ 1, 1000, tprojname$
 set file map dword 1, 416, 1
 wait for file map event 1
 while get file map dword(1, 416)=1
  wait for file map event 1
 endwhile
 rem add to recent files list
 if projectfilename$<>""
  set file map string$ 1, 1000, projectfilename$
  set file map dword 1, 438, 1
  wait for file map event 1
  while get file map dword(1, 438)=1
   wait for file map event 1
  endwhile
 endif
 close file map 1
return

_gridedit_intercept_savefirst:
 editorcanceltask=0
 if projectmodified=1
  open file map 1,"FPSEXCHANGE"
  set file map string$ 1, 1000, strarr$(369)
  set file map string$ 1, 1256, strarr$(370)
  set file map dword 1, 900, 2
  wait for file map event 1
  while get file map dword(1, 900)<>0
   wait for file map event 1
  endwhile
  tokay=get file map dword(1, 904)
  close file map 1
  rem refresh 3d view so dialog box not left black box
  for tsync=1 to 5 : sync : sleep 10 : next tsync
  if tokay=1
   rem yes save first
   gosub _gridedit_save_map_ask
   projectmodified=0 : gosub _gridedit_changemodifiedflag
  endif
  if tokay=2
   rem task cancelled
   editorcanceltask=1
  endif
 endif
return

_gridedit_open_map_ask:
 rem SAVE CURRENT (IF ANY)
 editorcanceltask=0
 if projectmodified=1
  rem If project modified, ask if want to save first
  gosub _gridedit_intercept_savefirst
 endif
 if editorcanceltask=0
  rem OPEN FPM
  open file map 1,"FPSEXCHANGE"
  set file map string$ 1, 1000, rootdir$+"mapbank\"
  set file map string$ 1, 1256, strarr$(371)
  set file map string$ 1, 1512, strarr$(372)
  set file map dword 1, 424, 1
  wait for file map event 1
  while get file map dword(1, 424)=1
   wait for file map event 1
  endwhile
  returnstring$=get file map string$(1, 1000)
  close file map 1
  rem refresh 3d view so dialog box not left black box
  for tsync=1 to 5 : sync : sleep 10 : next tsync
  if returnstring$<>""
   if lower$(right$(returnstring$,4))=".fpg"
    currentFPG$=right$(returnstring$,len(returnstring$)-len(rootdir$+"languagebank\"+language$+"\gamebank\"))
    gosub _interface_loadlevelFPMfrombuildgame
    rem extract FPM from level one of FPG
    projectfilename$=rootdir$+levelfpi$
    gosub _gridedit_load_map
   else
    if lower$(right$(returnstring$,4))=".fpm"
     projectfilename$=returnstring$
     gosub _gridedit_load_map
    else
     rem error bleep - not a FPG file!
    endif
   endif
   rem update to interface due to any gmultiplayergame change (from FPM load)
   gosub _arenamode_update
  endif
 endif
return

_gridedit_new_map_ask:
 rem SAVE CURRENT (IF ANY)
 editorcanceltask=0
 if projectmodified=1
  rem If project modified, ask if want to save first
  gosub _gridedit_intercept_savefirst
 endif
 rem refresh 3d view so dialog box not left black box
 for tsync=1 to 5 : sync : sleep 10 : next tsync
 if editorcanceltask=0
  rem NEW MAP
  gosub _gridedit_new_map
  rem update to interface due to any gmultiplayergame change
  if inputsys.donewarena=1
   rem Arena Mode
   gmultiplayergame=1 : gosub _arenamode_update
  else
   rem Single Player Level
   gmultiplayergame=0 : gosub _arenamode_update
  endif
 endif
return

_gridedit_save_map_ask:
 if projectfilename$=""
  gosub _gridedit_saveas_map
 else
  gosub _gridedit_save_map
 endif
return

_gridedit_saveas_map:
 rem SAVE AS DIALOG
 open file map 1,"FPSEXCHANGE"
 set file map string$ 1, 1000, rootdir$+"mapbank\"
 set file map string$ 1, 1256, strarr$(373)
 set file map string$ 1, 1512, strarr$(374)
 set file map dword 1, 428, 1
 wait for file map event 1
 while get file map dword(1, 428)=1
  wait for file map event 1
 endwhile
 returnstring$=get file map string$(1, 1000)
 close file map 1
 rem refresh 3d view so dialog box not left black box
 for tsync=1 to 5 : sync : sleep 10 : next tsync
 if returnstring$<>""
  if lower$(right$(returnstring$,4))<>".fpm" then returnstring$=returnstring$+".fpm"
  projectfilename$=returnstring$
  gosub _gridedit_save_map
 endif
return

_gridedit_rotatebuffermap:

rem temp array
newbuffermaxx=buffermaxy
newbuffermaxy=buffermaxx
dim storebuffermap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim storebufferrefmap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim storebuffermapolay(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)

rem store map data in rotation order
for layer=0 to bufferlayer
 for my=0 to buffermaxy
  for mx=0 to buffermaxx
   storebuffermap(layer,buffermaxy-my,mx)=buffermap(layer,mx,my)
   storebufferrefmap(layer,buffermaxy-my,mx)=bufferrefmap(layer,mx,my)
   storebuffermapolay(layer,buffermaxy-my,mx)=buffermapolay(layer,mx,my)
  next mx
 next my
next layer

rem put map data back in from store
undim buffermap()
undim bufferrefmap()
undim buffermapolay(0)
dim buffermap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim bufferrefmap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim buffermapolay(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
for layer=0 to bufferlayer
 for my=0 to newbuffermaxy
  for mx=0 to newbuffermaxx
   mapid=storebuffermap(layer,mx,my)
   if mapid<>0
    gosub _gridedit_getmapvalues
    inc maprotate : if maprotate>3 then maprotate=0
    inc maporient : if maporient>3 then maporient=0
    writebuffermap(layer,mx,my,mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
   endif
   refptr=storebufferrefmap(layer,mx,my)
   if refptr<>0
    bufferrefmap(layer,mx,my)=refptr
   endif
   tolayindex=storebuffermapolay(layer,mx,my)
   buffermapolay(layer,mx,my)=tolayindex
  next mx
 next my
next layer

rem new dimensions
buffermaxx=newbuffermaxx
buffermaxy=newbuffermaxy

rem record rotation count
inc bufferrotationcount
if bufferrotationcount>3 then dec bufferrotationcount,4

rem free usages
undim storebuffermap()
undim storebufferrefmap()
undim storebuffermapolay()

return

_gridedit_createbuffermesh:

rem Create mesh from buffermap
for layer=0 to bufferlayer
 for my=0 to buffermaxy
  for mx=0 to buffermaxx
   tbuffer=1 : tlayer=layer  : tx=mx : ty=my
   tmapid=buffermap(layer,mx,my)
   if tmapid<>0 then gosub _gridedit_addtile
   trefptr=bufferrefmap(layer,mx,my)
   if trefptr<>0
    refptr=trefptr+4 : e=*refptr
    gosub _gridedit_calctentitymesh
    gosub _gridedit_addentity
   endif
  next mx
 next my
next layer

return

_gridedit_deletebuffermesh:

rem Delete buffer meshes
if mastermeshmax>0
 for m=1 to mastermeshmax
  for s=0 to mastermeshsets
   if mastermesh(m,s).buffer=1
    obj=mastermesh(m,s).obj
    mastermesh(m,s).buffer=-1
    if object exist(obj)=1 then delete object obj
   endif
  next s
 next m
endif

return

_gridedit_updatelayershades:

rem assign fades to layers (FOR BLUEPRINT)
if mastermeshmax>0
 for m=1 to mastermeshmax
  if mastermesh(m).buffer=0
   for s=0 to mastermeshsets
    obj=mastermesh(m,s).obj
    if object exist(obj)=1
     dist=gridlayer-mastermesh(m,s).layer
     if dist=0
      show object obj
      fade object obj,100
      ghost object off obj
     else
      if gridlayershowsingle>0
       hide object obj
      else
       show object obj
       if dist>0
        tfade=50-(dist*10)
        if tfade<0 then tfade=0
        fade object obj,tfade
        ghost object off obj
       else
        tfade=25-(abs(dist)*5)
        if tfade<0 then tfade=0
        fade object obj,tfade
        ghost object on obj
       endif
      endif
     endif
    endif
   next s
  endif
 next m
endif

return

_gridedit_updatebufferobjects:

rem assign fades to layers (FOR CLIPBOARD BUFFER)
thighestpointy#=50+2+(gridlayer*100)
if mastermeshmax>0
 for m=1 to mastermeshmax
  if mastermesh(m).buffer=1
   for s=0 to mastermeshsets
    obj=mastermesh(m,s).obj
    if object exist(obj)=1
     if inputsys.activemouse=0
      hide object obj
     else
      tpointy#=50+2+(gridlayer*100)+(mastermesh(m,s).layer*100)
      if tpointy#>thighestpointy# then thighestpointy#=tpointy#
      position object obj,(inputsys.mmx*100)+50,tpointy#,(inputsys.mmy*-100)-50
      disable object zdepth obj
      ghost object on obj
      if mastermesh(m,s).layer=0
       fade object obj,100
      else
       fade object obj,40
      endif
      show object obj
     endif
    endif
   next s
  endif
 next m
endif

rem show arrow when clipboard in use
if bufferlayer<>-1
   if object exist(6)=1
 position object 6,(inputsys.mmx*100)+50+(buffermaxx*50),thighestpointy#+10,(inputsys.mmy*-100)-50-(buffermaxy*50)
 yrotate object 6,wrapvalue(bufferrotationcount*90)
 show object 6
else
 hide object 6
 endif
endif

return

_gridedit_updatetile:

rem two iterations (as corners need final walls to make calc)
stmx=mx : stmy=my
for ttwoiters=0 to 1
 for scy=upy-1 to upy+1
  for scx=upx-1 to upx+1
    if scx>=0 and scx<maxx
     if scy>=0 and scy<maxy
      if scx<>upx or scy<>upy or updatealltiles=1
       mapid=map(uplayer,scx,scy)
       if mapid<>0
        gosub _gridedit_getmapvalues
        if mapground<4
         layer=uplayer : mx=scx : my=scy
         addgridselection=mapselection
         addgridscaler=mapscaler
         addgridground=mapground
         addgridorient=maporient
         addgridsymbol=mapsymbol
         addoffsetx=scx-upx : addoffsety=scy-upy
         if addremovenotadd=1
          if nogridsmart=-1
           gosub _gridedit_addtogridmap
          else
           if nogridsmart=0
            rem opposite wall remove, but ONLY for the tile containing that wall, else default
            tokay=0
            if gridorient=3 and addoffsetx=-1 and addoffsety= 0 then tokay=1
            if gridorient=0 and addoffsetx= 0 and addoffsety=-1 then tokay=1
            if gridorient=1 and addoffsetx= 1 and addoffsety= 0 then tokay=1
            if gridorient=2 and addoffsetx= 0 and addoffsety= 1 then tokay=1
            if tokay=1
             gosub _gridedit_deletefromgridmap
            else
             gosub _gridedit_addtogridmap
            endif
           else
            gosub _gridedit_addtogridmap
           endif
          endif
         else
          gosub _gridedit_addtogridmap
         endif
        endif
       endif
      endif
     endif
    endif
  next scx
 next scy
next ttwoiters
mx=stmx : my=stmy

rem vars used to indicate to addtile if direct-tile or update-tile
addoffsetx=0 : addoffsety=0

return

_gridedit_calctile:

 rem calc local grid coord
 tmasterx=tx/40 : tlx=tx-(tmasterx*40)
 tmastery=ty/40 : tly=ty-(tmastery*40)

 rem vars to set
 currentmastermesh=-1 : obj=-1

 rem find object holding grid mesh
 if mastermeshmax>0
  for m=1 to mastermeshmax
   if mastermesh(m,0).buffer=tbuffer and mastermesh(m,0).layer=tlayer and mastermesh(m,0).worldx=tmasterx and mastermesh(m,0).worldy=tmastery
    obj=mastermesh(m,0).obj
    currentmastermesh=m
    m=mastermeshmax+1
   endif
  next m
 endif

 rem if not found
 if obj=-1
  `
  rem if exceeding mastermesh array size, increase it
  if mastermeshmax>=mastermeshsize
   oldmastermeshsize=mastermeshsize
   if oldmastermeshsize>0
    dim storemapentries(oldmastermeshsize,mastermeshsets,40,40) as mapentriestype
    dim storemastermesh(oldmastermeshsize,mastermeshsets) as mastermeshtype
    for m=0 to oldmastermeshsize
     for s=0 to mastermeshsets
      storemastermesh(m,s).obj=mastermesh(m,s).obj
      storemastermesh(m,s).buffer=mastermesh(m,s).buffer
      storemastermesh(m,s).layer=mastermesh(m,s).layer
      storemastermesh(m,s).worldx=mastermesh(m,s).worldx
      storemastermesh(m,s).worldy=mastermesh(m,s).worldy
      for ly=0 to 40
       for lx=0 to 40
        storemapentries(m,s,lx,ly).vertmax1=mapentries(m,s,lx,ly).vertmax1
        storemapentries(m,s,lx,ly).vertmax2=mapentries(m,s,lx,ly).vertmax2
        storemapentries(m,s,lx,ly).indexmax1=mapentries(m,s,lx,ly).indexmax1
        storemapentries(m,s,lx,ly).indexmax2=mapentries(m,s,lx,ly).indexmax2
       next lx
      next ly
     next s
    next m
    undim mastermesh()
    undim mapentries()
   endif
   inc mastermeshsize,10
   dim mapentries(mastermeshsize,mastermeshsets,40,40) as mapentriestype
   dim mastermesh(mastermeshsize,mastermeshsets) as mastermeshtype
   if oldmastermeshsize>0
    for m=0 to oldmastermeshsize
     for s=0 to mastermeshsets
      mastermesh(m,s).obj=storemastermesh(m,s).obj
      mastermesh(m,s).buffer=storemastermesh(m,s).buffer
      mastermesh(m,s).layer=storemastermesh(m,s).layer
      mastermesh(m,s).worldx=storemastermesh(m,s).worldx
      mastermesh(m,s).worldy=storemastermesh(m,s).worldy
      for ly=0 to 40
       for lx=0 to 40
        mapentries(m,s,lx,ly).vertmax1=storemapentries(m,s,lx,ly).vertmax1
        mapentries(m,s,lx,ly).vertmax2=storemapentries(m,s,lx,ly).vertmax2
        mapentries(m,s,lx,ly).indexmax1=storemapentries(m,s,lx,ly).indexmax1
        mapentries(m,s,lx,ly).indexmax2=storemapentries(m,s,lx,ly).indexmax2
       next lx
      next ly
     next s
    next m
    undim storemastermesh()
    undim storemapentries()
   endif
  endif
  `
  rem see if a mastermesh slot is spare
  tokay=-1
  if mastermeshmax>0
   for m=1 to mastermeshmax
    if mastermesh(m,0).buffer=-1
     tokay=m : m=mastermeshmax+1
    endif
   next m
  endif
  `
  rem create new master mesh
  if tokay=-1
   rem new slot
   inc mastermeshmax
   m=mastermeshmax
   mastermesh(m,0).obj=currentmeshobject+1
   mastermesh(m,1).obj=currentmeshobject+2
   inc currentmeshobject,2
  else
   rem existing slot and obj number
   m=tokay
  endif
  `
  for s=0 to mastermeshsets
   mastermesh(m,s).buffer=tbuffer
   mastermesh(m,s).layer=tlayer
   mastermesh(m,s).worldx=tmasterx
   mastermesh(m,s).worldy=tmastery
  next s
  obj=mastermesh(m,0).obj
  currentmastermesh=m
  `
 endif

return

_gridedit_addtile:

 rem calculate local coords
 gosub _gridedit_calctile

 rem work out map values
 mapid=tmapid
 mapmeshoffset=100
 gosub _gridedit_getmapvalues
 if mapground=1 then mapmeshoffset=116
 if mapground=2 then mapmeshoffset=132
 if mapground=3 then mapmeshoffset=148
 tmeshindex=mapmeshoffset+maptile

 rem copy mesh into obj
 tlockforset=0
 trotate#=maprotate*90
 gosub _gridedit_lockandcopy

return

_gridedit_addentity:

 rem calculate local coords
 gosub _gridedit_calctile

 rem Choose mesh representing entity
 tmeshindex=tentitymesh

 rem copy mesh into (obj+1)=entity set
 tlockforset=1
 obj=obj+1 : trotate#=0
 gosub _gridedit_lockandcopy

return

_gridedit_lockandcopy:

 rem Make object
 if object exist(obj)=0
  make object box obj,0,0,0
  set object collision off obj
  set object cull obj,0
  set object transparency obj,1
  position object obj,50+(tmasterx*4000),(tlayer*100)+(50-(tlockforset*50)),-50+(tmastery*-4000)
  set object filter obj,0
  set object texture obj,0,0
  texture object obj,editorimagesoffset+tlockforset
  if tlockforset=1 then disable object zwrite obj
  inc objadd
 endif

 rem lock vertexdata
 lock vertexdata for limb obj,0

 rem add mesh and record entries
 vertmax1=get vertexdata vertex count()
 indexmax1=get vertexdata index count()
 add mesh to vertexdata tmeshindex
 vertmax2=get vertexdata vertex count()
 indexmax2=get vertexdata index count()

 rem Lock and Copy For Map Tile Geometry
 if tlockforset=0
 `
 rem Customise uv data
 if mapsymbol>0

  rem Calcuate texture uv for symbol
  tsymboltexture=15+mapsymbol
  tv=tsymboltexture/8 : tu=tsymboltexture-(tv*8)
  s#=1.0/8.0 : u#=s#*tu : v#=s#*tv
  `
  rem Rotate uv data based on rotation
  meshmaprot=maprotate-maporient
  if meshmaprot<0 then inc meshmaprot,4
  if meshmaprot=0
   tc1u#=u# : tc1v#=v#
   tc2u#=u# : tc2v#=v#+s#
   tc3u#=u#+s# : tc3v#=v#+s#
   tc4u#=u#+s# : tc4v#=v#
  endif
  if meshmaprot=1
   tc1u#=u#+s# : tc1v#=v#
   tc2u#=u# : tc2v#=v#
   tc3u#=u# : tc3v#=v#+s#
   tc4u#=u#+s# : tc4v#=v#+s#
  endif
  if meshmaprot=2
   tc1u#=u#+s# : tc1v#=v#+s#
   tc2u#=u#+s# : tc2v#=v#
   tc3u#=u# : tc3v#=v#
   tc4u#=u# : tc4v#=v#+s#
  endif
  if meshmaprot=3
   tc1u#=u# : tc1v#=v#+s#
   tc2u#=u#+s# : tc2v#=v#+s#
   tc3u#=u#+s# : tc3v#=v#
   tc4u#=u# : tc4v#=v#
  endif

  rem Customise uv data
  if mapmeshoffset=100 then tvert=3
  if mapmeshoffset=116 then tvert=3
  if mapmeshoffset=132 then tvert=3
  if mapmeshoffset=148 then tvert=3
  set vertexdata uv vertmax1+(tvert*4)+0,tc1u#,tc1v#
  set vertexdata uv vertmax1+(tvert*4)+1,tc2u#,tc2v#
  set vertexdata uv vertmax1+(tvert*4)+2,tc3u#,tc3v#
  set vertexdata uv vertmax1+(tvert*4)+3,tc4u#,tc4v#

 endif

 rem Customise position data for cube meshes only
 if mapmeshoffset=100 or mapmeshoffset=116 or mapmeshoffset=132 or mapmeshoffset=148
  segid=mapselection
  if segmentprofile(segid).blueprint.floorsizey<>-1
  `
  rem Rotate mapscaler based on rotation
  meshscaler1 = (mapscaler && %0001)
  meshscaler2 = (mapscaler && %0010)>>1
  meshscaler3 = (mapscaler && %0100)>>2
  meshscaler4 = (mapscaler && %1000)>>3
  select maprotate
   case 0 : meshscaler = mapscaler : endcase
   case 1 : meshscaler = (meshscaler4) + (meshscaler1<<1) + (meshscaler2<<2) + (meshscaler3<<3) : endcase
   case 2 : meshscaler = (meshscaler3) + (meshscaler4<<1) + (meshscaler1<<2) + (meshscaler2<<3) : endcase
   case 3 : meshscaler = (meshscaler2) + (meshscaler3<<1) + (meshscaler4<<2) + (meshscaler1<<3) : endcase
  endselect
  `
  rem Resize mesh
  tsc#=99.8/2.0
  tfly#=segmentprofile(segid).blueprint.floorsizey/100.0
  tsdx#=segmentprofile(segid).blueprint.sidesizex/100.0
  tsdy#=segmentprofile(segid).blueprint.sidesizey/100.0
  tsdz#=segmentprofile(segid).blueprint.sidesizez/100.0
  tscx1#=tsc#*tsdx#*-1
  tscy1#=((tsc#*1.0)*-1)
  tscz1#=tsc#*tsdz#*-1
  tscx2#=tsc#*tsdx#
  tfly2#=((tsc#*1.0)*-1)+(tfly#*(tsc#*2))
  tscy2#=((tsc#*1.0)*-1)+(tsdy#*(tsc#*2))
  tscz2#=tsc#*tsdz#

  rem z+
  tvert=0
  for t=0 to 3
   if t=0 then x#=tscx1# : y#=tscy2# : z#=tscz1#
   if t=1 then x#=tscx1# : y#=tscy1# : z#=tscz1#
   if t=2 then x#=tscx2# : y#=tscy1# : z#=tscz1#
   if t=3 then x#=tscx2# : y#=tscy2# : z#=tscz1#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %0001)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem z-
  tvert=1
  for t=0 to 3
   if t=0 then x#=tscx1# : y#=tscy2# : z#=tscz2#
   if t=1 then x#=tscx1# : y#=tscy1# : z#=tscz2#
   if t=2 then x#=tscx2# : y#=tscy1# : z#=tscz2#
   if t=3 then x#=tscx2# : y#=tscy2# : z#=tscz2#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %0100)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem x+
  tvert=4
  for t=0 to 3
   if t=0 then x#=tscz2# : y#=tscy2# : z#=tscx1#
   if t=1 then x#=tscz2# : y#=tscy1# : z#=tscx1#
   if t=2 then x#=tscz2# : y#=tscy1# : z#=tscx2#
   if t=3 then x#=tscz2# : y#=tscy2# : z#=tscx2#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %0010)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem x -
  tvert=5
  for t=0 to 3
   if t=0 then x#=tscz1# : y#=tscy2# : z#=tscx1#
   if t=1 then x#=tscz1# : y#=tscy1# : z#=tscx1#
   if t=2 then x#=tscz1# : y#=tscy1# : z#=tscx2#
   if t=3 then x#=tscz1# : y#=tscy2# : z#=tscx2#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %1000)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem y+
  tvert=2
  for t=0 to 3
   if t=0 then x#=-50 : y#=tfly2# : z#=50
   if t=1 then x#=50 : y#=tfly2# : z#=50
   if t=2 then x#=50 : y#=tfly2# : z#=-50
   if t=3 then x#=-50 : y#=tfly2# : z#=-50
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
 endif
 endif
 `
 rem endif for Map Tile Geometry
 endif

 rem Lock and Copy For Entity Tile Geometry
 if tlockforset=1
 `
 `
 endif

 rem store entries (so we can delete later)
 mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax1=vertmax1
 mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax1=indexmax1
 mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2=vertmax2
 mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax2=indexmax2

 rem prepare scale, rotate, offset
 R=MAKE MATRIX4(1)
 R=MAKE MATRIX4(2)
 SET IDENTITY MATRIX4 1
 SET IDENTITY MATRIX4 2
 ROTATE Y MATRIX4 1,trotate#*(3.141592654/180.0)
 TRANSLATE MATRIX4 2,tlx*100,0,tly*-100
 MULTIPLY MATRIX4 1,1,2

 rem apply a transform to vertex data
 R=make vector3(2) : R=make vector3(3)
 R=make vector3(4) : R=make vector3(5)
 for v=vertmax1 to vertmax2-1
  `
  rem get vertex data
  x#=get vertexdata position x(v)
  y#=get vertexdata position y(v)
  z#=get vertexdata position z(v)
  SET VECTOR3 2,x#,y#,z#
  nx#=get vertexdata normals x(v)
  ny#=get vertexdata normals y(v)
  nz#=get vertexdata normals z(v)
  SET VECTOR3 3,nx#,ny#,nz#
  `
  rem transform vertex data for scale, rotate, offset
  TRANSFORM COORDS VECTOR3 4,2,1
  TRANSFORM NORMALS VECTOR3 5,3,1
  NORMALIZE VECTOR3 5,5
  `
  rem set new vertex data
  set vertexdata position v,x vector3(4),y vector3(4),z vector3(4)
  set vertexdata normals v,x vector3(5),y vector3(5),z vector3(5)
  `
 next v

 rem unlock vertexdata
 unlock vertexdata

return

_gridedit_removetile:

 rem calculate local coords
 gosub _gridedit_calctile

 rem Remove map tile
 tlockforset=0
 gosub _gridedit_lockanddelete

return

_gridedit_removeentity:

 rem calculate local coords
 gosub _gridedit_calctile

 rem Remove map tile
 obj=obj+1
 tlockforset=1
 gosub _gridedit_lockanddelete

return

_gridedit_lockanddelete:

 rem ensure valid for removal
 if mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2>0

  rem store entries (so we can delete later)
  vertmax1=mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax1
  indexmax1=mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax1
  vertmax2=mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2
  indexmax2=mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax2

  rem lock vertexdata
  lock vertexdata for limb obj,0

  rem delete mesh
  delete mesh from vertexdata vertmax1,vertmax2,indexmax1,indexmax2
  mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2=0

  rem unlock vertexdata
  unlock vertexdata

  rem must shuffle all v/i entries to keep track of existing meshes
  vgap=vertmax2-vertmax1
  igap=indexmax2-indexmax1
  for ly=0 to 40
   for lx=0 to 40
    if mapentries(currentmastermesh,tlockforset,lx,ly).vertmax1>vertmax1
     mapentries(currentmastermesh,tlockforset,lx,ly).vertmax1=mapentries(currentmastermesh,tlockforset,lx,ly).vertmax1-vgap
     mapentries(currentmastermesh,tlockforset,lx,ly).indexmax1=mapentries(currentmastermesh,tlockforset,lx,ly).indexmax1-igap
     mapentries(currentmastermesh,tlockforset,lx,ly).vertmax2=mapentries(currentmastermesh,tlockforset,lx,ly).vertmax2-vgap
     mapentries(currentmastermesh,tlockforset,lx,ly).indexmax2=mapentries(currentmastermesh,tlockforset,lx,ly).indexmax2-igap
    endif
   next lx
  next ly

 endif

return

_gridedit_refreshtile:

if wasmapid<>map(layer,mx,my)
 tbuffer=0 : tlayer=layer  : tx=mx : ty=my : tmapid=map(layer,mx,my)
 if map(layer,mx,my)<>0
  if wasmapid<>0 then gosub _gridedit_removetile
  gosub _gridedit_addtile
 else
  gosub _gridedit_removetile
 endif
endif

return

_gridedit_makemaskfromtile:
 `
 rem create mask from current maptile (left,top,right,bottom)
 rem and the corner data (lefttop,righttop,rightbottom,leftbottom)
 tamask=makemaskfromtile(maptile,maprotate)
 `
return

_gridedit_gettamask:
 `
 rem from map
 maptile=0 : maprotate=0
 mapid=map(layer,mx,my)
 if mapid<>0
  gosub _gridedit_getmapvalues
  addgridground=mapground
  addgridsymbol=mapsymbol
 else
  if nogridsmart=0
   rem WALL
   maprotate=gridorient : maptile=5
   addgridsymbol=1
  endif
  if nogridsmart=1
   rem FLOOR
   maprotate=gridorient : maptile=6
  endif
 endif
 `
 rem create mask from current maptile
 gosub _gridedit_makemaskfromtile
 `
return

_gridedit_filtercorners:
 `
 rem filter out corners if wall exists after above
 if tamask && %10000000 then tamask = tamask && %11110110
 if tamask && %01000000 then tamask = tamask && %11110011
 if tamask && %00100000 then tamask = tamask && %11111001
 if tamask && %00010000 then tamask = tamask && %11111100
 `
return

_gridedit_returntamask:
 `
 rem initial add vars
 addgridrotate=maprotate
 addmaptile=maptile
 `
 rem modify add vars with new mask
 select tamask

  case %11110000 : addmaptile=1 : addgridrotate=0 : endcase
  case %11010000 : addmaptile=2 : addgridrotate=0 : endcase
  case %11000000 : addmaptile=3 : addgridrotate=0 : endcase
  case %01010000 : addmaptile=4 : addgridrotate=0 : endcase
  case %01000000 : addmaptile=5 : addgridrotate=0 : endcase
  case %00000000 : addmaptile=6 : addgridrotate=0 : endcase
  case %00001000 : addmaptile=7 : addgridrotate=0 : endcase
  case %00001100 : addmaptile=8 : addgridrotate=0 : endcase
  case %00001010 : addmaptile=9 : addgridrotate=0 : endcase
  case %00001110 : addmaptile=10 : addgridrotate=0 : endcase
  case %00001111 : addmaptile=11 : addgridrotate=0 : endcase
  case %01000001 : addmaptile=12 : addgridrotate=0 : endcase
  case %01000010 : addmaptile=13 : addgridrotate=0 : endcase
  case %01000011 : addmaptile=14 : addgridrotate=0 : endcase
  case %11000010 : addmaptile=15 : addgridrotate=0 : endcase

`  case %11110000 : addmaptile=1 : addgridrotate=1 : endcase
  case %11100000 : addmaptile=2 : addgridrotate=1 : endcase
  case %01100000 : addmaptile=3 : addgridrotate=1 : endcase
  case %10100000 : addmaptile=4 : addgridrotate=1 : endcase
  case %00100000 : addmaptile=5 : addgridrotate=1 : endcase
`  case %00000000 : addmaptile=6 : addgridrotate=1 : endcase
  case %00000100 : addmaptile=7 : addgridrotate=1 : endcase
  case %00000110 : addmaptile=8 : addgridrotate=1 : endcase
  case %00000101 : addmaptile=9 : addgridrotate=1 : endcase
  case %00000111 : addmaptile=10 : addgridrotate=1 : endcase
`  case %00001111 : addmaptile=11 : addgridrotate=1 : endcase
  case %00101000 : addmaptile=12 : addgridrotate=1 : endcase
  case %00100001 : addmaptile=13 : addgridrotate=1 : endcase
  case %00101001 : addmaptile=14 : addgridrotate=1 : endcase
  case %01100001 : addmaptile=15 : addgridrotate=1 : endcase

`  case %11110000 : addmaptile=1 : addgridrotate=2 : endcase
  case %01110000 : addmaptile=2 : addgridrotate=2 : endcase
  case %00110000 : addmaptile=3 : addgridrotate=2 : endcase
  case %01010000 : addmaptile=4 : addgridrotate=2 : endcase
  case %00010000 : addmaptile=5 : addgridrotate=2 : endcase
`  case %00000000 : addmaptile=6 : addgridrotate=2 : endcase
  case %00000010 : addmaptile=7 : addgridrotate=2 : endcase
  case %00000011 : addmaptile=8 : addgridrotate=2 : endcase
  case %00001010 : addmaptile=9 : addgridrotate=2 : endcase
  case %00001011 : addmaptile=10 : addgridrotate=2 : endcase
`  case %00001111 : addmaptile=11 : addgridrotate=2 : endcase
  case %00010100 : addmaptile=12 : addgridrotate=2 : endcase
  case %00011000 : addmaptile=13 : addgridrotate=2 : endcase
  case %00011100 : addmaptile=14 : addgridrotate=2 : endcase
  case %00111000 : addmaptile=15 : addgridrotate=2 : endcase

`  case %11110000 : addmaptile=1 : addgridrotate=3 : endcase
  case %10110000 : addmaptile=2 : addgridrotate=3 : endcase
  case %10010000 : addmaptile=3 : addgridrotate=3 : endcase
  case %10100000 : addmaptile=4 : addgridrotate=3 : endcase
  case %10000000 : addmaptile=5 : addgridrotate=3 : endcase
`  case %00000000 : addmaptile=6 : addgridrotate=3 : endcase
  case %00000001 : addmaptile=7 : addgridrotate=3 : endcase
  case %00001001 : addmaptile=8 : addgridrotate=3 : endcase
  case %00000101 : addmaptile=9 : addgridrotate=3 : endcase
  case %00001101 : addmaptile=10 : addgridrotate=3 : endcase
`  case %00001111 : addmaptile=11 : addgridrotate=3 : endcase
  case %10000010 : addmaptile=12 : addgridrotate=3 : endcase
  case %10000100 : addmaptile=13 : addgridrotate=3 : endcase
  case %10000110 : addmaptile=14 : addgridrotate=3 : endcase
  case %10010100 : addmaptile=15 : addgridrotate=3 : endcase

 endselect
 `
 rem new system - 'sides control' construction
 writemap(layer,mx,my,addgridselection,addgridscaler,addgridground,addgridrotate,addgridorient,addgridsymbol,addmaptile)
 `
return

_gridedit_considercorners:
 `
 rem Possibility of intelegently adding corners where needed
 if mx>0 and my>0
  if (getmapmask(layer,mx-1,my) && %01000000)>0
   if (getmapmask(layer,mx,my-1) && %10000000)>0
    if (tamask && %11000000)=0 then tamask = tamask || %00001000
   endif
  endif
 endif
 if mx<maxx and my>0
  if (getmapmask(layer,mx+1,my) && %01000000)>0
   if (getmapmask(layer,mx,my-1) && %00100000)>0
    if (tamask && %01100000)=0 then tamask = tamask || %00000100
   endif
  endif
 endif
 if mx<maxx and my<maxy
  if (getmapmask(layer,mx+1,my) && %00010000)>0
   if (getmapmask(layer,mx,my+1) && %00100000)>0
    if (tamask && %00110000)=0 then tamask = tamask || %00000010
   endif
  endif
 endif
 if mx>0 and my<maxy
  if (getmapmask(layer,mx-1,my) && %00010000)>0
   if (getmapmask(layer,mx,my+1) && %10000000)>0
    if (tamask && %10010000)=0 then tamask = tamask || %00000001
   endif
  endif
 endif
 `
 rem Possibility of intelegently removal of corners where needed
 if mx>0 and my>0
  if (getmapmask(layer,mx-1,my) && %01000000)=0 or (getmapmask(layer,mx,my-1) && %10000000)=0
   if (tamask && %11000000)=0 then tamask = tamask && %11110111
  endif
 endif
 if mx<maxx and my>0
  if (getmapmask(layer,mx+1,my) && %01000000)=0 or (getmapmask(layer,mx,my-1) && %00100000)=0
   if (tamask && %01100000)=0 then tamask = tamask && %11111011
  endif
 endif
 if mx<maxx and my<maxy
  if (getmapmask(layer,mx+1,my) && %00010000)=0 or (getmapmask(layer,mx,my+1) && %00100000)=0
   if (tamask && %00110000)=0 then tamask = tamask && %11111101
  endif
 endif
 if mx>0 and my<maxy
  if (getmapmask(layer,mx-1,my) && %00010000)=0 or (getmapmask(layer,mx,my+1) && %10000000)=0
   if (tamask && %10010000)=0 then tamask = tamask && %11111110
  endif
 endif
 `
return

_gridedit_addtogridmap:
 `
 rem record current state
 wasmapid=map(layer,mx,my)
 `
 rem must erase old tile data so not influence new addition
 if tfreshgridadd=1 and nogridsmart=-1
  tmapid=map(layer,mx,my)
  if tmapid>0
   rem erase any entities on it
   rem erase tile
   map(layer,mx,my)=0
  endif
 endif
 `
 rem only add the set 'side'
 gosub _gridedit_gettamask
 `
 rem gridsmart system chooses best tile
 if nogridsmart=-1
  `
  rem vars used to indicate to addtile if direct-tile or update-tile
  if addoffsetx=0 and addoffsety=0
   rem default AUTO tile is all walls and floor (only direct-tile)
   tamask = %11110000
   rem force a floor for auto-full (only if not doing a buffer copy)
   if bufferlayer=-1 then addgridsymbol=0
   rem remove connected walls
   if mx>0
    if chkmapyes(layer,mx-1,my,addgridground)=1 then tamask = tamask && %01111111
   endif
   if mx<maxx
    if chkmapyes(layer,mx+1,my,addgridground)=1 then tamask = tamask && %11011111
   endif
   if my>0
    if chkmapyes(layer,mx,my-1,addgridground)=1 then tamask = tamask && %10111111
   endif
   if my<maxy
    if chkmapyes(layer,mx,my+1,addgridground)=1 then tamask = tamask && %11101111
   endif
  else
   rem update-tile only WALL in the direction of the direct-tile
   if mx-addoffsetx>=0 and mx-addoffsetx<=maxx and my-addoffsety>=0 and my-addoffsety<=maxy
    if chkmapyes(layer,mx-addoffsetx,my-addoffsety,addgridground)=1
     rem Remove wall to interconnect room
     if addoffsetx=-1 and addoffsety=-1 then tamask = tamask && %11111101
     if addoffsetx= 0 and addoffsety=-1 then tamask = tamask && %11101111
     if addoffsetx= 1 and addoffsety=-1 then tamask = tamask && %11111110
     if addoffsetx=-1 and addoffsety= 0 then tamask = tamask && %11011111
     if addoffsetx= 1 and addoffsety= 0 then tamask = tamask && %01111111
     if addoffsetx=-1 and addoffsety= 1 then tamask = tamask && %11111011
     if addoffsetx= 0 and addoffsety= 1 then tamask = tamask && %10111111
     if addoffsetx= 1 and addoffsety= 1 then tamask = tamask && %11110111
    else
     rem Add wall if no room to connect to
     if addoffsetx=-1 and addoffsety=-1 then tamask = tamask || %00000010
     if addoffsetx= 0 and addoffsety=-1 then tamask = tamask || %00010000
     if addoffsetx= 1 and addoffsety=-1 then tamask = tamask || %00000001
     if addoffsetx=-1 and addoffsety= 0 then tamask = tamask || %00100000
     if addoffsetx= 1 and addoffsety= 0 then tamask = tamask || %10000000
     if addoffsetx=-1 and addoffsety= 1 then tamask = tamask || %00000100
     if addoffsetx= 0 and addoffsety= 1 then tamask = tamask || %01000000
     if addoffsetx= 1 and addoffsety= 1 then tamask = tamask || %00001000
    endif
   endif
  endif
  `
 rem nosmart else
 else
  `
  rem direct-tile-add-one-X
  if addoffsetx=0 and addoffsety=0
   if nogridsmart=0
    rem WALL - TOP
    if gridorient=0
     tamask = tamask || %01000000
    endif
    rem RIGHT
    if gridorient=1
     tamask = tamask || %00100000
    endif
    rem BOTTOM
    if gridorient=2
     tamask = tamask || %00010000
    endif
    rem LEFT
    if gridorient=3
     tamask = tamask || %10000000
    endif
   endif
   if nogridsmart=1
    rem FLOOR
    addgridsymbol=0
   endif
  else
   if nogridsmart=0
    rem must add a reverse-version of wall (intele)
    if gridorient=3 and addoffsetx=-1 and addoffsety= 0 then tamask = tamask || %00100000
    if gridorient=0 and addoffsetx= 0 and addoffsety=-1 then tamask = tamask || %00010000
    if gridorient=1 and addoffsetx= 1 and addoffsety= 0 then tamask = tamask || %10000000
    if gridorient=2 and addoffsetx= 0 and addoffsety= 1 then tamask = tamask || %01000000
   endif
   if nogridsmart=1
    rem FLOOR
   endif
  endif
  `
 rem nosmart endif
 endif
 `
 rem Possibility of intelegently adding corners where needed
 gosub _gridedit_considercorners
 `
 rem filter out corners if wall exists after above
 gosub _gridedit_filtercorners
 `
 rem recreate maptile from new mask
 gosub _gridedit_returntamask
 `
 rem if changed, update grid
 gosub _gridedit_refreshtile
 `
return

_gridedit_deletefromgridmap:
 `
 rem record current state
 wasmapid=map(layer,mx,my)
 `
 rem only delete set 'side'
 gosub _gridedit_gettamask
 `
 rem in the case of deletes, assume the mapselection id
 addgridselection=mapselection
 `
 rem gridsmart system chooses best tile
 if nogridsmart=-1
  `
  rem default AUTO tile is NO walls (direct-tile only)
  if addoffsetx=0 and addoffsety=0
   tamask = %00000000
   addgridsymbol=1
  else
   rem add walls only in the direction of the direct-tile (return wall if delete direct-tile)
   if addoffsetx=-1 and addoffsety=-1 then tamask = tamask || %00000010
   if addoffsetx= 0 and addoffsety=-1 then tamask = tamask || %00010000
   if addoffsetx= 1 and addoffsety=-1 then tamask = tamask || %00000001
   if addoffsetx=-1 and addoffsety= 0 then tamask = tamask || %00100000
   if addoffsetx= 1 and addoffsety= 0 then tamask = tamask || %10000000
   if addoffsetx=-1 and addoffsety= 1 then tamask = tamask || %00000100
   if addoffsetx= 0 and addoffsety= 1 then tamask = tamask || %01000000
   if addoffsetx= 1 and addoffsety= 1 then tamask = tamask || %00001000
  endif
  `
 else
  `
  rem direct-tile-add-one-X (TOP,RIGHT,BOTTOM,LEFT)
  if addoffsetx=0 and addoffsety=0
   if nogridsmart=0
    rem WALL
    if gridorient=0 then tamask = tamask && %10110011
    if gridorient=1 then tamask = tamask && %11011001
    if gridorient=2 then tamask = tamask && %11101100
    if gridorient=3 then tamask = tamask && %01110110
   endif
   if nogridsmart=1
    rem remove FLOOR
    addgridsymbol=1
   endif
  else
   rem remove wall connected to direct-tile-wall
   if nogridsmart=0
    rem must remove a reverse-version of wall
    if gridorient=3 and addoffsetx=-1 and addoffsety= 0 then tamask = tamask && %11011111
    if gridorient=0 and addoffsetx= 0 and addoffsety=-1 then tamask = tamask && %11101111
    if gridorient=1 and addoffsetx= 1 and addoffsety= 0 then tamask = tamask && %01111111
    if gridorient=2 and addoffsetx= 0 and addoffsety= 1 then tamask = tamask && %10111111
   endif
   if nogridsmart=1
    rem remove no FLOOR
   endif
  endif
  `
 endif
 `
 rem filter out corners if wall exists after above
 gosub _gridedit_filtercorners
 `
 rem Possibility of intelegently adding corners where needed
 if (tamask && %11111111)=0 and addgridsymbol=1
  rem going to delete, no corners needed
 else
  gosub _gridedit_considercorners
 endif
 `
 rem recreate maptile from new mask
 gosub _gridedit_returntamask
 `
 rem If no floors or wall parts, mark map tile as deleted
 if (tamask && %11111111)=0 and addgridsymbol=1
  map(layer,mx,my)=0
 endif
 `
 rem erase any editor-entities that belong to this overlay (for lift platforms, etc)
 seg=mapselection : gosub _gridedit_deletesegentities
 `
 rem Refresh tile
 gosub _gridedit_refreshtile
 `
return

_gridedit_addentitytomap:

rem Entity To Add
entitymaintype=1
entitybankindex=gridentity

rem Create new or use free entity element
tokay=0
if entityelementlist>0
 for e=1 to entityelementlist
  if entityelement(e).maintype=0 then tokay=e : exit
 next e
endif
if tokay=0
 `
 inc entityelementlist
 e=entityelementlist

 if entityelementlist>entityelementmax
  dim storeentityelement(entityelementmax) as entitytype
  for e=1 to entityelementmax
   storeentityelement(e).editorfixed=entityelement(e).editorfixed
   storeentityelement(e).maintype=entityelement(e).maintype
   storeentityelement(e).bankindex=entityelement(e).bankindex
   storeentityelement(e).staticflag=entityelement(e).staticflag
   storeentityelement(e).x=entityelement(e).x
   storeentityelement(e).y=entityelement(e).y
   storeentityelement(e).z=entityelement(e).z
   storeentityelement(e).rx=entityelement(e).rx
   storeentityelement(e).ry=entityelement(e).ry
   storeentityelement(e).rz=entityelement(e).rz
   storeentityelement(e).eleprof=entityelement(e).eleprof
  next e
  undim entityelement()
  undim entityshadervar()
  inc entityelementmax,10
  dim entityelement(entityelementmax) as entitytype
  dim entityshadervar(entityelementmax,globalselectedshadermax)
  for e=1 to entityelementmax-10
   entityelement(e).editorfixed=storeentityelement(e).editorfixed
   entityelement(e).maintype=storeentityelement(e).maintype
   entityelement(e).bankindex=storeentityelement(e).bankindex
   entityelement(e).staticflag=storeentityelement(e).staticflag
   entityelement(e).x=storeentityelement(e).x
   entityelement(e).y=storeentityelement(e).y
   entityelement(e).z=storeentityelement(e).z
   entityelement(e).rx=storeentityelement(e).rx
   entityelement(e).ry=storeentityelement(e).ry
   entityelement(e).rz=storeentityelement(e).rz
   entityelement(e).eleprof=storeentityelement(e).eleprof
  next e
 endif
 `
else
 e=tokay
endif

rem Fill entity element details
entityelement(e).editorfixed=gridentityeditorfixed
entityelement(e).maintype=entitymaintype
entityelement(e).bankindex=entitybankindex
entityelement(e).staticflag=gridentitystaticmode
entityelement(e).x=gridentityposx#
entityelement(e).z=gridentityposz#
entityelement(e).y=gridentityposy#
entityelement(e).rx=gridentityrotatex#
entityelement(e).ry=gridentityrotatey#
entityelement(e).rz=gridentityrotatez#
entityelement(e).eleprof=grideleprof
`
rem FPGC - 250809 - as create entity, apply any texture change required
stentid=entid : entid=entitybankindex
gosub _entity_iseleprofunique
entdir$="entitybank\" : ent$=entitybank$(entid) : entpath$=getpath(ent$)
if entityelement(e).eleprof.uniqueelement=1 then gosub _entity_updatetextureandeffectfromeleprof
entid=stentid
`
rem V109 BETA11 - 130508 - 'entid' is not set, caused damage of zero bug (could not get gun data)
entid=entityelement(e).bankindex
`
rem GRIDELEPROF might contain GUN+FLAK Data
tgunid$=entityprofile(entid).isweapon$
gosub _entity_getgunidandflakid
if tgunid>0
 rem populate the actual gun and flak settings (for further weapon entity creations)
 firemode(tgunid,0).settings.damage=grideleprof.damage
 firemode(tgunid,0).settings.accuracy=grideleprof.accuracy
 firemode(tgunid,0).settings.reloadqty=grideleprof.reloadqty
 firemode(tgunid,0).settings.iterate=grideleprof.fireiterations
 if tflakid>0
  flak(tflakid).profile.lifespan=grideleprof.lifespan
  flak(tflakid).profile.zinc=grideleprof.throwspeed
  flak(tflakid).throwangle=grideleprof.throwangle
  flak(tflakid).profile.bounceonhit=grideleprof.bounceqty
  flak(tflakid).profile.explodeonhit=grideleprof.explodeonhit
 endif
 rem which must also populate ALL other entities of same weapon
 tgunidchanged=tgunid
 for te=1 to entityelementlist
  tentid=entityelement(te).bankindex
  tgunid$=entityprofile(tentid).isweapon$
  gosub _entity_getgunidandflakid
  if tgunid=tgunidchanged
   entityelement(te).eleprof.damage=grideleprof.damage
   entityelement(te).eleprof.accuracy=grideleprof.accuracy
   entityelement(te).eleprof.reloadqty=grideleprof.reloadqty
   entityelement(te).eleprof.fireiterations=grideleprof.fireiterations
   entityelement(te).eleprof.lifespan=grideleprof.lifespan
   entityelement(te).eleprof.throwspeed=grideleprof.throwspeed
   entityelement(te).eleprof.throwangle=grideleprof.throwangle
   entityelement(te).eleprof.bounceqty=grideleprof.bounceqty
   entityelement(te).eleprof.explodeonhit=grideleprof.explodeonhit
  endif
 next te
endif
`
rem Add entity reference into map
addtobufferref=0 : gosub _gridedit_addentityreftomap

return

_gridedit_calctentitymesh:
 rem based on E
 tentitymesh=201
 tentid=entityelement(e).bankindex
 if entityprofile(tentid).ismarker=0
  if entityprofile(tentid).ischaracter=1
   tentitymesh=206
  else
   if entityelement(e).staticflag=1
    tentitymesh=202
   else
    if gmultiplayergame=0
     tentitymesh=204
    else
     if entityprofile(tentid).isammo<>0 or entityprofile(tentid).isweapon<>0 or entityprofile(tentid).ischaracter<>0 or entityprofile(tentid).ishealth<>0
      tentitymesh=204
     else
      tentitymesh=202
     endif
    endif
   endif
  endif
 else
  if entityprofile(tentid).ismarker=1
   if entityprofile(tentid).lives<>-1
    tentitymesh=204
   else
    tentitymesh=208
   endif
  endif
  if entityprofile(tentid).ismarker=2 then tentitymesh=203
  if entityprofile(tentid).ismarker=3 then tentitymesh=207
  if entityprofile(tentid).ismarker=4 then tentitymesh=205
 endif
return

_gridedit_addentityreftomap:

rem determine grid position of entity
layer=entityelement(e).y/100.0
mx=entityelement(e).x/100.0
my=entityelement(e).z/-100.0

rem Set reference on map tile
if addtobufferref=0 then ptrbase=refmap(layer,mx,my)
if addtobufferref=1 then ptrbase=bufferrefmap(layer,mx,my)
if ptrbase=0
 tmax=1
 ptrbase=make memory(4+4)
else
 tmax=*ptrbase
 newptrbase=make memory(4+((tmax+1)*4))
 copy memory newptrbase, ptrbase, 4+(tmax*4)
 delete memory ptrbase
 ptrbase=newptrbase
 tmax=tmax+1
endif
ptr=ptrbase+0 : *ptr=tmax
ptr=ptrbase+(tmax*4) : *ptr=e

rem Add entity marker if new
if addtobufferref=0 then trefmap=refmap(layer,mx,my)
if addtobufferref=1 then trefmap=bufferrefmap(layer,mx,my)
if addtobufferref=0
 if trefmap=0
  gosub _gridedit_calctentitymesh
  tbuffer=0 : tlayer=layer  : tx=mx : ty=my
  gosub _gridedit_addentity
 endif
endif

rem Ensure latest base ptr used
if addtobufferref=0 then refmap(layer,mx,my)=ptrbase
if addtobufferref=1 then bufferrefmap(layer,mx,my)=ptrbase

return

_gridedit_deleteentityfrommap:

rem Entity Type To Delete
entitymaintype=1

rem Use entity coord to find tile
de=tentitytoselect
layer=entityelement(de).y/100.0
mx=entityelement(de).x/100.0
my=entityelement(de).z/-100.0

rem Get reference from map tile
ptrbase=refmap(layer,mx,my)
if ptrbase>0
 `
 tmax=*ptrbase
 ptr=ptrbase+4
 for tp=1 to tmax
  de=*ptr
  if de=tentitytoselect
   `
   rem blank from entity element list
   entityelement(de).bankindex=0
   entityelement(de).maintype=0
   entityelement(de).obj=0
   `
   while tp<tmax
    newptr=ptr+4
    de=*newptr
    *ptr=de
    inc ptr,4
    inc tp
   endwhile
   dec tmax : ptr=ptrbase+0 : *ptr=tmax
   exit
  endif
  inc ptr,4
  `
 next tp
 `
 rem remove from refmap
 if tmax=0
  delete memory ptrbase
  refmap(layer,mx,my)=0
 endif
 `
 rem remove entity marker from map (if no entities left in tile)
 if tmax=0
  tbuffer=0 : tlayer=layer  : tx=mx : ty=my
  gosub _gridedit_removeentity
 endif
 `
endif

return

_gridedit_deleteallentitiesontile:

rem Get reference from map tile
if ptrbase>0
 tmax=*ptrbase
 ptr=ptrbase+4
 for tp=1 to tmax
  rem blank from entity element list
  e=*ptr
  entityelement(e).bankindex=0
  entityelement(e).maintype=0
  inc ptr,4
 next tp
endif

return

_gridedit_addolay_findfree:
 `
 rem Find free olay index
 for tti=1 to olaylistmax
  if olaylist(tti,0)=0
   olayindex=tti : exit
  endif
 next tti
 if tti>olaylistmax
  rem my hunch is a redimmed array does not save straight, so
` inc olaylistmax
` dim olaylist(olaylistmax,50) as DWORD
  dim tempolaylist(olaylistmax,50) as DWORD
  for tolay=0 to olaylistmax
   for tolayi=0 to 50
    tempolaylist(tolay,tolayi)=olaylist(tolay,tolayi)
   next tolayi
  next tolay
  undim olaylist()
  toldolaylistmax=olaylistmax
  olayindex=olaylistmax+1
  inc olaylistmax,100
  dim olaylist(olaylistmax,50) as DWORD
  for tolay=0 to toldolaylistmax
   for tolayi=0 to 50
    olaylist(tolay,tolayi)=tempolaylist(tolay,tolayi)
   next tolayi
  next tolay
  undim tempolaylist()
 endif
 `
return

_gridedit_addolay_map:

rem record olay index in map grid
if mapolay(layer,mx,my)=0
 `
 rem find a new olay index
 gosub _gridedit_addolay_findfree
 `
 rem new seglist
 mapolay(layer,mx,my)=olayindex
 for ti=0 to 50
  olaylist(olayindex,ti)=0
 next ti
 `
else
 `
 rem find seglist from map
 olayindex=mapolay(layer,mx,my)
 `
endif

rem allow addition (only one per side of same selection
for ti=0 to 50
 mapid=olaylist(olayindex,ti)
 if mapid=0
  `
  rem Add OVERLAY MAP TILE at this point in list
  if buffermapid=0
   mapid=getmapid(addgridselection,addgridscaler,addgridground,addgridrotate,addgridorient,addgridsymbol,addmaptile)
   olaylist(olayindex,ti)=mapid
  else
   rem adjust offsets based on rotation
   mapid=buffermapid
   gosub _gridedit_getmapvalues
   inc maporient,bufferrotationcount
   if maporient>3 then dec maporient,4
   mapid=getmapid(mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
   olaylist(olayindex,ti)=mapid
  endif
  exit
  `
 else
  gosub _gridedit_getmapvalues
  if addgridselection=mapselection
   if segmentprofile(gridselection).vis.overlay=2
    exit
   else
    if gridorient=0 and maporient=0 then exit
    if gridorient=1 and maporient=1 then exit
    if gridorient=2 and maporient=2 then exit
    if gridorient=3 and maporient=3 then exit
   endif
  endif
 endif
next ti

return

_gridedit_deletesegentities:
 `
 rem scan all entities used by this seg and erase from tile location (mx,my,layer)
 for tp=0 to segmentprofileheader(seg).partmax
  if segmentprofile(seg,tp).partmode=3
    rem get entity details
    lgx#=segmentprofile(seg,tp).offx
    lgz#=segmentprofile(seg,tp).offz
    if gridorient>0
     for brot=0 to maporient-1
      lgss#=lgx# : lgx#=lgz# : lgz#=lgss#*-1
     next brot
    endif
    lgx#=lgx#+(50+(mx*100))
    lgz#=lgz#+((my*-100)-50)
    lgy#=segmentprofile(seg,tp).offy+(50+(layer*100))
    addentityx=lgx# : addentityy=lgy# : addentityz=lgz#
    addentityrx=0 : addentityry=segmentprofile(seg,tp).roty : addentityrz=0
    addentityry=addentityry+(gridorient*90)
    rem if entity here
    if entityelementlist>0
     for te=1 to entityelementlist
      if entityelement(te).maintype>0
       tgodelete=0
       if deleteolaymode=1
        rem if entity is inside tile
        if entityelement(te).x>=(mx*100) and entityelement(te).x<(mx*100)+100
         if entityelement(te).y>=(layer*100) and entityelement(te).y<(layer*100)+100
          if entityelement(te).z<(my*-100) and entityelement(te).z>=(my*-100)-100
           tgodelete=1
          endif
         endif
        endif
       endif
       if tgodelete=0
        tentid=entityelement(te).bankindex
        if abs((entityelement(te).x)-addentityx)<=2
         if abs((entityelement(te).y)-addentityy)<=2
          if abs((entityelement(te).z)-addentityz)<=2
           tgodelete=1
          endif
         endif
        endif
       endif
       if tgodelete=1
        tentitytoselect=te : entityelement(te).editorfixed=0
        gosub _gridedit_deleteentityfrommap
       endif
      endif
     next e
    endif
  endif
 next tp
 `
return

_gridedit_deleteolay_map:

`takes layer,mx,my
if mapolay(layer,mx,my)=0
 rem nothing to delete
else
 rem seglist present
 olayindex=mapolay(layer,mx,my)
 rem clear list out of segs that match direction
 for ti=0 to 50
  mapid=olaylist(olayindex,ti)
  if mapid<>0
   gosub _gridedit_getmapvalues
   if segmentprofile(mapselection).vis.overlay=2 or deleteolaymode=1
    olaylist(olayindex,ti)=0
   else
    if gridorient=0 and maporient=0 then olaylist(olayindex,ti)=0
    if gridorient=1 and maporient=1 then olaylist(olayindex,ti)=0
    if gridorient=2 and maporient=2 then olaylist(olayindex,ti)=0
    if gridorient=3 and maporient=3 then olaylist(olayindex,ti)=0
   endif
   if olaylist(olayindex,ti)=0
    rem erase any editor-entities that belong to this overlay
    seg=mapselection : gosub _gridedit_deletesegentities
   endif
  else
   exit
  endif
 next ti
 rem shuffle empty spaces out
 titer=0
 for ti=0 to 49
  if olaylist(olayindex,ti)=0
   for tti=ti to 49
    olaylist(olayindex,tti)=olaylist(olayindex,tti+1)
   next tti
   olaylist(olayindex,50)=0
   dec ti
  endif
  inc titer : if titer>50 then exit
 next ti
 rem if nothing left..
 if olaylist(olayindex,0)=0
  rem remove seglist ref
  mapolay(layer,mx,my)=0
 endif
endif

return

_gridedit_removeallolays_olayindex:
 rem clear list out of segs that match direction
 for ti=0 to 50
  mapid=olaylist(olayindex,ti)
  if mapid<>0
   olaylist(olayindex,ti)=0
  else
   exit
  endif
 next ti
 rem completely clear olaylist
 for ti=0 to 50
  olaylist(olayindex,ti)=0
 next ti
return

remstart
rem this deleted overlays without the fixed entities!
_gridedit_removeallolays:
 rem will remove all olays from all sides if primary segment paint on tile
 if mapolay(layer,mx,my)=0
  rem nothing to delete
 else
  rem seglist present
  olayindex=mapolay(layer,mx,my)
  rem clear list out of segs that match direction
  gosub _gridedit_removeallolays_olayindex
  rem remove seglist ref
  mapolay(layer,mx,my)=0
 endif
return
remend

`
` Meshes
`

_gridedit_createmeshes:

rem Interior
rem Make basic cube meshes (99.8=100 with CSG in makemeshprocess)
meshmax=16
for mesh=101 to 100+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=101 then modifycube(mesh,0,0,1,0,0,0)
 if mesh=102 then modifycube(mesh,0,0,2,0,6,0)
 if mesh=103 then modifycube(mesh,6,0,3,0,6,0)
 if mesh=104 then modifycube(mesh,0,0,4,0,6,6)
 if mesh=105 then modifycube(mesh,6,0,5,0,6,6)
 if mesh=106 then modifycube(mesh,6,6,6,0,6,6)
 if mesh=107 then modifycube(mesh,6,6,7,0,6,6)
 if mesh=108 then modifycube(mesh,6,6,8,0,6,6)
 if mesh=109 then modifycube(mesh,6,6,9,0,6,6)
 if mesh=110 then modifycube(mesh,6,6,10,0,6,6)
 if mesh=111 then modifycube(mesh,6,6,11,0,6,6)
 if mesh=112 then modifycube(mesh,6,0,12,0,6,6)
 if mesh=113 then modifycube(mesh,6,0,13,0,6,6)
 if mesh=114 then modifycube(mesh,6,0,14,0,6,6)
 if mesh=115 then modifycube(mesh,6,0,15,0,6,0)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Interior2
for mesh=117 to 116+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=117 then modifycube(mesh,0,0,1,19,0,0)
 if mesh=118 then modifycube(mesh,0,0,2,19,6,0)
 if mesh=119 then modifycube(mesh,6,0,3,19,6,0)
 if mesh=120 then modifycube(mesh,0,0,4,19,6,6)
 if mesh=121 then modifycube(mesh,6,0,5,19,6,6)
 if mesh=122 then modifycube(mesh,6,6,6,19,6,6)
 if mesh=123 then modifycube(mesh,6,6,7,19,6,6)
 if mesh=124 then modifycube(mesh,6,6,8,19,6,6)
 if mesh=125 then modifycube(mesh,6,6,9,19,6,6)
 if mesh=126 then modifycube(mesh,6,6,10,19,6,6)
 if mesh=127 then modifycube(mesh,6,6,11,19,6,6)
 if mesh=128 then modifycube(mesh,6,0,12,19,6,6)
 if mesh=129 then modifycube(mesh,6,0,13,19,6,6)
 if mesh=130 then modifycube(mesh,6,0,14,19,6,6)
 if mesh=131 then modifycube(mesh,6,0,15,19,6,0)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Exterior1
for mesh=132 to 131+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=132 then modifycube(mesh,6,6,32,6,6,6)
 if mesh=133 then modifycube(mesh,32,32,1,32,32,32)
 if mesh=134 then modifycube(mesh,32,32,2,32,6,32)
 if mesh=135 then modifycube(mesh,6,32,3,32,6,32)
 if mesh=136 then modifycube(mesh,32,32,4,32,6,6)
 if mesh=137 then modifycube(mesh,6,32,5,32,6,6)
 if mesh=138 then modifycube(mesh,6,6,6,32,6,6)
 if mesh=139 then modifycube(mesh,6,6,7,32,6,6)
 if mesh=140 then modifycube(mesh,6,6,8,32,6,6)
 if mesh=141 then modifycube(mesh,6,6,9,32,6,6)
 if mesh=142 then modifycube(mesh,6,6,10,32,6,6)
 if mesh=143 then modifycube(mesh,6,6,11,32,6,6)
 if mesh=144 then modifycube(mesh,6,32,12,32,6,6)
 if mesh=145 then modifycube(mesh,6,32,13,32,6,6)
 if mesh=146 then modifycube(mesh,6,32,14,32,6,6)
 if mesh=147 then modifycube(mesh,6,32,15,32,6,32)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Exterior2
for mesh=148 to 147+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=148 then modifycube(mesh,6,6,48,6,6,6)
 if mesh=149 then modifycube(mesh,48,48,1,48,48,48)
 if mesh=150 then modifycube(mesh,48,48,2,48,6,48)
 if mesh=151 then modifycube(mesh,6,48,3,48,6,48)
 if mesh=152 then modifycube(mesh,48,48,4,48,6,6)
 if mesh=153 then modifycube(mesh,6,48,5,48,6,6)
 if mesh=154 then modifycube(mesh,6,6,6,48,6,6)
 if mesh=155 then modifycube(mesh,6,6,7,48,6,6)
 if mesh=156 then modifycube(mesh,6,6,8,48,6,6)
 if mesh=157 then modifycube(mesh,6,6,9,48,6,6)
 if mesh=158 then modifycube(mesh,6,6,10,48,6,6)
 if mesh=159 then modifycube(mesh,6,6,11,48,6,6)
 if mesh=160 then modifycube(mesh,6,48,12,48,6,6)
 if mesh=161 then modifycube(mesh,6,48,13,48,6,6)
 if mesh=162 then modifycube(mesh,6,48,14,48,6,6)
 if mesh=163 then modifycube(mesh,6,48,15,48,6,48)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Entity makrer meshes (eight colors)
load mesh "editors\gfx\7.x",200
for mesh=201 to 208
 make object mesh,200,0
 scale object mesh,33,33,33
 if mesh=201 then modifyentity(mesh,0)
 if mesh=202 then modifyentity(mesh,1)
 if mesh=203 then modifyentity(mesh,2)
 if mesh=204 then modifyentity(mesh,3)
 if mesh=205 then modifyentity(mesh,4)
 if mesh=206 then modifyentity(mesh,5)
 if mesh=207 then modifyentity(mesh,6)
 if mesh=208 then modifyentity(mesh,7)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

return

_gridedit_recreaterealviewshroud:

rem calculate shroud position center
if shroudstatic=0
 shroudmmx=inputsys.mmx
 shroudmmy=inputsys.mmy
endif
if shroudsize=10
 shroudmmx=(cx#/100.0)
 shroudmmy=(cy#/100.0)
endif

rem selection
if shroudstatic<2
 `
 rem blanking shroud to overlay blueprint
 o=1 : objstart=realviewobjectoffset
 make object plain objstart,100,100
 set object collision off objstart
 xrotate object objstart,90
 texture object objstart,editorimagesoffset+8
 set object transparency objstart,1
 disable object zread objstart
 `
 rem define layer visibility
 if gridlayershowall=0
  lystart=-1 : lyend=0
 else
  lystart=-1 : lyend=layermax-1
 endif
 if shroudsize=10 then lystart=-4
 `
 rem realview objects make up rest
 segmentselectionstart=selectionbankoffset
 for ly=lystart to lyend
  for y=0-shroudsize to shroudsize
   for x=0-shroudsize to shroudsize
    if gridlayer+ly>=0 and gridlayer+ly<=layermax
     if gridlayershowsingle=0 or (gridlayershowsingle>0 and ly=0)
      if shroudmmx+x>=0 and shroudmmx+x<=maxx
       if shroudmmy-y>=0 and shroudmmy-y<=maxy
        `
        rem scene reveal
        mapid=map(gridlayer+ly,shroudmmx+x,shroudmmy-y)
        if mapid<>0
         gosub _gridedit_getmapvalues
         sourceobj=segmentselectionstart+mapselection
         if object exist(sourceobj)=0
          rem avoid crash by removing corrupt maptile
          map(gridlayer+ly,shroudmmx+x,shroudmmy-y)=0
         else
          obj=objstart+o
          if object exist(obj)=1 then delete object obj
          instance object obj,sourceobj
          set object collision off obj
          disable object zdepth obj
          hide object obj
          inc o
         endif
        endif
        `
        rem segment overlay reveal
        olayindex=mapolay(gridlayer+ly,shroudmmx+x,shroudmmy-y)
        if olayindex>0
         for ti=0 to 50
          mapid=olaylist(olayindex,ti)
          if mapid<>0
           gosub _gridedit_getmapvalues
           sourceobj=segmentselectionstart+mapselection
           obj=objstart+o
           if object exist(obj)=1 then delete object obj
           if object exist(sourceobj)=1
            instance object obj,sourceobj
           else
            make object cube obj,25
           endif
           set object collision off obj
           disable object zdepth obj
           hide object obj
           inc o
          else
           exit
          endif
         next ti
        endif
        `
        rem entity reveal
        ptrbase=refmap(gridlayer+ly,shroudmmx+x,shroudmmy-y)
        if ptrbase<>0
         tpmax=*ptrbase
         ptr=ptrbase+4
         for tp=1 to tpmax
          e=*ptr
          obj=objstart+o
          tentid=entityelement(e).bankindex
          sourceobj=entitybankoffset+tentid
          if object exist(obj)=1 then delete object obj
          if object exist(sourceobj)=1
           entityelement(e).profileobj=sourceobj
           enable object zwrite sourceobj
           entid=tentid : entobj=obj
           rem FPGC - 250809 - if texture changed per-element, use clone for visual accuracy (at cost of performance)
           if entityelement(e).eleprof.uniqueelement=1 and gshowalluniquetextures=1
            rem slower but can texture obj
            clone object obj,sourceobj,1
            if total object frames(obj)>0
             set object frame obj,0
             loop object obj : stop object obj
            endif
            texture object obj,entityelement(e).eleprof.texdid
           else
            rem maximum speed required - sacrifice visual accuracy!
            instance object obj,sourceobj
           endif
           if entityprofile(tentid).fixnewy<>0
            rotate object obj,0,entityprofile(tentid).fixnewy,0
            fix object pivot obj
           endif
           if entityprofile(tentid).scale<>0 then scale object obj,entityprofile(tentid).scale,entityprofile(tentid).scale,entityprofile(tentid).scale
          else
           make object sphere obj,25
          endif
          set object collision off obj
          position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
          rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
          entityelement(e).obj=obj
          disable object zdepth obj
          hide object obj
          inc ptr,4
          inc o
         next tp
        endif
        `
       endif
      endif
     endif
    endif
   next x
  next y
 next ly
 `
 rem Entity floating selection
 if realviewobjectfullpreview=0
  if gridentity>0
   obj=objstart+o
   sourceobj=entitybankoffset+gridentity
   if object exist(obj)=1 then delete object obj
   if object exist(sourceobj)=1
    entid=gridentity : entobj=obj
    enable object zwrite sourceobj
    rem allow clone when viewing the single entity up close
    gosub _entity_isgrideleprofunique
    tokay=0
    `if grideleprof.uniqueelement=1 and entityprofile(entid).ischaracter=0 then tokay=1
    if grideleprof.uniqueelement=1 then tokay=1 : rem FPGC - 250809 - allow character textures to be previewed
    if tokay=1
     clone object obj,sourceobj
     if total object frames(obj)>0
      set object frame obj,0
      if entityprofile(entid).ischaracter=1
       if entityprofile(entid).animmax>=1
        teai=0 : if entityanim(entid,1).start>0 then teai=1
        loop object obj,entityanim(entid,teai).start,entityanim(entid,teai).finish
       else
        loop object obj : stop object obj
       endif
      endif
     endif
     gosub _entity_updatetextureandeffectfromgrideleprof
    else
     instance object obj,sourceobj
    endif
   else
    make object sphere obj,25
   endif
   if entityprofile(gridentity).fixnewy<>0
    rotate object obj,0,entityprofile(gridentity).fixnewy,0
    fix object pivot obj
   endif
   tescale=entityprofile(gridentity).scale
   if tescale>0 then scale object obj,tescale,tescale,tescale
   set object collision off obj
   disable object zdepth obj
`   set object transparency obj,2
   gridentityobj=obj
   inc o
  endif
 endif
 `
 rem Record end of realview objects
 realviewobjectoffsetend=objstart+(o-1)
 `
endif

return

_gridedit_deleterealviewoldshroud:

rem clear OBJ values in entityelements (as all objects are being removed)
if entityelementlist>0
 for e=1 to entityelementlist
  entityelement(e).obj=0
 next e
endif

rem delete all objects used for realview
for obj=realviewobjectoffset to realviewobjectoffsetend
 if object exist(obj)=1 then delete object obj
next obj

rem Indicate no shroud
realviewobjectoffsetend=0

return

_gridedit_setpercvalue:
 if shroudsize=10
  if ly=-1 then perc#=perc#/1.5
  if ly=-2 then perc#=perc#/2.0
  if ly=-3 then perc#=perc#/2.5
  if ly=-4 then perc#=perc#/3.0
  if ly=-5 then perc#=perc#/4.0
 else
  if ly=-1 then perc#=perc#/1.5
 endif
return

_gridedit_displayrealviewshroud:

rem calculate shroud position smoothing
if shroudstatic<>0
 tx=shroudmmx
 ty=shroudmmy
else
 tx=inputsys.mmx
 ty=inputsys.mmy
endif

otx#=tx#+(cx#/100.0)
oty#=ty#+(cy#/100.0)
dec otx#,(tx+0.5)
dec oty#,(ty+0.5)
otx#=otx#*100
oty#=oty#*100
dista#=(shroudsize-1.0)*100.0
distb#=(shroudsize+0.5)*100.0

rem full view shroud keeps base in corner
if shroudsize=10
 basex#=(shroudmmx*100)+50
 basey#=(shroudmmy*-100)-50
else
 basex#=(tx*100)+50
 basey#=(ty*-100)-50
endif

rem define layer visibility
if gridlayershowall=0
 lystart=-1 : lyend=0
else
 lystart=-1 : lyend=layermax-1
endif
if shroudsize=10 then lystart=-4
`
rem create blanker
o=1 : objstart=realviewobjectoffset
if object exist(objstart)=1
 position object objstart,basex#+otx#,0+(gridlayer*100.0),basey#-oty#
 scale object objstart,200+(shroudsize*200),200+(shroudsize*200),100
 if gridlayershowall=1 then hide object objstart
 if grideditselect=4 then hide object objstart
 if shroudsize=10 then scale object objstart,15000,15000,15000
endif

rem if shroud exist to display
if realviewobjectoffsetend<>0

rem create realview instances
for ly=lystart to lyend
 for y=0-shroudsize to shroudsize
  for x=0-shroudsize to shroudsize
   if gridlayer+ly>=0 and gridlayer+ly<=layermax
    if gridlayershowsingle=0 or (gridlayershowsingle>0 and ly=0)
     if shroudmmx+x>=0 and shroudmmx+x<=maxx
      if shroudmmy-y>=0 and shroudmmy-y<=maxy
       `
       rem alpha perc (shroudsize of zero means show all)
       perc#=0.0
       objx#=basex#+(x*100) : objy#=basey#+(y*100)
       dx#=(objx#-basex#)-otx# : dy#=(objy#-basey#)+oty#
       aldist#=sqrt(abs(dx#*dx#)+abs(dy#*dy#))
       if aldist#<=dista#
        perc#=100.0
       else
        if aldist#<=distb#
         perc#=100.0-((aldist#-dista#)/1.5)
        endif
       endif
       if gridlayershowall=1
        perc#=100.0-((100.0/lyend)*ly)
        if perc#<25.0 then perc#=25.0
        if perc#>80.0 then perc#=80.0
       endif
       if shroudsize=10 then perc#=100.0
       `
       rem map segment
       mapid=map(gridlayer+ly,shroudmmx+x,shroudmmy-y)
       if mapid<>0
         rem determine if scene obj visible
         vis=1 : obj=objstart+o
         if object exist(obj)=1
            gosub _gridedit_getmapvalues
            if maptile>=49 then dec maptile,48
            mapatl=gridlayer+ly : mapatx=shroudmmx+x : mapaty=shroudmmy-y
            gosub _segment_customisesinglesegment
            rem position real object
            position object obj,objx#,50+((gridlayer+ly)*100.0),objy#
            rem set alpha for real object
            if shroudstatic=1
               remstart
               rem V118 - 050211 - many users complain this is more of a nuisance, so removed it
               if gridentity>0
                for ttto=0 to 99
                 if limb exist(obj,ttto)=1
                  ttsegparty#=limb position y(obj,ttto)
                  ttsegpartywhole=ttsegparty#/100 : ttsegpartywhole=ttsegpartywhole*100
                  ttsegparty#=ttsegparty#-ttsegpartywhole
                  if ttsegparty#>20 and ttsegparty#<80
                   tthisdx#=limb position x(obj,ttto)-camera position x()
                   tthisdy#=limb position y(obj,ttto)-camera position y()
                   tthisdz#=limb position z(obj,ttto)-camera position z()
                   tthisdd#=sqrt(abs(tthisdx#*tthisdx#)+abs(tthisdy#*tthisdy#)+abs(tthisdz#*tthisdz#))
                   tthisdx#=gridentityposx#-camera position x()
                   tthisdy#=gridentityposy#-camera position y()
                   tthisdz#=gridentityposz#-camera position z()
                   tthisdd2#=sqrt(abs(tthisdx#*tthisdx#)+abs(tthisdy#*tthisdy#)+abs(tthisdz#*tthisdz#))
                   if tthisdd#<200 and tthisdd#<tthisdd2#
                    hide limb obj,ttto
                   endif
                  endif
                 endif
                next ttto
               endif
               remend
               show object obj : set alpha mapping on obj,100
            else
               if perc#<=0.0
                  hide object obj
               else
                  show object obj
                  gosub _gridedit_setpercvalue
                  set alpha mapping on obj,perc#
               endif
            endif
         endif
         inc o
       endif
       `
       rem segment overlay reveal
       olayindex=mapolay(gridlayer+ly,shroudmmx+x,shroudmmy-y)
       if olayindex>0
        for ti=0 to 50
         mapid=olaylist(olayindex,ti)
         if mapid<>0
          rem determine if scene obj visible
          obj=objstart+o
          if object exist(obj)=1
             rem if scene obj present and visible, customise instance
             gosub _gridedit_getmapvalues
             if maptile>=49 then dec maptile,48
             mapatl=gridlayer+ly : mapatx=shroudmmx+x : mapaty=shroudmmy-y
             gosub _segment_customisesinglesegment
             rem position real object
             position object obj,objx#,50+((gridlayer+ly)*100.0),objy#
             rem set alpha for real object
             if shroudstatic=1
               show object obj : set alpha mapping on obj,100
             else
                if perc#<=0.0
                   hide object obj
                else
                   show object obj
                   gosub _gridedit_setpercvalue
                   set alpha mapping on obj,perc#
                endif
             endif
          endif
          inc o
         else
          exit
         endif
        next ti
       endif
       `
       rem entity reveal
       ptrbase=refmap(gridlayer+ly,shroudmmx+x,shroudmmy-y)
       if ptrbase<>0
         tpmax=*ptrbase
         ptr=ptrbase+4
         for tp=1 to tpmax
          rem set alpha for real object
          obj=objstart+o
          if shroudstatic=1
             show object obj : rem set alpha mapping on obj,100 - entities need to retain alpha
          else
             if perc#<=0.0
                hide object obj
             else
                show object obj
`                gosub _gridedit_setpercvalue
                rem set alpha mapping on obj,perc# - entities need to retain alpha
             endif
          endif
          inc ptr,4
          rem next reveal-obj
          inc o
         next tp
       endif
       `
      endif
     endif
    endif
   endif
   `
  next x
 next y
next ly

rem endif shroud exists
endif

rem create entity foating selection
if gridentity>0
 obj=objstart+o
 if object exist(obj)=1
`  position object obj,gridentityposx#,gridentityposy#+entityprofile(gridentity).offy,gridentityposz#
  position object obj,gridentityposx#,gridentityposy#,gridentityposz#
  rotate object obj,gridentityrotatex#,gridentityrotatey#,gridentityrotatez#
 endif
 inc o
endif

return

`
` SUPPORT SUBROUTINES FOR GRIDEDIT CODE
`

_gridedit_getmapvalues:
 `
 rem mapid in
 mapselection    = ( mapid && %11111111111100000000000000000000 ) >> 20
 mapscaler       = ( mapid && %00000000000011110000000000000000 ) >> 16
 mapground       = ( mapid && %00000000000000001100000000000000 ) >> 14
 maprotate       = ( mapid && %00000000000000000011000000000000 ) >> 12
 maporient       = ( mapid && %00000000000000000000110000000000 ) >> 10
 mapsymbol       = ( mapid && %00000000000000000000001111110000 ) >> 4
 maptile         = ( mapid && %00000000000000000000000000001111 )
 `
return


`
` SUBROUTINES FOR ARENA MODE TOGGLE
`

_arenamode_update:
 `
 rem In and Out of Arena Mode
 if gmultiplayergame=1
  rem toggle FPG to arena project
  if currentFPGtype=currentSMFPGtype
   currentFPGtype=currentAMFPGtype
   currentFPG$=currentAMFPG$
  endif
 else
  rem toggle FPG to singleplayer project
  if currentFPGtype=currentAMFPGtype
   currentFPGtype=currentSMFPGtype
   currentFPG$=currentSMFPG$
  endif
 endif
 `
return

`
` FUNCTION TO CHECK MAP DATA
`
function chkmapyes(l,x,y,ground)
 mapid = map(l,x,y)
 maptile = ( mapid && %00000000000000000000000000001111 )
 mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
 if mapground<4 and mapground=ground
  if maptile>0 and maptile<16 then res=1 else res=0
 else
  res=0
 endif
endfunction res

function chkmapno(l,x,y,ground)
 mapid = map(l,x,y)
 maptile = ( mapid && %00000000000000000000000000001111 )
 mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
 if mapground<4 and mapground=ground
  if maptile<=0 or maptile>=16 then res=1 else res=0
 else
  res=1
 endif
endfunction res

function getmapmask(l,x,y)
 tamask as DWORD
 mapid = map(l,x,y)
 maptile = ( mapid && %00000000000000000000000000001111 )
 maprotate = ( mapid && %00000000000000000011000000000000 ) >> 12
 tamask=makemaskfromtile(maptile,maprotate)
endfunction tamask

function makemaskfromtile(maptile,maprotate)
 rem create mask from current maptile (left,top,right,bottom)
 rem and the corner data (lefttop,righttop,rightbottom,leftbottom)
 tamask as DWORD
 tamask=%00000000
 if maprotate=0
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%11010000 : endcase
   case  3 : tamask=%11000000 : endcase
   case  4 : tamask=%01010000 : endcase
   case  5 : tamask=%01000000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00001000 : endcase
   case  8 : tamask=%00001100 : endcase
   case  9 : tamask=%00001010 : endcase
   case 10 : tamask=%00001110 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%01000001 : endcase
   case 13 : tamask=%01000010 : endcase
   case 14 : tamask=%01000011 : endcase
   case 15 : tamask=%11000010 : endcase
  endselect
 endif
 if maprotate=1
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%11100000 : endcase
   case  3 : tamask=%01100000 : endcase
   case  4 : tamask=%10100000 : endcase
   case  5 : tamask=%00100000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00000100 : endcase
   case  8 : tamask=%00000110 : endcase
   case  9 : tamask=%00000101 : endcase
   case 10 : tamask=%00000111 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%00101000 : endcase
   case 13 : tamask=%00100001 : endcase
   case 14 : tamask=%00101001 : endcase
   case 15 : tamask=%01100001 : endcase
  endselect
 endif
 if maprotate=2
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%01110000 : endcase
   case  3 : tamask=%00110000 : endcase
   case  4 : tamask=%01010000 : endcase
   case  5 : tamask=%00010000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00000010 : endcase
   case  8 : tamask=%00000011 : endcase
   case  9 : tamask=%00001010 : endcase
   case 10 : tamask=%00001011 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%00010100 : endcase
   case 13 : tamask=%00011000 : endcase
   case 14 : tamask=%00011100 : endcase
   case 15 : tamask=%00111000 : endcase
  endselect
 endif
 if maprotate=3
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%10110000 : endcase
   case  3 : tamask=%10010000 : endcase
   case  4 : tamask=%10100000 : endcase
   case  5 : tamask=%10000000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00000001 : endcase
   case  8 : tamask=%00001001 : endcase
   case  9 : tamask=%00000101 : endcase
   case 10 : tamask=%00001101 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%10000010 : endcase
   case 13 : tamask=%10000100 : endcase
   case 14 : tamask=%10000110 : endcase
   case 15 : tamask=%10010100 : endcase
  endselect
 endif
endfunction tamask

function getmapid(selection,scaler,ground,rotate,orient,symbol,side)
 mapid =         (selection << 20)
 mapid = mapid + (scaler << 16)
 mapid = mapid + (ground << 14)
 mapid = mapid + (rotate << 12)
 mapid = mapid + (orient << 10)
 mapid = mapid + (symbol << 4)
 mapid = mapid + (side)
endfunction mapid

function writemap(layer,mx,my,selection,scaler,ground,rotate,orient,symbol,side)
 mapid =         (selection << 20)
 mapid = mapid + (scaler << 16)
 mapid = mapid + (ground << 14)
 mapid = mapid + (rotate << 12)
 mapid = mapid + (orient << 10)
 mapid = mapid + (symbol << 4)
 mapid = mapid + (side)
 map(layer,mx,my)=mapid
endfunction

function writebuffermap(layer,mx,my,selection,scaler,ground,rotate,orient,symbol,side)
 mapid =         (selection << 20)
 mapid = mapid + (scaler << 16)
 mapid = mapid + (ground << 14)
 mapid = mapid + (rotate << 12)
 mapid = mapid + (orient << 10)
 mapid = mapid + (symbol << 4)
 mapid = mapid + (side)
 buffermap(layer,mx,my)=mapid
endfunction

`
` FUNCTION TO FIND ENTITY UNDER CURSOR
`
function findentitycursorobj()
 result=0 : tbesty#=-1.0
 for o=realviewobjectoffset+1 to realviewobjectoffsetend
  if object exist(o)=1
   if object visible(o)=1
    tadjustedtoareax#=desktop width()/800.0
    tadjustedtoareay#=desktop height()/600.0
    tadjustedtoareax#=inputsys.xmouse*tadjustedtoareax#
    tadjustedtoareay#=inputsys.ymouse*tadjustedtoareay#
    c=pick object(tadjustedtoareax#,tadjustedtoareay#,o,o)
    if c<>0
     tentitytoselect=findentityfromobj(o)
     if tentitytoselect>0
      ty#=entityelement(tentitytoselect).y
      if ty#>tbesty#
       tbesty#=ty# : result=tentitytoselect
      endif
     endif
    endif
   endif
  endif
 next o
endfunction result

`
` FUNCTION TO MODIFY OBJECT AT VERTEX LEVEL
`

function modifyplain(objno,bb)

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem calcuate uv area
tv=bb/8 : tu=bb-(tv*8)
s#=1.0/8.0 : u#=s#*tu : v#=s#*tv

rem adjust position data
set vertexdata position 0,-50,-49, 50
set vertexdata position 1,-50,-49,-50
set vertexdata position 2, 50,-49, 50
set vertexdata position 3, 50,-49,-50

rem adjust normals data
set vertexdata normals 0,0,1,0
set vertexdata normals 1,0,1,0
set vertexdata normals 2,0,1,0
set vertexdata normals 3,0,1,0

rem adjust UV data
set vertexdata uv 0,u#,v#
set vertexdata uv 1,u#,v#+s#
set vertexdata uv 2,u#+s#,v#
set vertexdata uv 3,u#+s#,v#+s#

rem Unlock the vertex data of the object
unlock vertexdata

endfunction

function modifycube(objno,ff,bb,tt,mm,rr,ll)

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem 0 front
rem 1 back
rem 2 top
rem 3 bottom
rem 4 right
rem 5 left
for p=0 to 5
 `
 rem define new normals
 if p=0 then nx=0 : ny=0 : nz=1
 if p=1 then nx=0 : ny=0 : nz=-1
 if p=2 then nx=0 : ny=1 : nz=0
 if p=3 then nx=0 : ny=1 : nz=0
 if p=4 then nx=-1 : ny=0 : nz=0
 if p=5 then nx=1 : ny=0 : nz=0
 `
 rem determine U/V flipping
 flip=0 : f=ff : b=bb : t=tt : m=mm : r=rr : l=ll
 if p=0 and ff>=100 then flip=1 : f=ff-100
 if p=1 and bb>=100 then flip=1 : b=bb-100
 if p=2 and tt>=100 then flip=1 : t=tt-100
 if p=3 and nm>=100 then flip=1 : m=mm-100
 if p=4 and rr>=100 then flip=1 : r=rr-100
 if p=5 and ll>=100 then flip=1 : l=ll-100
 `
 rem define area within texture
 if p=0 then tv=f/8 : tu=f-(tv*8)
 if p=1 then tv=b/8 : tu=b-(tv*8)
 if p=2 then tv=t/8 : tu=t-(tv*8)
 if p=3 then tv=m/8 : tu=m-(tv*8)
 if p=4 then tv=r/8 : tu=r-(tv*8)
 if p=5 then tv=l/8 : tu=l-(tv*8)
 `
 rem calcuate uv area
 s#=1.0/8.0 : u#=s#*tu : v#=s#*tv
 `
 rem adjust UV data
 if p=0
  if flip=0
   set vertexdata uv (p*4)+0,u#+s#,v#
   set vertexdata uv (p*4)+1,u#+s#,v#+s#
   set vertexdata uv (p*4)+2,u#,v#+s#
   set vertexdata uv (p*4)+3,u#,v#
  else
   set vertexdata uv (p*4)+0,u#+s#,v#+s#
   set vertexdata uv (p*4)+1,u#+s#,v#
   set vertexdata uv (p*4)+2,u#,v#
   set vertexdata uv (p*4)+3,u#,v#+s#
  endif
 endif
 if p=1
  if flip=0
   set vertexdata uv (p*4)+0,u#+s#,v#
   set vertexdata uv (p*4)+1,u#,v#
   set vertexdata uv (p*4)+2,u#,v#+s#
   set vertexdata uv (p*4)+3,u#+s#,v#+s#
  else
   set vertexdata uv (p*4)+0,u#+s#,v#+s#
   set vertexdata uv (p*4)+1,u#,v#+s#
   set vertexdata uv (p*4)+2,u#,v#
   set vertexdata uv (p*4)+3,u#+s#,v#
  endif
 endif
 if p=2
  set vertexdata uv (p*4)+0,u#,v#
  set vertexdata uv (p*4)+1,u#+s#,v#
  set vertexdata uv (p*4)+2,u#+s#,v#+s#
  set vertexdata uv (p*4)+3,u#,v#+s#
 endif
 if p=3
  set vertexdata uv (p*4)+0,u#,v#
  set vertexdata uv (p*4)+1,u#,v#+s#
  set vertexdata uv (p*4)+2,u#+s#,v#+s#
  set vertexdata uv (p*4)+3,u#+s#,v#
 endif
 if p=4
  if flip=0
   set vertexdata uv (p*4)+0,u#+s#,v#+s#
   set vertexdata uv (p*4)+1,u#+s#,v#
   set vertexdata uv (p*4)+2,u#,v#
   set vertexdata uv (p*4)+3,u#,v#+s#
  else
   set vertexdata uv (p*4)+0,u#+s#,v#
   set vertexdata uv (p*4)+1,u#+s#,v#+s#
   set vertexdata uv (p*4)+2,u#,v#+s#
   set vertexdata uv (p*4)+3,u#,v#
  endif
 endif
 if p=5
  if flip=0
   set vertexdata uv (p*4)+0,u#,v#+s#
   set vertexdata uv (p*4)+1,u#+s#,v#+s#
   set vertexdata uv (p*4)+2,u#+s#,v#
   set vertexdata uv (p*4)+3,u#,v#
  else
   set vertexdata uv (p*4)+0,u#,v#
   set vertexdata uv (p*4)+1,u#+s#,v#
   set vertexdata uv (p*4)+2,u#+s#,v#+s#
   set vertexdata uv (p*4)+3,u#,v#+s#
  endif
 endif
 `
 rem normals
 set vertexdata normals (p*4)+0,nx,ny,nz
 set vertexdata normals (p*4)+1,nx,ny,nz
 set vertexdata normals (p*4)+2,nx,ny,nz
 set vertexdata normals (p*4)+3,nx,ny,nz
 `
next p
`
rem Unlock the vertex data of the object
unlock vertexdata

endfunction

function modifyentity(objno,tex)

rem Smooth out mesh
set object smoothing objno,100

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem define area within texture
tv=tex/8 : tu=tex-(tv*8)
s#=1.0/8.0 : u#=s#*tu : v#=s#*tv

rem adjust UV data
vmax=12*3
for t=0 to vmax-1
 set vertexdata uv t,u#+(s#/2.0),v#+(s#/2.0)
next t

vmax=11*3
for t=vmax to vmax+5
 set vertexdata position t,0,0,0
next t

rem Unlock the vertex data of the object
unlock vertexdata

endfunction

function modifyplaneimagestrip(objno,texmax,texindex)

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem adjust UV data
s#=1.0/texmax : u#=texindex*s#
set vertexdata uv 0,u#+s#,0.0
set vertexdata uv 1,u#,0.0
set vertexdata uv 2,u#+s#,1.0
set vertexdata uv 3,u#,0.0
set vertexdata uv 4,u#,1.0
set vertexdata uv 5,u#+s#,1.0

rem Unlock the vertex data of the object
unlock vertexdata

endfunction

rem
rem Interface Constants
rem

rem PROPERTIES
#constant ENTITY_SETUP                           0
#constant ENTITY_WINDOW_TITLE                    4
#constant ENTITY_ADD_GROUP                       8
#constant ENTITY_DELETE_GROUP                   12
#constant ENTITY_SET_GROUP_INDEX                16
#constant ENTITY_SET_CONTROL_INDEX              20
#constant ENTITY_DELETE_CONTROL                 24
#constant ENTITY_ADD_EDIT_BOX                   28
#constant ENTITY_ADD_LIST_BOX                   32
#constant ENTITY_ADD_COLOR_PICKER               36
#constant ENTITY_ADD_FILE_PICKER                40
#constant ENTITY_ADD_FONT_PICKER                44
#constant ENTITY_SET_CONTROL_NAME               48
#constant ENTITY_SET_CONTROL_CONTENTS           52
#constant ENTITY_SET_CONTROL_DESCRIPTION        56
#constant ENTITY_SET_CONTROL_STATE              60
#constant ENTITY_GET_CONTROL_NAME               64
#constant ENTITY_GET_CONTROL_CONTENTS           68
#constant ENTITY_GET_CONTROL_DESCRIPTION        72
#constant ENTITY_ADD_ITEM_TO_LIST_BOX           76
#constant ENTITY_CLEAR_LIST_BOX                 80

#constant ENTITY_CONTROL_MODIFIED               92
#constant ENTITY_CONTROL_MODIFIED_GROUP         96
#constant ENTITY_CONTROL_MODIFIED_INDEX         100
#constant ENTITY_CONTROL_MODIFIED_RESET         104
#constant STRING_A                              1000
#constant STRING_B                              1256
#constant STRING_C                              1512
#constant STRING_D                              1768

rem BUILDGAME
#constant BUILD_GAME_SETUP                    0
#constant BUILD_GAME_SET_TITLE                4
#constant BUILD_GAME_BUTTON_OK                8
#constant BUILD_GAME_BUTTON_CANCEL            12
#constant BUILD_GAME_BUTTON_HELP              16
#constant BUILD_GAME_BUTTON_CLOSE             20
#constant BUILD_GAME_CLOSE                    24
#constant BUILD_GAME_TIMER                    28
#constant SET_EDIT_ITEM             40
#constant SET_EDIT_TEXT             44
#constant GET_EDIT_TEXT             48
#constant BUTTON_CLICKED            52
#constant BROWSE_DISPLAY            56
#constant BROWSE_FILE_SELECTED      60
#constant SET_LIST_ITEM               64
#constant ADD_LIST_ITEM               68
#constant GET_LIST_ITEM               72
#constant SET_LIST_INDEX              76
#constant DELETE_LIST_ITEM       116
#constant GET_LIST_SELECTION         120
#constant LIST_SELECTION                              124
#constant LIST_INSERT_ITEM                            128
#constant LIST_INSERT_POSITION                        132
#constant LIST_CLICKED               140
#constant LIST_CONTROL               144
#constant LIST_CLEAR               152
#constant LIST_SELECT_ITEM                      156
#constant LIST_SELECT_ITEM_INDEX                160
#constant SET_COMBO_ITEM                              80
#constant ADD_COMBO_ITEM                              84
#constant GET_COMBO_ITEM                              88
#constant SET_COMBO_INDEX                             92
#constant SET_RADIO_ITEM                              96
#constant GET_RADIO_ITEM                              100
#constant SET_RADIO_STATE                             148
#constant SET_PROGRESS_ITEM                           108
#constant SET_PROGRESS_POSITION                       112
#constant BUILD_GAME_PROJECT_WEAPONS_DISPLAY          136
global g_filemapoffset as DWORD

rem
rem BUILD GAME
rem

_interface_loadlevelFPMfrombuildgame:
 tfile$=currentFPG$
 if file exist(tfile$)=0 then tfile$="languagebank\"+language$+"\gamebank\"+currentFPG$
 if file exist(tfile$)=1
  dim data$(99)
  load array tfile$,data$()
  for l=0 to 99
   line$=data$(l)
   if len(line$)>0
    if lower$(left$(line$,4))=";end" then exit
    if left$(line$,1)<>";"
     rem take fieldname and values
     for c=0 to len(line$)
      if mid$(line$,c)="=" then mid=c : exit
     next c
     field$=lower$(removeedgespaces(left$(line$,mid-1)))
     value$=removeedgespaces(right$(line$,len(line$)-mid))
     for c=0 to len(value$)
      if mid$(value$,c)="," then mid=c : exit
     next c
     value1=val(removeedgespaces(left$(value$,mid-1)))
     value2$=removeedgespaces(right$(value$,len(value$)-mid))
     if len(value2$)>0 then value2=val(value2$) else value2=-1
     rem Level One FPM
     tryfield$="levelfpm1"
     if field$=tryfield$ then levelfpi$=value$
    endif
   endif
  next l
  undim data$()
 endif
return

_interface_loadbuildgame:

rem load current FPG file and fill data (abs or relative to gamebank)
tfile$=currentFPG$
if file exist(tfile$)=0 then tfile$="languagebank\"+language$+"\gamebank\"+currentFPG$
if file exist(tfile$)=1
 `
 rem current project FPG load data and set in dialog
 set_edit_item( 1, currentFPG$ )
 `
 rem clear old lists (if any)
 clear_list(2)
 clear_list(4)
 clear_list(5)
 clear_list(6)
 clear_list(7)
 clear_list(8)
 clear_list(9)
 clear_list(10)
 clear_list(11)
 `
 rem Load Data from file
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem Executable
    tryfield$="path" : if field$=tryfield$ then set_edit_item(11,value$)
    tryfield$="exe" : if field$=tryfield$ then set_edit_item(13,value$)
    `
    rem Keys
    if field$="keymax" then keymax=value1
    if keymax>0
     for s=1 to keymax
      tryfield$="key"+str$(s)
      if field$=tryfield$ then listkey(s)=value1
      tryfield$="keyname"+str$(s)
      if field$=tryfield$
       add_list_item( 2, value$ )
      endif
     next s
    endif
    `
    rem Weapons
    if field$="slotmax" then gunslotmax=value1
    if gunslotmax>0
     for s=1 to gunslotmax
      tryfield$="slot"+str$(s)
      if field$=tryfield$
       add_list_item(4,value$)
      endif
     next s
    endif
    `
    rem Screens
    tryfield$="title" : if field$=tryfield$ then add_list_item(5,value$)
    tryfield$="global" : if field$=tryfield$ then add_list_item(6,value$)
    tryfield$="gameover" : if field$=tryfield$ then add_list_item(7,value$)
    tryfield$="gamewon" : if field$=tryfield$ then add_list_item(8,value$)
    `
    rem Levels
    if field$="levelmax" then levelmax=value1
    if levelmax>0
     for v=1 to levelmax
      tryfield$="levelfpm"+str$(v)
      if field$=tryfield$ then levelfpm$=value$
      tryfield$="levelfpi"+str$(v)
      if field$=tryfield$
       levelfpi$=value$
       add_list_item(9,str$(v))
       add_list_item(10,levelfpm$)
       add_list_item(11,levelfpi$)
      endif
     next l
    endif
    `
    rem change global states to match build game
    tryfield$="lightmapping" : if field$=tryfield$ then glightmappingstate=value1
    tryfield$="lightmapshadows" : if field$=tryfield$ then glightshadowsstate=value1
    tryfield$="lightmapold" : if field$=tryfield$ then glightmappingold=value1
    tryfield$="dynamiclighting" : if field$=tryfield$ then gdynamiclightingstate=value1
    tryfield$="dynamicshadows" : if field$=tryfield$ then gdynamicshadowsstate=value1
    tryfield$="useeffects" : if field$=tryfield$ then guseeffectstate=value1
    tryfield$="useeffectsonguns" : if field$=tryfield$ then guseeffectongunsstate=value1
    tryfield$="useeffectsonscene" : if field$=tryfield$ then guseeffectonscenestate=value1
    tryfield$="useeffectsonentities" : if field$=tryfield$ then guseeffectonentitiesstate=value1
    tryfield$="dividetexturesize" : if field$=tryfield$ then gdividetexturesize=value1
    tryfield$="controllerhint" : if field$=tryfield$ then gcontrollerhint=value1
    tryfield$="vrmode" : if field$=tryfield$ then gvrmode=value1
    tryfield$="vrmodemag" : if field$=tryfield$ then gvrmodemag=value1

    tryfield$="mousesensitivity" : if field$=tryfield$ then gmousesensitivity=value1
    tryfield$="usefloor" : if field$=tryfield$ then gusefloorstate=value1
    `V109 BETA8 - 060508 - leave these for main SETUP.INI to control (otherwise hidden in FPG)
    `tryfield$="bloodonfloor" : if field$=tryfield$ then gbloodonfloor=value1
    `tryfield$="imageblockmode" : if field$=tryfield$ then gimageblockmode=value1
    tryfield$="shroudsize" : if field$=tryfield$ then shroudsize=value1
    tryfield$="newblossershaders" : if field$=tryfield$ then gnewblossershaders=value1
    tryfield$="postprocessing" : if field$=tryfield$ then gpostprocessing=value1
    tryfield$="showaioutlines" : if field$=tryfield$ then gshowaioutlines=value1
    tryfield$="airadius" : if field$=tryfield$ then gairadius=value1
    tryfield$="disablepeeking" : if field$=tryfield$ then gdisablepeeking=value1
    `
    rem arena settings
    tryfield$="gameobjectivetype" : if field$=tryfield$ then ggameobjectivetype=value1
    tryfield$="gameobjectivevalue" : if field$=tryfield$ then ggameobjectivevalue=value1
    tryfield$="oneshotkills" : if field$=tryfield$ then goneshotkills=value1
    tryfield$="maxplayers" : if field$=tryfield$ then numberofplayers=value1
    tryfield$="spawnrandom" : if field$=tryfield$ then gspawnrandom=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Set flags to show build-game-settings
 if glightmappingstate=0 then set_radio_state(1,1) : set_radio_state(2,0) : set_radio_state(3,0)
 if glightmappingstate=1 and glightshadowsstate=0 then set_radio_state(1,0) : set_radio_state(2,1) : set_radio_state(3,0)
 if glightmappingstate=1 and glightshadowsstate=1 then set_radio_state(1,0) : set_radio_state(2,0) : set_radio_state(3,1)
 if gdividetexturesize=0 then set_radio_state(4,0) : set_radio_state(5,0) : set_radio_state(6,1)
 if gdividetexturesize=2 then set_radio_state(4,0) : set_radio_state(5,1) : set_radio_state(6,0)
 if gdividetexturesize=16 then set_radio_state(4,1) : set_radio_state(5,0) : set_radio_state(6,0)
 if guseeffectstate=0 then set_radio_state(10,1) : set_radio_state(11,0)
 if guseeffectstate=1 then set_radio_state(10,0) : set_radio_state(11,1)
 `a=ghsrmode : set_radio_state(13,a)
 a=gdynamicshadowsstate : set_radio_state(14,a)
 a=gdynamiclightingstate : set_radio_state(15,a)
 a=gusefloorstate : set_radio_state(16,a)
 `
 rem Arena Settings
 if ggameobjectivetype=0 then gmultiplayergame=0 else gmultiplayergame=1
 if gmultiplayergame=1
  if ggameobjectivetype=0 then ggameobjectivetype=1
  if ggameobjectivetype=1 then set_radio_state(21,1) : set_radio_state(22,0) : set_radio_state(23,0)
  if ggameobjectivetype=2 then set_radio_state(21,0) : set_radio_state(22,1) : set_radio_state(23,0)
  if ggameobjectivetype=3 then set_radio_state(21,0) : set_radio_state(22,0) : set_radio_state(23,1)
  if ggameobjectivetype=2 then set_edit_item( 18, str$(ggameobjectivevalue) ) : set_edit_item( 19, "" )
  if ggameobjectivetype=3 then set_edit_item( 18, "" ) : set_edit_item( 19, str$(ggameobjectivevalue) )
  if goneshotkills=1 then set_radio_state(24,1) else set_radio_state(24,0)
  set_edit_item( 20, str$(numberofplayers) )
  if gspawnrandom=0 then set_radio_state(25,1) : set_radio_state(26,0)
  if gspawnrandom=1 then set_radio_state(25,0) : set_radio_state(26,1)
 else
  rem disable arena tab contents
  set_radio_state(21,0) : set_radio_state(22,0) : set_radio_state(23,0)
 endif
 gosub _arenamode_update
 `
 rem Ensure exe path is current and always filled
 value$=removeedgespaces(get_edit_item(11))
 if value$="" then set_edit_item(11,exedir$)
 `
endif

return

_interface_openbuildgame:

   ` open the file map
   open file map 1, "FPSBUILDGAME"

   rem default info
   set_edit_item( 3, strarr$(172) )
   set_edit_item( 9, strarr$(173) )
   set_edit_item( 10, strarr$(174) )
   set_edit_item( 12, "" )

   rem Movements
   add_list_item( 1, strarr$(175) )
   add_list_item( 1, strarr$(176) )
   add_list_item( 1, strarr$(177) )
   add_list_item( 1, strarr$(178) )
   add_list_item( 1, strarr$(179) )
   add_list_item( 1, strarr$(180) )
   add_list_item( 1, strarr$(181) )
   add_list_item( 1, "Reload" )
   add_list_item( 1, strarr$(182) )
   add_list_item( 1, strarr$(183) )
   add_list_item( 1, strarr$(184) )

   rem Weapon Slots
   add_list_item( 3, strarr$(185) )
   add_list_item( 3, strarr$(186) )
   add_list_item( 3, strarr$(187) )
   add_list_item( 3, strarr$(188) )
   add_list_item( 3, strarr$(189) )
   add_list_item( 3, strarr$(190) )
   add_list_item( 3, strarr$(191) )
   add_list_item( 3, strarr$(192) )
   add_list_item( 3, strarr$(193) )
   `
   rem pull project settings from FPG if different
   gosub _interface_prebuildgame
   gosub _interface_loadbuildgame

   ` close the file map
   close file map 1

return

_interface_closebuildgame:
 `
 rem Restore the test-game-settings
 gosub _interface_postbuildgame
 `
 rem Close the dialog
 open file map 1, "FPSBUILDGAME"
 set file map dword 1, BUILD_GAME_CLOSE, 1
 wait for file map event 1
 close file map 1
 `
return

_interface_prebuildgame:
 `
 rem record test-game-settings before enter BUILD GAME
 gdynamiclightingstateBG=gdynamiclightingstate
 gdynamicshadowsstateBG=gdynamicshadowsstate
 guseeffectstateBG=guseeffectstate
 guseeffectongunsstateBG=guseeffectongunsstate
 guseeffectonscenesstateBG=guseeffectonscenesstate
 guseeffectonentitiesstateBG=guseeffectonentitiesstate
 gdividetexturesizeBG=gdividetexturesize
 `ghsrmodeBG=ghsrmode
 glightmappingstateBG=glightmappingstate
 glightshadowsstateBG=glightshadowsstate
 gusefloorstateBG=gusefloorstate
 `
 rem arena mode settings
 ggameobjectivetypeBG=ggameobjectivetype
 ggameobjectivevalueBG=ggameobjectivevalue
 goneshotkillsBG=goneshotkills
 numberofplayersBG=numberofplayers
 gspawnrandomBG=gspawnrandom
 `
return

_interface_postbuildgame:
 `
 rem restore test-game-settings as leave buildgame
 gdynamiclightingstate=gdynamiclightingstateBG
 gdynamicshadowsstate=gdynamicshadowsstateBG
 guseeffectstate=guseeffectstateBG
 guseeffectongunsstate=guseeffectongunsstateBG
 guseeffectonscenesstate=guseeffectonscenesstateBG
 guseeffectonentitiesstate=guseeffectonentitiesstateBG
 gdividetexturesize=gdividetexturesizeBG
 `ghsrmode=ghsrmodeBG
 glightmappingstate=glightmappingstateBG
 glightshadowsstate=glightshadowsstateBG
 gusefloorstate=gusefloorstateBG
 `
 rem arena mode settings
 ggameobjectivetype=ggameobjectivetypeBG
 ggameobjectivevalue=ggameobjectivevalueBG
 goneshotkills=goneshotkillsBG
 numberofplayers=numberofplayersBG
 gspawnrandom=gspawnrandomBG
 `
return

_interface_createnewbuildgame:
 `
 rem ensure FPG name has FPG extension
 if lower$(right$(currentFPG$,4))<>".fpg"
  currentFPG$=currentFPG$+".fpg"
 endif
 `
 rem correct path
 setupfile$="languagebank\"+language$+"\gamebank\"+currentFPG$
 `
 rem if save file unique, create support files as this is NEW PROJECT
 tokay=1
 if file exist(setupfile$)=1
  open file map 2,"FPSEXCHANGE"
  set file map string$ 2, 1000, strarr$(194)
  set file map string$ 2, 1256, strarr$(195)
  set file map dword 2, 900, 1
  wait for file map event 2
  while get file map dword(2, 900)=1
   wait for file map event 2
  endwhile
  tokay=get file map dword(2, 904)
  close file map 2
 endif
 `
 rem continue or skip
 if tokay=1
  `
  rem determine name only of new project
  result$=setupfile$
  result$=right$(result$,len(result$)-len("languagebank\"+language$+"\gamebank\"))
  resultpath$=rootdir$+"languagebank\"+language$+"\gamebank\"
  `
  rem ensure name has no FPG ext
  if lower$(right$(result$,4))=".fpg"
   result$=left$(result$,len(result$)-4)
  endif
  `
  rem store old
  olddir$=get dir$()
  set dir resultpath$
  `
  rem create folder for FPI screens
  if path exist(result$)=0
   make directory result$
   set dir result$
  else
   set dir result$
  endif
  `
  for t=1 to 5
   if gmultiplayergame=0
    rem Single Player : create five FPI screens in correctly named folder
    if t=1 then tfile$="titlepage.fpi"
   else
    rem Arena Mode : create five FPI screens in correctly named folder
    if t=1 then tfile$="arenapage.fpi"
   endif
   if t=2 then tfile$="loadingpage.fpi"
   if t=3 then tfile$="setuplevel.fpi"
   if t=4 then tfile$="gamewon.fpi"
   if t=5 then tfile$="gameover.fpi"
   if file exist(tfile$)=1 then delete file tfile$
   if gmultiplayergame=0
    copy file rootdir$+"languagebank\"+language$+"\gamebank\templateoriginal\"+tfile$,tfile$
   else
    copy file rootdir$+"languagebank\"+language$+"\gamebank\templatearena\"+tfile$,tfile$
   endif
  next t
  `
  rem Leave folder just created
  set dir olddir$
  `
  rem New project is (can add FPG if not there)
  currentFPG$=result$+".fpg"
  setupfile$="languagebank\"+language$+"\gamebank\"+currentFPG$
  `
  rem Copy template FPG to new name
  tfile$=rootdir$+setupfile$
  if file exist(tfile$)=1 then delete file tfile$
  if gmultiplayergame=0
   copy file rootdir$+"languagebank\"+language$+"\gamebank\templateoriginal\mygame.fpg",tfile$
  else
   copy file rootdir$+"languagebank\"+language$+"\gamebank\templatearena\myarena.fpg",tfile$
  endif
  `
  rem Manipulate fields to reflect new project name
  gosub _interface_loadbuildgame
  set_edit_item(11,exedir$)
  set_edit_item(13,result$+".exe")
  if gmultiplayergame=0
   clear_list(5) : add_list_item(5,"languagebank\"+language$+"\gamebank\"+result$+"\titlepage.fpi")
  else
   clear_list(5) : add_list_item(5,"languagebank\"+language$+"\gamebank\"+result$+"\arenapage.fpi")
  endif
  clear_list(6) : add_list_item(6,"languagebank\"+language$+"\gamebank\"+result$+"\setuplevel.fpi")
  clear_list(7) : add_list_item(7,"languagebank\"+language$+"\gamebank\"+result$+"\gameover.fpi")
  clear_list(8) : add_list_item(8,"languagebank\"+language$+"\gamebank\"+result$+"\gamewon.fpi")
  tmapnameonly$=right$(projectfilename$,len(projectfilename$)-len(rootdir$))
  if gmultiplayergame=0
   if lower$(left$(tmapnameonly$,8))<>"mapbank\" then tmapnameonly$="mapbank\testgame.fpm"
  else
   if lower$(left$(tmapnameonly$,8))<>"mapbank\" then tmapnameonly$="mapbank\testarena.fpm"
  endif
  delete_list_item(10,0) : insert_list_item(10,0,tmapnameonly$)
  delete_list_item(11,0) : insert_list_item(11,0,"languagebank\"+language$+"\gamebank\"+result$+"\loadingpage.fpi")
  gosub _interface_savebuildgame
  `
 endif
 `
return

_interface_savebuildgame:
 `
 rem make sure states are reflective of the current dialog controls
 if get_radio_state(1)=1 then glightmappingstate=0 : glightshadowsstate=0
 if get_radio_state(2)=1 then glightmappingstate=1 : glightshadowsstate=0
 if get_radio_state(3)=1 then glightmappingstate=1 : glightshadowsstate=1
 if get_radio_state(4)=1 then gdividetexturesize=16
 if get_radio_state(5)=1 then gdividetexturesize=2
 if get_radio_state(6)=1 then gdividetexturesize=0
 if get_radio_state(10)=1 then guseeffectstate=0
 if get_radio_state(11)=1 then guseeffectstate=1
 if guseeffectstate=1
  guseeffectongunsstate=1
  guseeffectonscenesstate=1
  guseeffectonentitiesstate=1
 else
  guseeffectongunsstate=0
  guseeffectonscenesstate=0
  guseeffectonentitiesstate=0
 endif
 `a=get_radio_state(13) : ghsrmode=a
 a=get_radio_state(14) : gdynamicshadowsstate=a
 a=get_radio_state(15) : gdynamiclightingstate=a
 a=get_radio_state(16) : gusefloorstate=a
 `
 rem arena settings
 if get_radio_state(21)=1 then ggameobjectivetype=1
 if get_radio_state(22)=1 then ggameobjectivetype=2
 if get_radio_state(23)=1 then ggameobjectivetype=3
 if ggameobjectivetype=2
  ggameobjectivevalue = val ( get_edit_item(18) )
 endif
 if ggameobjectivetype=3
  ggameobjectivevalue = val ( get_edit_item(19) )
 endif
 if get_radio_state(24)=1 then goneshotkills=1 else goneshotkills=0
 numberofplayers = val ( get_edit_item(20) )
 if get_radio_state(25)=1 then gspawnrandom=0
 if get_radio_state(26)=1 then gspawnrandom=1
 `
 rem save new states to .FPG
 dim setuparr$(999) : i=0
 setuparr$(i)="; FPG Game Profile" : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="; Game Profile" : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="path           = "+get_edit_item(11) : inc i
 setuparr$(i)="exe            = "+get_edit_item(13) : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="; Keyboard Config" : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="keymax=11" : inc i
 for k=1 to 11
  keyval$=get_list_item( 2, k-1 )
  keyname$=keyval$
  for c=1 to len(keyval$)
   if mid$(keyval$,c)=" " then keyval$=left$(keyval$,c-1) : exit
  next c
  keyname$=right$(keyname$,len(keyname$)-(len(keyval$)+1))
  if listkey(k)=-1 then listkey(k)=val(keyval$)
  setuparr$(i)="key"+str$(k)+"           = "+str$(listkey(k)) : inc i
  setuparr$(i)="keyname"+str$(k)+"       = "+keyname$ : inc i
 next k
 setuparr$(i)="" : inc i
 setuparr$(i)="; Gunslots" : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="slotmax=9" : inc i
 setuparr$(i)="slot1          = "+get_list_item( 4, 0 ) : inc i
 setuparr$(i)="slot2          = "+get_list_item( 4, 1 ) : inc i
 setuparr$(i)="slot3          = "+get_list_item( 4, 2 ) : inc i
 setuparr$(i)="slot4          = "+get_list_item( 4, 3 ) : inc i
 setuparr$(i)="slot5          = "+get_list_item( 4, 4 ) : inc i
 setuparr$(i)="slot6          = "+get_list_item( 4, 5 ) : inc i
 setuparr$(i)="slot7          = "+get_list_item( 4, 6 ) : inc i
 setuparr$(i)="slot8          = "+get_list_item( 4, 7 ) : inc i
 setuparr$(i)="slot9          = "+get_list_item( 4, 8 ) : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="; Screen FPIs" : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="title          = "+get_list_item( 5, 0 ) : inc i
 setuparr$(i)="global         = "+get_list_item( 6, 0 ) : inc i
 setuparr$(i)="gameover       = "+get_list_item( 7, 0 ) : inc i
 setuparr$(i)="gamewon        = "+get_list_item( 8, 0 ) : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="; Levels" : inc i
 setuparr$(i)="" : inc i
 levelmax=1
 while get_list_item( 10, levelmax-1 )<>"" and levelmax<99
  inc levelmax
 endwhile
 dec levelmax
 setuparr$(i)="levelmax="+str$(levelmax) : inc i
 for l=1 to levelmax
  setuparr$(i)="levelfpm"+str$(l)+"      = "+get_list_item( 10, l-1 ) : inc i
  setuparr$(i)="levelfpi"+str$(l)+"      = "+get_list_item( 11, l-1 ) : inc i
 next l
 setuparr$(i)="" : inc i
 setuparr$(i)="; Build Specific Flags" : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="dynamiclighting="+str$(gdynamiclightingstate) : inc i
 setuparr$(i)="dynamicshadows="+str$(gdynamicshadowsstate) : inc i
 setuparr$(i)="useeffects="+str$( guseeffectstate ) : inc i
 setuparr$(i)="useeffectsonguns="+str$( guseeffectongunsstate ) : inc i
 setuparr$(i)="useeffectsonscene="+str$( guseeffectonscenesstate ) : inc i
 setuparr$(i)="useeffectsonentities="+str$( guseeffectonentitiesstate ) : inc i
 setuparr$(i)="dividetexturesize="+str$( gdividetexturesize ) : inc i
 setuparr$(i)="controllerhint="+str$( gcontrollerhint ) : inc i
 setuparr$(i)="vrmode="+str$( gvrmode ) : inc i
 setuparr$(i)="vrmodemag="+str$( gvrmodemag ) : inc i

 setuparr$(i)="mousesensitivity="+str$( gmousesensitivity ) : inc i
 setuparr$(i)="lightmapping="+str$(glightmappingstate) : inc i
 setuparr$(i)="lightmapshadows="+str$(glightshadowsstate) : inc i
 setuparr$(i)="lightmapold="+str$(glightmappingold) : inc i
 setuparr$(i)="usefloor="+str$(gusefloorstate) : inc i
 setuparr$(i)="bloodonfloor="+str$(gbloodonfloor) : inc i
 `V109 BETA8 - 060508 - leave these for main SETUP.INI to control (otherwise hidden in FPG)
 `setuparr$(i)="imageblockmode="+str$(gimageblockmode) : inc i
 setuparr$(i)="shroudsize="+str$(shroudsize) : inc i
 setuparr$(i)="newblossershaders="+str$( gnewblossershaders ) : inc i
 setuparr$(i)="postprocessing="+str$( gpostprocessing ) : inc i
 setuparr$(i)="showaioutlines="+str$( gshowaioutlines ) : inc i
 setuparr$(i)="airadius="+str$( gairadius ) : inc i
 setuparr$(i)="disablepeeking="+str$( gdisablepeeking ) : inc i
 setuparr$(i)="" : inc i
 setuparr$(i)="multiplayergame="+str$(gmultiplayergame) : inc i
 setuparr$(i)="gameobjectivetype="+str$(ggameobjectivetype) : inc i
 setuparr$(i)="gameobjectivevalue="+str$(ggameobjectivevalue) : inc i
 setuparr$(i)="oneshotkills="+str$(goneshotkills) : inc i
 setuparr$(i)="maxplayers="+str$(numberofplayers) : inc i
 setuparr$(i)="spawnrandom="+str$(gspawnrandom) : inc i
 setuparr$(i)="uniquegamecode="+guniquegamecode$ : inc i
 setuparr$(i)="" : inc i
 `
 rem determine name of save file
 if mid$(currentFPG$,2)<>":"
  setupfile$="languagebank\"+language$+"\gamebank\"+currentFPG$
 else
  setupfile$=currentFPG$
 endif
 `
 rem save out profile file
 save array setupfile$,setuparr$()
 undim setuparr$()
 `
return

_interface_calcnewlevelmax:
 levelmax=1
 while get_list_item( 10, levelmax-1 )<>"" and levelmax<99
  inc levelmax
 endwhile
 dec levelmax
return

_interface_handlebuildgame:
 `
 leavedialog=0
 while leavedialog=0
   `
   rem open filemap
   open file map 1, "FPSBUILDGAME"
   wait for file map event 1
   `
   rem main build game buttons
   ok     = get file map dword ( 1, BUILD_GAME_BUTTON_OK )
   help   = get file map dword ( 1, BUILD_GAME_BUTTON_HELP )
   cancel = get file map dword ( 1, BUILD_GAME_BUTTON_CANCEL )
   close  = get file map dword ( 1, BUILD_GAME_BUTTON_CLOSE )
   `
   rem Main Project File browse
   if ( get file map dword ( 1, BUTTON_CLICKED ) = 1 )
    set file map dword 1, BUTTON_CLICKED, 0
    wait for file map event 1
    tdir$=rootdir$+"languagebank\"+language$+"\gamebank\"
    browse( strarr$(196), tdir$, strarr$(197) )
    result$  = get file map string$ ( 1, 1000 )
    if result$<>""
     if mid$(result$,2)=":" then result$=right$(result$,len(result$)-len(tdir$))
     currentFPG$=result$ : gosub _interface_loadbuildgame
    endif
   endif
   `
   rem If user clicks NEW, create new project
   if get file map dword( 1, 180 ) = 1
    result$=get file map string$ ( 1, STRING_A )
    set file map dword 1, 180, 0
    wait for file map event 1
    if result$<>""
     currentFPG$=result$
     gosub _interface_createnewbuildgame
    endif
   endif
   `
   rem If detect click on Key Control, reset value as it has been updated
   if get file map dword ( 1, LIST_CLICKED )=10 and get file map dword ( 1, LIST_CONTROL ) = 10
    set file map dword 1, LIST_CLICKED, 0
    set file map dword 1, LIST_CONTROL, 0
    wait for file map event 1
    tsel=1+get_list_item_selection( 2 )
    listkey(tsel)=-1
   endif
   `
   rem Click FPI screens (change to another)
   for tscr=1 to 5
    if tscr=1 then tokay=0
    if tscr=2 then tokay=1
    if tscr=3 then tokay=2
    if tscr=4 then tokay=3
    if tscr=5 then tokay=11
    if get file map dword ( 1, LIST_CLICKED )=1 and get file map dword ( 1, LIST_CONTROL ) = tokay
     set file map dword 1, LIST_CLICKED, 0
     wait for file map event 1
     tsel=get_list_item_selection( 11 )
     tdir$=rootdir$+"languagebank\"+language$+"\gamebank\"
     browse( strarr$(198), tdir$, strarr$(199) )
     result$  = get file map string$ ( 1, 1000 )
     if result$<>""
      if mid$(result$,2)=":" then result$=right$(result$,len(result$)-len(tdir$))
      result$="languagebank\"+language$+"\gamebank\"+result$
      if tscr=1 then clear_list(5) : add_list_item(5,result$)
      if tscr=2 then clear_list(6) : add_list_item(6,result$)
      if tscr=3 then clear_list(7) : add_list_item(7,result$)
      if tscr=4 then clear_list(8) : add_list_item(8,result$)
      if tscr=5
       delete_list_item(11,tsel)
       insert_list_item(11,tsel,result$)
      endif
     endif
    endif
   next tscr
   `
   rem Click EDIT existing FPI screens
   for tscr=1 to 5
    if tscr=1 then tokay=2 : fpitype=1
    if tscr=2 then tokay=3 : fpitype=3
    if tscr=3 then tokay=4 : fpitype=4
    if tscr=4 then tokay=5 : fpitype=5
    if tscr=5 then tokay=8 : fpitype=2
    if get file map dword ( 1, BUTTON_CLICKED ) = tokay
     set file map dword 1, BUTTON_CLICKED, 0
     wait for file map event 1
     if tscr=5
      tsel=get_list_item_selection( 11 )
      fpiname$=get_list_item( 11, tsel )
     else
      fpiname$=get_list_item( 3+tokay, 0 )
     endif
     if fpiname$<>""
      gosub _interface_openfpi
      gosub _interface_handlefpi
     endif
    endif
   next tscr
   `
   rem Click to select FPM file
   if get file map dword ( 1, LIST_CLICKED )=1 and get file map dword ( 1, LIST_CONTROL ) = 10
    set file map dword 1, LIST_CLICKED, 0
    wait for file map event 1
    tsel=get_list_item_selection( 10 )
    tdir$=rootdir$+"mapbank\"
    browse( strarr$(200), tdir$, strarr$(201) )
    result$  = get file map string$ ( 1, 1000 )
    if result$<>""
     if mid$(result$,2)=":"
      if lower$(left$(result$,len(tdir$)))=lower$(tdir$)
       result$=right$(result$,len(result$)-len(tdir$))
      else
       result$=""
      endif
     endif
     if result$<>""
      result$="mapbank\"+result$
      if tsel>=0
       delete_list_item(10,tsel)
       insert_list_item(10,tsel,result$)
      endif
     endif
    endif
   endif
   `
   rem Click Executable folder browser button
   if ( get file map dword ( 1, BUTTON_CLICKED ) = 9 )
    set file map dword 1, BUTTON_CLICKED, 0
    wait for file map event 1
    result$ = browse_for_folder ( exedir$ )
    if result$<>""
     exedir$=result$ : set_edit_item(11,exedir$)
    endif
   endif
   `
   rem BUILD EXECUTABLE Click
   if get file map dword ( 1, BUTTON_CLICKED ) = 10
    `
    rem Debug this critical session
    timestampactivity(0,"BUILDGAME: Build button clicked")
    `
    rem check MP arena plr count
    if gmultiplayergame=1
     tokay=0
     ttfpmname$=get_list_item( 10, 0 )
     ttcurrent$=right$(currentprojectfilename$,len(currentprojectfilename$)-len(rootdir$))
     if lower$(ttcurrent$)=lower$(ttfpmname$)
      gosub _input_checkarenaminspec
      if tokay=0
       set_edit_item(12,strarr$(560))
      endif
     else
      tokay=1
     endif
    else
     tokay=1
    endif
    `
    rem Debug this critical session
    timestampactivity(0,"BUILDGAME: Checked MP arena player count, flag for TOKAY was "+str$(tokay))
    `
    rem proceed with buildgame
    if tokay=1
     `
     rem Debug this critical session
     timestampactivity(0,"BUILDGAME: Before save test map")
     `
     rem Save map data
     gosub _gridedit_save_test_map
     `
     rem Save contents of testmap to TEMP (buildexe might overwrite testmap files)
     projectfilename$="editors\gridedit\temp.fpm"
     gosub _mapfile_saveproject_fpm
     `
     rem Debug this critical session
     timestampactivity(0,"BUILDGAME: Before progress bar")
     `
     rem Initial progress text
     set file map dword 1, BUTTON_CLICKED, 0
     wait for file map event 1
     set_edit_item( 12, strarr$(202) )
     `
     rem Save build game data as quitting after built exe
     gosub _interface_savebuildgame
     `
     rem Save build-game-settings in SETUP.INI (for game engine build)
     savesetupfile$="buildsetup.ini"
     gosub _interface_savesetupfile
     savesetupfile$="setup.ini"
     `
     rem Make build update for exe
     texepath$=get_edit_item(11)
     texename$=get_edit_item(13)
     dim buildarr$(3)
     buildarr$(0)="[BUILD]"
     buildarr$(1)="path="+texepath$
     buildarr$(2)="name="+texename$
     buildarr$(3)=""
     save array rootdir$+"..\build.ini",buildarr$()
     undim buildarr$()
     `
     rem Debug this critical session
     timestampactivity(0,"BUILDGAME: Before fpsc-game launch")
     `
     rem Cause Game To Build
     open file map 2, "FPSEXCHANGE"
     set file map string$ 2, STRING_A, "fpsc-game.exe"
     set file map string$ 2, STRING_B, "-b"
     set file map dword 2, 916, 1
     set file map dword 2, 920, 1
     wait for file map event 2
     close file map 2
     `
    endif
    `
    rem Debug this critical session
    timestampactivity(0,"BUILDGAME: End of click build button")
    `
   endif
   `
   rem Weapon Choices
   if get file map dword ( 1, BUILD_GAME_PROJECT_WEAPONS_DISPLAY ) = 1
    ` add in our weapon types to the pop up dialog
    fillgloballistwithweapons()
    `for w=0 to 17 FPGC - 131009 - show ALL guns
    for w=0 to gunmax
     add_combo_box( 1, list$(w) )
    next w
    while get file map dword ( 1, BUILD_GAME_PROJECT_WEAPONS_DISPLAY ) = 1
     wait for file map event 1
    endwhile
   endif
   `
   rem ADD Level Button
   taddorinsertalistitem=0
   if get file map dword ( 1, BUTTON_CLICKED ) = 17
    taddorinsertalistitem=-1
   endif
   rem Insert Level Button
   if get file map dword ( 1, BUTTON_CLICKED ) = 6
    taddorinsertalistitem=get_list_item_selection( 9 )
   endif
   `
   rem Add/Insert Level Code
   if taddorinsertalistitem<>0
      index = taddorinsertalistitem
      tnum$=str$(levelmax+1)
      if index=-1
       insert_list_item( 9, index, tnum$ )
      else
       insert_list_item( 9, index, strarr$(203) )
      endif
      insert_list_item( 10, index, "mapbank\default.fpm" )
      result$="languagebank\"+language$+"\gamebank\"+currentFPG$
      if lower$(right$(result$,4))=".fpg"
       result$=left$(result$,len(result$)-4)
      endif
      tfile$=result$+"\loadingpage"+tnum$+".fpi"
      if file exist(tfile$)=0
       copy file "languagebank\"+language$+"\gamebank\templateoriginal\loadingpage.fpi",tfile$
      endif
      insert_list_item( 11, index, tfile$ )
      rem renumber level numbers for neatness
      clear_list(9)
      for tlvl=1 to levelmax+1
       add_list_item( 9, str$(tlvl) )
      next tlvl
      if index>=0
       rem set highlight to inserted
       select_list_item(9,index)
       select_list_item(10,index)
       select_list_item(11,index)
      endif
      set file map dword 1, BUTTON_CLICKED, 0
      wait for file map event 1
      gosub _interface_calcnewlevelmax
   endif

   ` delete a level
   if get file map dword ( 1, BUTTON_CLICKED ) = 7
      index = get_list_item_selection( 9 )
      delete_list_item( 9, index )
      delete_list_item( 10, index )
      delete_list_item( 11, index )
      set file map dword 1, BUTTON_CLICKED, 0
      wait for file map event 1
      gosub _interface_calcnewlevelmax
   endif

   ` END OF DIALOG
   if ok=1
    gosub _interface_savebuildgame
    leavedialog=1
   endif
   if cancel=1 or close=1
    leavedialog=1
   endif
   if help=1
    rem launch website from here
   endif

   ` close filemap
   close file map 1

   ` update
   sync
   `
 endwhile
 `
return


rem
rem PREFERENCES
rem

_interface_openprefs:
 `
 rem wait for prefs to start
 open file map 1, "FPSPREFERENCES"
 wait for file map event 1
 while get file map dword( 1, 0 )=0
  wait for file map event 1
 endwhile
 close file map 1
 `
 rem read current settings and populate dialog
 open file map 1, "FPSPREFERENCES"
 a=gdynamiclightingstate : set_radio_state(1,a)
 a=gdynamicshadowsstate : set_radio_state(2,a)
 if glightmappingstate=0 then set_radio_state(3,1) : set_radio_state(4,0) : set_radio_state(5,0)
 if glightmappingstate=1 and glightshadowsstate=0 then set_radio_state(3,0) : set_radio_state(4,1) : set_radio_state(5,0)
 if glightmappingstate=1 and glightshadowsstate=1 then set_radio_state(3,0) : set_radio_state(4,0) : set_radio_state(5,1)
 if guseeffectstate=0 then set_radio_state(6,1) : set_radio_state(7,0)
 if guseeffectstate=1 then set_radio_state(6,0) : set_radio_state(7,1)
 if gdividetexturesize=0 then set_radio_state(9,0) : set_radio_state(10,0) : set_radio_state(11,1)
 if gdividetexturesize=2 then set_radio_state(9,0) : set_radio_state(10,1) : set_radio_state(11,0)
 if gdividetexturesize=16 then set_radio_state(9,1) : set_radio_state(10,0) : set_radio_state(11,0)
 `a=ghsrmode : set_radio_state(12,a)
 a=gshowentitygameinfostate : set_radio_state(13,a)
 a=gshowdebugtextingamestate : set_radio_state(14,a)
 a=gusefloorstate : set_radio_state(15,a)
 if gmultiplayergame=0 then set_radio_state(16,1) : set_radio_state(17,0)
 if gmultiplayergame=1 then set_radio_state(16,0) : set_radio_state(17,1)
 close file map 1

return

_interface_closeprefs:
 open file map 1, "FPSPREFERENCES"
 set file map dword 1, 12, 1
 wait for file map event 1
 close file map 1
return

_interface_savesetupfile:

rem save new states to SETUP.INI
dim setuparr$(999)
setupfile$=savesetupfile$ : i=0
setuparr$(i)="[GAMERUN]" : inc i
setuparr$(i)="realgameview=0" : inc i
setuparr$(i)="dynamiclighting="+str$(gdynamiclightingstate) : inc i
setuparr$(i)="dynamicshadows="+str$(gdynamicshadowsstate) : inc i
setuparr$(i)="useeffects="+str$( guseeffectstate ) : inc i
setuparr$(i)="useeffectsonguns="+str$( guseeffectongunsstate ) : inc i
setuparr$(i)="useeffectsonscene="+str$( guseeffectonscenesstate ) : inc i
setuparr$(i)="useeffectsonentities="+str$( guseeffectonentitiesstate ) : inc i
setuparr$(i)="dividetexturesize="+str$( gdividetexturesize ) : inc i
setuparr$(i)="controllerhint="+str$( gcontrollerhint ) : inc i
setuparr$(i)="vrmode="+str$( gvrmode ) : inc i
setuparr$(i)="vrmodemag="+str$( gvrmodemag ) : inc i

setuparr$(i)="mousesensitivity="+str$( gmousesensitivity ) : inc i
setuparr$(i)="producelogfiles="+str$( gproducelogfiles ) : inc i
setuparr$(i)="hsrmode="+str$( ghsrmode ) : inc i
setuparr$(i)="optimizemode=1" : inc i
setuparr$(i)="aspectratio="+str$( gaspectratio ) : inc i
setuparr$(i)="newblossershaders="+str$( gnewblossershaders ) : inc i
setuparr$(i)="postprocessing="+str$( gpostprocessing ) : inc i
setuparr$(i)="showaioutlines="+str$( gshowaioutlines ) : inc i
setuparr$(i)="airadius="+str$( gairadius ) : inc i
setuparr$(i)="disablepeeking="+str$( gdisablepeeking ) : inc i
setuparr$(i)="disableparticles="+str$( gparticlesnotused ) : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEMULTIPLAYER]" : inc i
setuparr$(i)="multiplayergame="+str$(gmultiplayergame) : inc i
setuparr$(i)="gameobjectivetype="+str$(ggameobjectivetype) : inc i
setuparr$(i)="gameobjectivevalue="+str$(ggameobjectivevalue) : inc i
setuparr$(i)="oneshotkills="+str$(goneshotkills) : inc i
setuparr$(i)="maxplayers="+str$(numberofplayers) : inc i
setuparr$(i)="spawnrandom="+str$(gspawnrandom) : inc i
setuparr$(i)="uniquegamecode="+guniquegamecode$ : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEMAKE]" : inc i
setuparr$(i)="lightmapping="+str$(glightmappingstate) : inc i
setuparr$(i)="lightmapold="+str$(glightmappingold) : inc i
setuparr$(i)="lightmapshadows="+str$(glightshadowsstate) : inc i
setuparr$(i)="lightmapambientr="+str$(glightambientr) : inc i
setuparr$(i)="lightmapambientg="+str$(glightambientg) : inc i
setuparr$(i)="lightmapambientb="+str$(glightambientb) : inc i
setuparr$(i)="lightmapsunx="+str$(glightsunx) : inc i
setuparr$(i)="lightmapsuny="+str$(glightsuny) : inc i
setuparr$(i)="lightmapsunz="+str$(glightsunz) : inc i
setuparr$(i)="lightmapsunr="+str$(glightsunr) : inc i
setuparr$(i)="lightmapsung="+str$(glightsung) : inc i
setuparr$(i)="lightmapsunb="+str$(glightsunb) : inc i
setuparr$(i)="lightmapzerorange="+str$(glightzerorange) : inc i
setuparr$(i)="lightmapatten="+str$(glightatten) : inc i
setuparr$(i)="lightmapmaxsize="+str$(glightmaxsize) : inc i
setuparr$(i)="lightmapboost="+str$(glightboost) : inc i
setuparr$(i)="lightmaptexsize="+str$(glighttexsize) : inc i
setuparr$(i)="lightmapquality="+str$(glightquality) : inc i
setuparr$(i)="lightmapblurmode="+str$(glightblurmode) : inc i
setuparr$(i)="lightmapthreadmax="+str$(glightthreadmax) : inc i
setuparr$(i)="bloodonfloor="+str$(gbloodonfloor) : inc i
setuparr$(i)="imageblockmode="+str$(gimageblockmode) : inc i
setuparr$(i)="shroudsize="+str$(shroudsize) : inc i
setuparr$(i)="showalluniquetextures="+str$(gshowalluniquetextures) : inc i
setuparr$(i)="systemmemorycapoff="+str$(gsystemmemorycapoff) : inc i
setuparr$(i)="entitytogglingoff="+str$(gentitytogglingoff) : inc i
setuparr$(i)="extracollisionbuilddisabled="+str$(gextracollisionbuilddisabled) : inc i
setuparr$(i)="alwaysconfirmsave="+str$(galwaysconfirmsave) : inc i
setuparr$(i)="simplifiedcharacterediting="+str$(gsimplifiedcharacterediting) : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEDEBUG]" : inc i
setuparr$(i)="exitpromptreport="+str$(gexitpromptreportmodestate) : inc i
setuparr$(i)="debugreport=0" : inc i
setuparr$(i)="showentitygameinfo="+str$( gshowentitygameinfostate ) : inc i
setuparr$(i)="showdebugtextingame="+str$( gshowdebugtextingamestate ) : inc i
setuparr$(i)="debugreportstepthrough=0" : inc i
setuparr$(i)="usesky=1" : inc i
setuparr$(i)="usefloor="+str$( gusefloorstate ) : inc i
setuparr$(i)="useenvsounds=1" : inc i
setuparr$(i)="useweapons=1" : inc i
setuparr$(i)="includeonlyvideo=0" : inc i
setuparr$(i)="includeonlyname=gamecore" : inc i
setuparr$(i)="width=1024" : inc i
setuparr$(i)="height=768" : inc i
setuparr$(i)="depth=32" : inc i
setuparr$(i)="aspectratio="+str$(gaspectratio) : inc i
setuparr$(i)="useuniquelynamedentities=0" : inc i
setuparr$(i)="exportassets="+str$(gexportassets) : inc i
setuparr$(i)="loadreport="+str$(gloadreportstate) : inc i

rem default game profile for test game
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEPROFILE]" : inc i

rem test game defaults or real-build-game-data
if savesetupfile$="setup.ini"
 `
 rem test game defaults
 setuparr$(i)="key1           = 17" : inc i
 setuparr$(i)="key2           = 31" : inc i
 setuparr$(i)="key3           = 30" : inc i
 setuparr$(i)="key4           = 32" : inc i
 setuparr$(i)="key5           = 57" : inc i
 setuparr$(i)="key6           = 46" : inc i
 setuparr$(i)="key7           = 28" : inc i
 setuparr$(i)="key8           = 19" : inc i
 setuparr$(i)="key9           = 16" : inc i
 setuparr$(i)="key10          = 18" : inc i
 setuparr$(i)="key11          = 42" : inc i
 setuparr$(i)="global         = languagebank\"+language$+"\gamebank\mygame\setuplevel.fpi" : inc i
 setuparr$(i)="levelmax       = 1"
 setuparr$(i)="levelfpm1      = " : inc i
 setuparr$(i)="levelfpi1      = languagebank\"+language$+"\gamebank\mygame\loadingpage.fpi" : inc i
 `
else
 `
 rem build game short-list data for game exe
 for k=1 to 11
  setuparr$(i)="key"+str$(k)+"           = "+str$(listkey(k)) : inc i
 next k
 setuparr$(i)="slot1          = "+get_list_item( 4, 0 ) : inc i
 setuparr$(i)="slot2          = "+get_list_item( 4, 1 ) : inc i
 setuparr$(i)="slot3          = "+get_list_item( 4, 2 ) : inc i
 setuparr$(i)="slot4          = "+get_list_item( 4, 3 ) : inc i
 setuparr$(i)="slot5          = "+get_list_item( 4, 4 ) : inc i
 setuparr$(i)="slot6          = "+get_list_item( 4, 5 ) : inc i
 setuparr$(i)="slot7          = "+get_list_item( 4, 6 ) : inc i
 setuparr$(i)="slot8          = "+get_list_item( 4, 7 ) : inc i
 setuparr$(i)="slot9          = "+get_list_item( 4, 8 ) : inc i
 setuparr$(i)="title          = "+get_list_item( 5, 0 ) : inc i
 setuparr$(i)="global         = "+get_list_item( 6, 0 ) : inc i
 setuparr$(i)="gameover       = "+get_list_item( 7, 0 ) : inc i
 setuparr$(i)="gamewon        = "+get_list_item( 8, 0 ) : inc i
 levelmax=1
 while get_list_item( 10, levelmax-1 )<>"" and levelmax<99
  inc levelmax
 endwhile
 dec levelmax
 setuparr$(i)="levelmax="+str$(levelmax) : inc i
 for l=1 to levelmax
  setuparr$(i)="levelfpm"+str$(l)+"      = "+get_list_item( 10, l-1 ) : inc i
  setuparr$(i)="levelfpi"+str$(l)+"      = "+get_list_item( 11, l-1 ) : inc i
 next l
 `
endif

rem Save the setup file to name and root location (1-or absfilename from var$)
save array "..\"+setupfile$,setuparr$()
undim setuparr$()

return

_interface_saveprefs:

rem place settings from dialog back into states
a=get_radio_state(1) : gdynamiclightingstate=a
a=get_radio_state(2) : gdynamicshadowsstate=a
if get_radio_state(3)=1 then glightmappingstate=0 : glightshadowsstate=0
if get_radio_state(4)=1 then glightmappingstate=1 : glightshadowsstate=0
if get_radio_state(5)=1 then glightmappingstate=1 : glightshadowsstate=1
if get_radio_state(6)=1 then guseeffectstate=0
if get_radio_state(7)=1 then guseeffectstate=1
if guseeffectstate=1
 guseeffectongunsstate=1
 guseeffectonscenesstate=1
 guseeffectonentitiesstate=1
else
 guseeffectongunsstate=0
 guseeffectonscenesstate=0
 guseeffectonentitiesstate=0
endif
rem FPGC - 040510 - more severe reducer for very low (good for large level testing)
`if get_radio_state(9)=1 then gdividetexturesize=4
if get_radio_state(9)=1 then gdividetexturesize=16
if get_radio_state(10)=1 then gdividetexturesize=2
if get_radio_state(11)=1 then gdividetexturesize=0
`a=get_radio_state(12) : ghsrmode=a
a=get_radio_state(13) : gshowentitygameinfostate=a
a=get_radio_state(14) : gshowdebugtextingamestate=a
a=get_radio_state(15) : gusefloorstate=a
if get_radio_state(16)=1 then gmultiplayergame=0
if get_radio_state(17)=1 then gmultiplayergame=1
savesetupfile$="setup.ini" : gosub _interface_savesetupfile

rem update to interface due to any gmultiplayergame change
gosub _arenamode_update

return

_interface_handleprefs:
 leavedialog=0
 while leavedialog=0
  open file map 1, "FPSPREFERENCES"
  wait for file map event 1
  if get file map dword ( 1, 4 ) = 1
   gosub _interface_saveprefs
   leavedialog=1
  endif
  if get file map dword ( 1, 8 ) = 1
   leavedialog=1
  endif
  if get file map dword ( 1, 0 ) = 0
   leavedialog=1
  endif
  close file map 1
  sync
 endwhile
return


rem
rem PROPERTIES
rem

_interface_openpropertywindow:
 `
 rem Open proprty window
 open file map 1, "FPSEXCHANGE"
 set file map dword 1, 978, 1
 set file map dword 1, 458, 0
 wait for file map event 1
 editorinterfaceactive=e
 close file map 1
 `
 rem open the entity file map
 open file map 2, "FPSENTITY"
 wait for file map event 2
 `
 rem wait until the entity window is read
 if get file map dword( 2, ENTITY_SETUP ) = 1
  `
  rem FPGC - 070510 - simplified character properties
  if gsimplifiedcharacterediting=1 and entityprofile(gridentity).ischaracter=1
   rem flag the simple character properties layout (FPGC)
   tsimplecharview=1
  else
   rem Setup usage flags
   tsimplecharview=0
   tflaglives=0 : tflaglight=0 : tflagobjective=0 : tflagtdecal=0 : tflagdecalparticle=0 : tflagspawn=0 : tflagifused=0
   tflagvis=0 : tflagchar=0 : tflagweap=0 : tflagammo=0 : tflagai=1 : tflagsound=0 : tflagsoundset=0 : tflagnosecond=0
   tflagmobile=0 : tflaghurtfall=0 : tflaghasweapon=0 : tflagammoclip=0 : tflagstats=0 : tflagquantity=0
   tflagvideo=0
   rem If its static and arena mode, only do optional visuals, ignore rest
   tstatic=0
   if gmultiplayergame=1
    if entityprofile(gridentity).isflak=1
     tstatic=1
    else
     if entityprofile(gridentity).isammo<>0 or entityprofile(gridentity).isweapon<>0 or entityprofile(gridentity).ischaracter<>0 or entityprofile(gridentity).ishealth<>0
      tstatic=0
     else
      tstatic=1
     endif
    endif
   endif
   if gmultiplayergame=1 and tstatic=1
    rem only allow arena mode static entity optional visuals
    tflagvis=1 : tflagai=0
   else
    rem FPGC - 260310 - new entitylight indicated with new flag
    if entityprofile(gridentity).islightmarker=1
     tflaglight=1
    else
     if entityprofile(gridentity).ismarker=0
      tflagvis=1 : tflagmobile=1 : tflagobjective=1 : tflagsound=1 : tflagstats=1 : tflagspawn=1
      if entityprofile(gridentity).ischaracter>0 then tflaglives=1 : tflagchar=1 : tflaghurtfall=1 : tflaghasweapon=1 : tflagsoundset=1 : tflagsound=0
      if len(entityprofile(gridentity).isweapon$)>2 then tflagweap=1 : tflagammoclip=1 : tflagsound=0
      if entityprofile(gridentity).isammo>0 then tflagammo=1 : tflagobjective=0 : tflagsound=0
     else
      if entityprofile(gridentity).ismarker=1
       tflagai=0
       rem FPGC - 160909 - filtered fpgcgenre=1 is shooter genre
       if fpgcgenre=1
        rem Shooter legacy properties for player start
        if entityprofile(gridentity).lives>0
         tflagstats=1 : tflaglives=1 : tflagsoundset=1 : tflaghurtfall=1 : tflaghasweapon=1 : tflagquantity=1
        else
         tflagsound=1 : tflagnosecond=1
        endif
       else
        rem Other genre's have no ammo quantity and weapon is renamed as equipment
        if entityprofile(gridentity).lives=-1
         rem checkpint marker is type 1
         tflagsound=1 : tflagnosecond=1
        else
         tflagstats=1 : tflaglives=1 : tflagsoundset=1 : tflaghurtfall=1 : tflaghasweapon=1
        endif
       endif
      endif
      if entityprofile(gridentity).ismarker=3 then tflagobjective=1 : tflagnosecond=1 : tflagifused=1
      if entityprofile(gridentity).ismarker=4 then tflagtdecal=1 : tflagdecalparticle=1
      if entityprofile(gridentity).ismarker=3
       if entityprofile(gridentity).markerindex=1
        rem video
        tflagvideo=1
       else
        rem sound
        tflagsound=1
       endif
      endif
     endif
    endif
   endif
  endif
  `
  rem set array and counters to track scope of contents of each group
  dim propfield(16)
  for t=0 to 16 : propfield(t)=0 : next t
  `
  rem set the window title
  setpropertybase(ENTITY_WINDOW_TITLE,strarr$(411))
  `
  rem FPGC - 070510 - open entity properties filemap and wait for signal to write
  open file map 3, "ENTITYPROPERTIES"
  g_filemapoffset = 8
  if ( dll exist(1)=0 ) then load dll "Kernel32.dll", 1
  while get file map dword(3,0) = 1
   `sleep 10
   call dll 1,"Sleep",10
  endwhile
  `
  if tsimplecharview=1
   `
   rem Wizard (simplified) property editing
   group=0 : startgroup("Character Info") : controlindex=0
   setpropertystring2(group,grideleprof.name$,strarr$(413),"Choose a unique name for this character") : inc controlindex
   setpropertylist2(group,controlindex,grideleprof.aimain$,"Behaviour","Select a behaviour for this character",11) : inc controlindex
   setpropertyfile2(group,grideleprof.soundset1$,"Voiceover","Select a WAV or OGG file this character will use during their behaviour","audiobank\") : inc controlindex
   setpropertystring2(group,grideleprof.ifused$,"If Used","Sometimes used to specify the name of an entity to be activated") : inc controlindex
   `
  else
   `
   rem Name
   group=0 : startgroup(strarr$(412)) : controlindex=0
   setpropertystring2(group,grideleprof.name$,strarr$(413),strarr$(204)) : inc controlindex
   if entityprofile(gridentity).ismarker=0 or entityprofile(gridentity).islightmarker=1
    if gmultiplayergame=0
     if gentitytogglingoff=0
      setpropertylist2(group,controlindex,str$(gridentitystaticmode),strarr$(414),strarr$(205),0) : inc controlindex
     endif
    endif
   endif
   `
   rem Basic AI
   if gmultiplayergame=0
    if tflagai=1
     propfield(group)=controlindex
     inc group : startgroup(strarr$(415)) : controlindex=0
     setpropertyfile2(group,grideleprof.aiinit$,strarr$(561),strarr$(206),"scriptbank\") : inc controlindex
     setpropertyfile2(group,grideleprof.aimain$,strarr$(417),strarr$(207),"scriptbank\") : inc controlindex
     setpropertyfile2(group,grideleprof.aidestroy$,strarr$(418),strarr$(208),"scriptbank\") : inc controlindex
    endif
   endif
   `
   rem Has Weapon
   if gmultiplayergame=0
    if tflaghasweapon=1
     setpropertylist2(group,controlindex,grideleprof.hasweapon$,strarr$(419),strarr$(209),1) : inc controlindex
    endif
   endif
   `
   rem Is Weapon (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre)
   if tflagweap=1 and fpgcgenre=1
    setpropertystring2(group,str$(grideleprof.damage),strarr$(420),strarr$(210)) : inc controlindex
    setpropertystring2(group,str$(grideleprof.accuracy),strarr$(421),strarr$(211)) : inc controlindex
    if grideleprof.weaponisammo=0
     setpropertystring2(group,str$(grideleprof.reloadqty),strarr$(422),strarr$(212)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.fireiterations),strarr$(423),strarr$(213)) : inc controlindex
    else
     if gmultiplayergame=0
      setpropertystring2(group,str$(grideleprof.lifespan),strarr$(424),strarr$(214)) : inc controlindex
      setpropertystring2(group,str$(grideleprof.throwspeed),strarr$(425),strarr$(215)) : inc controlindex
      setpropertystring2(group,str$(grideleprof.throwangle),strarr$(426),strarr$(216)) : inc controlindex
      setpropertystring2(group,str$(grideleprof.bounceqty),strarr$(427),strarr$(217)) : inc controlindex
      setpropertylist2(group,controlindex,str$(grideleprof.explodeonhit),strarr$(428),strarr$(218),0) : inc controlindex
     endif
    endif
   endif
   `
   rem Is Character
   if tflagchar=1
    if gmultiplayergame=0
     setpropertylist2(group,controlindex,str$(grideleprof.cantakeweapon),strarr$(429),strarr$(219),0) : inc controlindex
     rem FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
     if fpgcgenre=1
      setpropertystring2(group,str$(grideleprof.quantity),strarr$(430),strarr$(220)) : inc controlindex
      setpropertystring2(group,str$(grideleprof.rateoffire),strarr$(431),strarr$(221)) : inc controlindex
     endif
    endif
   endif
   if tflagquantity=1 then setpropertystring2(group,str$(grideleprof.quantity),strarr$(432),strarr$(222)) : inc controlindex
   `
   rem AI Extra
   if tflagvis=1 and tflagai=1
    if gmultiplayergame=0
     if tflagchar=1
      rem FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
      if fpgcgenre=1
       setpropertyfile2(group,grideleprof.aishoot$,strarr$(433),strarr$(223),"scriptbank\") : inc controlindex
      endif
      setpropertystring2(group,str$(grideleprof.coneangle),strarr$(434),strarr$(224)) : inc controlindex
      rem FPGC - 060710 - generic scripts can now activate entity specified in this field (disappearactivate)
      setpropertystring2(group,grideleprof.ifused$,strarr$(437),strarr$(226)) : inc controlindex
     else
      if tflagweap=0 and tflagammo=0
       propfield(group)=controlindex
       inc group : startgroup(strarr$(435)) : controlindex=0
       setpropertystring2(group,grideleprof.usekey$,strarr$(436),strarr$(225)) : inc controlindex
       setpropertystring2(group,grideleprof.ifused$,strarr$(437),strarr$(226)) : inc controlindex
      endif
     endif
    endif
   endif
   if tflagifused=1
    if gmultiplayergame=0
     setpropertystring2(group,grideleprof.usekey$,strarr$(436),strarr$(225)) : inc controlindex
     setpropertystring2(group,grideleprof.ifused$,strarr$(438),strarr$(227)) : inc controlindex
    endif
   endif
   `
   rem Spawn Settings
   if tflagspawn=1
    if gmultiplayergame=0 or (gmultiplayergame=1 and tflagchar=0)
     propfield(group)=controlindex
     inc group : startgroup(strarr$(439)) : controlindex=0
     setpropertylist2(group,controlindex,str$(grideleprof.spawnatstart),strarr$(562),strarr$(563),0) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnmax),strarr$(440),strarr$(231)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnupto),strarr$(441),strarr$(232)) : inc controlindex
     setpropertylist2(group,controlindex,str$(grideleprof.spawnafterdelay),strarr$(442),strarr$(233),0) : inc controlindex
     setpropertylist2(group,controlindex,str$(grideleprof.spawnwhendead),strarr$(443),strarr$(234),0) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawndelay),strarr$(444),strarr$(235)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawndelayrandom),strarr$(564),strarr$(565)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnqty),strarr$(445),strarr$(236)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnqtyrandom),strarr$(566),strarr$(567)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnvel),strarr$(568),strarr$(569)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnvelrandom),strarr$(570),strarr$(571)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnangle),strarr$(572),strarr$(573)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnanglerandom),strarr$(574),strarr$(575)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.spawnlife),strarr$(576),strarr$(577)) : inc controlindex
    endif
   endif
   `
   rem Visual
   if tflagvis=1
    propfield(group)=controlindex
    inc group : startgroup(strarr$(446)) : controlindex=0
    setpropertyfile2(group,grideleprof.texd$,strarr$(447),strarr$(237),"") : inc controlindex
    setpropertyfile2(group,grideleprof.texaltd$,strarr$(448),strarr$(238),"") : inc controlindex
    setpropertyfile2(group,grideleprof.effect$,strarr$(578),strarr$(579),"effectbank\") : inc controlindex
    setpropertystring2(group,str$(grideleprof.transparency),strarr$(449),strarr$(240)) : inc controlindex
    setpropertystring2(group,str$(grideleprof.reducetexture),strarr$(450),strarr$(241)) : inc controlindex
   endif
   `
   rem Statistics
   if gmultiplayergame=0 or (gmultiplayergame=1 and tstatic=0)
    if (tflagvis=1 or tflagobjective=1 or tflaglives=1 or tflagstats=1) and tflagweap=0 and tflagammo=0
     propfield(group)=controlindex
     inc group : startgroup(strarr$(451)) : controlindex=0
     if gmultiplayergame=0
      if tflaglives=1 then setpropertystring2(group,str$(grideleprof.lives),strarr$(452),strarr$(242)) : inc controlindex
     endif
     if tflagvis=1 or tflagstats=1
      if tflaglives=1
       setpropertystring2(group,str$(grideleprof.strength),strarr$(453),strarr$(243)) : inc controlindex
      else
       setpropertystring2(group,str$(grideleprof.strength),strarr$(454),strarr$(244)) : inc controlindex
      endif
      if gmultiplayergame=0
       setpropertystring2(group,str$(grideleprof.speed),strarr$(455),strarr$(245)) : inc controlindex
      endif
     endif
     if tflaghurtfall=1 then setpropertystring2(group,str$(grideleprof.hurtfall),strarr$(456),strarr$(246)) : inc controlindex
     if gmultiplayergame=0
      if tflagmobile=1 then setpropertylist2(group,controlindex,str$(grideleprof.isimmobile),strarr$(457),strarr$(247),0) : inc controlindex
     endif
     if gmultiplayergame=0 or (gmultiplayergame=1 and entityprofile(gridentity).ismarker=3)
      if tflagobjective=1 then setpropertystring2(group,str$(grideleprof.isobjective),strarr$(458),strarr$(248)) : inc controlindex
     endif
    endif
   endif
   `
   rem Physics Data (non-multiplayer)
   if gmultiplayergame=0
    if entityprofile(gridentity).ismarker=0 and entityprofile(gridentity).islightmarker=0
     propfield(group)=controlindex
     inc group : startgroup(strarr$(596)) : controlindex=0
     if grideleprof.physics<>1 then grideleprof.physics=0
     setpropertylist2(group,controlindex,str$(grideleprof.physics),strarr$(580),strarr$(581),0) : inc controlindex
     setpropertylist2(group,controlindex,str$(grideleprof.phyalways),strarr$(582),strarr$(583),0) : inc controlindex
     setpropertystring2(group,str$(grideleprof.phyweight),strarr$(584),strarr$(585)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.phyfriction),strarr$(586),strarr$(587)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.phyforcedamage),strarr$(588),strarr$(589)) : inc controlindex
     setpropertystring2(group,str$(grideleprof.rotatethrow),strarr$(590),strarr$(591)) : inc controlindex
     setpropertylist2(group,controlindex,str$(grideleprof.explodable),strarr$(592),strarr$(593),0) : inc controlindex
     setpropertystring2(group,str$(grideleprof.explodedamage),strarr$(594),strarr$(595)) : inc controlindex
    endif
   endif
   `
   rem Ammo data (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
   if fpgcgenre=1
    if tflagammo=1 or tflagammoclip=1
     propfield(group)=controlindex
     inc group : startgroup(strarr$(459)) : controlindex=0
     setpropertystring2(group,str$(grideleprof.quantity),strarr$(460),strarr$(249)) : inc controlindex
    endif
   endif
   `
   rem Light data
   if tflaglight=1
    propfield(group)=controlindex
    inc group : startgroup(strarr$(461)) : controlindex=0
    setpropertystring2(group,str$(grideleprof.light.range),strarr$(462),strarr$(250)) : inc controlindex
    setpropertycolor2(group,grideleprof.light.color,strarr$(463),strarr$(251)) : inc controlindex
   endif
   `
   rem Decal data
   if tflagtdecal=1
    propfield(group)=controlindex
    `
    rem FPGC - 300710 - could never change base decal, so comment out this property (entity denotes decal choice)
    `inc group : startgroup(strarr$(464)) : controlindex=0
    `setpropertyfile2(group,grideleprof.basedecal$,strarr$(465),strarr$(252),"gamecore\decals\") : inc controlindex
    `
    rem Decal Particle data
    if tflagdecalparticle=1
     inc group : startgroup("Decal Particle") : controlindex=0
     setpropertylist2(group,controlindex,str$(grideleprof.particleoverride),"Custom Settings","Whether you wish to override default settings",0) : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.offsety),"OffsetY","Vertical adjustment of start position") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.scale),"Scale","A value from 0 to 100, denoting size of particle") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.randomstartx),"Random Start X","Random start area") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.randomstarty),"Random Start Y","Random start area") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.randomstartz),"Random Start Z","Random start area") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.linearmotionx),"Linear Motion X","Constant motion direction") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.linearmotiony),"Linear Motion Y","Constant motion direction") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.linearmotionz),"Linear Motion Z","Constant motion direction") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.randommotionx),"Random Motion X","Random motion direction") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.randommotiony),"Random Motion Y","Random motion direction") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.randommotionz),"Random Motion Z","Random motion direction") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.mirrormode),"Mirror Mode","Set to one to reverse the particle") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.camerazshift),"Camera Z Shift","Shift particle towards camera") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.scaleonlyx),"Scale Only X","Percentage X over Y scale") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.lifeincrement),"Life Increment","Control lifespan of particle") : inc controlindex
     setpropertystring2(group,str$(grideleprof.particle.alphaintensity),"Alpha Intensity","Control alpha percentage of particle") : inc controlindex
     rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
     setpropertylist2(group,controlindex,str$(grideleprof.particle.animated),"Animated Texture","Sets whether the particle decal texture is animated or static.", 0) : inc controlindex
    endif
    `
   endif
   `
   rem Sound or Video data
   if tflagsound=1 or tflagsoundset=1
    propfield(group)=controlindex
    inc group : startgroup(strarr$(466)) : controlindex=0
    rem FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
    if fpgcgenre=1
     if tflagsound=1 then setpropertyfile2(group,grideleprof.soundset$,strarr$(467),strarr$(253),"audiobank\") : inc controlindex
     if tflagsoundset=1 then setpropertyfile2(group,grideleprof.soundset$,strarr$(469),strarr$(255),"audiobank\voices\") : inc controlindex
     if tflagnosecond=0
      rem V118 - 040210 - allow secondary $1 even for soundset users (characters) - so can use the $1 for TALK
      if tflagsound=1 or tflagsoundset=1 then setpropertyfile2(group,grideleprof.soundset1$,strarr$(468),strarr$(254),"audiobank\") : inc controlindex
     endif
    else
     rem Allow full access to both SCRIPT $0 and $1 when not specifically a shooter genre
     if tflagsoundset=1
      setpropertyfile2(group,grideleprof.soundset$,strarr$(469),strarr$(255),"audiobank\voices\") : inc controlindex
     else
      setpropertyfile2(group,grideleprof.soundset$,strarr$(467),strarr$(253),"audiobank\") : inc controlindex
     endif
     setpropertyfile2(group,grideleprof.soundset1$,strarr$(468),strarr$(254),"audiobank\") : inc controlindex
    endif
   endif
   if tflagvideo=1
    propfield(group)=controlindex
    inc group : startgroup(strarr$(597)) : controlindex=0
    rem FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
    if fpgcgenre=1
     setpropertyfile2(group,grideleprof.soundset$,strarr$(598),strarr$(599),"audiobank\") : inc controlindex
     setpropertyfile2(group,grideleprof.soundset1$,strarr$(600),strarr$(601),"videobank\") : inc controlindex
    else
     rem Non shooter genre uses MEDIA ZONE for WEBLINK and AUDIOVIDEO (combined as we have seperate SOUND ZONE)
     setpropertystring2(group,grideleprof.soundset$,strarr$(598),strarr$(599)) : inc controlindex
     setpropertyfile2(group,grideleprof.soundset1$,strarr$(600),strarr$(601),"videobank\") : inc controlindex
    endif
   endif
   `
  endif
  `
  rem End of data
  propfield(group)=controlindex
  propfieldgroupmax=group
  `
  rem FPGC - 070510 - finish bulk entity properties population
  set file map dword 3,g_filemapoffset,0 : inc g_filemapoffset,4
  set file map dword 3,0,1
  `
 endif
 `
 rem FPGC - 070510 - close bulk file map
 close file map 3
 `
 wait for file map event 2
 close file map 2
 `
return

_interface_copydatatoentity:
 `
 rem go through all active fields
 for iGroup=0 to propfieldgroupmax
  for iControl=0 to propfield(iGroup)-1
   `
   rem Get data
   tfield$ = getpropertyfield(iGroup,iControl)
   tdata$ = getpropertydata(iGroup,iControl)
   `
   rem If tdata$ was absolute file, truncate to remove first part
   if mid$(tdata$,2)=":"
    chopthis$=rootdir$
    if lower$(tfield$)=lower$(strarr$(413)) then chopthis$=chopthis$+"scriptbank\"
    if lower$(tfield$)=lower$(strarr$(416)) then chopthis$=chopthis$+"scriptbank\"
    if lower$(tfield$)=lower$(strarr$(561)) then chopthis$=chopthis$+"scriptbank\"
    if lower$(tfield$)=lower$(strarr$(417)) then chopthis$=chopthis$+"scriptbank\"
    if lower$(tfield$)=lower$(strarr$(418)) then chopthis$=chopthis$+"scriptbank\"
    if lower$(tfield$)=lower$(strarr$(433)) then chopthis$=chopthis$+"scriptbank\"
    if lower$(tfield$)=lower$(strarr$(464)) then chopthis$=chopthis$+"gamecore\decals\"
    if lower$(tfield$)=lower$(strarr$(469)) then chopthis$=chopthis$+"audiobank\voices\"
    tdata$=right$(tdata$,len(tdata$)-len(chopthis$))
    if lower$(tfield$)=lower$(strarr$(464)) or lower$(tfield$)=lower$(strarr$(469))
     rem get path (folder name) only
     tdata$=getpath(tdata$) : tdata$=left$(tdata$,len(tdata$)-1)
    endif
   endif
   `
   rem All YES and NO strings are auto converted if value expected
   tokay=1
   if lower$(tfield$)=lower$(strarr$(413)) then tokay=0
   if lower$(tfield$)=lower$(strarr$(436)) then tokay=0
   if lower$(tfield$)=lower$(strarr$(437)) then tokay=0
   if lower$(tfield$)=lower$(strarr$(464)) then tokay=0
   if lower$(tfield$)=lower$(strarr$(469)) then tokay=0
   if lower$(tfield$)=lower$(strarr$(469)) then tokay=0
   if tokay=1
    if lower$(tdata$)=lower$(strarr$(470)) then tdata$="1"
    if lower$(tdata$)=lower$(strarr$(471)) then tdata$="0"
   endif
   `
   rem FPGC - 070510 - add behaviour folder back, along with FPI (from combo friendly name to script filename)
   if lower$(tfield$)="behaviour"
    tdata$="behaviours\"+tdata$+".fpi"
   endif
   `
   rem get field data
   if lower$(tfield$)=lower$(strarr$(413)) then grideleprof.name$=tdata$
   if lower$(tfield$)=lower$(strarr$(414)) then gridentitystaticmode=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(561)) then grideleprof.aiinit$=tdata$
   if lower$(tfield$)=lower$(strarr$(417)) then grideleprof.aimain$=tdata$
   if lower$(tfield$)="behaviour" then grideleprof.aimain$=tdata$
   if lower$(tfield$)=lower$(strarr$(418)) then grideleprof.aidestroy$=tdata$
   if lower$(tfield$)=lower$(strarr$(433)) then grideleprof.aishoot$=tdata$
   if lower$(tfield$)=lower$(strarr$(434)) then grideleprof.coneangle=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(419)) then grideleprof.hasweapon$=tdata$
   if lower$(tfield$)=lower$(strarr$(436)) then grideleprof.usekey$=tdata$
   if lower$(tfield$)=lower$(strarr$(437)) then grideleprof.ifused$=tdata$
   if lower$(tfield$)=lower$(strarr$(562)) then grideleprof.spawnatstart=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(440)) then grideleprof.spawnmax=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(441)) then grideleprof.spawnupto=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(442)) then grideleprof.spawnafterdelay=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(443)) then grideleprof.spawnwhendead=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(444)) then grideleprof.spawndelay=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(445)) then grideleprof.spawnqty=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(564)) then grideleprof.spawndelayrandom=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(566)) then grideleprof.spawnqtyrandom=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(568)) then grideleprof.spawnvel=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(570)) then grideleprof.spawnvelrandom=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(572)) then grideleprof.spawnangle=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(574)) then grideleprof.spawnanglerandom=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(576)) then grideleprof.spawnlife=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(447)) then grideleprof.texd$=tdata$
   if lower$(tfield$)=lower$(strarr$(448)) then grideleprof.texaltd$=tdata$
   if lower$(tfield$)=lower$(strarr$(578)) then grideleprof.effect$=tdata$
   if lower$(tfield$)=lower$(strarr$(449)) then grideleprof.transparency=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(450)) then grideleprof.reducetexture=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(454)) then grideleprof.strength=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(453)) then grideleprof.strength=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(457)) then grideleprof.isimmobile=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(429)) then grideleprof.cantakeweapon=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(430)) then grideleprof.quantity=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(431)) then grideleprof.rateoffire=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(420)) then grideleprof.damage=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(421)) then grideleprof.accuracy=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(422)) then grideleprof.reloadqty=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(423)) then grideleprof.fireiterations=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(424)) then grideleprof.lifespan=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(425)) then grideleprof.throwspeed=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(426)) then grideleprof.throwangle=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(427)) then grideleprof.bounceqty=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(428)) then grideleprof.explodeonhit=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(455)) then grideleprof.speed=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(432)) then grideleprof.quantity=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(460)) then grideleprof.quantity=val(tdata$)
   `if lower$(tfield$)=lower$(strarr$(452)) : ta=val(tdata$) : if ta>0 : grideleprof.lives=ta : endif : endif
   if lower$(tfield$)=lower$(strarr$(452)) then grideleprof.lives=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(456)) then grideleprof.hurtfall=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(458)) then grideleprof.isobjective=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(464)) then grideleprof.basedecal$=tdata$
   `
   rem FPGC - 300710 - read data changes back into grideleprof
   if lower$(tfield$)="custom settings" then grideleprof.particleoverride=val(tdata$)
   if lower$(tfield$)="offsety" then grideleprof.particle.offsety=val(tdata$)
   if lower$(tfield$)="scale" then grideleprof.particle.scale=val(tdata$)
   if lower$(tfield$)="random start x" then grideleprof.particle.randomstartx=val(tdata$)
   if lower$(tfield$)="random start y" then grideleprof.particle.randomstarty=val(tdata$)
   if lower$(tfield$)="random start z" then grideleprof.particle.randomstartz=val(tdata$)
   if lower$(tfield$)="linear motion x" then grideleprof.particle.linearmotionx=val(tdata$)
   if lower$(tfield$)="linear motion y" then grideleprof.particle.linearmotiony=val(tdata$)
   if lower$(tfield$)="linear motion z" then grideleprof.particle.linearmotionz=val(tdata$)
   if lower$(tfield$)="random motion x" then grideleprof.particle.randommotionx=val(tdata$)
   if lower$(tfield$)="random motion y" then grideleprof.particle.randommotiony=val(tdata$)
   if lower$(tfield$)="random motion z" then grideleprof.particle.randommotionz=val(tdata$)
   if lower$(tfield$)="mirror mode" then grideleprof.particle.mirrormode=val(tdata$)
   if lower$(tfield$)="camera z shift" then grideleprof.particle.camerazshift=val(tdata$)
   if lower$(tfield$)="scale only x" then grideleprof.particle.scaleonlyx=val(tdata$)
   if lower$(tfield$)="life increment" then grideleprof.particle.lifeincrement=val(tdata$)
   if lower$(tfield$)="alpha intensity" then grideleprof.particle.alphaintensity=val(tdata$)
   rem V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
   if lower$(tfield$)="animated texture" then grideleprof.particle.animated=val(tdata$)
   `
   if lower$(tfield$)=lower$(strarr$(467)) then grideleprof.soundset$=tdata$
   if lower$(tfield$)=lower$(strarr$(468)) then grideleprof.soundset1$=tdata$
   if lower$(tfield$)=lower$(strarr$(469)) then grideleprof.soundset$=tdata$
   if lower$(tfield$)=lower$(strarr$(598)) then grideleprof.soundset$=tdata$
   if lower$(tfield$)=lower$(strarr$(600)) then grideleprof.soundset1$=tdata$
   if lower$(tfield$)="voiceover" then grideleprof.soundset1$=tdata$
   if lower$(tfield$)=lower$(strarr$(462)) then grideleprof.light.range=val(tdata$)
   `
   if lower$(tfield$)=lower$(strarr$(580)) then grideleprof.physics=val(tdata$)
   if grideleprof.physics<>1 then grideleprof.physics=2
   if lower$(tfield$)=lower$(strarr$(582)) then grideleprof.phyalways=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(584)) then grideleprof.phyweight=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(586)) then grideleprof.phyfriction=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(588)) then grideleprof.phyforcedamage=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(590)) then grideleprof.rotatethrow=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(592)) then grideleprof.explodable=val(tdata$)
   if lower$(tfield$)=lower$(strarr$(594)) then grideleprof.explodedamage=val(tdata$)
   `
   if lower$(tfield$)=lower$(strarr$(463))
    tr$=tdata$
    for t=1 to len(tr$)
     if mid$(tr$,t)=" " then tr$=left$(tr$,t) : exit
    next t
    tdata$=right$(tdata$,(len(tdata$)-len(tr$)))
    tg$=tdata$
    for t=1 to len(tg$)
     if mid$(tg$,t)=" " then tg$=left$(tg$,t) : exit
    next t
    tb$=right$(tdata$,(len(tdata$)-len(tg$)))
    grideleprof.light.color=rgb(val(tr$),val(tg$),val(tb$))
   endif
   `
  next iControl
 next iGroup
 `
return

_interface_closepropertywindow:
 `
 rem Close proprty window
 if editorinterfaceactive>0
  `
  rem Close dialog
  open file map 1, "FPSEXCHANGE"
  set file map dword 1, 978, 2
  set file map dword 1, 462, 0
  wait for file map event 1
  editorinterfaceactive=0
  close file map 1
  `
 endif
 `
return

_interface_handlepropertywindow:

rem If interface active
if editorinterfaceactive>0
 `
 rem Open for management
 open file map 2, "FPSENTITY"
 wait for file map event 2
 `
 rem if APPLY clicked, copy data to entity
 if get file map dword( 2, 112 )=1
  gosub _interface_copydatatoentity
  set file map dword 2, 112, 0
  wait for file map event 2
  editorinterfaceleave=1
 endif
 `
 rem see if the user clicked on the close button
 if get file map dword( 2, 108 ) = 1
   set file map dword 2, 108, 0
   wait for file map event 2
   editorinterfaceleave=1
 endif
 `
 rem see if the user clicked on the CANCEL button
 if get file map dword( 2, 116 ) = 1
   set file map dword 2, 116, 0
   wait for file map event 2
   editorinterfaceleave=1
 endif
 `
 close file map 2
 `
endif

return

rem
rem FPI Wizard Window
rem

_interface_openfpi:
 `
 rem open the screen FPI file for FPI editing
 open file map 4, "FPSEXCHANGE"
 set file map dword 4, 990, 1
 wait for file map event 4
 close file map 4
 `
 rem open FPIDialog filemap
 do
  open file map 2, "FPSFPIWIZARD"
  wait for file map event 2
  if get file map dword( 2, 0 ) = 1 then exit
  close file map 2
 loop
 `
 rem Enter FPI Wizard Title
 if fpitype=1 then fpititle$=strarr$(256)
 if fpitype=2 then fpititle$=strarr$(257)
 if fpitype=3 then fpititle$=strarr$(258)
 if fpitype=4 then fpititle$=strarr$(259)
 if fpitype=5 then fpititle$=strarr$(260)
 fpititle$=fpititle$+" ["+fpiname$+"]"
 set file map string$ 2, 1000, fpititle$
 set file map dword 2, 216, 1
 wait for file map event 2
 while get file map dword( 2, 216 ) = 1
  wait for file map event 2
 endwhile
 `
 rem Get data from FPID file (existing wizard data)
 undim fsarr()
 dim fsarr(65) as string
 if file exist(fpiname$+"d")=1
  load array fpiname$+"d",fsarr()
 else
  rem default values for FPI files
  if fpitype=1
   fsarr(1)="gamecore\backdrops\Basic\background.jpg"
   fsarr(2)="audiobank\music\generic\title.wav"
   fsarr(3)="gamecore\huds\pointer.tga"
   fsarr(22)="languagebank\"+language$+"\gamecore\backdrops\basic\gamemenu.tga" : fsarr(23)="50" : fsarr(24)="10"
   fsarr(31)="languagebank\"+language$+"\gamecore\backdrops\basic\newgame.tga"
   fsarr(32)="50"
   fsarr(33)="45"
   rem V103
   fsarr(34)="languagebank\"+language$+"\gamecore\backdrops\basic\loadgame.tga"
   fsarr(35)="50"
   fsarr(36)="55"
   fsarr(37)="languagebank\"+language$+"\gamecore\backdrops\basic\exitgame.tga"
   fsarr(38)="50"
   fsarr(39)="65"
  endif
  if fpitype=2
   fsarr(1)="gamecore\backdrops\Basic\background.jpg"
   fsarr(2)="audiobank\music\generic\incident.wav"
   fsarr(22)="languagebank\"+language$+"\gamecore\backdrops\basic\loading.tga" : fsarr(23)="50" : fsarr(24)="50"
   fsarr(25)="gamecore\huds\loadingbarbox.tga"
   fsarr(26)="50"
   fsarr(27)="95"
   fsarr(28)="gamecore\huds\loadingbar.tga"
   fsarr(29)="50"
   fsarr(30)="95"
  endif
  if fpitype=3
`   fsarr(1)="gamecore\backdrops\Basic\background.jpg"
   fsarr(2)="audiobank\music\generic\main.wav"
   fsarr(3)="gamecore\huds\pointer.tga"
   fsarr(4)="skybank\natural\ngt"
   fsarr(5)="0"
   fsarr(6)="0"
   fsarr(7)="0"
   fsarr(8)="0"
   fsarr(9)="25"
   fsarr(10)="255"
   fsarr(11)="255"
   fsarr(12)="255"
   fsarr(13)="gamecore\huds\fader.tga"
   fsarr(14)="gamecore\huds\eyehud.tga"
   fsarr(15)="gamecore\huds\zoom.tga"
   fsarr(16)="languagebank\"+language$+"\gamecore\huds\lives.tga"
   fsarr(17)="gamecore\huds\numeric1.tga"
   fsarr(18)="languagebank\"+language$+"\gamecore\huds\health.tga"
   fsarr(19)="gamecore\huds\numeric1.tga"
   fsarr(20)="gamecore\huds\ammo.tga"
   fsarr(21)="gamecore\huds\numeric1.tga"
   fsarr(22)="languagebank\"+language$+"\gamecore\backdrops\basic\gamemenu.tga" : fsarr(23)="50" : fsarr(24)="10"
   rem V103
   fsarr(40)="languagebank\"+language$+"\gamecore\backdrops\basic\loadgame.tga"
   fsarr(41)="50"
   fsarr(42)="40"
   fsarr(43)="languagebank\"+language$+"\gamecore\backdrops\basic\savegame.tga"
   fsarr(44)="50"
   fsarr(45)="50"
   fsarr(25)="languagebank\"+language$+"\gamecore\backdrops\basic\saving.tga"
   fsarr(26)="50"
   fsarr(27)="50"
   fsarr(46)="languagebank\"+language$+"\gamecore\backdrops\basic\exitgame.tga"
   fsarr(47)="50"
   fsarr(48)="60"
   fsarr(49)="languagebank\"+language$+"\gamecore\backdrops\basic\returntogame.tga"
   fsarr(50)="50"
   fsarr(51)="70"
   fsarr(53)="5"
   fsarr(54)="5"
   fsarr(55)="4"
   fsarr(56)="8"
   fsarr(57)="15"
   fsarr(58)="5"
   fsarr(59)="14"
   fsarr(60)="8"
   fsarr(61)="85"
   fsarr(62)="8"
   fsarr(63)="88"
   fsarr(64)="12"
  endif
  if fpitype=4
   fsarr(1)="gamecore\backdrops\Basic\background.jpg"
   fsarr(2)="audiobank\music\generic\incident.wav"
   fsarr(22)="languagebank\"+language$+"\gamecore\backdrops\basic\gameover.tga" : fsarr(23)="50" : fsarr(24)="50"
   fsarr(52)="6000"
  endif
  if fpitype=5
   fsarr(1)="gamecore\backdrops\Basic\background.jpg"
   fsarr(2)="audiobank\music\generic\victory.wav"
   fsarr(22)="languagebank\"+language$+"\gamecore\backdrops\basic\gamecomplete.tga" : fsarr(23)="50" : fsarr(24)="50"
   fsarr(52)="6000"
  endif
 endif
 `
 rem Details
 fpisetup=0 : fpipointer=0 : fpiheaderimage=0
 fpigamebuttons=0 : fpigamemenubuttons=0 : fpiloading=0 : fpitimeout=0
 if fpitype=1 then fpipointer=1 : fpiheaderimage=1 : fpigamebuttons=1
 if fpitype=2 then fpiheaderimage=1 : fpiloading=1
 if fpitype=3 then fpipointer=1 : fpiheaderimage=1 : fpigamemenubuttons=1 : fpisetup=1
 if fpitype=4 then fpitimeout=1 : fpiheaderimage=1
 if fpitype=5 then fpitimeout=1 : fpiheaderimage=1
 `
 rem array to hold wheether fields valid
 dim fpifield(9)
 for t=0 to 9 : fpifield(t)=0 : next t
 tgroupsworking=1
 `
 rem Fill with correct fields
 add_group(strarr$(476)) : fgg=0 : fii=0
 if fpitype<>3
  add_file_picker( fgg, strarr$(477), fsarr(1), strarr$(261), rootdir$+"gamecore\backdrops\" ) : inc fii
 endif
 add_file_picker( fgg, strarr$(478), fsarr(2), strarr$(262), rootdir$+"audiobank\" ) : inc fii
 if fpipointer=1
  add_file_picker( fgg, strarr$(479), fsarr(3), strarr$(263), rootdir$+"gamecore\backdrops\" ) : inc fii
 endif
 if fpisetup=1
  if tgroupsworking=1 then fpifield(fgg)=fii : add_group(strarr$(480)) : inc fgg : fii=0
  add_file_picker_ex( fgg, strarr$(481), fsarr(4), strarr$(264), rootdir$+"skybank\", strarr$(624), strarr$(625) ) : inc fii
  add_edit_box( fgg, strarr$(482), fsarr(5), strarr$(265) ) : inc fii
  add_edit_box( fgg, strarr$(483), fsarr(6), strarr$(266) ) : inc fii
  add_edit_box( fgg, strarr$(484), fsarr(7), strarr$(267) ) : inc fii
  add_edit_box( fgg, strarr$(485), fsarr(8), strarr$(268) ) : inc fii
  add_edit_box( fgg, strarr$(486), fsarr(9), strarr$(269) ) : inc fii
  add_edit_box( fgg, strarr$(487), fsarr(10), strarr$(270) ) : inc fii
  add_edit_box( fgg, strarr$(488), fsarr(11), strarr$(271) ) : inc fii
  add_edit_box( fgg, strarr$(489), fsarr(12), strarr$(272) ) : inc fii
  if tgroupsworking=1 then fpifield(fgg)=fii : add_group(strarr$(490)) : inc fgg : fii=0
  add_file_picker( fgg, strarr$(491), fsarr(13), strarr$(273), rootdir$+"gamecore\huds\" ) : inc fii
  add_file_picker( fgg, strarr$(492), fsarr(14), strarr$(274), rootdir$+"gamecore\huds\" ) : inc fii
  add_file_picker( fgg, strarr$(493), fsarr(15), strarr$(275), rootdir$+"gamecore\huds\" ) : inc fii
  if tgroupsworking=1 then fpifield(fgg)=fii : add_group(strarr$(494)) : inc fgg : fii=0
  add_file_picker( fgg, strarr$(495), fsarr(16), strarr$(496), rootdir$+"languagebank\"+language$+"\gamecore\huds\" ) : inc fii
  add_edit_box( fgg, strarr$(497), fsarr(53), strarr$(276) ) : inc fii
  add_edit_box( fgg, strarr$(498), fsarr(54), strarr$(277) ) : inc fii
  add_file_picker( fgg, strarr$(499), fsarr(17), strarr$(500), rootdir$+"gamecore\huds\" ) : inc fii
  add_edit_box( fgg, strarr$(501), fsarr(55), strarr$(278) ) : inc fii
  add_edit_box( fgg, strarr$(502), fsarr(56), strarr$(279) ) : inc fii
  add_file_picker( fgg, strarr$(503), fsarr(18), strarr$(504), rootdir$+"languagebank\"+language$+"\gamecore\huds\" ) : inc fii
  add_edit_box( fgg, strarr$(505), fsarr(57), strarr$(280) ) : inc fii
  add_edit_box( fgg, strarr$(506), fsarr(58), strarr$(281) ) : inc fii
  add_file_picker( fgg, strarr$(507), fsarr(19), strarr$(508), rootdir$+"gamecore\huds\" ) : inc fii
  add_edit_box( fgg, strarr$(509), fsarr(59), strarr$(282) ) : inc fii
  add_edit_box( fgg, strarr$(510), fsarr(60), strarr$(283) ) : inc fii
  if fpgcgenre<>0
   rem FPGC - 170610 - weapon related properties not in FPGC variant
   add_file_picker( fgg, strarr$(511), fsarr(20), strarr$(512), rootdir$+"gamecore\huds\" ) : inc fii
   add_edit_box( fgg, strarr$(513), fsarr(61), strarr$(284) ) : inc fii
   add_edit_box( fgg, strarr$(514), fsarr(62), strarr$(285) ) : inc fii
   add_file_picker( fgg, strarr$(515), fsarr(21), strarr$(516), rootdir$+"gamecore\huds\" ) : inc fii
   add_edit_box( fgg, strarr$(517), fsarr(63), strarr$(286) ) : inc fii
   add_edit_box( fgg, strarr$(518), fsarr(64), strarr$(287) ) : inc fii
  endif
 endif
 if fpiheaderimage=1
  if tgroupsworking=1 then fpifield(fgg)=fii : add_group(strarr$(519)) : inc fgg : fii=0
  add_file_picker( fgg, strarr$(520), fsarr(22), strarr$(521), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(522), fsarr(23), strarr$(288) ) : inc fii
  add_edit_box( fgg, strarr$(523), fsarr(24), strarr$(289) ) : inc fii
 endif
 if fpiloading=1
  add_file_picker( fgg, strarr$(524), fsarr(25), strarr$(525), rootdir$+"gamecore\huds\" ) : inc fii
  add_edit_box( fgg, strarr$(526), fsarr(26), strarr$(290) ) : inc fii
  add_edit_box( fgg, strarr$(527), fsarr(27), strarr$(291) ) : inc fii
  add_file_picker( fgg, strarr$(528), fsarr(28), strarr$(529), rootdir$+"gamecore\huds\" ) : inc fii
  add_edit_box( fgg, strarr$(530), fsarr(29), strarr$(292) ) : inc fii
  add_edit_box( fgg, strarr$(531), fsarr(30), strarr$(293) ) : inc fii
 endif
 if fpigamebuttons=1
  add_file_picker( fgg, strarr$(532), fsarr(31), strarr$(294), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(533), fsarr(32), strarr$(295) ) : inc fii
  add_edit_box( fgg, strarr$(534), fsarr(33), strarr$(296) ) : inc fii
  rem V103
  add_file_picker( fgg, strarr$(535), fsarr(34), strarr$(297), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(536), fsarr(35), strarr$(298) ) : inc fii
  add_edit_box( fgg, strarr$(537), fsarr(36), strarr$(299) ) : inc fii
  add_file_picker( fgg, strarr$(538), fsarr(37), strarr$(300), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(539), fsarr(38), strarr$(301) ) : inc fii
  add_edit_box( fgg, strarr$(540), fsarr(39), strarr$(302) ) : inc fii
 endif
 if fpigamemenubuttons=1
  rem V103
  add_file_picker( fgg, strarr$(541), fsarr(40), strarr$(303), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(542), fsarr(41), strarr$(304) ) : inc fii
  add_edit_box( fgg, strarr$(543), fsarr(42), strarr$(305) ) : inc fii
  add_file_picker( fgg, strarr$(544), fsarr(43), strarr$(306), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(545), fsarr(44), strarr$(307) ) : inc fii
  add_edit_box( fgg, strarr$(546), fsarr(45), strarr$(308) ) : inc fii
  add_file_picker( fgg, strarr$(653), fsarr(25), strarr$(657), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(654), fsarr(26), strarr$(307) ) : inc fii
  add_edit_box( fgg, strarr$(655), fsarr(27), strarr$(308) ) : inc fii
  add_file_picker( fgg, strarr$(547), fsarr(46), strarr$(309), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(548), fsarr(47), strarr$(310) ) : inc fii
  add_edit_box( fgg, strarr$(549), fsarr(48), strarr$(311) ) : inc fii
  add_file_picker( fgg, strarr$(550), fsarr(49), strarr$(312), rootdir$+"languagebank\"+language$+"\gamecore\backdrops\" ) : inc fii
  add_edit_box( fgg, strarr$(551), fsarr(50), strarr$(313) ) : inc fii
  add_edit_box( fgg, strarr$(552), fsarr(51), strarr$(314) ) : inc fii
 endif
 if fpitimeout=1
  add_edit_box( fgg, strarr$(553), fsarr(52), strarr$(315) ) : inc fii
 endif
 fpifield(fgg)=fii
 `
 rem Close filemap
 close file map 2
 `
return

_interface_savefpi:
 `
 rem get name and data from all fields
 undim fsarr()
 dim fsarr(65) as string
 for iGroup=0 to fgg
  for iControl=0 to fpifield(iGroup)-1
   `
   rem get name and data from field
   set file map dword 2, ENTITY_SET_GROUP_INDEX, iGroup
   set file map dword 2, ENTITY_SET_CONTROL_INDEX, iControl
   set file map dword 2, ENTITY_GET_CONTROL_NAME, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_GET_CONTROL_NAME ) = 1
    wait for file map event 2
   endwhile
   name$ = get file map string$( 2, STRING_A )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, iGroup
   set file map dword 2, ENTITY_SET_CONTROL_INDEX, iControl
   set file map dword 2, ENTITY_GET_CONTROL_CONTENTS, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_GET_CONTROL_CONTENTS ) = 1
    wait for file map event 2
   endwhile
   data$ = get file map string$( 2, STRING_B )
   `
   rem match up data with correct string
   fs$=strarr$(477) : if name$=fs$ then fsarr(1)=data$
   fs$=strarr$(478) : if name$=fs$ then fsarr(2)=data$
   fs$=strarr$(479) : if name$=fs$ then fsarr(3)=data$
   fs$=strarr$(481) : if name$=fs$ then fsarr(4)=data$
   fs$=strarr$(482) : if name$=fs$ then fsarr(5)=data$
   fs$=strarr$(483) : if name$=fs$ then fsarr(6)=data$
   fs$=strarr$(484) : if name$=fs$ then fsarr(7)=data$
   fs$=strarr$(485) : if name$=fs$ then fsarr(8)=data$
   fs$=strarr$(486) : if name$=fs$ then fsarr(9)=data$
   fs$=strarr$(487) : if name$=fs$ then fsarr(10)=data$
   fs$=strarr$(488) : if name$=fs$ then fsarr(11)=data$
   fs$=strarr$(489) : if name$=fs$ then fsarr(12)=data$
   fs$=strarr$(491) : if name$=fs$ then fsarr(13)=data$
   fs$=strarr$(492) : if name$=fs$ then fsarr(14)=data$
   fs$=strarr$(493) : if name$=fs$ then fsarr(15)=data$
   fs$=strarr$(495) : if name$=fs$ then fsarr(16)=data$
   fs$=strarr$(499) : if name$=fs$ then fsarr(17)=data$
   fs$=strarr$(503) : if name$=fs$ then fsarr(18)=data$
   fs$=strarr$(507) : if name$=fs$ then fsarr(19)=data$
   fs$=strarr$(511) : if name$=fs$ then fsarr(20)=data$
   fs$=strarr$(515) : if name$=fs$ then fsarr(21)=data$
   fs$=strarr$(520) : if name$=fs$ then fsarr(22)=data$
   fs$=strarr$(522) : if name$=fs$ then fsarr(23)=data$
   fs$=strarr$(523) : if name$=fs$ then fsarr(24)=data$
   fs$=strarr$(524) : if name$=fs$ then fsarr(25)=data$
   fs$=strarr$(526) : if name$=fs$ then fsarr(26)=data$
   fs$=strarr$(527) : if name$=fs$ then fsarr(27)=data$
   fs$=strarr$(528) : if name$=fs$ then fsarr(28)=data$
   fs$=strarr$(530) : if name$=fs$ then fsarr(29)=data$
   fs$=strarr$(531) : if name$=fs$ then fsarr(30)=data$
   fs$=strarr$(532) : if name$=fs$ then fsarr(31)=data$
   fs$=strarr$(533) : if name$=fs$ then fsarr(32)=data$
   fs$=strarr$(534) : if name$=fs$ then fsarr(33)=data$
   fs$=strarr$(535) : if name$=fs$ then fsarr(34)=data$
   fs$=strarr$(536) : if name$=fs$ then fsarr(35)=data$
   fs$=strarr$(537) : if name$=fs$ then fsarr(36)=data$
   fs$=strarr$(538) : if name$=fs$ then fsarr(37)=data$
   fs$=strarr$(539) : if name$=fs$ then fsarr(38)=data$
   fs$=strarr$(540) : if name$=fs$ then fsarr(39)=data$
   fs$=strarr$(541) : if name$=fs$ then fsarr(40)=data$
   fs$=strarr$(542) : if name$=fs$ then fsarr(41)=data$
   fs$=strarr$(543) : if name$=fs$ then fsarr(42)=data$
   fs$=strarr$(544) : if name$=fs$ then fsarr(43)=data$
   fs$=strarr$(545) : if name$=fs$ then fsarr(44)=data$
   fs$=strarr$(546) : if name$=fs$ then fsarr(45)=data$
   fs$=strarr$(547) : if name$=fs$ then fsarr(46)=data$
   fs$=strarr$(548) : if name$=fs$ then fsarr(47)=data$
   fs$=strarr$(549) : if name$=fs$ then fsarr(48)=data$
   fs$=strarr$(550) : if name$=fs$ then fsarr(49)=data$
   fs$=strarr$(551) : if name$=fs$ then fsarr(50)=data$
   fs$=strarr$(552) : if name$=fs$ then fsarr(51)=data$
   fs$=strarr$(553) : if name$=fs$ then fsarr(52)=data$
   fs$=strarr$(497) : if name$=fs$ then fsarr(53)=data$
   fs$=strarr$(498) : if name$=fs$ then fsarr(54)=data$
   fs$=strarr$(501) : if name$=fs$ then fsarr(55)=data$
   fs$=strarr$(502) : if name$=fs$ then fsarr(56)=data$
   fs$=strarr$(505) : if name$=fs$ then fsarr(57)=data$
   fs$=strarr$(506) : if name$=fs$ then fsarr(58)=data$
   fs$=strarr$(509) : if name$=fs$ then fsarr(59)=data$
   fs$=strarr$(510) : if name$=fs$ then fsarr(60)=data$
   fs$=strarr$(513) : if name$=fs$ then fsarr(61)=data$
   fs$=strarr$(514) : if name$=fs$ then fsarr(62)=data$
   fs$=strarr$(517) : if name$=fs$ then fsarr(63)=data$
   fs$=strarr$(518) : if name$=fs$ then fsarr(64)=data$
   `
  next iControl
 next iGroup
 `
 rem Create new FPI file
 undim fpifile$()
 dim fpifile$(99) : i=0
 if fpitype=1
  fpititle$=strarr$(316)
  fpifile$(i)=";AIScript from Wizard" : inc i
  fpifile$(i)=";Header" : inc i
  fpifile$(i)="desc          = "+fpititle$ : inc i
  fpifile$(i)=";Script" : inc i
  fpifile$(i)=":state=0:music="+fsarr(2) : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(23)+",hudy="+fsarr(24)+",hudimage="+fsarr(22)+",hudmake=display" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(32)+",hudy="+fsarr(33)+",hudimage="+fsarr(31)+",hudtype=1,hudmake=button" : inc i
  rem V103
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(35)+",hudy="+fsarr(36)+",hudimage="+fsarr(34)+",hudtype=2,hudmake=button" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(38)+",hudy="+fsarr(39)+",hudimage="+fsarr(37)+",hudtype=5,hudmake=button" : inc i
  fpifile$(i)=":state=0:hudreset,hudx=50,hudy=50,hudimage="+fsarr(03)+",hudmake=pointer" : inc i
  fpifile$(i)=":state=0:state=2" : inc i
  fpifile$(i)=":state=2:backdrop="+fsarr(1) : inc i
  fpifile$(i)=":state=2,hudselectionmade=1:destroy" : inc i
  fpifile$(i)=":state=2,hudselectionmade=5:quitgame,destroy" : inc i
  rem V103
  fpifile$(i)=":state=2,hudselectionmade=2:loadgame" : inc i
 endif
 if fpitype=2
  fpititle$=strarr$(317)
  fpifile$(i)=";AIScript from Wizard" : inc i
  fpifile$(i)=";Header" : inc i
  fpifile$(i)="desc          = "+fpititle$ : inc i
  fpifile$(i)=";Script" : inc i
  fpifile$(i)=":state=0:music="+fsarr(2) : inc i
  fpifile$(i)=":state=0:backdrop="+fsarr(1) : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(23)+",hudy="+fsarr(24)+",hudimage="+fsarr(22)+",hudmake=display" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(26)+",hudy="+fsarr(27)+",hudimage="+fsarr(25)+",hudmake=display" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(29)+",hudy="+fsarr(30)+",hudimage="+fsarr(28)+",hudhide=1,hudtype=1,hudmake=internal" : inc i
  fpifile$(i)=":state=0:state=1" : inc i
 endif
 if fpitype=3
  fpititle$=strarr$(318)
  fpifile$(i)=";AIScript from Wizard" : inc i
  fpifile$(i)=";Header" : inc i
  fpifile$(i)="desc          = "+fpititle$ : inc i
  fpifile$(i)="; Setup Level Stats" : inc i
  fpifile$(i)=":state=0:sky="+fsarr(4) : inc i
  fpifile$(i)=":state=0:music="+fsarr(2)+",musicvolume=50,soundscale=25" : inc i
  fpifile$(i)=":state=0:fog="+fsarr(5)+",fogred="+fsarr(6)+",foggreen="+fsarr(7)+",fogblue="+fsarr(8) : inc i
  fpifile$(i)=":state=0:ambience="+fsarr(9)+",ambiencered="+fsarr(10)+",ambiencegreen="+fsarr(11)+",ambienceblue="+fsarr(12) : inc i
  fpifile$(i)="" : inc i
  fpifile$(i)=":state=0:hudreset,hudx=50,hudy=50,hudsizex=1024,hudsizey=768,hudimage="+fsarr(13)+",hudhide=1,hudtype=3,hudmake=internal" : inc i
  fpifile$(i)=":state=0:hudreset,hudx=50,hudy=50,hudred=128,hudgreen=0,hudblue=0,hudsizex=1024,hudsizey=768,hudimage="+fsarr(14)+",hudhide=1,hudtype=2,hudmake=internal" : inc i
  fpifile$(i)=":state=0:hudreset,hudx=50,hudy=50,hudred=128,hudgreen=128,hudblue=128,hudsizex=1024,hudsizey=768,hudimage="+fsarr(15)+",hudhide=1,hudtype=4,hudmake=internal" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(53)+",hudy="+fsarr(54)+",hudimage="+fsarr(16)+",hudtype=1,hudmake=display" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(55)+",hudy="+fsarr(56)+",hudsizex=16,hudsizey=16,hudimage="+fsarr(17)+",hudtype=1,hudmake=numeric" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(57)+",hudy="+fsarr(58)+",hudimage="+fsarr(18)+",hudtype=2,hudmake=display" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(59)+",hudy="+fsarr(60)+",hudsizex=16,hudsizey=16,hudimage="+fsarr(19)+",hudtype=2,hudmake=numeric" : inc i
  if len(fsarr(61))>0 then fpifile$(i)=":state=0:hudreset,hudx="+fsarr(61)+",hudy="+fsarr(62)+",hudimage="+fsarr(20)+",hudtype=3,hudmake=status" : inc i
  if len(fsarr(63))>0 then fpifile$(i)=":state=0:hudreset,hudx="+fsarr(63)+",hudy="+fsarr(64)+",hudsizex=16,hudsizey=16,hudimage="+fsarr(21)+",hudtype=3,hudmake=numeric" : inc i
  fpifile$(i)="; Setup Game Menu" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(23)+",hudy="+fsarr(24)+",hudimage="+fsarr(22)+",hudname=gamemenutitle,hudhide=1,hudmake=display" : inc i
  rem V103
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(41)+",hudy="+fsarr(42)+",hudimage="+fsarr(40)+",hudtype=2,hudname=loadgame,hudhide=1,hudmake=button" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(44)+",hudy="+fsarr(45)+",hudimage="+fsarr(43)+",hudtype=3,hudname=savegame,hudhide=1,hudmake=button" : inc i
  if len(fsarr(26))>0 then fpifile$(i)=":state=0:hudreset,hudx="+fsarr(26)+",hudy="+fsarr(27)+",hudimage="+fsarr(25)+",hudname=savingprompt,hudhide=1,hudmake=display" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(47)+",hudy="+fsarr(48)+",hudimage="+fsarr(46)+",hudtype=5,hudname=quitgame,hudhide=1,hudmake=button" : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(50)+",hudy="+fsarr(51)+",hudimage="+fsarr(49)+",hudtype=4,hudname=returngame,hudhide=1,hudmake=button" : inc i
  fpifile$(i)=":state=0:hudreset,hudx=50,hudy=50,hudimage="+fsarr(3)+",hudname=pointer,hudhide=1,hudmake=pointer" : inc i
  fpifile$(i)=":state=0:state=1" : inc i
  fpifile$(i)="" : inc i
  fpifile$(i)="; Main Game" : inc i
  fpifile$(i)=":state=1,escapekeypressed=1:pausegame,state=2" : inc i
  rem V103
  fpifile$(i)=":state=1,scancodekeypressed=197:pausegame,state=11" : inc i
  fpifile$(i)=":state=1,scancodekeypressed=64:hudshow=savingprompt,quicksavegame,pausegame,state=21" : inc i
  fpifile$(i)=":state=1,scancodekeypressed=67:quickloadgame,state=31" : inc i
  fpifile$(i)=":state=11,scancodekeypressed=0:state=12" : inc i
  fpifile$(i)=":state=12,scancodekeypressed=197:resumegame,state=13" : inc i
  fpifile$(i)=":state=13,scancodekeypressed=0:state=1" : inc i
  fpifile$(i)=":state=21,scancodekeypressed=0:hudunshow=savingprompt,resumegame,state=1" : inc i
  fpifile$(i)=":state=31,scancodekeypressed=0:state=1" : inc i
  fpifile$(i)="" : inc i
  fpifile$(i)="; Game Menu" : inc i
  fpifile$(i)=":state=2,escapekeypressed=0:state=3" : inc i
  rem V103
  fpifile$(i)=":state=3:hudshow=gamemenutitle,hudshow=loadgame,hudshow=savegame,hudshow=quitgame,hudshow=returngame,hudshow=pointer,state=4" : inc i
  fpifile$(i)=":state=4,hudselectionmade=2:loadgame" : inc i
  fpifile$(i)=":state=4,hudselectionmade=3:savegame,state=6" : inc i
  fpifile$(i)=":state=4,hudselectionmade=5:continuegame,destroy" : inc i
  fpifile$(i)=":state=4,hudselectionmade=4:state=6" : inc i
  fpifile$(i)=":state=4,escapekeypressed=1:state=5" : inc i
  fpifile$(i)=":state=5,escapekeypressed=0:state=6" : inc i
  fpifile$(i)=":state=6:hudunshow=gamemenutitle,hudunshow=loadgame,hudunshow=savegame,hudunshow=quitgame,hudunshow=returngame,hudunshow=pointer,resumegame,state=1" : inc i
 endif
 if fpitype=4 or fpitype=5
  if fpitype=4 then fpititle$=strarr$(319)
  if fpitype=5 then fpititle$=strarr$(320)
  fpifile$(i)=";AIScript from Wizard" : inc i
  fpifile$(i)=";Header" : inc i
  fpifile$(i)="desc          = "+fpititle$ : inc i
  fpifile$(i)=";Script" : inc i
  fpifile$(i)=":state=0:music="+fsarr(2) : inc i
  fpifile$(i)=":state=0:backdrop="+fsarr(1) : inc i
  fpifile$(i)=":state=0:hudreset,hudx="+fsarr(23)+",hudy="+fsarr(24)+",hudimage="+fsarr(22)+",hudmake=display" : inc i
  fpifile$(i)=":state=0:timerstart,state=1" : inc i
  fpifile$(i)=":state=1,timergreater="+fsarr(52)+":destroy" : inc i
 endif
 `
 rem save the string array as an FPI file
 if file exist(fpiname$+"d")=1 then delete file fpiname$+"d"
 if file exist(fpiname$)=1 then delete file fpiname$
 save array fpiname$+"d",fsarr()
 save array fpiname$,fpifile$()
 `
return

_interface_handlefpi:
 `
 rem loop while editing FPI
 leavefpi=0
 while leavefpi=0
  `
  rem open filemap
  open file map 2, "FPSFPIWIZARD"
  wait for file map event 2
  `
  rem If change recorded, and absolute path, correct to relative path
  for iGroup=0 to fgg
   for iControl=0 to fpifield(iGroup)-1
    set file map dword 2, ENTITY_SET_GROUP_INDEX, iGroup
    set file map dword 2, ENTITY_SET_CONTROL_INDEX, iControl
    set file map dword 2, ENTITY_GET_CONTROL_CONTENTS, 1
    wait for file map event 2
    while get file map dword( 2, ENTITY_GET_CONTROL_CONTENTS ) = 1
     wait for file map event 2
    endwhile
    data$ = get file map string$( 2, STRING_B )
    if mid$(data$,2)=":"
     newdata$=right$(data$,len(data$)-len(rootdir$))
     if lower$(right$(newdata$,2))=".x"
      rem sky model, only need path
      tskyname$=getpath(newdata$)
      newdata$=left$(tskyname$,len(tskyname$)-1)
     endif
     set file map dword 2, ENTITY_SET_GROUP_INDEX, iGroup
     set file map dword 2, ENTITY_SET_CONTROL_INDEX, iControl
     set file map string$ 2, STRING_A, newdata$
     set file map dword 2, ENTITY_SET_CONTROL_CONTENTS, 1
     wait for file map event 2
     while get file map dword( 2, ENTITY_SET_CONTROL_CONTENTS ) = 1
      wait for file map event 2
     endwhile
    endif
   next iControl
  next iGroup
  `
  rem If select OK, save
  if get file map dword ( 2, 204 ) = 1
   gosub _interface_savefpi
   set file map dword 2, 212, 1
   wait for file map event 2
   leavefpi=1
  endif
  `
  rem Detect for CANCEL and CLOSE, to leave
  if get file map dword ( 2, 208 )=1
   set file map dword 2, 212, 1
   wait for file map event 2
   leavefpi=1
  endif
  `
  rem If select PREVIEW, run FPI preview application window
  if get file map dword ( 2, 220 ) = 1
   rem save settings in TEMP FPI
   storefpiname$=fpiname$
   fpiname$="languagebank\"+language$+"\gamebank\templateoriginal\previewpage.fpi"
   gosub _interface_savefpi
   rem run preview with
   set dir ".."
   execute file "FPSC-Screens.exe",str$(fpitype)+","+fpiname$,"",1
   set dir "Files"
   rem restore preview button
   set file map dword 2, 220, 0
   wait for file map event 2
   rem restore pfpiname
   fpiname$=storefpiname$
  endif
  `
  rem Close filemap
  close file map 2
  `
 endwhile
 `
return

rem
rem FPGC - 070510 - New Interface Properties Functions (Bulk Setting)
rem

function startgroup(s$)
 if s$="" then s$=""
 set file map dword 3,g_filemapoffset,2 : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,len(s$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,s$ : inc g_filemapoffset,((len(s$)+3)/4 )*4
endfunction

function endgroup()
 set file map dword 3,g_filemapoffset,0 : inc g_filemapoffset,4
endfunction

function setpropertystring2(group,data$,field$,desc$)
 if data$="" then data$=""
 set file map dword 3,g_filemapoffset,3 : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,group : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,len(field$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,field$ : inc g_filemapoffset,((len(field$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(data$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,data$ : inc g_filemapoffset,((len(data$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(desc$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,desc$ : inc g_filemapoffset,((len(desc$)+3)/4 )*4
endfunction

function setpropertycolor2(group,dataval as DWORD,field$,desc$)
 data$=str$(rgbr(dataval))+" "+str$(rgbg(dataval))+" "+str$(rgbb(dataval))
 set file map dword 3,g_filemapoffset,4 : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,group : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,len(field$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,field$ : inc g_filemapoffset,((len(field$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(data$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,data$ : inc g_filemapoffset,((len(data$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(desc$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,desc$ : inc g_filemapoffset,((len(desc$)+3)/4 )*4
endfunction

function setpropertyfile2(group,data$,field$,desc$,within$)
 if data$="" then data$=""
 set file map dword 3,g_filemapoffset,5 : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,group : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,len(field$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,field$ : inc g_filemapoffset,((len(field$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(data$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,data$ : inc g_filemapoffset,((len(data$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(desc$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,desc$ : inc g_filemapoffset,((len(desc$)+3)/4 )*4
 s$ = rootdir$+within$
 set file map dword 3,g_filemapoffset,len(s$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,s$ : inc g_filemapoffset,((len(s$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(strarr$(321)) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,strarr$(321) : inc g_filemapoffset,((len(strarr$(321))+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(strarr$(322)) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,strarr$(322) : inc g_filemapoffset,((len(strarr$(322))+3)/4 )*4
endfunction

function setpropertylist2(group,controlindex,data$,field$,desc$,listtype)
 if data$="" then data$=""
 if listtype=0
  rem yesno
  if data$="0" then data$=strarr$(471)
  if data$="1" then data$=strarr$(470)
 endif
 if listtype=11
  rem behaviours (trim scriptbank behaviours and .fpi)
  data$=right$(data$,len(data$)-len("behavioursx"))
  data$=left$(data$,len(data$)-4)
  data$=upper$(left$(data$,1))+lower$(right$(data$,len(data$)-1))
 endif
 set file map dword 3,g_filemapoffset,6 : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,group : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,controlindex : inc g_filemapoffset,4
 set file map dword 3,g_filemapoffset,len(field$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,field$ : inc g_filemapoffset,((len(field$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(data$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,data$ : inc g_filemapoffset,((len(data$)+3)/4 )*4
 set file map dword 3,g_filemapoffset,len(desc$) : inc g_filemapoffset,4
 set file map string$ 3,g_filemapoffset,desc$ : inc g_filemapoffset,((len(desc$)+3)/4 )*4
 listmax=0
 if listtype=0
  listmax=1
  list$(0)=strarr$(471)
  list$(1)=strarr$(470)
 endif
 if listtype=1
  listmax=fillgloballistwithweapons()
 endif
 if listtype=11
  listmax=fillgloballistwithbehaviours()
 endif
 set file map dword 3,g_filemapoffset,listmax : inc g_filemapoffset,4
 for i = 0 to listmax
  set file map dword 3,g_filemapoffset,len(list$( i )) : inc g_filemapoffset,4
  set file map string$ 3,g_filemapoffset,list$( i ) : inc g_filemapoffset,((len(list$( i ))+3)/4 )*4
 next i
endfunction

rem
rem Interface Properties Functions
rem

function setpropertybase(code, s$)
 if s$="" then s$=""
 set file map string$ 2, STRING_A, s$
 set file map string$ 2, STRING_B, ""
 set file map string$ 2, STRING_C, ""
 set file map dword 2, code, 1
 wait for file map event 2
 while get file map dword( 2, code ) = 1
  wait for file map event 2
 endwhile
endfunction

function setpropertystring(group,data$,field$,desc$)
 if data$="" then data$=""
 set file map string$ 2, STRING_A, field$
 set file map string$ 2, STRING_B, data$
 set file map string$ 2, STRING_C, desc$
 set file map dword 2, ENTITY_SET_GROUP_INDEX, group
 set file map dword 2, ENTITY_ADD_EDIT_BOX, 1
 wait for file map event 2
 while get file map dword( 2, ENTITY_ADD_EDIT_BOX ) = 1
  wait for file map event 2
 endwhile
endfunction

function setpropertycolor(group,dataval as DWORD,field$,desc$)
 data$=str$(rgbr(dataval))+" "+str$(rgbg(dataval))+" "+str$(rgbb(dataval))
 set file map dword 2, ENTITY_SET_GROUP_INDEX, group
 set file map string$ 2, STRING_A, field$
 set file map string$ 2, STRING_B, data$
 set file map string$ 2, STRING_C, desc$
 set file map dword 2, ENTITY_ADD_COLOR_PICKER, 1
 wait for file map event 2
 while get file map dword( 2, ENTITY_ADD_COLOR_PICKER ) = 1
  wait for file map event 2
 endwhile
endfunction

function setpropertyfile(group,data$,field$,desc$,within$)
 if data$="" then data$=""
 set file map dword 2, ENTITY_SET_GROUP_INDEX, group
 set file map string$ 2, STRING_A, field$
 set file map string$ 2, STRING_B, data$
 set file map string$ 2, STRING_C, desc$
 set file map string$ 2, 2024, rootdir$+within$
 set file map string$ 2, 2280, strarr$(321)
 set file map string$ 2, 2536, strarr$(322)
 set file map dword 2, ENTITY_ADD_FILE_PICKER, 1
 wait for file map event 2
 while get file map dword( 2, ENTITY_ADD_FILE_PICKER ) = 1
  wait for file map event 2
 endwhile
endfunction

function fillgloballistwithweapons()
 dim list$(1+gunmax)
 list$(0) = ""
 for gunid=1 to gunmax
  list$(gunid) = gun(gunid).name$
 next gunid
 retvalue=gunmax
endfunction retvalue

function fillgloballistwithbehaviours_init()
 retvalue=0
 if path exist(rootdir$+"scriptbank\behaviours")=1
  storedir$=get dir$()
  set dir rootdir$+"scriptbank\behaviours"
  perform checklist for files
  dim behaviourlist$(checklist quantity())
  for c=1 to checklist quantity()
   file$=checklist string$(c)
   if lower$(right$(file$,4))=".fpi"
    inc retvalue
    file$=left$(file$,len(file$)-4)
    behaviourlist$(retvalue)=upper$(left$(file$,1))+lower$(right$(file$,len(file$)-1))
   endif
  next c
  set dir storedir$
 endif
endfunction retvalue

function fillgloballistwithbehaviours()
 retvalue=behaviourlistmax
 dim list$(retvalue)
 list$(0)=""
 if retvalue>0
  for n=1 to retvalue
   list$(n-1)=behaviourlist$(n)
  next n
  retvalue=retvalue-1
 endif
endfunction retvalue

function setpropertylist(group,controlindex,data$,field$,desc$,listtype)
 if data$="" then data$=""
 if listtype=0
  if data$="0" then data$=strarr$(471)
  if data$="1" then data$=strarr$(470)
 endif
 set file map string$ 2, STRING_A, field$
 set file map string$ 2, STRING_B, data$
 set file map string$ 2, STRING_C, desc$
 set file map dword 2, ENTITY_SET_GROUP_INDEX, group
 set file map dword 2, ENTITY_SET_CONTROL_INDEX, controlindex
 set file map dword 2, ENTITY_ADD_LIST_BOX, 1
 wait for file map event 2
 while get file map dword( 2, ENTITY_ADD_LIST_BOX ) = 1
  wait for file map event 2
 endwhile
 listmax=0
 if listtype=0
  list$(0)=strarr$(471)
  list$(1)=strarr$(470)
  listmax=1
 endif
 if listtype=1
  listmax=fillgloballistwithweapons()
 endif
 if listtype=11
  listmax=fillgloballistwithbehaviours()
 endif
 for i = 0 to listmax
  set file map dword 2, ENTITY_SET_GROUP_INDEX, group
  set file map dword 2, ENTITY_SET_CONTROL_INDEX, controlindex
  set file map string$ 2, STRING_A, list$( i )
  set file map dword 2, ENTITY_ADD_ITEM_TO_LIST_BOX, 1
  wait for file map event 2
  while get file map dword( 2, ENTITY_ADD_ITEM_TO_LIST_BOX ) = 1
   wait for file map event 2
  endwhile
 next i
endfunction

rem
rem Interface Properties Expressions
rem

function getpropertyfield(group,iControl)
 set file map dword 2, ENTITY_GET_CONTROL_NAME, 1
 set file map dword 2, ENTITY_SET_GROUP_INDEX, group
 set file map dword 2, ENTITY_SET_CONTROL_INDEX, iControl
 wait for file map event 2
 while get file map dword( 2, ENTITY_GET_CONTROL_NAME ) = 1
  wait for file map event 2
 endwhile
 field$ = get file map string$( 2, STRING_A )
endfunction field$

function getpropertydata(group,iControl)
 set file map dword 2, ENTITY_GET_CONTROL_CONTENTS, 1
 set file map dword 2, ENTITY_SET_GROUP_INDEX, group
 set file map dword 2, ENTITY_SET_CONTROL_INDEX, iControl
 wait for file map event 2
 while get file map dword( 2, ENTITY_GET_CONTROL_CONTENTS ) = 1
  wait for file map event 2
 endwhile
 data$ = get file map string$( 2, STRING_B )
endfunction data$

rem
rem COMMON INTERFACE FUNCTIONS
rem

function set_progress_position( item, position )
   set file map dword 1, SET_PROGRESS_ITEM, item
   set file map dword 1, SET_PROGRESS_POSITION, position
   wait for file map event 1
   while get file map dword ( 1, SET_PROGRESS_ITEM ) = 1
    wait for file map event 1
   endwhile
endfunction

function get_list_box( item, index )
   set file map dword 1, SET_LIST_ITEM, item
   set file map dword 1, SET_LIST_INDEX, index
   set file map dword 1, GET_LIST_ITEM, 1
   wait for file map event 1
   while get file map dword ( 1, GET_LIST_ITEM ) = 1
    wait for file map event 1
   endwhile
   contents$ = get file map string$ ( 1, STRING_A )
endfunction contents$

function set_radio_state( item, state )
   if state=0 then state=2
   set file map dword 1, SET_RADIO_ITEM, item
   set file map dword 1, SET_RADIO_STATE, state
   wait for file map event 1
   while get file map dword ( 1, SET_RADIO_STATE ) > 0
    wait for file map event 1
   endwhile
endfunction

function get_radio_state( item )
   set file map dword 1, SET_RADIO_ITEM, item
   wait for file map event 1
   while get file map dword ( 1, SET_RADIO_ITEM ) > 0
    wait for file map event 1
   endwhile
   state = get file map dword ( 1, GET_RADIO_ITEM )
endfunction state

function set_edit_item( item, text$ )
   set file map dword 1, SET_EDIT_ITEM, item
   set file map string$ 1, STRING_A, text$
   set file map dword 1, SET_EDIT_TEXT, 1
   wait for file map event 1
   while get file map dword ( 1, SET_EDIT_TEXT ) = 1
    wait for file map event 1
   endwhile
endfunction

function get_edit_item( item )
   set file map dword 1, SET_EDIT_ITEM, item
   set file map dword 1, GET_EDIT_TEXT, 1
   wait for file map event 1
   while get file map dword ( 1, GET_EDIT_TEXT ) = 1
    wait for file map event 1
   endwhile
   text$ = get file map string$ ( 1, STRING_A )
endfunction text$

function browse( title$, directory$, filter$ )
   set file map string$ 1, STRING_A, title$
   set file map string$ 1, STRING_B, directory$
   set file map string$ 1, STRING_C, filter$
   set file map dword 1, BROWSE_DISPLAY, 1
   wait for file map event 1
   while get file map dword ( 1, BROWSE_FILE_SELECTED ) = 0
    wait for file map event 1
   endwhile
   set file map dword 1, BROWSE_FILE_SELECTED, 0
   set file map dword 1, BUTTON_CLICKED, 0
endfunction

function browse_for_folder( directory$ )
   set file map string$ 1, STRING_A, directory$
   set file map dword 1, 200, 1
   wait for file map event 1
   while get file map dword ( 1, 204 ) = 0
    wait for file map event 1
   endwhile
   set file map dword 1, 204, 0
   wait for file map event 1
   text$ = get file map string$ ( 1, STRING_A )
   set file map dword 1, BUTTON_CLICKED, 0
   wait for file map event 1
endfunction text$

function add_list_item( item, text$ )
   set file map dword 1, SET_LIST_ITEM, item
   set file map string$ 1, STRING_A, text$
   set file map dword 1, ADD_LIST_ITEM, 1
   wait for file map event 1
   while get file map dword ( 1, ADD_LIST_ITEM ) = 1
    wait for file map event 1
   endwhile
endfunction

function get_list_item( item, index )
   set file map dword 1, SET_LIST_ITEM, item
   set file map dword 1, SET_LIST_INDEX, index
   set file map dword 1, GET_LIST_ITEM, 1
   wait for file map event 1
   while get file map dword ( 1, GET_LIST_ITEM ) = 1
    wait for file map event 1
   endwhile
   text$ = get file map string$ ( 1, STRING_A )
endfunction text$

function delete_list_item( item, index )
   set file map dword 1, SET_LIST_ITEM, item
   set file map dword 1, SET_LIST_INDEX, index
   set file map dword 1, DELETE_LIST_ITEM, 1
   wait for file map event 1
   while get file map dword ( 1, DELETE_LIST_ITEM ) = 1
    wait for file map event 1
   endwhile
endfunction

function clear_list( item )
   set file map dword 1, SET_LIST_ITEM, item
   set file map dword 1, LIST_CLEAR, 1
   wait for file map event 1
   while get file map dword ( 1, LIST_CLEAR ) = 1
    wait for file map event 1
   endwhile
endfunction

function select_list_item( item, selectionindex )
   set file map dword 1, SET_LIST_ITEM, item
   set file map dword 1, LIST_SELECT_ITEM_INDEX, selectionindex
   set file map dword 1, LIST_SELECT_ITEM, 1
   wait for file map event 1
   while get file map dword ( 1, LIST_SELECT_ITEM ) = 1
    wait for file map event 1
   endwhile
endfunction

function get_list_item_selection( item )
   selection = -1
   set file map dword 1, SET_LIST_ITEM, item
   set file map dword 1, GET_LIST_SELECTION, 1
   wait for file map event 1
   while get file map dword ( 1, GET_LIST_SELECTION ) = 1
    wait for file map event 1
   endwhile
   selection = get file map dword( 1, LIST_SELECTION )
endfunction selection

function insert_list_item( item, position, text$ )
   set file map dword 1, SET_LIST_ITEM, item
   set file map dword 1, LIST_INSERT_POSITION, position
   set file map string$ 1, STRING_A, text$
   set file map dword 1, LIST_INSERT_ITEM, 1
   wait for file map event 1
   while get file map dword ( 1, LIST_INSERT_ITEM ) = 1
    wait for file map event 1
   endwhile
endfunction

function add_combo_box( item, text$ )
   set file map dword 1, SET_COMBO_ITEM, item
   set file map string$ 1, STRING_A, text$
   set file map dword 1, ADD_COMBO_ITEM, 1
   wait for file map event 1
   while get file map dword ( 1, ADD_COMBO_ITEM ) = 1
    wait for file map event 1
   endwhile
endfunction

`
` Property Functions
`

function add_group( name$ )
   set file map string$ 2, STRING_A, name$
   set file map dword 2, ENTITY_ADD_GROUP, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_ADD_GROUP ) = 1
    wait for file map event 2
   endwhile
endfunction

function add_edit_box( group, name$, contents$, description$ )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map string$ 2, STRING_A, name$
   set file map string$ 2, STRING_B, contents$
   set file map string$ 2, STRING_C, description$
   set file map dword 2, ENTITY_ADD_EDIT_BOX, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_ADD_EDIT_BOX ) = 1
    wait for file map event 2
   endwhile
endfunction

function add_color_picker( group, name$, contents$, description$ )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map string$ 2, STRING_A, name$
   set file map string$ 2, STRING_B, contents$
   set file map string$ 2, STRING_C, description$
   set file map dword 2, ENTITY_ADD_COLOR_PICKER, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_ADD_COLOR_PICKER ) = 1
    wait for file map event 2
   endwhile
endfunction

function add_file_picker_ex( group, name$, contents$, description$, dir$, filter$, title$ )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map string$ 2, STRING_A, name$
   set file map string$ 2, STRING_B, contents$
   set file map string$ 2, STRING_C, description$
   set file map string$ 2, 2024, dir$
   if filter$<>""
    set file map string$ 2, 2280, filter$
   else
    set file map string$ 2, 2280, strarr$(323)
   endif
   if title$<>""
    set file map string$ 2, 2536, title$
   else
    set file map string$ 2, 2536, strarr$(324)
   endif
   set file map dword 2, ENTITY_ADD_FILE_PICKER, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_ADD_FILE_PICKER ) = 1
    wait for file map event 2
   endwhile
endfunction

function add_file_picker( group, name$, contents$, description$, dir$ )
 add_file_picker_ex( group, name$, contents$, description$, dir$, "", "" )
endfunction

function add_font_picker( group, name$, contents$, description$ )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map string$ 2, STRING_A, name$
   set file map string$ 2, STRING_B, contents$
   set file map string$ 2, STRING_C, description$
   set file map dword 2, ENTITY_ADD_FONT_PICKER, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_ADD_FONT_PICKER ) = 1
    wait for file map event 2
   endwhile
endfunction

function add_list_box( group, name$, contents$, description$ )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map string$ 2, STRING_A, name$
   set file map string$ 2, STRING_B, contents$
   set file map string$ 2, STRING_C, description$
   set file map dword 2, ENTITY_ADD_LIST_BOX, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_ADD_LIST_BOX ) = 1
    wait for file map event 2
   endwhile
endfunction

function add_item_to_list_box( group, control, item$ )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map dword 2, ENTITY_SET_CONTROL_INDEX, control
   set file map string$ 2, STRING_A, item$
   set file map dword 2, ENTITY_ADD_ITEM_TO_LIST_BOX, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_ADD_ITEM_TO_LIST_BOX ) = 1
    wait for file map event 2
   endwhile
endfunction

function get_control_name( group, control )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map dword 2, ENTITY_SET_CONTROL_INDEX, control
   set file map dword 2, ENTITY_GET_CONTROL_NAME, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_GET_CONTROL_NAME ) = 1
    wait for file map event 2
   endwhile
   name$ =  get file map string$( 2, STRING_A )
endfunction name$

function get_control_contents( group, control )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map dword 2, ENTITY_SET_CONTROL_INDEX, control
   set file map dword 2, ENTITY_GET_CONTROL_CONTENTS, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_GET_CONTROL_CONTENTS ) = 1
    wait for file map event 2
   endwhile
   contents$ = get file map string$( 2, STRING_B )
endfunction contents$

function get_control_description( group, control )
   set file map dword 2, ENTITY_SET_GROUP_INDEX, group
   set file map dword 2, ENTITY_SET_CONTROL_INDEX, control
   set file map dword 2, ENTITY_GET_CONTROL_DESCRIPTION, 1
   wait for file map event 2
   while get file map dword( 2, ENTITY_GET_CONTROL_DESCRIPTION ) = 1
    wait for file map event 2
   endwhile
   description$ = get file map string$( 2, STRING_C )
endfunction description$

`
`
`

function popup_text( statusbar$ )
 open file map 1,"FPSEXCHANGE"
 set file map dword 1, 750, 1
 wait for file map event 1
 close file map 1
 while 1
  open file map 2, "FPSPOPUP"
  wait for file map event 2
  if get file map dword( 2, 0 ) = 1
   set file map string$ 2, 1000, statusbar$
   set file map dword 2, 4, 1
   wait for file map event 2
   while get file map dword( 2, 4 ) = 1
    wait for file map event 2
   endwhile
   close file map 2
   exit
  endif
  close file map 2
  sync
 endwhile
endfunction

function popup_text_change( statusbar$ )
 open file map 2, "FPSPOPUP"
 wait for file map event 2
 if get file map dword( 2, 0 ) = 1
  set file map string$ 2, 1000, statusbar$
  set file map dword 2, 4, 1
  wait for file map event 2
  while get file map dword( 2, 4 ) = 1
   wait for file map event 2
  endwhile
  close file map 2
 endif
endfunction

function popup_text_close()
 open file map 2, "FPSPOPUP"
 set file map dword 2, 8, 1
 wait for file map event 2
 close file map 2
endfunction

function timestampactivity(i,desc$)
 if gproducelogfiles=1
  if i=0
   inc timestampactivityindex
   if timestampactivityindex>999
    timestampactivityindex=999
   endif
   i=timestampactivityindex
  else
   timestampactivityindex=i
  endif
  if i>timestampactivitymax
   timestampactivitymax=i
  endif
  dim timestampactivity$(timestampactivitymax)
  timestampactivity$(i)=str$(timer())+" : "+desc$
  file$="..\"+trueappname$+".log" : if file exist(file$)=1 then delete file file$
  if len(trueappname$)>0
   open to write 1,file$
    for t=1 to timestampactivitymax
     write string 1,timestampactivity$(t)
    next t
   close file 1
  endif
 endif
endfunction

function loadresource()
 `
 rem Load previously captured resource data
 memoryusagetable$=rootdir$+"editors\gridedit\memusedtable.dat"
 if file exist(memoryusagetable$)=1
  open to read 1,memoryusagetable$
   read file 1,numberofitems
   if numberofitems>0
    dim gamememtable(numberofitems-1) as gamememtabletype
    for n=0 to numberofitems-1
     read string 1,name$ : gamememtable(n).name$=name$
     read file 1,memused : gamememtable(n).memused=memused
    next n
   else
    empty array gamememtable()
   endif
  close file 1
 endif
endfunction

function saveresource()
 `
 rem Save out resource captures
 memoryusagetable$=rootdir$+"editors\gridedit\memusedtable.dat"
 if file exist(memoryusagetable$)=1 then delete file memoryusagetable$
 open to write 1,memoryusagetable$
  numberofitems=1+array count(gamememtable())
  write file 1,numberofitems
  if numberofitems>0
   for n=0 to numberofitems-1
    name$=gamememtable(n).name$ : write string 1,name$
    memused=gamememtable(n).memused : write file 1,memused
   next n
  endif
 close file 1
 if 1
  memoryusagetable$=rootdir$+"editors\gridedit\memusedtable.log"
  if file exist(memoryusagetable$)=1 then delete file memoryusagetable$
  open to write 1,memoryusagetable$
   numberofitems=1+array count(gamememtable())
   write string 1,"COUNT="+str$(numberofitems)
   if numberofitems>0
    for n=0 to numberofitems-1
     write string 1,str$(n)+":"+gamememtable(n).name$+" ["+str$(gamememtable(n).memused)+"]"
    next n
   endif
   write string 1,"END"
  close file 1
 endif
endfunction

function openresource(name$)
 rem find existing slot, or free slot
 if len(name$)>1
  actuallyused=0
  gamememresourceid=-1
  name$=lower$(name$)
  if array count(gamememtable())>=0
   for n=0 to array count(gamememtable())
    if gamememtable(n).name$=name$
     gamememresourceid=n : exit
    endif
   next n
  endif
  if gtestgamemodefromeditor=1
   rem test game records size of memory usage (start)
   if gamememresourceid=-1
    n=array count(gamememtable())+1
    dim gamememtable(n) as gamememtabletype
    gamememtable(n).name$=name$
    gamememtable(n).memused=-1
    gamememresourceid=n
   endif
   gamememstamp=system smem available(1)
  else
   rem real game or map editor usage tracks existing resources memory usage
   actuallyused=0
   if gamememresourceid>=0
    actuallyused=gamememtable(gamememresourceid).memused
   endif
  endif
 endif
endfunction actuallyused

function closeresource()
 if gamememresourceid>=0
  if gtestgamemodefromeditor=1
   rem test game records size of memory usage (end)
   if gamememtable(gamememresourceid).memused=-1
    rem and only if not filled in do we write the memory used
    memoryused=system smem available(1)-gamememstamp
    gamememtable(gamememresourceid).memused=memoryused
   endif
   gamememresourceid=-1
  else
   rem rea game or map editing does nothing here (all happened with openresource)
  endif
 endif
endfunction

function control_escapekey()
 returnvalue=escapekey()
 if gxbox=1
  rem FPGC - 220210 - intercept with controller input
  if gxboxcontrollertype=0
   if joystick fire x(6)=1 then returnvalue=1
   if joystick fire x(7)=1 then returnvalue=1
  endif
  if gxboxcontrollertype=1
   if joystick fire x(8)=1 then returnvalue=1
   if joystick fire x(9)=1 then returnvalue=1
  endif
 endif
endfunction returnvalue

function control_mouseclick_mode(mode as integer)
 returnvalue=mouseclick()
 if gxbox=1
  rem FPGC - 220210 - intercept with controller input
  if gxboxcontrollertype=0
   if joystick z()<-500 then returnvalue=1
  endif
  if gxboxcontrollertype=1
   if joystick fire x(5)=1 or joystick fire x(7)=1 then returnvalue=1
  endif
  if mode=0
   if joystick fire a()=1 then returnvalue=1
   if joystick fire b()=1 then returnvalue=1
   if joystick fire c()=1 then returnvalue=1
   if joystick fire d()=1 then returnvalue=1
  endif
  if mode=1
   rem FPGC - 150310 - only one main controller button for left click
   if joystick fire b()=1 then returnvalue=1
  endif
 endif
 if fpgcgenre=0
  rem FPGC - 150310 - game creator is non-shooting, so LEFT is PICKUP/DROP, RIGHT=NULL
  treturnvalue=returnvalue
  if returnvalue=1 then treturnvalue=2
  if returnvalue=2 then rreturnvalue=0
  returnvalue=treturnvalue
 endif
endfunction returnvalue

function control_mouseclick()
 tresult=control_mouseclick_mode(0)
endfunction tresult

rem
rem DARKVOICES LIPSYNC SUBROUTINES
rem
rem _lipsync_playspeech       - load and play speech
rem _lipsync_timeline_process - load LIPSYNC data into array
rem _lipsync_control          - control mouth during speech

type lipsynctype
 playing
 currentsoundfile$
 oldcurrentsoundfile$
 lipsyncfile$
 time as DWORD
 timelineptr as DWORD
 timelinemax as DWORD
 pose
 posetravelspeed
 lastpose
endtype
type lipsynctimelinetype
 s as DWORD
 e as DWORD
 t as DWORD
 s$ as string
endtype
lipsync as lipsynctype
type lipsyncglobaltype
 playing as integer
 time as DWORD
 soundid as integer
endtype
lipsyncglobal as lipsyncglobaltype

_lipsync_init:
 `
 rem create lip sync time line array and setup phoneme frames
 dim timeline(25000) as lipsynctimelinetype
 `
 rem DarkVOICES Head
 ph_a=1 : ph_c=4 : ph_e=2 : ph_f=3 : ph_l=5
 ph_m=6 : ph_o=7 : ph_r=10 : ph_u=8 : ph_w=9 : ph_rest=0
 `
return

_lipsync_playspeech:

rem load WAV sound and LIPSYNC data (takes soundid from external sound playing engine)
lipsyncglobal.playing=0
if lipsyncglobal.playing=0
 if oldcurrentsoundfile$<>currentsoundfile$
  oldcurrentsoundfile$=currentsoundfile$
  `if sound exist(1)=1 then delete sound 1
  `load sound currentsoundfile$,1
  lipsyncfile$=left$(currentsoundfile$,len(currentsoundfile$)-4)+".lipsync"
  gosub _lipsync_timeline_process
 endif
 `play sound 1
 lipsyncglobal.time=timer()
 lipsyncglobal.playing=1
 lipsyncglobal.soundid=soundid
endif

return

_lipsync_timeline_process:

dim lipsync$(25000)
for t=0 to 24999
 lipsync$(t)=""
next t
timelineptr=0
if file exist(lipsyncfile$)=1
 load array lipsyncfile$,lipsync$()
else
 rem lipsync missing, but allow to carry on
 if gproducelogfiles=1 then timestampactivity(0,"Missing LIPSYNC file="+lipsyncfile$)
endif
for l=1 to 24999
 `
 rem cut up phm
 cuti=0
 dim cut$(5)
 cut$(0)=""
 cut$(1)=""
 cut$(2)=""
 cut$(3)=""
 cut$(4)=""
 cut$(5)=""
 cutme$=lipsync$(l)
 for n=1 to len(cutme$)+1
  if len(cutme$)>=1 and cuti<=5
   if mid$(cutme$,n)=" " or n=len(cutme$)
    if n=len(cutme$)
     cut$(cuti)=lower$(left$(cutme$,n))
     cutme$=right$(cutme$,len(cutme$)-(len(cut$(cuti))))
    else
     cut$(cuti)=lower$(left$(cutme$,n-1))
     cutme$=right$(cutme$,len(cutme$)-(len(cut$(cuti))+1))
    endif
    inc cuti
    n=0
   endif
  endif
 next n
 `
 rem approximations to 10 poses (ideally 39)
 if cut$(0)="phn"
  st=val(cut$(1))
  en=val(cut$(2))
  if cut$(4)="m" then ty=ph_m
  if cut$(4)="ae" then ty=ph_a
  if cut$(4)="n" then ty=ph_c
  if cut$(4)="ay" then ty=ph_a
  if cut$(4)="x" then ty=ph_rest
  if cut$(4)="iy" then ty=ph_a
  if cut$(4)="ih" then ty=ph_a
  if cut$(4)="eh" then ty=ph_e
  if cut$(4)="ah" then ty=ph_a
  if cut$(4)="uw" then ty=ph_w
  if cut$(4)="uh" then ty=ph_w
  if cut$(4)="aa" then ty=ph_a
  if cut$(4)="ao" then ty=ph_o
  if cut$(4)="ey" then ty=ph_a
  if cut$(4)="oy" then ty=ph_o
  if cut$(4)="aw" then ty=ph_o
  if cut$(4)="ow" then ty=ph_o
  if cut$(4)="l" then ty=ph_l
  if cut$(4)="r" then ty=ph_r
  if cut$(4)="y" then ty=ph_u
  if cut$(4)="w" then ty=ph_w
  if cut$(4)="er" then ty=ph_u
  if cut$(4)="ng" then ty=ph_c
  if cut$(4)="ch" then ty=ph_u
  if cut$(4)="j" then ty=ph_r
  if cut$(4)="dh" then ty=ph_l
  if cut$(4)="b" then ty=ph_m
  if cut$(4)="d" then ty=ph_l
  if cut$(4)="g" then ty=ph_r
  if cut$(4)="p" then ty=ph_m
  if cut$(4)="t" then ty=ph_r
  if cut$(4)="k" then ty=ph_c
  if cut$(4)="z" then ty=ph_c
  if cut$(4)="zh" then ty=ph_c
  if cut$(4)="v" then ty=ph_f
  if cut$(4)="f" then ty=ph_f
  if cut$(4)="th" then ty=ph_l
  if cut$(4)="s" then ty=ph_r
  if cut$(4)="sh" then ty=ph_r
  if cut$(4)="h" then ty=ph_r
  inc timelineptr
  timeline(timelineptr).s=st
  timeline(timelineptr).e=en
  timeline(timelineptr).t=ty
  timeline(timelineptr).s$=cut$(4)
 endif
 `
next l
timelinemax=timelineptr

return

_lipsync_control:
 `
 rem get mouth pose
 pose=0
 if lipsyncglobal.playing=1
  if lipsyncglobal.soundid<1
   lipsyncglobal.playing=0
  else
   current as DWORD
   current=(timer()-lipsyncglobal.time)+150
   for t=1 to timelinemax
    if current>=timeline(t).s and current<=timeline(t).e
     pose=timeline(t).t
     if pose=ph_rest then pose=0
     if pose<>lastpose
      posetravelspeed=timeline(t).e-current
     endif
     lastpose=pose
    endif
   next t
   if sound playing(lipsyncglobal.soundid)=0 then lipsyncglobal.playing=0
  endif
 endif
 `
 rem set frame of mouth in head model to match pose
 remstart
 headobjid=2
 fr=pose
 screenrate#=screen fps()
 if fr<>lfr
  lfr=fr
  if posetravelspeed>0
   screenrate#=1000.0/screenrate#
   posetravelspeed=posetravelspeed-screenrate#
   percspeed#=(posetravelspeed+0.0)/screenrate#
   if percspeed#<1.0 then percspeed#=1.0
   posetravelspeed=0
   `set object interpolation headobjid,100.0/percspeed#
   set object interpolation headobjid,100
   set object frame headobjid,fr*120
  endif
 endif
 if playing=0
  set object frame headobjid,frr*120
 endif
 remend
 `
return

Rem Hockeykid - 250210 - Dark AI create/declare constants
#constant STATE_IDLE 0
#constant STATE_ATTACKING 1
#constant STATE_COVER 2
#constant STATE_RETREAT 3
#constant STATE_CUSTOM 4

_darkai_start:
 `
 rem Moved AI START to VERY beginning as AI ENTITY EXIST gets called VERY early
 AI Start
 `
return

_darkai_init:
 `
 rem clears the AI system of all data
 AI Reset : darkaiplayer=0
 `
 rem FPGC - 300710 - DarkAI only in single player (we still call START and create containers as AI code intersects MP code)
 if gmultiplayergame=0
  `
  Rem Create team 1
  w=AIFindEmptyTeam()
  aifaction(w,1).team=1
  `
 endif
 `
 rem N-CORE threading (if available, and if no debug in progress)
 `seems to conflict with new script based approach, ah well
 `if gshowaioutlines=0
 ` rem cannot use n-core in debug as objects for debug visuals are created sequentially
 ` AI SET THREAD MODE 1
 ` AI SET THREAD COUNT 4
 `endif
 `
 rem X10 Set common entity radius and avoidance model (22)
 `AI Set Radius 20 : AI Set Avoid Mode 5 : rem 5 - avoidance grid system
 `AI SET BLOCKING THRESHOLD 3 : rem number of corpses before grid is marked solid
 rem Hockeykid entity radius and avoidance model
 ai set radius gairadius : rem ai set avoid mode 1
 `
 rem V118 - 080211 - switch to grid based avoidance system (less likely to push fellows into walls)
 rem V119 - 230611 - Hockeykid - Sounds nice, but doesn't seem to work as desired. Apparently the blocking threshold is incorrect
 rem 1 AI can stop another AI, instead of 3 :S
 ai set avoid mode 5 : AI SET BLOCKING THRESHOLD 3 rem changed back to stop fellows into walls
` ai set avoid mode 1
 `
 rem Universe containers (required for static entities)
 for layer=0 to 19
  if layer>0 then AI Add Container layer
  container(layer).y# = (layer*100)+50
  container(layer).id = layer
 next layer
 `
return

_darkai_free:
 `
 rem after each level, reset AI so a new level can be loaded
 rem it also frees the OBS file loaded for the obstacle data
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  AI Reset
 endif
 `
return

_darkai_addai:

 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  if ai entity exist(obj)
   ai kill entity obj
  endif
  tcont=0
  for y=0 to 19
   if entityelement(e).y >= container(y).y#-50.0 and entityelement(e).y <= container(y).y#+50.0
    tcont=y : exit
   endif
  next y
  entityelement(e).darkai.team=team
  if entityelement(e).darkai.team<>1
   ai add enemy obj,0,tcont
  else
   ai add friendly obj,0,tcont
  endif
  `
  AI Set Entity Can Select targets obj,0
  ai set entity view arc obj,entityelement(e).eleprof.coneangle*0.7,entityelement(e).eleprof.coneangle
  `
  rem FPGC - 060510 - height measures characters EYE from FEET (for alternative visibility raycast)
  AI Set Entity Height obj,entityelement(e).eleprof.coneheight
  `AI Set Entity Turn Speed obj,entityelement(e).eleprof.speed*2 ` FPGC - 100710 - all chars turn VERY slowly!
  AI Set Entity Turn Speed obj,entityelement(e).eleprof.speed*6
  `
  ai set entity fire arc obj,entityelement(e).eleprof.coneangle-(entityelement(e).eleprof.coneangle*0.3)`20
  ai set entity view range obj,600
  ai set entity attack distance obj,200-rnd(50)+rnd(50)
  ai set entity aggressive obj
  entityelement(e).darkai.hearingrange=700
  `ai set entity hearing range obj,700
  `ai set entity hearing threshold obj,10
  ai set entity can roam obj,1
  REM DAI SPEED
  ai set entity speed obj,entityelement(e).eleprof.speed/2.0
  rem lee - 240111 - place virtual DAI entity position X units before 'floor' to avoid ray cast collision with geometry!
  ai set entity position obj,entityelement(e).x,entityelement(e).y+5,entityelement(e).z
  tcontainerid=entityelement(e).y+50
  if tcontainerid<0 then tcontainerid=0
  if tcontainerid>19 then tcontainerid=19
  ai set entity idle position obj,entityelement(e).x,entityelement(e).z,tcontainerid
  ai set entity angle y obj,entityelement(e).ry
  targetcontainer=AIFindContainer(entityelement(e).y+25)
  ai entity go to position obj,entityelement(e).x,entityelement(e).z,targetcontainer
  ai set entity can duck obj,1
  ai set entity avoid distance obj,300
  ai set entity can strafe obj,1
  ai set entity control obj,0
 endif
Return

_darkai_control:
 `
 Rem Hockeykid - 250210 - Dark AI control subroutine
 obj=entityelement(e).obj
 if obj=0 then return
 if ai entity exist(obj)=0 then return
 `
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=1 then return
 `
 Rem reset ttarget(s)
 ttargetvisible=0
 ttargetvisibleduck=0
 inc gameperfentities2, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()
 Rem add all new targets to target list
 Gosub Add_Targets
 inc gameperfentities3, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()
 `
 rem Collect Sensory Information
 tobjtarget=0
 if ai get entity target id(obj,1)<>0 then tobjtarget=entityelement(e).ttarget
 `
 tsound=ai get entity heard sound(obj)
 ttargets=ai get entity count targets(obj)
 `
 rem Collect Target Information (280410 - added tobjtarget<65535 to prevent crash)
 if tobjtarget>0 and tobjtarget<65535
  if object exist(tobjtarget)=1
   if tobjtarget=physicsplayerborble
    ttargetx#=camera position x()
    ttargety#=camera position y()
    ttargetz#=camera position z()
   else
    ttargetx#=ai get entity target x(obj)
    ttargety#=object position y(tobjtarget)
    ttargetz#=ai get entity target z(obj)
   endif
   ttargetvisible=ai get entity can see(obj,ttargetx#,ttargety#,ttargetz#,1)
   ttargetvisibleduck=ai get entity can see(obj,ttargetx#,ttargety#,ttargetz#,0)
  endif
 endif
 `
 rem Collect Status Information
 tentid=entityelement(e).bankindex
 tducking=ai get entity is ducking(obj)
 tmoving=ai get entity is moving(obj)
 tturning=ai get entity is turning(obj)
 tavoiding=ai get entity avoiding(obj)
 `
 Rem Hockeykid - 250210 - Added line so Dark AI entities have footfall sounds
 if tmoving>0
      plrid=entityelement(e).fakeplayerid
    if entityprofile(entid).footfallmax>0 and plrid>1
     rem V110 BETA5 - 080608 - manually controlled footfalls (from FPE data)
     manuallycontrolledfootfallframe=1
     if obj>0
      tcurrentkeyframe=object frame(obj)
      for q=0 to entityprofile(entid).footfallmax-1
       if entityfootfall(entid,q).keyframe=tcurrentkeyframe then manuallycontrolledfootfallframe=1+tcurrentkeyframe : exit
      next q
      `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)
      if manuallycontrolledfootfallframe>1
       rem make a footfall sound for the entity
       movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
       broadcast3dsound(entityelement(e).x,entityelement(e).y,entityelement(e).z,0,entityelement(e).obj)
       gosub _player_playfootfall
       `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)+"   PING!"
      endif
     endif
     manuallycontrolledfootfallframe=0
    else
     rem default - timer based footfalls
     if tstep#>0.0
      if entityelement(e).mover.run=1
       basespeed#=55
      else
       basespeed#=35
      endif
      if entityelement(e).eleprof.speed<>100
       tss#=entityelement(e).eleprof.speed/100.0
       basespeed#=basespeed#*tss#
      endif
      endif
      movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
      broadcast3dsound(entityelement(e).x,entityelement(e).y,entityelement(e).z,0,entityelement(e).obj)
      if plrid>1 then gosub _player_playfootfall

      endif


 endif
 `
 rem Collect State Information
 tstate=entityelement(e).darkai.state

 rem Collect Position Information
 tmyx#=entityelement(e).x`object position x(obj)
 tmyy#=entityelement(e).y`object position y(obj)
 tmyz#=entityelement(e).z`object position z(obj)
 `
 rem Reset Actions
 ai set entity no look at point obj
 entityelement(e).darkai.running=0

 Rem Attack Awarness action
 if entityelement(e).darkai.autoattackoff=1
  ttargets=0
  tobjtarget=0
  ttargetvisibleduck=0
  ttargetvisible=0
  ttargetx#=0.0
  ttargety#=0.0
  ttargetz#=0.0
 endif

 Rem Finish path - game was save
 if entityelement(e).darkai.daihasdest=1
  desty#=ai get entity container(entityelement(e).obj)
  ai entity go to position entityelement(e).obj,entityelement(e).darkai.daidestx,entityelement(e).darkai.daidestz,desty#
  entityelement(e).darkai.daihasdest=0
 endif

 rem Sees opponent
 if entityelement(e).darkai.autoattackoff=0
  if ttargetvisible=1 and entityelement(e).darkai.state=STATE_IDLE or ttargets>0 and entityelement(e).darkai.state=STATE_IDLE
   if ttargetvisibleduck=0
    entityelement(e).darkai.state=STATE_COVER
   else
    entityelement(e).darkai.state=STATE_ATTACKING
   endif
  endif
 endif

 Rem Hockeykid - 100310 - If not in any of these action modes and entity is set to automatic mode then turn off
 if entityelement(e).darkai.control=1
  if entityelement(e).darkai.actionmode<>0 and entityelement(e).darkai.actionmode<>1 and entityelement(e).darkai.actionmode<>4
   entityelement(e).darkai.control=0 : ai set entity control obj,0
  endif
 endif

 rem Idle
 if tstate=STATE_IDLE
  rem Stand up
  if tducking=1 then ai entity stand obj

  Rem Hockeykid - All AI types
  if entityelement(e).darkai.actionmode=5
   `ai entity move to closest sound obj
   AIMoveToSound(obj,obje)
   entityelement(e).darkai.actionmode=0
  endif
  if entityelement(e).darkai.actionmode=6
   ai entity move away from sound obj
  endif
  Rem Hockeykid - 160310 - Patrol path, this command creates a path from current point to a path point
  if entityelement(e).darkai.actionmode=8
   i=entityelement(e).darkai.path
   targetcontainer=AIFindContainer(points(i).y+25)
   ai entity go to position obj,points(i).x,points(i).z,targetcontainer
   entityelement(e).darkai.actionmode=0
  endif
  `
  Rem Hockeykid - 020310 - Special area for allies only
  if entityelement(e).darkai.team=1
   rem Follow the player
   if entityelement(e).darkai.actionmode=1
    ai set entity control obj,1
    ai entity follow player obj,60
    entityelement(e).darkai.follow=1
    Rem set the entities control variable to 1 so can be swtiched off later if on
    entityelement(e).darkai.control=1
    entityelement(e).darkai.actionmode=0
   endif

   if entityelement(e).darkai.actionmode=4 and entityelement(e).darkai.follow<>0
    ai entity separate obj
    Rem Hockeykid - 030310 - Reset control mode to manual
    if entityelement(e).darkai.control=1 then entityelement(e).darkai.control=0 : ai set entity control obj,0
    entityelement(e).darkai.follow=0
    Rem Hockeykid - 030310 - Call actionmode 3 so entities stop right away
    entityelement(e).darkai.actionmode=3
    entityelement(e).darkai.follow=0
   endif

   if entityelement(e).darkai.actionmode<>4 and entityelement(e).darkai.follow<>0 and entityelement(e).darkai.actionmode<>0
    ai entity separate obj
    Rem Hockeykid - 030310 - Reset control mode to manual
    if entityelement(e).darkai.control=1 then entityelement(e).darkai.control=0 : ai set entity control obj,0
    entityelement(e).darkai.follow=0
    targetcontainer=AIFindContainer(entityelement(e).y+25)
    ai entity go to position obj,entityelement(e).x,entityelement(e).z,targetcontainer
   endif
   `
  endif
  `
  Rem Hockeykid - 020310 -  Area for both enemies and allies
  rem Move randomly
  if entityelement(e).darkai.delay<timer() and entityelement(e).darkai.actionmode=2
   entityelement(e).darkai.delay=timer()+2500
   ai entity random move obj,300,1000
  endif
  `
  rem Stop entity in its tracks
  if entityelement(e).darkai.actionmode=3
   Rem entity must be in manual mode
   if entityelement(e).darkai.control=1 then ai set entity control obj,0 : entityelement(e).darkai.control=0
   targetcontainer=AIFindContainer(entityelement(e).y+25)
   ai entity go to position obj,entityelement(e).x,entityelement(e).z,targetcontainer
   entityelement(e).darkai.actionmode=0
  endif
  `
  Rem Alert entity if Ambushed
  Rem This can be done purley through scripting now
  entityelement(e).darkai.ambushed=0
  `
  rem Sees opponent
  if entityelement(e).darkai.autoattackoff=0
   if ttargetvisible=1 or ttargets>0
    if ttargetvisibleduck=0
     entityelement(e).darkai.state=STATE_COVER
    else
     entityelement(e).darkai.state=STATE_ATTACKING
    endif
   endif
  endif
 endif

 rem Attacking
 if tstate=STATE_ATTACKING or tstate=STATE_COVER
  rem if told to, stop entity from moving
  if entityelement(e).darkai.aistop=1 then ai entity stop obj

  if tobjtarget>0
   `ai entity look at position obj,ttargetx#,ttargetz#
   if entityelement(e).darkai.state<>STATE_COVER and ttargetvisibleduck=0
    entityelement(e).darkai.state=STATE_COVER : ai entity move to cover obj,ttargetx#,ttargetz#
   endif

   rem if called instruct entity to move to cover
   if entityelement(e).darkai.actionmode=7 and entityelement(e).darkai.state<>STATE_COVER and ttargetvisibleduck=0
    entityelement(e).darkai.state=STATE_COVER
    ai entity move to cover obj,ttargetx#,ttargetz#
   endif

   rem if more than 2 enemies then run
   if ttargets>2 and tmoving=1
    entityelement(e).darkai.running=1
   endif

   if entityelement(e).health<(entityelement(e).eleprof.strength*0.5)
    rem if health at half then move to cover
    if tmoving=0 then ai entity move to cover obj,ttargetx#,ttargetz# : entityelement(e).darkai.state=STATE_COVER
    entityelement(e).darkai.running=1
   else
    if ttargetvisible=0
     rem if lost target then try to find him
     if tmoving=0 then ai entity move close obj,ttargetx#,ttargetz#,200.0
    else
     rem V118 this seems to have been commented back in by Sean on 28-01-11 - no reason why
     rem without this entity's will continue to move in 1 direction
     `if entityelement(e).darkai.delay2>timer() and entityelement(e).darkai.state=STATE_ATTACKING then ai entity stop obj
    endif
   endif
  else
   ai entity search area obj
   entityelement(e).darkai.state=STATE_IDLE
  endif

  if entityelement(e).darkai.ambushed>0 and entityelement(e).darkai.autoattackoff=0
   entityelement(e).darkai.ambushed=0
   ai entity look at position obj,entityelement(e).darkai.ambushx#,entityelement(e).darkai.ambushz#
  endif
  if entityelement(e).darkai.state<>STATE_ATTACKING and ttargetvisibleduck>0
   entityelement(e).darkai.state=STATE_ATTACKING
  endif
 endif

 rem Open Attacking
 if tstate=STATE_ATTACKING
  if ai get entity is ducking(obj)=1 or (entityelement(e).darkai.running=1 and tmoving=1)
   ai entity stand obj
  endif

  if entityelement(e).darkai.delay2<timer()
   `entityelement(e).darkai.delay2=timer()+1500
   `instrafe=1
   `if tmoving=0 then ai entity strafe target obj
  else
   `instrafe=0
  endif

 endif

 rem Cover
 if tstate=STATE_COVER
  if entityelement(e).darkai.delay<timer()
   rem check for target height
   tscaley=object size y(obj)/2.0
   t3dvischeck=static raycast(tmyx#,tmyy#-(tscaley*0.75),tmyz#,ttargetx#,ttargety#,ttargetz#)
   `
   if t3dvischeck=0
    rem stand and shoot
    ai entity stand obj
    entityelement(e).darkai.delay=timer()+500+rnd(2000)
   else
    if ai get entity is ducking(obj)=1 or (entityelement(e).darkai.running=1 and tmoving=1)
     rem stand and shoot while moving
     ai entity stand obj
     entityelement(e).darkai.delay=timer()+500+rnd(2000)
    else
     rem duck if standing still
     ai entity duck obj
     if entityelement(e).health<(entityelement(e).eleprof.strength*0.5)
      entityelement(e).darkai.delay=timer()+2000+rnd(5000)
     else
      entityelement(e).darkai.delay=timer()+1000+rnd(3000)
     endif
    endif
   endif

  endif
 endif

 rem Retreat
 if tstate=STATE_RETREAT
  rem Stand up and run
  if tducking=1 then ai entity stand obj
  entityelement(e).darkai.running=1
  `
  rem Move to cover if we see our target
  if tmoving=0 and ttargetvisible=1
   ai entity move to cover obj,ttargetx#,ttargetz#
  endif
  rem Return to idle if no target is visible
  if ttargetvisible=0 and ttargetvisibleduck=0
   entityelement(e).darkai.state=STATE_IDLE
  endif
 endif

 Rem Any State
 Rem check if entity is at cover
 if entityelement(e).darkai.movingtocover=1
  if entityelement(e).darkai.actionmode<>0 then entityelement(e).darkai.movingtocover=0
  if ai get entity x(obj)>=entityelement(e).darkai.coverx-3 and ai get entity x(obj)<=entityelement(e).darkai.coverx+3 and ai get entity z(obj)>=entityelement(e).darkai.coverz-3 and ai get entity z(obj)<=entityelement(e).darkai.coverz+3
   rem at or near cover
   entityelement(e).darkai.movingtocover=0
   entityelement(e).darkai.state=STATE_COVER
  else
   rem if not at cover then continue to move towards it
   targetcontainer=AIFindContainer(entityelement(e).y+25)
   ai entity go to position obj,entityelement(e).darkai.coverx,entityelement(e).darkai.coverz,targetcontainer
  endif
 endif

 Rem Hockeykid - 050410 - reset call flag if times up
 if entityelement(e).darkai.called>0
  if timer()-entityelement(e).darkai.calldelay>=1000 then entityelement(e).darkai.called=0
 else
  if entityelement(e).darkai.called=-1 and timer()-entityelement(e).darkai.calldelay2>=5000 then entityelement(e).darkai.called=0
 endif

 rem Apply Direction
 tmovx#=ai get entity move x(obj)
 tmovz#=ai get entity move z(obj)
 `
 rem Get entity position info
 tentx#=ai get entity x(obj)
 tentz#=ai get entity z(obj)
 `
 rem update entity's position
 entityelement(e).mover.da=ai get entity angle y(obj)
 entityelement(e).x=tentx#
 entityelement(e).z=tentz#
 entityelement(e).darkai.aiy=Object Position Y(obj)

 rem Apply Animation
 entityelement(e).darkai.action=0
 if tmoving=1
  rem calculate difference in view and move angle
  moveangle#=wrapvalue(atanfull(tmovx#,tmovz#))
  viewangle#=wrapvalue(ai get entity angle y(obj))
  diffangle#=moveangle#-viewangle# : conda#=diffangle#
  if conda#>180 then conda#=360-conda#
  if conda#<-180 then conda#=conda#+360
  entityelement(e).darkai.action=1
  `
  rem apply animation type flag
  rem FPGC - 100710 - do not trigger strafe flag (and subsequent animation) until establish proper strafe build-up
  tstillstrafing=0
  if conda#>80.0 then entityelement(e).darkai.strafebuildup=entityelement(e).darkai.strafebuildup+1 : tstillstrafing=1
  if conda#<-80.0 then entityelement(e).darkai.strafebuildup=entityelement(e).darkai.strafebuildup-1 : tstillstrafing=1
  if tstillstrafing=0 then entityelement(e).darkai.strafebuildup=0
  if entityelement(e).darkai.strafebuildup<>0
   if entityelement(e).darkai.strafebuildup>5 then entityelement(e).darkai.action=4
   if entityelement(e).darkai.strafebuildup<-5 then entityelement(e).darkai.action=3
  endif
  if conda#<-120.0 or conda#>120.0 then entityelement(e).darkai.action=2
  if entityelement(e).aimoved=1 then entityelement(e).aimoved=0
 endif
 `
 rem reset ehit flag
 if entityelement(e).darkai.ehit=-1 then entityelement(e).darkai.ehit=0
 `
 rem Work out distance to target (run if over 600 units away)
 entityelement(e).mover.run=0
 if entityelement(e).darkai.autoattackoff=0
  if entityelement(e).darkai.action=1
   tenttargetx#=ai get entity destination x(obj)-tentx#
   tenttargetz#=ai get entity destination z(obj)-tentz#
   tenttarget#=sqrt(abs(tenttargetx#*tenttargetx#)+abs(tenttargetz#*tenttargetz#))
   if tenttarget#>175
    entityelement(e).darkai.runbuildup=entityelement(e).darkai.runbuildup+1
    if entityelement(e).darkai.runbuildup>20
     entityelement(e).mover.run=1
     entityelement(e).darkai.action=5
    endif
   else
    entityelement(e).darkai.runbuildup=0
   endif
  endif
 endif
 `
 rem Set entity move speed
 if entityelement(e).mover.run=1
  ai set entity speed obj,entityelement(e).eleprof.speed*1.5
 else
  ai set entity speed obj,entityelement(e).eleprof.speed/2.0
 endif
 `
 Rem Calculate Zone Info
 `
 rem V117 - 280410 - find floor for this entity (as climb/decent ramp/stairs between containers)
 if AI GET ENTITY CHANGING CONTAINERS(obj)<>0
  tmvszy#=(object size y(obj)/2)
  tfloorstarty#=entityelement(e).y+20
  tfloory#=AI RAY CAST(entityelement(e).x,tfloorstarty#,entityelement(e).z,entityelement(e).x,tfloorstarty#-30,entityelement(e).z)
  if tfloory#<>-1
   rem floor contours of floor instantly (step size above)
   entityelement(e).y = tfloorstarty#-(tfloory#*30.0)
  else
   rem artificial gravity to decent ramps and staircases
   toldcontainer=(entityelement(e).y+5)/100
   entityelement(e).y = entityelement(e).y - 8
   rem if fall creates a container transition, do it
   tnewcontainer=(entityelement(e).y+5)/100
   if tnewcontainer<>toldcontainer
    rem entity has dropped into new container
    if tnewcontainer<0 then tnewcontainer=0
    if tnewcontainer>19 then tnewcontainer=19
    AI Set Entity Container obj,tnewcontainer
   endif
  endif
  AI Set Entity Y Position obj,entityelement(e).y
 endif
 `
 rem update col map
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   if viscolmap(tx,ty,tz)=0 then viscolmap(tx,ty,tz)=e
   if entityelement(e).curvcmx<>tx or entityelement(e).curvcmy<>ty or entityelement(e).curvcmz<>tz
    otx=entityelement(e).curvcmx
    oty=entityelement(e).curvcmy
    otz=entityelement(e).curvcmz
    if viscolmap(otx,oty,otz)=e then viscolmap(otx,oty,otz)=0
    entityelement(e).curvcmx=tx
    entityelement(e).curvcmy=ty
    entityelement(e).curvcmz=tz
   endif
  endif
 endif
 `
 rem FPGC - 060510 - feedback internal AI state to debug string
 entitydebug$(e)="Internal State:"+AI Get Entity State$(obj)+"  STATE:"+str$(entityelement(e).darkai.state)+"  ACTIONMODE:"+str$(entityelement(e).darkai.actionmode)+"  CAN SEE:"+str$(ttargetvisible)+"["+str$(ttargetvisibleduck)+"]("+str$(int(ttargetx#))+","+str$(int(ttargety#))+","+str$(int(ttargetz#))+") IS MOVING:"+str$(ai get entity is moving(obj))
 `
return

_darkai_debug:
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  rem FPGC - 310310 - added SETUP.INI flag to control whether we see AI outlines
  if gshowaioutlines=1
   for layer=0 to 19
    AI Debug Show Obstacle Bounds layer,6+(layer*100)
    AI Debug Show Waypoints layer,15+(layer*100)
   next layer
   Rem debug view cones
   ai debug show view arcs 550
  endif
 endif
 Ai Debug Show Avoidance Angles 550
return

_ai_find_angle:

tdx#=ex1#-ex2#
tdy#=ey1#-ey2#
tdz#=ez1#-ez2#

 `fadist#=sqrt((ex1#-ex2#)^2 + (ez1#-ez2#)^2)
 fadist#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
 if entityelement(e).eyeoffset=0 then entityelement(e).eyeoffset=80
 entityangle#=atanfull((ey1#+ey1eyeoffset)-(ey2#+entityelement(e).eyeoffset), fadist#)
return

_darkai_stop:
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  targetcontainer=AIFindContainer(entityelement(e).y+25)
  ai entity go to position entityelement(e).obj,entityelement(e).x,entityelement(e).z,targetcontainer
 endif
return

_darkai_stopfollow:
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  if entityelement(e).darkai.team=1
   ai entity separate entityelement(e).obj
   if entityelement(e).darkai.control=1 then ai set entity control entityelement(e).obj,0 : entityelement(e).darkai.control=0
   targetcontainer=AIFindContainer(entityelement(e).y+25)
   ai entity go to position entityelement(e).obj,entityelement(e).x,entityelement(e).z,targetcontainer
   entityelement(e).darkai.follow=0
  endif
 endif
return

_darkai_callteam:
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  arraycount=array count(ischaracter())
  maxdist#=maxdist#^2
  for i=1 to arraycount
   y=ischaracter(i)
   if ai entity exist(entityelement(y).obj)
    if entityelement(y).obj<>entityelement(e).obj and entityelement(y).darkai.team=entityelement(e).darkai.team
     dst#=(entityelement(y).x-entityelement(e).x)^2+(entityelement(y).z-entityelement(e).z)^2
     if dst#<=maxdist#
      if entityelement(y).darkai.called=0 then entityelement(y).darkai.called=entityelement(e).obj : entityelement(y).darkai.calldelay=timer()
     endif
    endif
   endif
  next i
 endif
Return

_darkai_plrcallteam:
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  arraycount=array count(ischaracter())
  maxdist#=maxdist#^2
  x#=Object Position X(physicsplayerborble)
  y#=Object Position Y(physicsplayerborble)
  z#=Object Position Z(physicsplayerborble)
  for i=1 to arraycount
   y=ischaracter(i)
   if ai entity exist(entityelement(y).obj)
    if entityelement(y).darkai.team=1
     dst#=(entityelement(y).x-x#)^2+(entityelement(y).z-z#)^2
     if dst#<=maxdist#
      if entityelement(y).darkai.called=0 then entityelement(y).darkai.called=physicsplayerborble : entityelement(y).darkai.calldelay=timer()
     endif
    endif
   endif
  next i
 endif
Return

_darkai_find_safezone:
 arraycount=array count(aisafezone())
 cloestdist#=999999
 tbesti=0
 if arraycount=0 then return
 for i=1 to arraycount
  distx#=aisafezone(i).x-entityelement(e).x
  disty#=aisafezone(i).y-entityelement(e).y
  distz#=aisafezone(i).z-entityelement(e).z
  szdist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  if aisafezone(i).occupied=0
   if szdist#<cloestdist#
    cloestdist#=szdist#
    tbesti=i
   endif
  endif
 next i
Return

_SafeZone_Update:
 arraycount2=array count(ischaracter())
 arraycount=array count(aisafezone())
 if arraycount=0 or arraycount2=0 then return
 for i=1 to arraycount
  aisafezone(i).occupied=0
 next i
 for x=1 to arraycount2
  for i=1 to arraycount
   distx#=aisafezone(i).x-entityelement(x).x
   disty#=aisafezone(i).y-entityelement(x).y
   distz#=aisafezone(i).z-entityelement(x).z
   szdist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
   if szdist#<=100
    aisafezone(i).occupied=1
   endif
  next i
 next x
Return

Add_Targets:
 `
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  if ai entity exist(entityelement(e).obj)=1
   arraycount=array count(ischaracter())
   teamslot=AIFindTeam(entityelement(e).darkai.team)
   for i=1 to arraycount
    y=ischaracter(i)
    if entityelement(y).obj>0
     if ai entity exist(entityelement(y).obj)
      foundenemy=0
      for x=1 to FactionArrayMax
       if entityelement(y).obj<>entityelement(e).obj and entityelement(y).darkai.team<>entityelement(e).darkai.team and aifaction(teamslot,x).enemy=entityelement(y).darkai.team
        if ai get entity can see(entityelement(e).obj,object position x(entityelement(y).obj),object position y(entityelement(y).obj),object position z(entityelement(y).obj),1)>0
         ai entity add target entityelement(e).obj,entityelement(y).obj
        endif
       endif
       if entityelement(y).darkai.team=aifaction(teamslot,x).enemy then foundenemy=1
      next x
      if foundenemy=0
       ai entity remove target entityelement(e).obj,entityelement(y).obj
       Rem Hockeykid - 300710 - Do not allow the objects in the way (glass etc) to mix up the ai
       if entityelement(e).targetinway>0
        target=entityelement(e).realtarget
       else
        target=entityelement(e).actualtarget
       endif
       if target>1
        c=target-1
        if entityelement(c).obj=entityelement(y).obj then entityelement(e).actualtarget=0 : entityelement(e).realtarget=0 : entityelement(e).targetinway=0
       endif
      endif
      `
      Rem If entityelement(y).actualtarget>0 and the target no longer exist on the list reset flag
      if ai entity exist(entityelement(y).obj)
       tokay=0
       if ai get entity count targets(entityelement(y).obj)=0 then entityelement(y).actualtarget=0
       if entityelement(y).actualtarget>1 and ai get entity count targets(entityelement(y).obj)>0
        tcount=ai get entity count targets(entityelement(y).obj)
        Rem Hockeykid - 300710 - Do not allow the objects in the way (glass etc) to mix up the ai
        if entityelement(y).targetinway>0
         target=entityelement(y).realtarget
        else
         target=entityelement(y).actualtarget
        endif
        for x=1 to tcount
         c=target-1
         if entityelement(c).obj=ai get entity target id(entityelement(y).obj,x) then tokay=1 : exit
        next x
        if tokay=0 then entityelement(y).actualtarget=0 : entityelement(e).realtarget=0 : entityelement(e).targetinway=0
       endif
      endif
      `
     endif
    endif
   next i
   if player(1).health>0 or playerstartstrength=0
    rem FPGC - 150710 - previous code would call 'ai get entity can see' 'FactionArrayMax' times, only needs calling once for (E).OBJ
    tenemytargetflagged=0
    for x=1 to FactionArrayMax
     if aifaction(teamslot,x).enemy=1
      tenemytargetflagged=1
     endif
    next x
    if tenemytargetflagged=1
     rem V118 - 240111 - do not use borble, use camera position (pefect line of sight)
     `if ai get entity can see(entityelement(e).obj,object position x(physicsplayerborble),object position y(physicsplayerborble),object position z(physicsplayerborble),1)>0
     if ai get entity can see(entityelement(e).obj,camera position x(),camera position y(),camera position z(),1)>0
      ai entity add target entityelement(e).obj,physicsplayerborble
     endif
    endif
   endif
  endif
 endif
 `
return

_Character_Array:
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1
   array insert at bottom ischaracter()
   xp=array count(ischaracter())
   ischaracter(xp)=e
  endif
 next e
Return

_target_determinevisibility:

rem used by an entity when looking at their target
rem determine if target exposed to be visible to tmpx#,tmpy#,tmpz#,dist# and (e)
tvisibility=1
tvisibilityifbreak=0 : tvisibilityifbreakdist#=9999.99

rem deduct from 100 percent visible, if drop below zero, enemy cannot see plr
visprobcount=100

rem instant block if other object obstructs it
for tte=1 to entityelementlist
 if tte<>e and entityelement(tte).obj<>ttarget
  Rem don't allow the engine to run and intersect object on a DAI entity or character, this could mess with targeting
  tentid=entityelement(tte).bankindex
  if entityprofile(tentid).ischaracter=0 and entityelement(tte).active=1 and entityelement(tte).dormant=0 and entityelement(tte).collisionactive=1 and ai entity exist(entityelement(tte).obj)=0
   tdistx#=entityelement(e).x-entityelement(tte).x
   tdisty#=entityelement(e).y-entityelement(tte).y
   tdistz#=entityelement(e).z-entityelement(tte).z
   ttdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if ttdist#<=dist# and entityelement(tte).obj>0
    ttdst#=intersect object(entityelement(tte).obj,tmpx#,tmpy#,tmpz#,tmpx2#,tmpy2#,tmpz2#)
    if ttdst#>0
     if entityelement(tte).eleprof.transparency=0 then tvisibility=0
     if entityelement(tte).eleprof.transparency>0
      if ttdst#<tvisibilityifbreakdist#
       tvisibilityifbreak=tte
       tvisibilityifbreakdist#=ttdst#
      endif
     endif
     `if tvisibility=0 then tte=entityelementlist+1
    endif
   endif
  endif
 endif
next tte

return

Function AIUpdateSounds()
 arraycount=array count(aisound())
 for i=1 to arraycount
  if aisound(i).alive=1
   inc totalsounds
   Rem Check Timer and if it is past 1.2 seconds destory the sound flag
   if timer()-aisound(i).time>=300 then aisound(i).alive=0
  endif
 next i
Endfunction

Function AIHeardSound(obje)
 tclosestdist#=99999.0
 output=0
 arraycount=array count(aisound())
 hearing=entityelement(obje).darkai.hearingrange
 teamslot=AIFindTeam(entityelement(obje).darkai.team)
 for i=1 to arraycount
  tokay=1
  for x=1 to FactionArrayMax
   if aisound(i).team=aifaction(teamslot,x).ally then tokay=0 : exit
  next x
  if tokay=1
   if aisound(i).alive=1 and aisound(i).team<>entityelement(obje).darkai.team
rem calculate sound distance
                  tobjx#=entityelement(obje).x
                  tobjy#=entityelement(obje).y
                  tobjz#=entityelement(obje).z

                  tdx#=aisound(i).x-tobjx#
                  tdy#=aisound(i).y-tobjy#
                  tdz#=aisound(i).z-tobjz#
                 dst#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))

    if dst#<=hearing and dst#<tclosestdist#
     output=i : tclosestdist#=dst#
    endif
   endif
  endif
 next i
Endfunction output

Function AIMoveToSound(obj,obje)
 rem FPGC - 300710 - DarkAI only in single player
 if gmultiplayergame=0
  if entityelement(obje).darkai.hearingrange=0 then entityelement(obje).darkai.hearingrange=700
  sound=AIHeardSound(obje)
  if sound>0
   targetcontainer=AIFindContainer(aisound(sound).y+25)
   ai entity go to position obj,aisound(sound).x,aisound(sound).z,targetcontainer
  endif
 endif
Endfunction

Function AIFindTeam(team)
 w=0
 for i=1 to FactionArrayMax
  if aifaction(i,1).team=team then w=i : exit
 next i
Endfunction w

Function AIFindEmptyTeam()
 slot=0
 For x=1 to FactionArrayMax
  if aifaction(x,1).team=0 then slot=x : exit
 next x
Endfunction slot

Function AIParseFactions(string$,teamtype)
 lines=len(string$)
 team$=""
 Rem Find team that will add these to the faction list
 for i=0 to lines
  if mid$(string$,i)=" " then a=i : exit
 next i
 for i=0 to a-1
  team$=team$+mid$(string$,i)
 next i
 team=val(team$)
 teamslot=AIFindTeam(team)
 space=a
 if teamslot=0 then exitfunction
 `
 a$=""
 lastmark=0
 for i=a+1 to lines
  if mid$(string$,i)<>"|"
   a$=a$+mid$(string$,i)
  else
   lastmark=i
   teama=val(a$)
   found=AIFindTeam(teama)
   if found>0 then AIInsertFactions(team,teamslot,teama,teamtype)
   a$=""
  endif
 next i
 `
 a$=""
 if lastmark<>0
  for i=lastmark+1 to lines
   a$=a$+mid$(string$,i)
  next i
 else
  for i=space+1 to lines
   a$=a$+mid$(string$,i)
  next i
 endif
 teama=val(a$)
 found=AIFindTeam(teama)
 if found>0 then AIInsertFactions(team,teamslot,teama,teamtype)
 `
Endfunction

Function AIInsertFactions(team,teamslot,teama,teamtype)
 emptyslot=0
 if teamtype=1
  Rem remove if in another faction group
  for x=1 to FactionArrayMax
   if aifaction(teamslot,x).ally=teama then aifaction(teamslot,x).ally=0 : exit
   if aifaction(teamslot,x).neutral=teama then aifaction(teamslot,x).neutral=0 : exit
  next x

  for x=1 to FactionArrayMax
   if aifaction(teamslot,x).enemy=0 and emptyslot=0 then emptyslot=x
   if aifaction(teamslot,x).enemy=teama then emptyslot=x : exit
  next x
  `
  if emptyslot<>0
   aifaction(teamslot,emptyslot).enemy=teama
   if mutualfactionoff=0
    oppslot=AIFindTeam(aifaction(teamslot,emptyslot).enemy)
    for x=1 to FactionArrayMax
     if aifaction(oppslot,x).ally=teama then aifaction(oppslot,x).ally=0 : exit
     if aifaction(oppslot,x).neutral=teama then aifaction(oppslot,x).neutral=0 : exit
    next x

    for x=1 to FactionArrayMax
     if aifaction(oppslot,x).enemy=0 and emptyslot=0 then emptyslot=x
     if aifaction(oppslot,x).enemy=teama then emptyslot=x : exit
    next x
    if emptyslot<>0 then aifaction(oppslot,emptyslot).enemy=team
   endif
  endif
 endif
 `
 if teamtype=2
  Rem remove if in another faction group
  for x=1 to FactionArrayMax
   if aifaction(teamslot,x).enemy=teama then aifaction(teamslot,x).enemy=0 : exit
   if aifaction(teamslot,x).neutral=teama then aifaction(teamslot,x).neutral=0 : exit
  next x

  for x=1 to FactionArrayMax
   if aifaction(teamslot,x).ally=0 and emptyslot=0 then emptyslot=x
   if aifaction(teamslot,x).ally=teama then emptyslot=x : exit
  next x
  `
  if emptyslot<>0
   aifaction(teamslot,emptyslot).ally=teama
   if mutualfactionoff=0
    oppslot=AIFindTeam(aifaction(teamslot,emptyslot).ally)
    for x=1 to FactionArrayMax
     if aifaction(oppslot,x).enemy=teama then aifaction(oppslot,x).enemy=0 : exit
     if aifaction(oppslot,x).neutral=teama then aifaction(oppslot,x).neutral=0 : exit
    next x

    for x=1 to FactionArrayMax
     if aifaction(oppslot,x).ally=0 and emptyslot=0 then emptyslot=x
     if aifaction(oppslot,x).ally=teama then emptyslot=x : exit
    next x
    if emptyslot<>0 then aifaction(oppslot,emptyslot).ally=team
   endif
  endif
 endif
 `
 if teamtype=3
  Rem remove if in another faction group
  for x=1 to FactionArrayMax
   if aifaction(teamslot,x).enemy=teama then aifaction(teamslot,x).enemy=0 : exit
   if aifaction(teamslot,x).ally=teama then aifaction(teamslot,x).ally=0 : exit
  next x

  for x=1 to FactionArrayMax
   if aifaction(teamslot,x).neutral=0 and emptyslot=0 then emptyslot=x
   if aifaction(teamslot,x).neutral=teama then emptyslot=x : exit
  next x
  `
  if emptyslot<>0
   aifaction(teamslot,emptyslot).neutral=teama
   if mutualfactionoff=0
    oppslot=AIFindTeam(aifaction(teamslot,emptyslot).neutral)
    for x=1 to FactionArrayMax
     if aifaction(oppslot,x).enemy=teama then aifaction(oppslot,x).enemy=0 : exit
     if aifaction(oppslot,x).ally=teama then aifaction(oppslot,x).ally=0 : exit
    next x

    for x=1 to FactionArrayMax
     if aifaction(oppslot,x).neutral=0 and emptyslot=0 then emptyslot=x
     if aifaction(oppslot,x).neutral=teama then emptyslot=x : exit
    next x
    if emptyslot<>0 then aifaction(oppslot,emptyslot).neutral=team
   endif
  endif
 endif
Endfunction

Function AIFindContainer(y#)
 container=(y#)/100
 if container<0 then container=0
 if container>19 then container=19
Endfunction container

rem
rem POST PROCESS SUBROUTINES - Uses Camera One As Post Process Screen Aligned QUAD
rem

_postprocess_init:
 `
 rem full screen shaders
 bloomfilescreen$="effectbank\ps_2_0\post-bloom.fx"
 depthoffieldfilescreen$="effectbank\ps_2_0\post-depthoffield.fx"
 addfiletocollection(bloomfilescreen$)
 addfiletocollection(depthoffieldfilescreen$)
 rem markblosser - also add any additional post effects and media (must be in "effectbank\postprocess" folder)
 addallfilestocollection("effectbank\postprocess")
 load image "effectbank\postprocess\gasmask_normal.dds",65538
 load image "effectbank\postprocess\gasmask_mask.dds",65539
 load image "effectbank\postprocess\refract_normal.dds",65540
 if file exist ("effectbank\postprocess\multi_1.dds")=1 then load image "effectbank\postprocess\multi_1.dds",65541
 if file exist ("effectbank\postprocess\multi_2.dds")=1 then load image "effectbank\postprocess\multi_2.dds",65542
 load image "effectbank\postprocess\filmreel_scratches.dds",65543
 load image "effectbank\postprocess\rain_diffuse.dds",65544
 load image "effectbank\postprocess\rain_normal.dds",65545
 `
 rem if flagged, use post processing (camera one)
 if gpostprocessmode=0 and gpostprocessing<>0 and segobjusedformapeditor=0
  `
  rem kind of post process (gpostprocessing)
  rem 1 - bloom
  rem 2 - depth of field
  tshaderchoice$=bloomfilescreen$
  if gpostprocessing=1 then tshaderchoice$=bloomfilescreen$ : gpostprocessingnotransparency=0 : gdepthcameraid=0
  if gpostprocessing=2 then tshaderchoice$=depthoffieldfilescreen$ : gpostprocessingnotransparency=0 : gdepthcameraid=4

  rem LightRay Addition
  if gpostprocessing=3 then global lgmodraysactive : lgmodraysactive=1 : gdepthcameraid=0
  if gpostprocessing=4 then global lgmodraysactive : lgmodraysactive=2 : gdepthcameraid=0
  if gpostprocessing=5 then global lgmodraysactive : lgmodraysactive=3 : gdepthcameraid=0
  if gpostprocessing=6 then global lgmodraysactive : lgmodraysactive=4 : gdepthcameraid=0
  if gpostprocessing=7 then global lgmodraysactive : lgmodraysactive=5 : gdepthcameraid=0
  `
  if gpostprocessing<=2
   `
   rem FPGC - 200310 - new camera 3 holds post-process screen quad (requires U75+)
   gfinalrendercameraid=3
   if gpostprocessing<=2
    make camera gfinalrendercameraid
    if effect exist(65535)=1 then delete effect 65535
    load effect tshaderchoice$,65535,0
   endif
   set camera view gfinalrendercameraid,0,0,1,1
   set current camera 0
   `
   rem FPGC - 070410 - make a depth camera and assign it to image X
   if gdepthcameraid>0
    if gpostprocessing<=2 then make camera gdepthcameraid
    set camera view gdepthcameraid,0,0,1,1
    color backdrop gdepthcameraid,rgb(255,128,128)
    set current camera 0
   endif
   `
   rem post process mode on
   if gpostprocessing=0 or gpostprocessing=1 or gpostprocessing=2 then gpostprocessmode=1
   `
  endif
  `
 endif
 `
return

_postprocess_free:
 `
 rem free any resources created by post process technique
 if gpostprocessmode=1
  delete effect 65535
  delete object 65536
  if gfinalrendercameraid>0 then delete camera gfinalrendercameraid : set current camera 0 : gfinalrendercameraid=0
  if gdepthcameraid<>0 then delete camera gdepthcameraid : set current camera 0 : gdepthcameraid=0
  gpostprocessingnotransparency=0
  gpostprocessmode=0
 endif
 `
return

_postprocess_apply:
 `
 if gpostprocessmode=1
  `
  rem make sure ALL objects render only to required cameras (now we have more than one camera)
  for o=1 to 65535
   if object exist(o)=1
    if gdepthcameraid>0
     tokay=0
     for fbei=1 to gfastboneeffectshaderidmax
      if gfastboneeffectshaderid(fbei)=objecteffect(o)
       tokay=1
      endif
     next fbei
     if tokay=1
      rem FPGC - 080410 - displacement technology. set this to move an object to the depth camera
      rem NOTE: entities using fastbone need to go here as the shader animates the geometry (to align with real game render)
      rem NOTE: new fields for DECAL and ENTITYPROFILE, and provide both texture and shaders to depth camera render objects!
      set object mask o,%111+(1<<gdepthcameraid),0,0,1
     else
      set object mask o,%111+(1<<gdepthcameraid),0,0,0
     endif
    else
     set object mask o,%111,0,0,0
    endif
   endif
  next o
  `
  rem FPGC - 070710 - some objects must be excluded from depth render
  for o=hudbankoffset to hudbankoffset+31
   if object exist(o)=1
    set object mask o,%111,0,0,0
   endif
  next o
  `
  rem create and prepare resources for full screen final render
  if object exist(65536)=1
   show object 65536
  else
   make object plain 65536,2,2 : set object effect 65536,65535
   set object mask 65536,(1 << gfinalrendercameraid)
  endif
  set camera to image 0,65536,screen width(),screen height(),2
  texture object 65536,0,65536
  if gdepthcameraid>0
   set camera to image gdepthcameraid,65537,screen width(),screen height(),2
   texture object 65536,1,65537
  endif
  if gfinalrendercameraid>0
   set camera view gfinalrendercameraid,0,0,screen width(),screen height()
  endif
  `
 endif
 `
return

_postprocess_renderdepthcamera:
 `
 rem FPGC - 070410 - set the scene to remove all RED by using only ambient lighting add RED FOG to simulate distance
 if gdepthcameraid>0
  `
  rem set lighting for depth render
  set current camera gdepthcameraid
  position camera gdepthcameraid,camera position x(0),camera position y(0),camera position z(0)
  rotate camera gdepthcameraid,camera angle x(0),camera angle y(0),camera angle z(0)
  color backdrop gdepthcameraid,rgb(255,0,0),rgb(0,128,128)
  for l=0 to 7
   if light exist(l)=1 then hide light l
  next l
  fog on
  fog color 255,128,128
  fog distance 0,500
  `
  rem entities that use fastbone need some constants overriding (for FOG)
  for fbei=1 to gfastboneeffectshaderidmax
   tfsbeffectid=gfastboneeffectshaderid(fbei)
   r=make vector4(1)
   set vector4 1,0,0,0,0
   set effect constant vector tfsbeffectid,"AmbiColor",1
   set vector4 1,0,0,0,0
   set effect constant vector tfsbeffectid,"SurfColor",1
   set vector4 1,1,0.0,0.0,1.0/500.0
   set effect constant vector tfsbeffectid,"FogColor",1
   set vector4 1,0.0,0.5,0.5,1.0
   set effect constant vector tfsbeffectid,"FillerColor",1
   r=delete vector4(1)
  next fbei
  `
  rem render the depth scene
  sync mask (1 << gdepthcameraid)
  fastsync
  sync mask %11111111 - (1 << gdepthcameraid)
  if gshowdebugtextingamestate=1
   set sprite 1,0,1 : sprite 1,0,0,65537 : size sprite 1,160,120
  endif
  `
  rem entities that use fastbone need some constants overriding (for FOG)
  for fbei=1 to gfastboneeffectshaderidmax
   tfsbeffectid=gfastboneeffectshaderid(fbei)
   r=make vector4(1)
   set vector4 1,1,1,1,1
   set effect constant vector tfsbeffectid,"SurfColor",1
   set vector4 1,0,0,0,0.000001
   set effect constant vector tfsbeffectid,"FogColor",1
   set vector4 1,0,0,0,0
   set effect constant vector tfsbeffectid,"FillerColor",1
   r=delete vector4(1)
  next fbei
  `
  rem restore general lighting
  color backdrop gdepthcameraid,rgb(0,64,0),0
  set current camera 0
  for l=0 to 7
   if light exist(l)=1 then show light l
  next l
  fog off
  fog color 0,0,0
  `
 endif
 `
return

_postprocess_off:
 `
 rem FPGC
 if gpostprocessmode=1
  `
  if object exist(65536)=1 then hide object 65536
  set camera view 0,0,0,screen width(),screen height()
  if gfinalrendercameraid>0
   set camera view gfinalrendercameraid,0,0,1,1
  endif
  `
 endif
 `
return

Rem Water subroutine(s)
_water_control:
 if waterbump#>0
   waterdecalripple=waterdecalripplemaster
 else
  waterdecalripple=0
 endif
 Rem Handle raising water and lowering water - Scene Commander, rearranged to reduce test.
 tupdatewater=0
 if gtestgamemodefromeditor=1
 if keystate(201) then inc waterheight# : watertimer=5 : ambiencetimer=0
 if keystate(209) then dec waterheight# : watertimer=5 : ambiencetimer=0
 endif
 if waterheight#<1 then waterheight#=0
 if waterheight#<>oldwaterheight# then tupdatewater=1 : oldwaterheight#=waterheight# : position object waterobj,0,waterheight#,0
 `
 if watertimer>0 and gtestgamemodefromeditor=1
  `
  if grawtextsize<>12 then set text size 12 : grawtextsizelast=-1
  if grawtextfont$<>"Verdana" then set text font "Verdana" : grawtextfontlast$="Verdana"
  `
  water$="Water Height: "+str$(waterheight#)`+" Red: "+str$(hudambiencered)+" Blue: "+str$(hudambienceblue)+" Green: "+str$(hudambiencegreen)
  center text (gdisplaywidth/100.0)*50,1,water$
  `
  time$="Press enter to save water height: "+str$(watertimer)
  center text (gdisplaywidth/100.0)*50,Text Height(water$)+4,time$
  if keystate(28)=1
   rem FPGC - 130710 - if in test mode, save ambient setting from config file
   if file exist("editors\gridedit\testwater.txt")=1 then delete file "editors\gridedit\testwater.txt"
   open to write 1,"editors\gridedit\testwater.txt"
   write string 1,str$(waterheight#)
   close file 1
   watertimer=0
  endif
  `
  if waterwatch=0 then waterwatch=timer()
  if timer()-waterwatch>=1000 then dec watertimer : waterwatch=0
 endif
 if watertimer<=0 then watertimer=0
 `
 Rem Check is swimming along surface
 tnearsurfaceofwater=abs(camera position y()-waterheight#)
 if camera position y()>waterheight#
  if playerunderwater=1
   Rem Leave water sound
   if playersound(1,20)>0
   rem scene commander change, leave sound for gulp sound. I prefered it. WAS 17
    playinternal3dsound(playersound(1,20),camera position x(),camera position y(),camera position z())
   endif
   if waterunderwatersoundid>0 then stop sound waterunderwatersoundid
   triggersplash=2
   `
   rem V118 - 060211 - change ALL sounds back when return from underwater
   if soundfredrop=1
    for s=1 to 60000
     if sound exist(s)=1
      rem 280311- TerryFix
      if sound speed(s)>10000
       set sound speed s,sound speed(s)+10000
      endif
     endif
    next s
    soundfredrop=0
    soundfrequencymodifier=0
   endif
   `
  endif
  playerunderwater=0
 else
  if playerunderwater=0
   Rem Enter water sound
   if playersound(1,18)>0
    playinternal3dsound(playersound(1,18),camera position x(),camera position y(),camera position z())
   endif
   if waterunderwatersoundid>0 then loop sound waterunderwatersoundid
   triggersplash=1
   `
   rem V118 - 060211 - change ALL sounds when underwater
   if soundfredrop=0
    for s=1 to 60000
     if sound exist(s)=1
      rem 280311- TerryFix
      if sound speed(s)>10000
       set sound speed s,sound speed(s)-10000
      endif
     endif
    next s
    soundfredrop=1
    soundfrequencymodifier=-10000
   endif
   `
  endif
  playerunderwater=1
 endif
 `
 rem trigger some ripples using the decal system
 if waterdecalripple>0
  ripplex=camera position x()+rnd(4)-2
  ripplez=camera position z()+rnd(4)-2
  if (plrkeyC)=1
   rem crouch causes ripples in water
   theightofplrcamforripple#=22.0
  else
   rem waling in water causes ripples
   theightofplrcamforripple#=57.0
  endif
  if camera position y()<waterheight#+theightofplrcamforripple# and camera position y()>waterheight#
   if abs(lastripplex-ripplex)>5 or abs(lastripplez-ripplez)>5
    lastripplex=ripplex : lastripplez=ripplez
    ripplequantity=70
   else
    ripplequantity=5000
   endif
   if timer()-rippleplayermakes>ripplequantity
    rippleplayermakes=timer()
    decalid=waterdecalripple
    decalorient=0
    decalx=ripplex
    decaly=waterheight#+1.0
    decalz=ripplez
    decalorient=2
    decalscalemodx=50 : decalscalemody=decalscalemodx
    decalalpha=25
    originatore=0 : gosub _decalelement_create
   endif
  endif
 endif
 `
 rem water splash
 if splashdecalid>0 and triggersplash<>0
  if timer()-splashsplash>500
   splashsplash=timer()
   decalid=splashdecalid
   decalorient=0
   if triggersplash=2
    decalx=newxvalue(camera position x(),camera angle y(),40.0)
    decalz=newzvalue(camera position z(),camera angle y(),40.0)
    decaly=waterheight#-50.0
    decalscalemodx=50
   else
    decalx=camera position x()
    decalz=camera position z()
    decaly=waterheight#
    decalscalemodx=100
   endif
   decalscalemody=decalscalemodx
   decalalpha=100
   originatore=0 : gosub _decalelement_create
  endif
  triggersplash=0
 endif
 `
return

function getintervar(e,var$)
 select var$
  case "$PH"
   temp=player(1).health
  endcase
  case "$PL"
   temp=player(1).lives
  endcase
  case "$RCA"
   temp=weaponammo(weaponammoindex+ammooffset)
  endcase
  case "$CA"

    temp=weaponammo(weaponammoindex+ammooffset)

  endcase
   case "$CLA"

    temp=weaponclipammo(weaponammoindex+ammooffset)

  endcase
  case "$EH"
   temp=entityelement(e).health
  endcase
  case "$EA"
   temp=entityelement(e).currentammo
  endcase
  case "$EPX"
   temp=entityelement(e).x
  endcase
  case "$EPY"
   temp=entityelement(e).y
  endcase
  case "$EPZ"
   temp=entityelement(e).z
  endcase
  case "$EAX"
   temp=entityelement(e).rx
  endcase
  case "$EAY"
   temp=entityelement(e).ry
  endcase
  case "$EAZ"
   temp=entityelement(e).rz
  endcase
  Rem Scene Commander
  case "$ARM"
   temp=armour
  endcase
  case "$AIR"
   temp=airleft
  endcase
  case "$FPS"
   temp=screen fps()
  endcase
  case "$WAT"
   temp=waterheight#
  endcase
  case "$MAX"
   temp=maxslots
  endcase

   case "$DIS"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   temp=plrdistance#

   endcase

   case "$DIF"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   temp=(plrdistance#/100)*8.33

   endcase

   case "$DIM"
   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(e).x-tcamx#
   tdy#=entityelement(e).y-tcamy#
   tdz#=entityelement(e).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    temp=(plrdistance#/100)*2.54

   endcase

  rem Hockeykid
  case "$CAX"
   `Grab camera to check
   temp=camera angle x(0)
  endcase
  case "$CAY"
   `Grab camera to check
   temp=camera angle y(0)
  endcase
  case "$CAZ"
   `Grab camera to check
   temp=camera angle z(0)
  endcase
  case "$CPX"
   `Grab camera to check
   temp=camera position x(0)
  endcase
  case "$CPY"
   `Grab camera to check
   temp=camera position y(0)
  endcase
  case "$CPZ"
   `Grab camera to check
   temp=camera position z(0)
  endcase
 endselect
endfunction temp

function setintervar(e,var$,alter#)
 select var$
  case "$PH"
   player(1).health=alter#
  endcase
  case "$PL"
   player(1).lives=alter#
  endcase
  case "$RCA"
   weaponammo(weaponammoindex+ammooffset)=int(alter#)
  endcase
  case "$CA"

    weaponammo(weaponammoindex+ammooffset)=int(alter#)

  endcase
   case "$CLA"

    weaponclipammo(weaponammoindex+ammooffset)=int(alter#)

  endcase
  case "$EH"
   entityelement(e).health=alter#
  endcase
  case "$EA"
   entityelement(e).currentammo=alter#
  endcase
   case "$EPX"
   entityelement(e).x=alter#
   updateposition=1
  endcase
  case "$EPY"
   entityelement(e).y=alter#
   updateposition=1
  endcase
  case "$EPZ"
   entityelement(e).z=alter#
   updateposition=1
  endcase
  case "$EAX"
   entityelement(e).rx=alter#
   updaterotation=1
  endcase
  case "$EAY"
   entityelement(e).ry=alter#
   updaterotation=1
  endcase
  case "$EAZ"
   entityelement(e).rz=alter#
   updaterotation=1
  endcase
  Rem Scene Commander
  case "$ARM"
   armour=alter#
  endcase
  case "$AIR"
   airleft=alter#
  endcase
  case "$WAT"
   waterheight#=alter#
  endcase
  case "$MAX"
   maxslots=alter#
  endcase

  rem Hockeykid
  case "$CAX"
   `Grab camera to check
   xrotate camera 0,alter#
  endcase
  case "$CAY"
   `Grab camera to check
   yrotate camera 0,alter#
  endcase
  case "$CAZ"
   `Grab camera to check
   zrotate camera 0,alter#
  endcase
  case "$CPX"
   camerapositionx=alter#
  endcase
  case "$CPY"
   camerapositiony=alter#
  endcase
  case "$CPZ"
   camerapositionz=alter#
  endcase
 endselect

if updateposition=1 or updaterotation=1
  rem turn off collision
  if entityelement(e).collisionactive=1 and entityelement(e).eleprof.physics=1
   togglecol=1
   createdestroymode=1 : createdestroye=e
   gosub createdestroy_physics_e
  endif
 endif
 if updateposition=1 then position object entityelement(e).obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
 if updaterotation=1 then rotate object entityelement(e).obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
 if updateposition=1 or updaterotation=1
  if togglecol=1
   createdestroymode=2 : createdestroye=e
   gosub createdestroy_physics_e
  endif
 endif
endfunction

function MakeWater()
 `
 rem TestGameFromEditor Mode Water Height
 if gtestgamemodefromeditor<>0
  if file exist("editors\gridedit\testwater.txt")=1
   open to read 1,"editors\gridedit\testwater.txt"
   read string 1,a$ : waterheight#=val(a$)
   close file 1
  endif
 endif
 `
 Img=19876
 Rem Cameras
 Sw#=screen width():Sh#=screen height()
 for c=1 to 2
  if camera exist(c)=0 then make camera c : rem (Sean: I added the camera exist check as it crashed if you re-entered game.)
  set camera range c,2.0,realrange#
  set camera aspect c,realaspect#
  backdrop off c`n c : color backdrop c,rgb(0,255,0)
  if c=1 then set camera to image c,Img,Sw#,Sh#
  if c=2 then set camera to image c,Img+1,Sw#,Sh#
  set camera fov c,realfov#
 next c

 Rem Make Water plain
 path$="effectbank\common\"
 if file exist(path$+"water_N.dds") then load image path$+"water_N.dds",Img+2 : addfiletocollection(path$+"water_N.dds")
 if file exist(path$+"Fresnel.bmp") then load image path$+"Fresnel.bmp",Img+3 : addfiletocollection(path$+"Fresnel.bmp")
 if file exist(path$+"WaterMask.bmp") then load image path$+"WaterMask.bmp",Img+4 : addfiletocollection(path$+"WaterMask.bmp")
 `
 make object plain waterobj,80*100,80*100
 for i=0 to 4
  texture object waterobj,i,Img+i
 next i
 xrotate object waterobj,270
 if file exist(path$+"Water.fx") then load effect path$+"Water.fx",waterfx,0,1 : set object effect waterobj,waterfx : addfiletocollection(path$+"Water.fx")
 set object transparency waterobj,1
 hide object waterobj
 set object collision off waterobj
endfunction

function UpDateWater()
 `
 rem UpDate Water plain position
 set current camera 0
 position object waterobj,0,waterheight#,0
 hide object waterobj
 `
 rem LightRay Addition
 if lgmodraysactive=2 then hide object 52
 if lgmodraysactive=1 then hide object 99000
 if lgmodraysactive=1 then hide object 99001
 `
 rem V118 - 300111 - pass fog color to water plane shader
 if WaterFx>0
  r=make vector4(1)
  set vector4 1,(waterfogred/255.0),(waterfoggreen/255.0),(waterfogblue/255.0),1.0/waterfogfar
  set effect constant vector WaterFx,"FogColor",1
  r=delete vector4(1)
 endif
 `
 rem V118 - 300111 - Prepare effects to switch fog ON
 r=make vector4(1)
 for teffectid=effectbankoffset to effectbankoffset+effectbankmax
  if teffectid<>0
   if effect exist(teffectid)=1
    set vector4 1,(waterfogred/255.0),(waterfoggreen/255.0),(waterfogblue/255.0),1.0/waterfogfar
    set effect constant vector teffectid,"FogColor",1
   endif
  endif
 next teffectid
 r=delete vector4(1)
 `
 rem Upade Refract and Reflect cameras

 set effect technique WaterFx,"Refract"
 UpDateRefraction()
 if camera position y(0)>waterheight#
  set effect technique WaterFx,"ReflectRefract"
  if hudfogon=0
   rem SHADER fog off - Restore effects to switch fog OFF
   r=make vector4(1)
   for teffectid=effectbankoffset to effectbankoffset+effectbankmax
    if teffectid<>0
     if effect exist(teffectid)=1
      set vector4 1,0,0,0,0.00000001
      set effect constant vector teffectid,"FogColor",1
     endif
    endif
   next teffectid
   r=delete vector4(1)
  endif
   rem Scene Commander water performance
  if waterflec<>0

  if camera position y(playercam)<(waterheight#+waterflec)

  UpDateReflection()
 endif
  endif
  `rem Scene Commander end
  if hudfogon=0
   rem FF fog off - maybe this should be before UpDateReflection?
   fog off
  endif
  waterfogon=0
 else
  waterfogon=1
 endif
 show object waterobj
 `
 rem LightRay Addition
 if lgmodraysactive=2 then show object 52
 if lgmodraysactive=1 then show object 99000
 if lgmodraysactive=1 then show object 99001
 set current camera 0
 `
endfunction

function UpDateRefraction()
 Img=19876
 `debug - see reflection and refraction cameras
 `if 1
 ` if scancode()=2 then paste image img+0,0,0
 ` if scancode()=3 then paste image img+1,0,0
 `endif
 set camera fov 0,realfov#
 set camera aspect 0,realaspect#
 set camera range 0,2.0,realrange#
 set camera fov 1,realfov#
 set camera aspect 1,realaspect#
 set camera range 1,2.0,realrange#
 position camera 1,camera position x(0),camera position y(0),camera position z(0)
 rotate camera 1,camera angle x(0),camera angle y(0),camera angle z(0)
 `backdrop off 1 : rem backdrop on 1 : color backdrop 1,rgb(255,100,0)
 if camera position y(0)>waterheight#
  set camera clip 1,1,0,waterheight#+5,0,0,-1,0
  waterfogon=2
 endif
 if camera position y(0)<waterheight#
  set camera clip 1,1,0,waterheight#-5,0,0,1,0
  waterfogon=1
 endif
 set camera clip 2,0,0,0,0,0,0,0
 sync mask (1 << 1)
 fastsync
 sync mask %11111111 - (1 << 1) - (1 << 2)
endfunction

function UpDateReflection()
 set camera fov 2,realfov#
 set camera aspect 2,realaspect#
 set camera range 2,2.0,realrange#
 position camera 2,camera position x(0),waterheight#-(camera position y(0)-waterheight#),camera position z(0)
 rotate camera 2,-camera angle x(0),camera angle y(0),camera angle z(0)
 backdrop off 2 : rem backdrop on 2 : color backdrop 2,rgb(100,255,0)
 set camera clip 1,0,0,0,0,0,0,0
 set camera clip 2,1,0,waterheight#-5,0,0,1,0
 sync mask (1 << 2)
 fastsync
 sync mask %11111111 - (1 << 1) - (1 << 2)
endfunction

function makecompass()

if sprite exist(compassobject)=1
   delete sprite compassobject
endif
if sprite exist(needleobject)=1
   delete sprite needleobject
endif
if image exist(compassobject)=1
   delete image compassobject
endif
if image exist(needleobject)=1
   delete image needleobject
endif
if image exist(compassobject) = 0
   set image colorkey 0,0,0

   load image "databank\compass.png",compassobject

endif
if image exist(needleobject) = 0
   set image colorkey 0,0,0
   load image "databank\needle.png",needleobject

endif
if sprite exist(compassobject)=0
   sprite compassobject,-10000,-10000,compassobject
   offset sprite compassobject,sprite width(compassobject)/2,sprite height(compassobject)/2
   set sprite compassobject,1,1

   hide sprite compassobject
endif
if sprite exist(needleobject)=0
   sprite needleobject,-10000,-10000,needleobject
   offset sprite needleobject,sprite width(needleobject)/2,sprite height(needleobject)/2
   set sprite needleobject,1,1

   hide sprite needleobject
endif

endfunction

function makeradar()

for f=blipstart to blipstart+20
if sprite exist(f)=1
   delete sprite f
   if image exist(f)
   delete image f
   endif
endif
next f

   if sprite exist(radarobject)=1
   delete sprite radarobject
   if image exist(radarobject)=1
   delete image radarobject
   endif
   endif


for f=blipstart to blipstart+20
a$="databank\blip"+str$(f-radarobject)+".png"
if file exist(a$)
load image a$,f
sprite f,-100000,-100000,f
offset sprite f,sprite width(f)/2,sprite height(f)/2
set sprite f,0,1
set sprite priority f,1
hide sprite f

endif
next f

if file exist("databank\radarback.png")
load image "databank\radarback.png",radarobject
sprite radarobject,-100000,-100000,radarobject
offset sprite radarobject,sprite width(radarobject)/2,sprite height(radarobject)/2
set sprite radarobject,0,1
hide sprite radarobject

endif
endfunction
rem GUI-X9 (knxrb) >>>
_gui_init:
    if MenuInit = 0
        MenuInit = 1
        gosub _gui_types
    endif
return

_gui_types:
    global guiUsed as integer = 0
    global mMouseState as integer = 0
    global mMouseUp as integer = 0
    global MouseDownHud$ as string = ""
    global MouseUpHud$ as string = ""
    global MouseOverHud$ as string = ""
    global RImageOffset as integer = 15000
    global totImages as integer = 0
    global tHuds as integer = 0
    global tCheckbox as integer = 0
    global tChoice as integer = 0
    global tSlider as integer = 0
    global tVar as integer = 0
    global tSVar as integer = 0
    global tTimer as integer = 0
    global MouseSprite as integer = -1
    global maxparse as integer = 8
    global parsetotal as integer = 0
    global GUILoad as integer = 0
    global LoadHudX as float = 0.0
    global LoadHudY as float = 0.0
    global GUISave as integer = 0
    global SaveHudX as float = 0.0
    global SaveHudY as float = 0.0
    global initLoadSave as integer = 0
    global GUIDC as integer = 1
    global guiIA as integer = 1
    global guiloaderhud as integer = -1
    global guieyehud as integer = -1
    global guifaderhud as integer = -1
    global guifaderalpha as integer = 0
    global guieyetimer as integer = 0
    global guihurttime as integer = 100
    global guifaderspeed as integer = 4
    global guiloadprogress as float = 100.0

    type guihudtype
        Name As String
        Visible As Boolean
        NormImageNo As Integer
        OverImageNo As Integer
        Hovered As Boolean
        Left As Float
        Top As Float
        Width As Float
        Height As Float
        AL As Float
        AT As Float
        AW As Float
        AH As Float
        dR As Integer
        dG As Integer
        dB As Integer
        iA As Integer
        IsButton As Integer
        IsNumeric As Integer
        StrNumeric As String
    endtype
    dim guihud(299) as guihudtype

    type guicheckboxtype
        Name As String
        Visible As Boolean
        NormImageNo As Integer
        CheckImageNo As Integer
        CheckState As Boolean
        Left As Float
        Top As Float
        Width As Float
        Height As Float
        AL As Float
        AT As Float
        AW As Float
        AH As Float
        dR As Integer
        dG As Integer
        dB As Integer
        iA As Integer
    endtype
    dim guicheckbox(299) as guicheckboxtype

    type guichoicetype
        Name As String
        Visible As Boolean
        State0 As String
        State1 As String
        State2 As String
        State3 As String
        State4 As String
        State5 As String
        State6 As String
        State7 As String
        State8 As String
        State9 As String
        TotalStates As Integer
        SelectedState As String
        SelectedStateNum As Integer
        StateWidth As Float
        BackImageNo As Integer
        FillImageNo As Integer
        SliderImageNo As Integer
        Left As Float
        Top As Float
        Width As Float
        Height As Float
        AL As Float
        AT As Float
        AW As Float
        AH As Float
        SliderLeft As Float
        SliderTop As Float
        SliderWidth As Float
        SliderHeight As Float
        SL As Float
        ST As Float
        SW As Float
        SH As Float
        dR As Integer
        dG As Integer
        dB As Integer
        iA As Integer
    endtype
    dim guichoice(299) as guichoicetype

    type guislidertype
        Name As String
        Visible As Boolean
        BackImageNo As Integer
        FillImageNo As Integer
        SliderImageNo As Integer
        BVal As Float
        SVal As Integer
        MaxValue As Integer
        Left As Float
        Top As Float
        Width As Float
        Height As Float
        AL As Float
        AT As Float
        AW As Float
        AH As Float
        SliderLeft As Float
        SliderTop As Float
        SliderWidth As Float
        SliderHeight As Float
        SL As Float
        ST As Float
        SW As Float
        SH As Float
        dR As Integer
        dG As Integer
        dB As Integer
        iA As Integer
    endtype
    dim guislider(299) as guislidertype

    type guisetupvartype
        Name As String
        Value As String
        SetupLine As String
        Saved As Boolean
    endtype
    dim guisvar(299) as guisetupvartype

    type guitimertype
        Name As String
        Time As Integer
        RunTime As Integer
        Started As Boolean
    endtype
    dim guitimer(299) as guitimertype

    type guiimagetype
        Name As String
        ImageNo As Integer
        Width As Float
        Height As Float
        Path As String
        LFIB As Integer
    endtype
    dim guiimage(999) as guiimagetype

    dim guival(maxparse) as string
return

_gui_run:
 if guiIA=1
    MouseOverHud$ = ""
    if mMouseUp = 2 then mMouseUp = 0
    mMouseState = mouseclick()
    if mMouseState = 1 and mMouseUp = 0
        mMouseUp = 1
        MouseUpHud$ = ""
    endif
    if mMouseState = 0 and mMouseUp = 1
        mMouseUp = 2
        MouseDownHud$ = ""
    endif
    for cH = 0 to tHuds-1
        if guihud(cH).Visible = 1
            if guihud(cH).IsButton = 1 and guihud(cH).IsNumeric = 0
                if inputmousex() > guihud(cH).AL-(guihud(cH).AW/2) and inputmousex() < guihud(cH).AL+(guihud(cH).AW/2) and inputmousey() > guihud(cH).AT-(guihud(cH).AH/2) and inputmousey() < guihud(cH).AT+(guihud(cH).AH/2)
                    guihud(cH).Hovered = 1
                    MouseOverHud$ = guihud(cH).Name
                    if mMouseUp = 1 then MouseDownHud$ = guihud(cH).Name
                    if mMouseUp = 2 then MouseUpHud$ = guihud(cH).Name
                else
                    guihud(cH).Hovered = 0
                endif
                if guihud(cH).Hovered = 0
                    if guihud(cH).NormImageNo > 0
                        if sprite exist(guihud(cH).NormImageNo)
                            set sprite alpha guihud(cH).NormImageNo,guihud(cH).iA
                            set sprite diffuse guihud(cH).NormImageNo,guihud(cH).dR,guihud(cH).dG,guihud(cH).dB
                            size sprite guihud(cH).NormImageNo,guihud(cH).AW,guihud(cH).AH
                            paste sprite guihud(cH).NormImageNo,guihud(cH).AL-(guihud(cH).AW/2),guihud(cH).AT-(guihud(cH).AH/2)
                        endif
                    endif
                else
                    if guihud(cH).OverImageNo > 0
                        if sprite exist(guihud(cH).OverImageNo)
                            set sprite alpha guihud(cH).OverImageNo,guihud(cH).iA
                            set sprite diffuse guihud(cH).OverImageNo,guihud(cH).dR,guihud(cH).dG,guihud(cH).dB
                            size sprite guihud(cH).OverImageNo,guihud(cH).AW,guihud(cH).AH
                            paste sprite guihud(cH).OverImageNo,guihud(cH).AL-(guihud(cH).AW/2),guihud(cH).AT-(guihud(cH).AH/2)
                        endif
                    endif
                endif
            endif
            if guihud(cH).IsButton = 0 and guihud(cH).IsNumeric = 0
                if guihud(cH).NormImageNo > 0
                    if sprite exist(guihud(cH).NormImageNo)
                        set sprite alpha guihud(cH).NormImageNo,guihud(cH).iA
                        set sprite diffuse guihud(cH).NormImageNo,guihud(cH).dR,guihud(cH).dG,guihud(cH).dB
                        size sprite guihud(cH).NormImageNo,guihud(cH).AW,guihud(cH).AH
                        paste sprite guihud(cH).NormImageNo,guihud(cH).AL-(guihud(cH).AW/2),guihud(cH).AT-(guihud(cH).AH/2)
                    endif
                endif
            endif
            if guihud(cH).IsNumeric = 1
                for tP=1 to len(guihud(cH).StrNumeric)
                    tPNX=-1
                    if mid$(guihud(cH).StrNumeric,tP)="." then tPNX=10
                    if mid$(guihud(cH).StrNumeric,tP)="\" then tPNX=11
                    if tPNX=-1 then tPNX=asc(mid$(guihud(cH).StrNumeric,tP))-asc("0")
                    if tPNX<>-1
                        tPNY=tPNX/4 : tPNX=tPNX-(tPNY*4) : tPX#=(1.0/guihud(cH).AW)*(guihud(cH).AW/4) : tPY#=(1.0/guihud(cH).AH)*(guihud(cH).AH/4)
                        if guihud(cH).NormImageNo>0
                            set sprite texture coord guihud(cH).NormImageNo,0,(tPX#*tPNX),(tPY#*tPNY)
                            set sprite texture coord guihud(cH).NormImageNo,1,(tPX#*tPNX)+tPX#,(tPY#*tPNY)
                            set sprite texture coord guihud(cH).NormImageNo,2,(tPX#*tPNX),(tPY#*tPNY)+tPY#
                            set sprite texture coord guihud(cH).NormImageNo,3,(tPX#*tPNX)+tPX#,(tPY#*tPNY)+tPY#
                            size sprite guihud(cH).NormImageNo,guihud(cH).AW/4,guihud(cH).AH/4
                            paste sprite guihud(cH).NormImageNo,(guihud(cH).AL-((guihud(cH).AW/4)/2))+((tP-1)*((guihud(cH).AW/4))-2),guihud(cH).AT-((guihud(cH).AW/4)/2)
                        endif
                    endif
                next tP
            endif
        endif
    next cH
    for cC = 0 to tCheckbox-1
        if guicheckbox(cC).Visible = 1
            if guicheckbox(cC).CheckState = 0
                if guicheckbox(cC).NormImageNo > 0
                    if sprite exist(guicheckbox(cC).NormImageNo)
                        set sprite alpha guicheckbox(cC).NormImageNo,guicheckbox(cC).iA
                        set sprite diffuse guicheckbox(cC).NormImageNo,guicheckbox(cC).dR,guicheckbox(cC).dG,guicheckbox(cC).dB
                        size sprite guicheckbox(cC).NormImageNo,guicheckbox(cC).AW,guicheckbox(cC).AH
                        paste sprite guicheckbox(cC).NormImageNo,guicheckbox(cC).AL-(guicheckbox(cC).AW/2),guicheckbox(cC).AT-(guicheckbox(cC).AH/2)
                    endif
                endif
            else
                if guicheckbox(cC).CheckImageNo > 0
                    if sprite exist(guicheckbox(cC).CheckImageNo)
                        set sprite alpha guicheckbox(cC).CheckImageNo,guicheckbox(cC).iA
                        set sprite diffuse guicheckbox(cC).CheckImageNo,guicheckbox(cC).dR,guicheckbox(cC).dG,guicheckbox(cC).dB
                        size sprite guicheckbox(cC).CheckImageNo,guicheckbox(cC).AW,guicheckbox(cC).AH
                        paste sprite guicheckbox(cC).CheckImageNo,guicheckbox(cC).AL-(guicheckbox(cC).AW/2),guicheckbox(cC).AT-(guicheckbox(cC).AH/2)
                    endif
                endif
            endif
            if mMouseUp = 2
               if inputmousex() > guicheckbox(cC).AL-(guicheckbox(cC).AW/2) and inputmousex() < guicheckbox(cC).AL+(guicheckbox(cC).AW/2) and inputmousey() > guicheckbox(cC).AT-(guicheckbox(cC).AH/2) and inputmousey() < guicheckbox(cC).AT+(guicheckbox(cC).AH/2)
                   if guicheckbox(cC).CheckState = 1
                        guicheckbox(cC).CheckState = 0
                   else
                        guicheckbox(cC).CheckState = 1
                   endif
               endif
           endif
        endif
    next cC
    for cS = 0 to tSlider-1
        if guislider(cS).Visible = 1
            box (guislider(cS).AL - guislider(cS).AW / 2),(guislider(cS).AT - guislider(cS).AH / 2),(guislider(cS).AL + guislider(cS).AW / 2),(guislider(cS).AT + guislider(cS).AH / 2)
            if guislider(cS).BackImageNo > 0
                if sprite exist(guislider(cS).BackImageNo)
                    set sprite alpha guislider(cS).BackImageNo,guislider(cS).iA
                    set sprite diffuse guislider(cS).BackImageNo,guislider(cS).dR,guislider(cS).dG,guislider(cS).dB
                    size sprite guislider(cS).BackImageNo,guislider(cS).AW,guislider(cS).AH
                    paste sprite guislider(cS).BackImageNo,guislider(cS).AL-(guislider(cS).AW/2),guislider(cS).AT-(guislider(cS).AH/2)
                endif
            endif
            if guislider(cS).FillImageNo > 0
                if sprite exist(guislider(cS).FillImageNo)
                    set sprite alpha guislider(cS).FillImageNo,guislider(cS).iA
                    set sprite diffuse guislider(cS).FillImageNo,guislider(cS).dR,guislider(cS).dG,guislider(cS).dB
                    sX = (guislider(cS).AL - guislider(cS).AW / 2) - 2
                    sDiff = (guislider(cS).SL - (guislider(cS).AL - (guislider(cS).AW / 2)))
                    iW = image width(guislider(cS).FillImageNo)
                    iH = image height(guislider(cS).FillImageNo)
                    for cX = sX to sX + sDiff step iW
                        paste sprite guislider(cS).FillImageNo,cX+2,guislider(cS).ST-(iH/2)
                    next
                endif
            endif
            if guislider(cS).SliderImageNo > 0
                if sprite exist(guislider(cS).SliderImageNo)
                    set sprite alpha guislider(cS).SliderImageNo,guislider(cS).iA
                    set sprite diffuse guislider(cS).SliderImageNo,guislider(cS).dR,guislider(cS).dG,guislider(cS).dB
                    size sprite guislider(cS).SliderImageNo,guislider(cS).SW,guislider(cS).SH
                    paste sprite guislider(cS).SliderImageNo,guislider(cS).SL,guislider(cS).ST-(guislider(cS).SH/2)
                endif
            endif
            if mMouseState = 1
                if inputmousex() > (guislider(cS).AL - guislider(cS).AW / 2) - 10 and inputmousex() < (guislider(cS).AL + guislider(cS).AW / 2) + 10 and inputmousey() > (guislider(cS).AT - guislider(cS).AH / 2) - 10 and inputmousey() < (guislider(cS).AT + guislider(cS).AH / 2)  + 10
                    guislider(cS).BVal = inputmousex() - guislider(cS).AL + (guislider(cS).AW/2)
                    if guislider(cS).BVal < 0 then guislider(cS).BVal = 0
                    if guislider(cS).BVal > guislider(cS).AW then guislider(cS).BVal = guislider(cS).AW
                    guislider(cS).SL = (guislider(cS).AL - (guislider(cS).AW / 2)) + ((guislider(cS).BVal/guislider(cS).AW)*guislider(cS).AW) - (guislider(cS).SW / 2)
                    guislider(cS).SVal = ((guislider(cS).SL-(guislider(cS).AL-(guislider(cS).AW/2))+(guislider(cS).SW/2))/guislider(cS).AW)*guislider(cS).MaxValue
                endif
            endif
        endif
    next cS
    for cS = 0 to tChoice-1
        if guichoice(cS).Visible = 1
            if guichoice(cS).BackImageNo > 0
                if sprite exist(guichoice(cS).BackImageNo)
                    set sprite alpha guichoice(cS).BackImageNo,guichoice(cS).iA
                    set sprite diffuse guichoice(cS).BackImageNo,guichoice(cS).dR,guichoice(cS).dG,guichoice(cS).dB
                    size sprite guichoice(cS).BackImageNo,guichoice(cS).AW,guichoice(cS).AH
                    paste sprite guichoice(cS).BackImageNo,guichoice(cS).AL-(guichoice(cS).AW/2),guichoice(cS).AT-(guichoice(cS).AH/2)
                endif
            endif
            if guichoice(cS).FillImageNo > 0
                if sprite exist(guichoice(cS).FillImageNo)
                    set sprite alpha guichoice(cS).FillImageNo,guichoice(cS).iA
                    set sprite diffuse guichoice(cS).FillImageNo,guichoice(cS).dR,guichoice(cS).dG,guichoice(cS).dB
                    sX = (guichoice(cS).AL - guichoice(cS).AW / 2) - 2
                    sDiff = (guichoice(cS).SL - (guichoice(cS).AL - (guichoice(cS).AW / 2)))
                    iW = image width(guichoice(cS).FillImageNo)
                    iH = image height(guichoice(cS).FillImageNo)
                    for cX = sX to sX + sDiff step iW
                        paste sprite guichoice(cS).FillImageNo,cX+2,guichoice(cS).ST-(iH/2)
                    next
                endif
            endif
            if guichoice(cS).SliderImageNo > 0
                if sprite exist(guichoice(cS).SliderImageNo)
                    set sprite alpha guichoice(cS).SliderImageNo,guichoice(cS).iA
                    set sprite diffuse guichoice(cS).SliderImageNo,guichoice(cS).dR,guichoice(cS).dG,guichoice(cS).dB
                    size sprite guichoice(cS).SliderImageNo,guichoice(cS).SW,guichoice(cS).SH
                    paste sprite guichoice(cS).SliderImageNo,guichoice(cS).SL,guichoice(cS).ST-(guichoice(cS).SH/2)
                endif
            endif
            if guichoice(cS).TotalStates >= 2 then center text guichoice(cS).AL-(guichoice(cS).AW/2), guichoice(cS).AT+20, guichoice(cS).State1
            if guichoice(cS).TotalStates >= 2 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+guichoice(cS).StateWidth, guichoice(cS).AT+20, guichoice(cS).State2
            if guichoice(cS).TotalStates >= 3 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*2), guichoice(cS).AT+20, guichoice(cS).State3
            if guichoice(cS).TotalStates >= 4 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*3), guichoice(cS).AT+20, guichoice(cS).State4
            if guichoice(cS).TotalStates >= 5 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*4), guichoice(cS).AT+20, guichoice(cS).State5
            if guichoice(cS).TotalStates >= 6 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*5), guichoice(cS).AT+20, guichoice(cS).State6
            if guichoice(cS).TotalStates >= 7 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*6), guichoice(cS).AT+20, guichoice(cS).State7
            if guichoice(cS).TotalStates >= 8 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*7), guichoice(cS).AT+20, guichoice(cS).State8
            if guichoice(cS).TotalStates >= 9 then center text guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*8), guichoice(cS).AT+20, guichoice(cS).State9
            if mMouseState = 1
                if inputmousex() > (guichoice(cS).AL - guichoice(cS).AW / 2) - 10 and inputmousex() < (guichoice(cS).AL + guichoice(cS).AW / 2) + 10 and inputmousey() > (guichoice(cS).AT - guichoice(cS).AH / 2) - 10 and inputmousey() < (guichoice(cS).AT + guichoice(cS).AH / 2)  + 10
                    nDist# = guichoice(cS).AW+20 : nState = 0
                    for sI = 0 To 9 step 1
                        DX# = guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*sI)
                        DY# = guichoice(cS).AT
                        CD# = CalcStateDistance(inputmousex(),inputmousey(),DX#,DY#)
                        if CD# <= nDist#
                            nDist# = CD#
                            nState = sI
                            guichoice(cS).SelectedStateNum = nState + 1
                            guichoice(cS).SL = guichoice(cS).AL-(guichoice(cS).AW/2)+(guichoice(cS).StateWidth*sI)-(guichoice(cS).SW / 2)
                        endif
                    next
                    if guichoice(cS).SelectedStateNum = 1 Then guichoice(cS).SelectedState = guichoice(cS).State1
                    if guichoice(cS).SelectedStateNum = 2 Then guichoice(cS).SelectedState = guichoice(cS).State2
                    if guichoice(cS).SelectedStateNum = 3 Then guichoice(cS).SelectedState = guichoice(cS).State3
                    if guichoice(cS).SelectedStateNum = 4 Then guichoice(cS).SelectedState = guichoice(cS).State4
                    if guichoice(cS).SelectedStateNum = 5 Then guichoice(cS).SelectedState = guichoice(cS).State5
                    if guichoice(cS).SelectedStateNum = 6 Then guichoice(cS).SelectedState = guichoice(cS).State6
                    if guichoice(cS).SelectedStateNum = 7 Then guichoice(cS).SelectedState = guichoice(cS).State7
                    if guichoice(cS).SelectedStateNum = 8 Then guichoice(cS).SelectedState = guichoice(cS).State8
                    if guichoice(cS).SelectedStateNum = 9 Then guichoice(cS).SelectedState = guichoice(cS).State9
                endif
            endif
        endif
    next cS
    if GUILoad = 1
        if initLoadSave = 0
           gosub _saveload_savebox_load
           if sprite exist(saveload.saveloadimg+1)=0
                sprite saveload.saveloadimg+1,-10000,-10000,saveload.saveloadimg+1
                set sprite saveload.saveloadimg+1,0,1
           endif
           initLoadSave = 1
        endif
        LoadHudX = (gdisplaywidth/2)-image width(saveload.saveloadimg+1)/2
        LoadHudY = (gdisplayheight/2)-image height(saveload.saveloadimg+1)/2
        tttspacer=300
        saveload.slothighlight = -1
        if sprite exist(saveload.saveloadimg+1) then paste sprite saveload.saveloadimg+1,LoadHudX,LoadHudY
        ink rgb(255,255,255),0 : center text LoadHudX+tttspacer,LoadHudY+6,strarr$(646)
        for sloti = 1 to 9
            dY# = LoadHudY+20+(sloti*27)
            if  inputmousex() > LoadHudX and inputmousex() < LoadHudX+280 and inputmousey() > dY# and inputmousey() < dY#+27
                 if saveloadslot$(sloti) <> strarr$(645)
                    saveload.slothighlight = sloti
                    if saveload.slothighlight>0
                        slotimg = saveload.saveloadimg + 10 + saveload.slothighlight
                        if image exist(slotimg) = 1 then paste image slotimg,LoadHudX+320,LoadHudY+40,1
                    endif
                    ink rgb(255,255,255),0
                endif
            else
                ink rgb(35,35,35),0
            endif
``            text LoadHudX+25,dY#+4,str$(sloti)+") "+saveloadslot$(sloti)
            text LoadHudX+25,dY#+4,"HELLO WORLD"
        next sloti
        if mMouseUp = 2 and saveload.slothighlight <> -1
            if sprite exist(saveload.saveloadimg+1) then delete sprite saveload.saveloadimg+1
            GUILoad = 0 : GUISave = 0 : saveload.slotselected = saveload.slothighlight : saveload.slothighlight = -1
            saveloadfile$ = "gamesaves\slot"+str$(saveload.slotselected)+".dat" : saveload.slotselected = -1
            loadsavedlevel$ = saveloadfile$ : saveloadfile$ = "" : gosub _saveload_savebox_free
            continueokay = 1 : levelwon = 3 : HideAllGUI() : mMouseUp = 0 : MouseUpHud$ = ""
        endif
        if escapekey() then GUILoad = 0 : GUISave = 0 : gosub _saveload_savebox_free : HideAllGUI()
    endif
    if GUISave = 1
        if initLoadSave = 0
           gosub _saveload_savebox_load
           if sprite exist(saveload.saveloadimg+1)=0
                sprite saveload.saveloadimg+1,-10000,-10000,saveload.saveloadimg+1
                set sprite saveload.saveloadimg+1,0,1
           endif
           initLoadSave = 1
        endif
        SaveHudX = (gdisplaywidth/2)-image width(saveload.saveloadimg+1)/2
        SaveHudY = (gdisplayheight/2)-image height(saveload.saveloadimg+1)/2
        tttspacer=300
        saveload.slothighlight = -1
        if sprite exist(saveload.saveloadimg+1) then paste sprite saveload.saveloadimg+1,SaveHudX,SaveHudY
        ink rgb(255,255,255),0 : center text SaveHudX+tttspacer,SaveHudY+6,strarr$(647)
        for sloti = 1 to 9
            dY# = SaveHudY+20+(sloti*27)
            if inputmousex() > SaveHudX and inputmousex() < SaveHudX+280 and inputmousey() > dY# and inputmousey() < dY#+27
                 saveload.slothighlight = sloti
                 if saveload.slothighlight>0
                    slotimg = saveload.saveloadimg + 10 + saveload.slothighlight
                    if image exist(slotimg) = 1 then paste image slotimg,SaveHudX+320,SaveHudY+40,1
                endif
                ink rgb(255,255,255),0
            else
                ink rgb(35,35,35),0
            endif
            text SaveHudX+25,dY#+4,str$(sloti)+") "+saveloadslot$(sloti)
        next sloti
        if mMouseUp = 2 and saveload.slothighlight <> -1
            if sprite exist(saveload.saveloadimg+1) then delete sprite saveload.saveloadimg+1
            GUILoad=  0 : GUISave = 0 : saveload.slotselected = saveload.slothighlight : saveload.slothighlight = -1
            saveloadfile$ = "gamesaves\slot"+str$(saveload.slotselected)+".dat"
            gosub _saveload_savebox_dosave : gosub _saveload_savegame : saveload.slotselected = -1
            gosub _saveload_savebox_free : HideAllGUI() : mMouseUp = 0 : MouseUpHud$ = ""
        endif
        if escapekey() then GUILoad = 0 : GUISave = 0 : gosub _saveload_savebox_free : HideAllGUI()
    endif
    if guiIA=1 and GUIDC=1
        if MouseSprite > 0
            if sprite exist(MouseSprite)
                hide mouse
                paste sprite MouseSprite,inputmousex(),inputmousey()
           remstart
            else
                if aihudpointerimagestore > 0
                    if image exist(aihudpointerimagestore)=0 then show mouse
                endif
           remend
            endif
       remstart
        else
            if aihudpointerimagestore > 0
                if image exist(aihudpointerimagestore)=0 then show mouse
            endif
       remend
        endif
    endif
    if guiloaderhud > -1
        if guihud(guiloaderhud).NormImageNo > -1
            if sprite exist(guihud(guiloaderhud).NormImageNo)
                set sprite alpha guihud(guiloaderhud).NormImageNo,255
                t1#=guihud(guiloaderhud).Width*guiloadprogress
                size sprite guihud(guiloaderhud).NormImageNo,t1#,guihud(guiloaderhud).AH
                paste sprite guihud(guiloaderhud).NormImageNo,guihud(guiloaderhud).AL-(guihud(guiloaderhud).Width/2),guihud(guiloaderhud).AT-(guihud(guiloaderhud).Height/2)
                center text guihud(guiloaderhud).AL-(guihud(guiloaderhud).Width/2),guihud(guiloaderhud).AT-(guihud(guiloaderhud).Height/2),str$(t1#)+"%"
                guihud(guiloaderhud).Visible = 0
            endif
        endif
    endif
    if guifaderhud > -1
        if guihud(guifaderhud).NormImageNo > -1
            if sprite exist(guihud(guifaderhud).NormImageNo)
                size sprite guihud(guifaderhud).NormImageNo,screen width(),screen height()
                set sprite alpha guihud(guifaderhud).NormImageNo,guifaderalpha
                paste sprite guihud(guifaderhud).NormImageNo,0,0
                guihud(guifaderhud).Visible = 0
            endif
        endif
    endif
    if guieyehud > -1 and guieyetimer > 0
        if guihud(guieyehud).NormImageNo > -1
            if sprite exist(guihud(guieyehud).NormImageNo)
                set sprite alpha guihud(guieyehud).NormImageNo,255
                size sprite guihud(guieyehud).NormImageNo,screen width(),screen height()
                paste sprite guihud(guieyehud).NormImageNo,0,0
                guieyetimer = guieyetimer - 1
                if guieyetimer < 0 then guieyetimer = 0
                if guieyetimer = 0
                    guihud(guieyehud).Visible = 0
                else
                    guihud(guieyehud).Visible = 1
                endif
            endif
        endif
    endif
 endif
return

function GUIImageFromName(CheckName as string)
    rINo = -1
    for cI = 0 to totImages-1
        if lower$(guiimage(cI).Name) = lower$(CheckName)
            rINo = guiimage(ci).ImageNo
            exit
        endif
    next cI
endfunction rINo

function GUIHudFromName(CheckName as string)
    rINo = -1
    for cI = 0 to tHuds-1
        if rIno = -1 and lower$(guihud(cI).Name) = lower$(CheckName)
            rINo = cI
            exit
        endif
    next cI
endfunction rINo

function GUICheckboxFromName(CheckName as string)
    rINo = -1
    for cI = 0 to tCheckbox-1
        if rIno = -1 and lower$(guicheckbox(cI).Name) = lower$(CheckName)
            rINo = cI
            exit
        endif
    next cI
endfunction rINo

function GUISliderFromName(CheckName as string)
    rINo = -1
    for cI = 0 to tSlider-1
        if rIno = -1 and lower$(guislider(cI).Name) = lower$(CheckName)
            rINo = cI
            exit
        endif
    next cI
endfunction rINo

function GUIChoiceFromName(CheckName as string)
    rINo = -1
    for cI = 0 to tChoice-1
        if rIno = -1 and lower$(guichoice(cI).Name) = lower$(CheckName)
            rINo = cI
            exit
        endif
    next cI
endfunction rINo

function GUITimerFromName(CheckName as string)
    rINo = -1
    for cI = 0 to tTimer-1
        if rIno = -1 and lower$(guitimer(cI).Name) = lower$(CheckName)
            rINo = cI
            exit
        endif
    next cI
endfunction rINo

function GUISVarFromName(CheckName as string)
    rINo = -1
    for cI = 0 to tSVar-1
        if rIno = -1 and lower$(guisvar(cI).Name) = lower$(CheckName)
            rINo = cI
            exit
        endif
    next cI
endfunction rINo

function CalcStateDistance(X1# as float, Y1# as float, X2# as float, Y2# as float)
   null = make vector2(99)
   set vector2 99, X1#-X2#, Y1#-Y2#
   retRes# = length vector2(99)
   null = delete vector2(99)
endfunction retRes#

function LoadGUIImage(Name as string, Path as string)
    if lower$(Name) <> "na" and Name <> "-" and lower$(Name) <> "none"
        rINo = -1
        for cI = 0 to totImages-1
            if lower$(guiimage(cI).Name) = lower$(Name)
                rINo = cI
                exit
            endif
        next cI
        if rINo = -1
            if image exist(RImageOffset+totImages) then delete image RImageOffset+totImages
            if sprite exist(RImageOffset+totImages) then delete sprite RImageOffset+totImages
            guiimage(totImages).Name = Name
            guiimage(totImages).Path = Path
            guiimage(totImages).ImageNo = RImageOffset+totImages
            if file exist("imageblock.bin")=0
                if file exist(get dir$()+"\"+guiimage(totImages).Path) then load image get dir$()+"\"+guiimage(totImages).Path,guiimage(totImages).ImageNo
                if image exist(guiimage(totImages).ImageNo) then guiimage(totImages).LFIB = 0
            endif
            if file exist("imageblock.bin")=1
                if image file exist(guiimage(totImages).Path)=1
                    load image guiimage(totImages).Path,guiimage(totImages).ImageNo
                    if image exist(guiimage(totImages).ImageNo) then guiimage(totImages).LFIB = 1
                endif
                if image file exist(guiimage(totImages).Path)=0 and guiimage(totImages).LFIB <> 1
                    if file exist(get dir$()+"\"+guiimage(totImages).Path) then load image get dir$()+"\"+guiimage(totImages).Path,guiimage(totImages).ImageNo
                    if image exist(guiimage(totImages).ImageNo) then guiimage(totImages).LFIB = 0
                endif
            endif
            if image exist(guiimage(totImages).ImageNo)
                sprite guiimage(totImages).ImageNo,-10000,-10000,guiimage(totImages).ImageNo
                set sprite guiimage(totImages).ImageNo,0,1
                guiimage(totImages).Width = image width(guiimage(totImages).ImageNo)
                guiimage(totImages).Height = image height(guiimage(totImages).ImageNo)
            else
                guiimage(totImages).ImageNo = -1
            endif
            totImages=totImages+1
        Endif
    endif
endfunction

function ReplaceGUIImage(Name as string, Path as string)
    rINo = -1
    for cI = 0 to totImages-1
        if lower$(guiimage(cI).Name) = lower$(Name)
            rINo = cI
            exit
        endif
    next cI
    if rINo <> -1
        if guiimage(rINo).ImageNo <> -1
            if image exist(guiimage(rINo).ImageNo) then delete image guiimage(rINo).ImageNo
        endif
        if guiimage(rINo).ImageNo <> -1
            if sprite exist(guiimage(rINo).ImageNo) then delete sprite guiimage(rINo).ImageNo
        endif
        guiimage(rINo).Path = Path
        if file exist("imageblock.bin")=0
            if file exist(get dir$()+"\"+guiimage(rINo).Path) then load image get dir$()+"\"+guiimage(rINo).Path,guiimage(rINo).ImageNo
            if image exist(guiimage(rINo).ImageNo) then guiimage(rINo).LFIB = 0
        endif
        if file exist("imageblock.bin")=1
            if image file exist(guiimage(rINo).Path)=1
                load image guiimage(rINo).Path,guiimage(rINo).ImageNo
                if image exist(guiimage(rINo).ImageNo) then guiimage(rINo).LFIB = 1
            endif
            if image file exist(guiimage(rINo).Path)=0 and guiimage(rINo).LFIB <> 1
                if file exist(get dir$()+"\"+guiimage(rINo).Path) then load image get dir$()+"\"+guiimage(rINo).Path,guiimage(rINo).ImageNo
                if image exist(guiimage(rINo).ImageNo) then guiimage(rINo).LFIB = 0
            endif
        endif
        if image exist(guiimage(rINo).ImageNo)
            sprite guiimage(rINo).ImageNo,-10000,-10000,guiimage(rINo).ImageNo
            set sprite guiimage(rINo).ImageNo,0,1
            guiimage(rINo).Width = image width(guiimage(rINo).ImageNo)
            guiimage(rINo).Height = image height(guiimage(rINo).ImageNo)
        else
            guiimage(rINo).ImageNo = -1
        endif
    endif
endfunction

function ScreenXPos(uX as float)
    retX# = (10.24)*uX
endfunction retX#

function ScreenYPos(uY as float)
    retY# = (7.68)*uY
endfunction retY#

function UpdateSliderData(sID)
    guislider(sID).AL = (ScreenXPos(guislider(sID).Left)/1024)*gdisplaywidth
    guislider(sID).AT = (ScreenYPos(guislider(sID).Top)/768)*gdisplayheight
    guislider(sID).AW = (guislider(sID).Width/1024)*gdisplaywidth
    guislider(sID).AH = (guislider(sID).Height/768)*gdisplayheight
    guislider(sID).SliderTop = guislider(sID).Top
    guislider(sID).ST =  (ScreenYPos(guislider(sID).SliderTop)/768)*gdisplayheight
    guislider(sID).SL = (guislider(sID).AL - (guislider(sID).AW / 2)) + ((guislider(sID).BVal/guislider(sID).AW)*guislider(sID).AW) - (guislider(sID).SW / 2)
    guislider(sID).SVal = ((guislider(sID).SL-(guislider(sID).AL-(guislider(sID).AW/2))+(guislider(sID).SW/2))/guislider(sID).AW)*guislider(sID).MaxValue
endfunction

function UpdateChoiceData(sID)
    guichoice(sID).AL = (ScreenXPos(guichoice(sID).Left)/1024)*gdisplaywidth
    guichoice(sID).AT = (ScreenYPos(guichoice(sID).Top)/768)*gdisplayheight
    guichoice(sID).AW = (guichoice(sID).Width/1024)*gdisplaywidth
    guichoice(sID).AH = (guichoice(sID).Height/768)*gdisplayheight
    guichoice(sID).sliderTop = guichoice(sID).Top
    guichoice(sID).ST = (ScreenYPos(guichoice(sID).sliderTop)/768)*gdisplayheight
    guichoice(sID).StateWidth =  guichoice(sID).AW / (guichoice(sID).TotalStates-1)
    guichoice(sID).SL = guichoice(sID).AL-(guichoice(sID).AW/2)+(guichoice(sID).StateWidth*guichoice(sID).SelectedStateNum)-(guichoice(sID).SW / 2)
endfunction

function ParseValues(strCheck$ as string)
    for cI = 0 to maxparse step 1
        guival(cI) = ""
    next
    totval = 0 : parsetotal = 0: guival(totval) = first token$(strCheck$," ") : totval = 1 : parsetotal = 1
    repeat
        guival(totval) = next token$(" ")
        totval = totval + 1 : parsetotal = parsetotal + 1
    until totval = maxparse or guival(totval-1) = ""
endfunction

function HideAllGUI()
    for cH = 0 to tHuds-1
       guihud(cH).Visible = 0
    next cH
    for cC = 0 to tCheckbox-1
       guicheckbox(cC).Visible = 0
    next cC
    for cS = 0 to tSlider-1
       guislider(cS).Visible = 0
    next cS
    for cS = 0 to tChoice-1
       guichoice(cS).Visible = 0
    next cS
endfunction

function ClearAllGUI()
    guiloaderhud = -1
    guieyehud = -1
    guifaderhud = -1
    tHuds = 0
    tCheckbox = 0
    tSlider = 0
    tChoice = 0
    tVar = 0
    tSVar = 0
    tTimer = 0
    for cI = RImageOffset to RImageOffset+totImages-1
        if image exist(cI) then delete image cI
        if sprite exist(cI) then delete sprite cI
    next
    totImages = 0
endfunction

function SaveSetupVariables()
       dim startsetup$(999)
       load array exeroot$+"\"+setupfilename$,startsetup$()
       tLines = 0
       for cV=1 to 999
           if startsetup$(cV)=""
               if startsetup$(cV-1)<>"" then tLines=tLines+1
           else
               tLines=tLines+1
           endif
       next cV
       tLines=tLines+1
       tL = 0
       for cV=0 to tSVar
           if guisvar(cV).Name<>"" and guisvar(cV).SetupLine<>"" and guisvar(cV).Value<>""
               fLine = -1
               for cL=0 to 999
                   if lower$(left$(startsetup$(cL),len(guisvar(cV).SetupLine)))=lower$(guisvar(cV).SetupLine) then fLine = cL : exit
               next cL
               if fLine <> -1
                   startsetup$(fLine)=guisvar(cV).SetupLine+"="+guisvar(cV).Value
                   guisvar(cV).Saved=1
               else
                   startsetup$(tLines+tL)=guisvar(cV).SetupLine+"="+guisvar(cV).Value
                   tL = tL + 1 : guisvar(cV).Saved=1
               endif
           endif
       next cV
       save array exeroot$+"\"+setupfilename$,startsetup$()
       undim startsetup$()
endfunction

function MakeGUIHud(Name as string, NormImage as string, OverImage as string, L as float, T as float, W as float, H as float)
    rINo = -1
    for cI = 0 to tHuds-1
        if lower$(guihud(cI).Name) = lower$(Name)
            rINo = cI
            exit
        endif
    next cI
    if rINo = -1
        guihud(tHuds).Name = Name
        guihud(tHuds).Visible = 1
        guihud(tHuds).NormImageNo = GUIImageFromName(NormImage)
        guihud(tHuds).OverImageNo = GUIImageFromName(OverImage)
        guihud(tHuds).Hovered = 0
        guihud(tHuds).Left = L
        guihud(tHuds).Top = T
        guihud(tHuds).Width = W
        guihud(tHuds).Height = H
        guihud(tHuds).dR = 255
        guihud(tHuds).dG = 255
        guihud(tHuds).dB = 255
        guihud(tHuds).iA = 255
        guihud(tHuds).IsButton = 1
        guihud(tHuds).IsNumeric = 0
        if guihud(tHuds).NormImageNo > -1
            if W = -1 Then guihud(tHuds).Width = image width(guihud(tHuds).NormImageNo)
            if H = -1 Then guihud(tHuds).Height = image height(guihud(tHuds).NormImageNo)
        endif
        guihud(tHuds).AL = (ScreenXPos(guihud(tHuds).Left)/1024)*gdisplaywidth
        guihud(tHuds).AT = (ScreenYPos(guihud(tHuds).Top)/768)*gdisplayheight
        guihud(tHuds).AW = (guihud(tHuds).Width/1024)*gdisplaywidth
        guihud(tHuds).AH = (guihud(tHuds).Height/768)*gdisplayheight
        if lower$(Name) = "loader" then guiloaderhud = tHuds
        if lower$(Name) = "fader" then guifaderhud = tHuds
        if lower$(Name) = "eyehud" then guieyehud = tHuds
        tHuds = tHuds + 1
    endif
endfunction

function MakeGUICheckbox(Name as string, NormImage as string, CheckImage as string, L as float, T as float, W as float, H as float)
    rINo = -1
    for cI = 0 to tCheckbox-1
        if lower$(guicheckbox(cI).Name) = lower$(Name)
            rINo = cI
            exit
        endif
    next cI
    if rINo = -1
        guicheckbox(tCheckbox).Name = Name
        guicheckbox(tCheckbox).Visible = 1
        guicheckbox(tCheckbox).NormImageNo = GUIImageFromName(NormImage)
        guicheckbox(tCheckbox).CheckImageNo = GUIImageFromName(CheckImage)
        guicheckbox(tCheckbox).CheckState = 0
        guicheckbox(tCheckbox).Left = L
        guicheckbox(tCheckbox).Top = T
        guicheckbox(tCheckbox).Width = W
        guicheckbox(tCheckbox).Height = H
        guicheckbox(tCheckbox).dR = 255
        guicheckbox(tCheckbox).dG = 255
        guicheckbox(tCheckbox).dB = 255
        guicheckbox(tCheckbox).iA = 255
        if W = -1 Then guicheckbox(tCheckbox).Width = image width(guicheckbox(tCheckbox).NormImageNo)
        if H = -1 Then guicheckbox(tCheckbox).Height = image height(guicheckbox(tCheckbox).NormImageNo)
        guicheckbox(tCheckbox).AL = (ScreenXPos(guicheckbox(tCheckbox).Left)/1024)*gdisplaywidth
        guicheckbox(tCheckbox).AT = (ScreenYPos(guicheckbox(tCheckbox).Top)/768)*gdisplayheight
        guicheckbox(tCheckbox).AW = (guicheckbox(tCheckbox).Width/1024)*gdisplaywidth
        guicheckbox(tCheckbox).AH = (guicheckbox(tCheckbox).Height/768)*gdisplayheight
        tCheckbox = tCheckbox + 1
    endif
endfunction

function MakeGUISlider(Name as string, BackImage as string, FillImage as string, SliderImage as string, L as float, T as float, W as float, H as float)
    rINo = -1
    for cI = 0 to tSlider-1
        if lower$(guislider(cI).Name) = lower$(Name)
            rINo = cI
            exit
        endif
    next cI
    if rINo = -1
        guislider(tSlider).Name = Name
        guislider(tSlider).Visible = 1
        guislider(tSlider).BackImageNo = GUIImageFromName(BackImage)
        guislider(tSlider).FillImageNo = -1
        if lower$(FillImage) <> "none" Then guislider(tSlider).FillImageNo = GUIImageFromName(FillImage)
        guislider(tSlider).SliderImageNo = GUIImageFromName(SliderImage)
        guislider(tSlider).BVal = 0
        guislider(tSlider).SVal = 0
        guislider(tSlider).MaxValue = 100
        guislider(tSlider).Left = L
        guislider(tSlider).Top = T
        guislider(tSlider).Width = W
        guislider(tSlider).Height = H
        guislider(tSlider).dR = 255
        guislider(tSlider).dG = 255
        guislider(tSlider).dB = 255
        guislider(tSlider).iA = 255
        if W = -1 Then guislider(tSlider).Width = image width(guislider(tSlider).BackImageNo)
        if H = -1 Then guislider(tSlider).Height = image height(guislider(tSlider).BackImageNo)
        guislider(tSlider).AL = (ScreenXPos(guislider(tSlider).Left)/1024)*gdisplaywidth
        guislider(tSlider).AT = (ScreenYPos(guislider(tSlider).Top)/768)*gdisplayheight
        guislider(tSlider).AW = (guislider(tSlider).Width/1024)*gdisplaywidth
        guislider(tSlider).AH = (guislider(tSlider).Height/768)*gdisplayheight
        guislider(tSlider).SliderLeft = L
        guislider(tSlider).SliderTop = T
        guislider(tSlider).SliderWidth = image width(guislider(tSlider).SliderImageNo)
        guislider(tSlider).SliderHeight = image height(guislider(tSlider).SliderImageNo)
        guislider(tSlider).ST =  (ScreenYPos(guislider(tSlider).SliderTop)/768)*gdisplayheight
        guislider(tSlider).SW = (guislider(tSlider).SliderWidth/1024)*gdisplaywidth
        guislider(tSlider).SH = (guislider(tSlider).SliderHeight/768)*gdisplayheight
        guislider(tSlider).SL = (guislider(tSlider).AL - (guislider(tSlider).AW / 2)) + (guislider(tSlider).BVal / 100) * guislider(tSlider).AW - (guislider(tSlider).SW / 2)
        tSlider = tSlider + 1
    endif
endfunction

function MakeGUIChoice(Name as string, BackImage as string, FillImage as string, SliderImage as string, State1 as string, State2 as string, L as float, T as float, W as float, H as float)
    rINo = -1
    for cI = 0 to tChoice-1
        if lower$(guichoice(cI).Name) = lower$(Name)
            rINo = cI
            exit
        endif
    next cI
    if rINo = -1
        guichoice(tChoice).Name = Name
        guichoice(tChoice).Visible = 1
        guichoice(tChoice).BackImageNo = GUIImageFromName(BackImage)
        guichoice(tChoice).FillImageNo = -1
        if lower$(FillImage) <> "none" Then guichoice(tChoice).FillImageNo = GUIImageFromName(FillImage)
        guichoice(tChoice).SliderImageNo = GUIImageFromName(SliderImage)
        guichoice(tChoice).State1 = State1
        guichoice(tChoice).State2 = State2
        guichoice(tChoice).TotalStates = 2
        guichoice(tChoice).SelectedStateNum = 1
        guichoice(tChoice).SelectedState = State1
        guichoice(tChoice).Left = L
        guichoice(tChoice).Top = T
        guichoice(tChoice).Width = W
        guichoice(tChoice).Height = H
        guichoice(tChoice).dR = 255
        guichoice(tChoice).dB = 255
        guichoice(tChoice).dG = 255
        guichoice(tChoice).iA = 255
        if W = -1 Then guichoice(tChoice).Width = image width(guichoice(tChoice).BackImageNo)
        if H = -1 Then guichoice(tChoice).Height = image height(guichoice(tChoice).BackImageNo)
        guichoice(tChoice).AL = (guichoice(tChoice).Left/1024)*gdisplaywidth
        guichoice(tChoice).AT = (guichoice(tChoice).Top/768)*gdisplayheight
        guichoice(tChoice).AL = (ScreenXPos(guichoice(tChoice).Left)/1024)*gdisplaywidth
        guichoice(tChoice).AT = (ScreenYPos(guichoice(tChoice).Top)/768)*gdisplayheight
        guichoice(tChoice).AW = (guichoice(tChoice).Width/1024)*gdisplaywidth
        guichoice(tChoice).AH = (guichoice(tChoice).Height/768)*gdisplayheight
        guichoice(tChoice).SliderLeft = L
        guichoice(tChoice).SliderTop = T
        guichoice(tChoice).SliderWidth = image width(guichoice(tChoice).SliderImageNo)
        guichoice(tChoice).SliderHeight = image height(guichoice(tChoice).SliderImageNo)
        guichoice(tChoice).ST = (ScreenYPos(guichoice(tChoice).SliderTop)/768)*gdisplayheight
        guichoice(tChoice).SW = (guichoice(tChoice).SliderWidth/1024)*gdisplaywidth
        guichoice(tChoice).SH = (guichoice(tChoice).SliderHeight/768)*gdisplayheight
        guichoice(tChoice).SL = guichoice(tChoice).AL-(guichoice(tChoice).AW/2)+guichoice(tChoice).StateWidth-(guichoice(tChoice).SW / 2)
        guichoice(tChoice).StateWidth =  guichoice(tChoice).AW / (guichoice(tChoice).TotalStates-1)
        tChoice = tChoice + 1
    endif
endfunction

function MakeGUITimer(Name as string, Start as integer)
    rINo = -1
    for cI = 0 to tTimer-1
        if lower$(guitimer(cI).Name) = lower$(Name)
            rINo = cI
            exit
        endif
    next cI
    if rINo = -1
        guitimer(tTimer).Name = Name
        guitimer(tTimer).Time = timer()
        guitimer(tTimer).RunTime = 0
        if Start < 0 then Start = 0 : if Start > 1 then Start = 1
        guitimer(tTimer).Started = Start
        tTimer = tTimer + 1
    endif
endfunction

function MakeGUISetupVar(Name as string, Value as string, SetupLine as string)
    rINo = -1
    for cI = 0 to tSVar-1
        if lower$(guisvar(cI).Name) = lower$(Name)
            rINo = cI
            exit
        endif
    next cI
    if rINo = -1
        guisvar(tSVar).Name = Name
        guisvar(tSVar).Value = Value
        if right$(SetupLine,1) = "=" then SetupLine=left$(SetupLine,len(SetupLine)-1)
        guisvar(tSVar).SetupLine = SetupLine
        guisvar(tSVar).Saved = 0
        tSVar = tSVar + 1
    endif
endfunction

remstart - Below code to be removed after GUI-X9 has finished beta, not beforehand in-case it is required for something in the near future.
function CheckBuildScripts(ePath$, tLanguage$)
   rem Copy scripts manually so the default scripts aren't edited incase the user doesn't use GUI-X9 for their next build.
    if file exist(get dir$()+"\Files\script.gx9")
        open to read 1,get dir$()+"\Files\script.gx9"
        if file open(1)=1
            read string 1,strTitlePage$
            read string 1,strLoadingScreen$
            read string 1,strSetupLevel$
            read string 1,strGameOver$
            read string 1,strGameWon$
            read string 1,strSky$
            read string 1,skyFolder1$
            read string 1,skyFolder2$
        endif
        close file 1
    endif
    if lower$(right$(currentFPG$,4))=".fpg"
        guiFPG$=left$(currentFPG$,len(currentFPG$)-4)
    else
        guiFPG$=currentFPG$
    endif
    if path exist(ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$)=0 then make directory ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$
    if file exist(get dir$()+"\"+strTitlePage$)
        if file exist(ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\titlepage.fpi") then delete file ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\titlepage.fpi"
    endif
    if file exist(get dir$()+"\"+strLoadingScreen$)
         if file exist(ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\loadingpage.fpi") then delete file ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\loadingpage.fpi"
    endif
    if file exist(get dir$()+"\"+strSetupLevel$)
         if file exist(ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\setuplevel.fpi") then delete file ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\setuplevel.fpi"
    endif
    if file exist(get dir$()+"\"+strGameOver$)
        if file exist(ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\gameover.fpi") then delete file ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\gameover.fpi"
    endif
    if file exist(get dir$()+"\"+strGameWon$)
        if file exist(ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\gamewon.fpi") then delete file ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\gamewon.fpi"
    endif
    if strTitlepage$ <> "" and file exist(get dir$()+"\"+strTitlePage$) then copy file get dir$()+"\"+strTitlePage$,ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\titlepage.fpi"
    if strLoadingScreen$ <> "" and file exist(get dir$()+"\"+strLoadingScreen$) then copy file get dir$()+"\"+strLoadingScreen$,ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\loadingpage.fpi"
    if strSetupLevel$ <> "" and file exist(get dir$()+"\"+strSetupLevel$) then copy file get dir$()+"\"+strSetupLevel$,ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\setuplevel.fpi"
    if strGameOver$ <> "" and file exist(get dir$()+"\"+strGameOver$) then copy file get dir$()+"\"+strGameOver$,ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\gameover.fpi"
    if strGameWon$ <> "" and file exist(get dir$()+"\"+strGameWon$) then copy file get dir$()+"\"+strGameWon$,ePath$+"\Files\languagebank\"+tLanguage$+"\gamebank\"+guiFPG$+"\gamewon.fpi"
    if path exist(ePath$+"/Files/skybank/")=0 then make directory ePath$+"/Files/skybank/"
    if path exist(ePath$+"/Files/skybank/"+skyFolder1$+"/")=0 then make directory ePath$+"/Files/skybank/"+skyFolder1$+"/"
    if path exist(ePath$+"/Files/skybank/"+skyFolder1$+"/"+skyFolder2$+"/")=0 then make directory ePath$+"/Files/skybank/"+skyFolder1$+"/"+skyFolder2$+"/"
    if file exist(get dir$()+"/Files/skybank/"+skyFolder1$+"/"+skyFolder2$+"/"+strSky$+".x") then load object get dir$()+"/Files/skybank/"+skyFolder1$+"/"+skyFolder2$+"/"+strSky$+".x",55555
    if object exist(55555)
        save object ePath$+"/Files/skybank/"+skyFolder1$+"/"+skyFolder2$+"/"+left$(strSky$,3)+".dbo",55555
        delete object 55555
    endif
endfunction

function GUI_ATIB()
    dim fArray(999,1) as string : tF = 0
    if file exist("script.gx9")
        open to read 1,"script.gx9"
        if file open(1)=1
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,skyFolder1$
            read string 1,skyFolder2$
            while file end(1)=0
                read string 1,fArray(tF,0)
                read string 1,fArray(tF,1)
                tF = tF + 1
            endwhile
        endif
        close file 1
    endif
    for cF = 0 to tF-1
        if fArray(cF,0) <> "" and fArray(cF,1) <> ""
            if left$(lower$(fArray(cF,1)),3) = "sky"
                copy file fArray(cF,0),get dir$()+"\skybank\"+skyFolder1$+"\"+skyFolder2$+"\"+right$(fArray(cF,1),len(fArray(cF,1))-3)
                if right$(lower$(fArray(cF,1)),4) = ".dds" or right$(lower$(fArray(cF,1)),4) = ".tga"
                    if file exist("skybank\"+skyFolder1$+"\"+skyFolder2$+"\"+right$(fArray(cF,1),len(fArray(cF,1))-3)) then load image "skybank\"+skyFolder1$+"\"+skyFolder2$+"\"+right$(fArray(cF,1),len(fArray(cF,1))-3),80000+cF
                endif
            else
                copy file fArray(cF,0),get dir$()+"\languagebank\"+language$+"\gamecore\backdrops\basic\"+fArray(cF,1)
                if right$(lower$(fArray(cF,1)),4) = ".png" or right$(lower$(fArray(cF,1)),4) = ".jpg" or right$(lower$(fArray(cF,1)),4) = ".gif" or right$(lower$(fArray(cF,1)),4) = ".bmp" or right$(lower$(fArray(cF,1)),4) = ".dds" or right$(lower$(fArray(cF,1)),4) = ".tga"
                    if file exist("languagebank\"+language$+"\gamecore\backdrops\basic\"+fArray(cF,1)) then load image "languagebank\"+language$+"\gamecore\backdrops\basic\"+fArray(cF,1),80000+cF
                endif
            endif
        endif
    next
endfunction

function GUI_CITF(ePath$, eName$)
    dim fArray(999,1) as string : tF = 0
    if file exist("script.gx9")
        open to read 1,"script.gx9"
        if file open(1)=1
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            read string 1,unused$
            while file end(1)=0
                read string 1,fArray(tF,0)
                read string 1,fArray(tF,1)
                tF = tF + 1
            endwhile
        endif
        close file 1
    endif
    for cF = 0 to tF-1
        if fArray(cF,0) <> "" and fArray(cF,1) <> ""
            if path exist(ePath$+eName$)=0 then make directory ePath$+eName$
            if path exist(ePath$+eName$+"\files\")=0 then make directory ePath$+eName$+"\files\"
            if path exist(ePath$+eName$+"\files\languagebank\")=0 then make directory ePath$+eName$+"\files\languagebank\"
            if path exist(ePath$+eName$+"\files\languagebank\"+language$)=0 then make directory ePath$+eName$+"\files\languagebank\"+language$
            if path exist(ePath$+eName$+"\files\languagebank\"+language$+"\gamecore\")=0 then make directory ePath$+eName$+"\files\languagebank\"+language$+"\gamecore\"
            if path exist(ePath$+eName$+"\files\languagebank\"+language$+"\gamecore\backdrops\")=0 then make directory ePath$+eName$+"\files\languagebank\"+language$+"\gamecore\backdrops\"
            if path exist(ePath$+eName$+"\files\languagebank\"+language$+"\gamecore\backdrops\basic\")=0 then make directory ePath$+eName$+"\files\languagebank\"+language$+"\gamecore\backdrops\basic\"
            if file exist(fArray(cF,0)) then copy file fArray(cF,0),ePath$+eName$+"\files\languagebank\"+language$+"\gamecore\backdrops\basic\"+fArray(cF,1)
        endif
    next
endfunction
remend
rem GUI-X9 (knxrb) <<<

Setup_LightRays:
 global RayCam : RayCam=Find_Free_Camera()
 global Sw# : Sw#=gdisplaywidth
 global Sh# : Sh#=gdisplayheight
 load image "effectbank\lightray\sun.bmp",4 : addfiletocollection("effectbank\lightray\sun.bmp")
 `
 rem Make light ray sun plane
 make object plain 99000,1500*2,1500*2
 texture object 99000,4
 set object transparency 99000,1
 set object light 99000,0
 set object mask 99000,2^RayCam
 `
 rem Make and setup light ray camera
 make camera RayCam
 set camera to image RayCam,6,gdisplaywidth/3,gdisplayheight/3
 set camera range RayCam,1,realrange#
 set camera aspect RayCam,realaspect# : rem (Sw#/Sh#)
 set camera fov RayCam,realfov# : rem 75
 backdrop on RayCam
 color backdrop RayCam,rgb(0,0,0)
 `
 rem make light ray scatter FX plane
 load effect "effectbank\lightray\scatter.fx",3,0 : addfiletocollection("effectbank\lightray\scatter.fx")
 make object plain 99001,2,2,1
 texture object 99001,6
 set object effect 99001,3
 set object mask 99001,(2^0)
 ghost object on 99001,0
 set object transparency 99001,1
return

Update_LightRays:
rem take out debug info
` if lrdebugdeactive=0
  rem debug, display light ray camera image
 ` if keystate(2)=1
 `  paste image 6,0,0
 ` endif
` endif
 `
 rem update scatter shader
 y=wrapvalue(object angle y(99000))
 null=make vector4(10)
 set vector4 10,CalcLightDirX(y),-0.5,CalcLightDirZ(y),0
 set effect constant vector 3,"LightDir",10
 null=delete vector4(10)
 rem altered for better performance
 if lrswitchsamples=1
  if lrsamples=1
   set effect constant integer 3,"SampleNum",80
   set camera to image RayCam,6,gdisplaywidth/3,gdisplayheight/3
  else
   set effect constant integer 3,"SampleNum",0
   set camera to image RayCam,6,1,1
  endif
  lrswitchsamples=0
 endif
 `
 rem debug, alter light ray sun object's rotation
 if lrdebugdeactive=0
  if keystate(201)=1 then inc rotvar#,0.1
  if keystate(209)=1 then dec rotvar#,0.1
 endif
 `
 rem update light ray sun object
 position object 99000,camera position x(0),camera position y(0),camera position z(0)
 rotate object 99000,-32.5,0+rotvar#,0
 move object 99000,2000
 rem update light ray scatter object
 position object 99001,camera position x(0),camera position y(0),camera position z(0)
 rotate object 99001,camera angle x(0),camera angle y(0),camera angle z(0)
 `
 rem update light ray camera
 position camera RayCam,camera position x(0),camera position y(0),camera position z(0)
 rotate camera RayCam,camera angle x(0),camera angle y(0),camera angle z(0)
return

Setup_Bloom:
 global fov : fov=75
 global Sw# : Sw#=gdisplaywidth
 global Sh# : Sh#=gdisplayheight
 dis#=(sh#/2)/tan(fov/2)
 global bloom_cam : bloom_cam=Find_Free_Camera()
 global bloom_img : bloom_img=50
 global bloom_obj : bloom_obj=50
 global cameranumbervar : cameranumbervar=0
 global lrbloomobjactive : lrbloomobjactive=0
 `
 rem make and setup bloom camera
 make camera bloom_cam
 set camera to image bloom_cam,bloom_img,sw#,sh#,2
 set camera range bloom_cam,3,realrange#
 set camera fov bloom_cam,realfov# : rem fov
 set camera aspect bloom_cam,realaspect# : rem (sw#/sh#)
 `
 rem make and setup bloom object
 `make object plain bloom_obj+2,-1920/400,1080/400//-sw#/(400),sh#/(400)
 make object plain bloom_obj+2,4.8,2
 load effect "effectbank\ps_2_0\post-bloom.fx",bloom_obj+2,0,1
 texture object bloom_obj+2,0,bloom_img
 set object effect bloom_obj+2,bloom_obj+2
 set object transparency bloom_obj+2,1
return

Update_Bloom:
 rem debug, display bloom camera image
 if lrdebugdeactive=0
  if keystate(3)=1
   paste image bloom_img,0,0
  endif
 endif
 `
 rem toggle bloom on and off
 if lrswitchbloomactive=1
  if lrbloomactive=1
   set camera to image bloom_cam,bloom_img,sw#,sh#,2
   lrbloomobjactive=1
  else
   set camera to image bloom_cam,bloom_img,1,1,2
   lrbloomobjactive=0
  endif
  lrswitchbloomactive=0
 endif
 `
 rem update bloom camera
 position camera bloom_cam,camera position x(),camera position y(),camera position z()
 rotate camera bloom_cam,camera angle x(),camera angle y(),camera angle z()
 `
 rem update bloom object
 dis#=(sh#/2)/tan(fov/2)
 position object bloom_obj+2,camera position x(),camera position y(),camera position z()
 rotate object bloom_obj+2,camera angle x(),camera angle y(),camera angle z()
 move object bloom_obj+2,dis#/400
 move object up bloom_obj+2,0.01
 move object left bloom_obj+2,0.01
 scale object bloom_obj+2,101,101,0
return

function SyncAll()
 rem update light rays only
 if lgmodraysactive=1
  rem update light rays
  gosub Update_LightRays
  `
  rem create black effect for all unlit parts of the level
  for blackeffects=effectbankoffset to effectbankoffset+effectbankmax
   if blackeffects<>0
    if effect exist(blackeffects)=1
     set effect technique blackeffects,"RenderColor"
    endif
   endif
  next blackeffect
  `
  rem hide skybox, scatter plane, and water plane for camera render
  if object exist(65123)=1 then hide object 65123
  if object exist(65124)=1 then hide object 65124
  hide object 99001
  Rem Scene Commander - only deal with water plane if water is on.
  `if wateron=1
 ` hide object waterobj
  `endif
 if wateron=1 then show object waterobj `s4real fix plane showing up.

  `
  rem mask all hudbankoffset object for raycamera render
  for o=hudbankoffset to hudbankoffset+31
   if object exist(o)=1
    set object mask o,2^0
   endif
  next o
  `
  rem mask all decals from raycamera render
  for f=1 to decalelementmax
   tobj=decalelementoffset+f
   if object exist(tobj)=1
    set object mask tobj,(2^0)
   endif
  next f
  `
  rem render RayCam
  sync mask 2^RayCam : fastsync
  `
  rem show skybox, scatter plane, and water plane for camera render
  if object exist(65123)=1 then show object 65123
  if object exist(65124)=1 then show object 65124
  show object 99001
  Rem Scene Commander - only deal with water plane if water is on.
 ` if wateron=1
 ` show object waterobj
 ` endif
  if wateron=1 then show object waterobj `s4real fix plane showing up.

  `
  rem set new black effect technique
  for blackeffects=effectbankoffset to effectbankoffset+effectbankmax
   if blackeffects<>0
    if effect exist(blackeffects)=1
     set effect technique blackeffects,"dx9textured"
    endif
   endif
  next blackeffect
  `
  rem render remaining cameras
  sync mask 2^1
  sync mask 2^0
  set current camera 0:sync

 endif
 `
 rem update light rays and bloom
 if lgmodraysactive=2
  rem update light rays
  gosub Update_LightRays
  rem update bloom
  gosub Update_Bloom
  `
  rem create black effect for all unlit parts of the level
  for blackeffects=effectbankoffset to effectbankoffset+effectbankmax
   if blackeffects<>0
    if effect exist(blackeffects)=1
     set effect technique blackeffects,"RenderColor"
    endif
   endif
  next blackeffect
  `
  rem mask skybox
  if object exist(65123)=1 then set object mask 65123,(2^0)+(2^bloom_cam)
  if object exist(65124)=1 then set object mask 65124,(2^0)+(2^bloom_cam)
  rem hide bloom plane, scatter plane, and water plane for camera render
  hide object 52
  hide object 99001
  hide object waterobj
  `
  rem mask all hudbankoffset object for raycamera render
  for o=hudbankoffset to hudbankoffset+31
   if object exist(o)=1
    set object mask o,%1+(1 << RayCam)
   endif
  next o
  `
  rem mask all decals from raycamera render
  for f=1 to decalelementmax
   tobj=decalelementoffset+f
   if object exist(tobj)=1
    set object mask tobj,(2^0)+(2^bloom_cam)
   endif
  next f
  `
  rem render RayCam
  sync mask 2^RayCam : fastsync
  `
  rem show scatter plane, and water plane for camera render
  show object 99001
  show object waterobj
  `
  rem set new black effect technique
  for blackeffects=effectbankoffset to effectbankoffset+effectbankmax
   if blackeffects<>0
    if effect exist(blackeffects)=1
     set effect technique blackeffects,"dx9textured"
    endif
   endif
  next blackeffect
  `
  rem render remaining cameras
  sync mask 2^bloom_cam : fastsync
  sync mask 2^2
  sync mask 2^1
  if lrbloomobjactive=1 then show object 52
  sync mask 2^0
  set current camera 0 : sync
 endif
endfunction

function CreateLGMod()
 if lgmodraysactive=1 then gosub Setup_LightRays
 if lgmodraysactive=2
  gosub Setup_Bloom
  gosub Setup_LightRays
 endif
endfunction

function Find_Free_Camera()
 for c=1 to 32
  if camera exist(c)=0 then exitfunction c
 next c
endfunction c

function CalcLightDirX(objang#)
 ldirang#=-0.75*sin(objang#)
endfunction ldirang#

function CalcLightDirZ(objang#)
 ldirang#=-0.75*cos(objang#)
endfunction ldirang#

rem Scene commander special fast paste for numerics
function specialpaste(x,y,newpaste$)

ink rgb(255,255,255),0
done=0
for hudid=1 to hudmax

   if hud(hudid).maintype=6 and done=0
    rem NUMERIC
    for tt=1 to len(newpaste$)
     ttnum=-1
     if mid$(newpaste$,tt)="." then ttnum=10
     if mid$(newpaste$,tt)="\" then ttnum=11
     if ttnum=-1 then ttnum=asc(mid$(newpaste$,tt))-asc("0")
     if ttnum<>-1
      ttnumy=ttnum/4 : ttnum=ttnum-(ttnumy*4) : ttbitx#=(1.0/64.0)*16 : ttbity#=(1.0/64.0)*16
      if hud(hudid).image>0
       set sprite texture coord hudid,0,(ttbitx#*ttnum),(ttbity#*ttnumy)
       set sprite texture coord hudid,1,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)
       set sprite texture coord hudid,2,(ttbitx#*ttnum),(ttbity#*ttnumy)+ttbity#
       set sprite texture coord hudid,3,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)+ttbity#
       paste sprite hudid,x+((tt-1)*12),y
      endif
      endif

    next tt
    done=1
    endif
    if done<>0 then exitfunction
    next hudid

    endfunction

    function displayobjective()

   rem display isobjective direction

   if istheobjective=0 or objectivemode=0
   if sprite exist(objectiveobject)
   hide sprite objectiveobject
   endif
   exitfunction
   endif

   if istheobjective>0 and object exist(physicsplayerborble)=1

   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(istheobjective).x-tcamx#
   tdy#=entityelement(istheobjective).y+(object size(entityelement(istheobjective).obj)/2)-tcamy#
   tdz#=entityelement(istheobjective).z-tcamz#

   howfar=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   howfar=int(howfar/25)

      if howfar<>1 then howfar=howfar*2

      if howfar<1 then howfar=1
      entityelement(istheobjective).objectivecurrentrange=howfar
      if howfar>entityelement(istheobjective).objectiveradarrange then exitfunction
      rem calculate player and objective level for objective mode=2
      playerlevel=int(object position y(physicsplayerborble))/100
      if playerlevel<0 then playerlevel=0
      if playerlevel>19 then playerlevel=19

      objectivelevel=int(entityelement(istheobjective).y)/100
      if objectivelevel<0 then objectivelevel=0
      if objectivelevel>19 then objectivelevel=19
      rem find the angle.
      fundx#=entityelement(istheobjective).x-camera position x()
      fundy#=camera position z()-entityelement(istheobjective).z
      funangle#=atanfull(fundy#,fundx#)
      rrr#=funangle#-camera angle y()

      if sprite exist(objectiveobject)=1

         if objectivemode=1 or (objectivemode=2 and playerlevel=objectivelevel)
         show sprite objectiveobject
         paste sprite objectiveobject,objectivex+(cos(rrr#)*howfar),objectivey+(sin(rrr#)*howfar)
         endif
     endif

      if entityelement(istheobjective).health<=0 then istheobjective=0

   endif

rem end is o

    endfunction

function culling(e,entid,obj)

 `text 200,200,str$(timeelapsed#)

 Rem Scene commander, check for dead entities on a delayed death timer.
if timer()-entityelement(e).delaydestroytimer>entityelement(e).delaydestroy
   if entityelement(e).delaytimeactive=1
   entityelement(e).delaytimeactive=0
   gosub _killentity
   endif
endif
   ` text 200,200,str$(weaponammo(weaponammoindex+ammooffset))
 rem if not just using FPSC default culling
if gmultiplayergame<>1 and cullmode<>0

rem get player position
 tcamx#=object position x(physicsplayerborble)
 tcamy#=object position y(physicsplayerborble)
 tcamz#=object position z(physicsplayerborble)

`for e=1 to entityelementlist
`entid=entityelement(e).bankindex
`obj=entityelement(e).obj

rem only check entities not hidden by system and those that are active
hiddenbackup=entityelement(e).ishidden

if entityelement(e).activated=0 and entityelement(e).spawn.atstart=0
 entityelement(e).ishidden=2
 else
   entityelement(e).ishidden=hiddenbackup
 endif

if entityelement(e).ishidden<>2


remstart
if lx#>30 then lx#=30
if lx#<-30 then lx#=-30
if ly#>30 then ly#=30
if ly#<-30 then ly#=-30
if lz#>30 then lz#=30
if lz#<-30 then lz#=-30

ode set linear velocity obj,lx#,ly#,lz#
remend

`plx#=ode get body linear velocity x(physicsplayerborble)
`ply#=ode get body linear velocity y(physicsplayerborble)
`plz#=ode get body linear velocity z(physicsplayerborble)

`if plx#>pmaxX# then pmaxX#=plx#
`if ply#>pmaxY# then pmaxY#=ply#
`if plz#>pmaxZ# then pmaxZ#=plz#

`text 200,200,str$(plx#)+" "+str$(pmaxX#)
`text 200,220,str$(ply#)+" "+str$(pmaxY#)
`text 200,240,str$(plz#)+" "+str$(pmaxZ#)



            if obj>0

            `text object screen x(obj),object screen y(obj),str$(edistance(e))

            seeit=0
            Rem get is object on screen
               if object exist(obj) then seeit=object in screen(obj)

                  if entityelement(e).eleprof.physics=3 and entityelement(e).eleprof.isimmobile=1 and entityelement(e).cullimmobile=1 then entityelement(e).eleprof.physics=99


                  rem doors and windows, characters and the dead excluded from the cull.
                  `if object exist(obj) and (entityprofile(entid).ischaracter<>1 and entityelement(e).eleprof.physics<>3 and seeit=1)
                  if seeit=1

         Rem get object distance

                  if entityelement(e).eleprof.physics=99 then entityelement(e).eleprof.physics=3

                 ` text object screen x(obj),object screen y(obj),str$(entityprofile(entid).scale)

                 tdx#=object position x(obj)-tcamx#
                 tdy#=object position y(obj)+(object size(obj)/2)-tcamy#
                 tdz#=object position z(obj)-tcamz#
                 `edistance(e)
                  howfar=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))

                  `size adjustment, arrived at through experimentation and is approximately cullmodi*100=1 segment
                  sizeis=int(object size(obj)/10)
                  rem cullmodi allows user adjustment to global entity culling
                  sizeis=sizeis*cullmodi


                        if sizeis>hudfognear and hudfogon=1 then sizesis=hudfognear
                        if waterfognear<sizeis and waterfogon>0 then sizeis=waterfognear
                        rem if entity has user defined cull then use that
                     if entityelement(e).cullstate>3 then sizeis=entityelement(e).cullstate

                        Rem Scene Commnader, do not cull if object in motion or if really close or set to always show.
                        lx#=ode get body linear velocity x(obj)
                        ly#=ode get body linear velocity y(obj)
                        lz#=ode get body linear velocity z(obj)

                        if int(lx#)<>0 or int(ly#)<>0 or int(lz#)<>0 or howfar<500 or entityelement(e).cullstate=2
                              show object obj
                              entityelement(e).ishidden=0
                              exitfunction
                        endif

                     Rem Scene Commander, with newer culling additions, alpha fading isn't so important, so now isn't a default setting to improve performance.
                           if entityelement(e).usefade=1
                              fade=abs(howfar-sizeis)
                              else
                              fade=100
                           endif

                           if entityelement(e).ishidden<>3 and entityelement(e).cullstate<>2
                              if fade<=entityelement(e).ai.destalphafade and fade<101
                              set alpha mapping on obj,fade
                              endif
                           endif



                           if howfar>=sizeis or entityelement(e).cullstate=3 or seeit=0
                           hide object obj
                           entityelement(e).ishidden=1
                           exitfunction
                           endif

                              if howfar<sizeis
                              show object obj
                              entityelement(e).ishidden=0

                              endif

                        endif


         rem close obj 'cullable'
`text object screen x(obj),object screen y(obj),str$(obj)

         endif

      rem close obj exist

      endif

endif

`  next e

  rem close if no culling
  `endif

endfunction

function edistance(te)

entobj=entityelement(te).obj
   if entobj>0 and physicsplayerborble>0

   tcamx#=object position x(physicsplayerborble)
   tcamy#=object position y(physicsplayerborble)
   tcamz#=object position z(physicsplayerborble)

   tdx#=entityelement(te).x-tcamx#
   tdy#=entityelement(te).y+(object size(entobj)/2)-tcamy#
   tdz#=entityelement(te).z-tcamz#
   plrdistance#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   else
   plrdistance#=9999999
   endif

   endfunction


function alterlimbscale(en,lm,ls)

tempobj=entityelement(en).obj
if tempobj>0
if object exist(tempobj)
 select lm
 case 1
  if limb exist(tempobj,entityprofile(entityelement(en).bankindex).headlimb)

  scale limb tempobj,entityprofile(entityelement(en).bankindex).headlimb,ls,ls,ls

  endif
 endcase

 case 2
  if limb exist(tempobj,entityelement(en).LC)
  scale limb tempobj,entityelement(en).LC,ls,ls,ls

  endif
 endcase
 case 3
  if limb exist(tempobj,entityelement(en).RC)
  scale limb tempobj,entityelement(en).RC,ls,ls,ls

  endif
 endcase
 case 4
  if limb exist(tempobj,entityelement(en).LF)
  scale limb tempobj,entityelement(en).LF,ls,ls,ls

  endif
 endcase
 case 5
  if limb exist(tempobj,entityelement(en).RF)
  scale limb tempobj,entityelement(en).RF,ls,ls,ls

  endif
 endcase
case 6
  if limb exist(tempobj,entityelement(en).LT)
  scale limb tempobj,entityelement(en).LT,ls,ls,ls

  endif
 endcase
 case 7
  if limb exist(tempobj,entityelement(en).RT)
  scale limb tempobj,entityelement(en).RT,ls,ls,ls

  endif
 endcase
 case 8
  if limb exist(tempobj,entityelement(en).LH)
  scale limb tempobj,entityelement(en).LH,ls,ls,ls

  endif
 endcase
 case 9
  if limb exist(tempobj,entityelement(en).RH)
  scale limb tempobj,entityelement(en).RH,ls,ls,ls

  endif
 endcase
 case 10
  if limb exist(tempobj,entityelement(en).LFA)
  scale limb tempobj,entityelement(en).LFA,ls,ls,ls

  endif
 endcase
 case 11
  if limb exist(tempobj,entityelement(en).RFA)
  scale limb tempobj,entityelement(en).RFA,ls,ls,ls
  endif
 endcase
 case 12
  if limb exist(tempobj,entityelement(en).LUA)
  scale limb tempobj,entityelement(en).LUA,ls,ls,ls

  endif
 endcase
 case 13
  if limb exist(tempobj,entityelement(en).RUA)
  scale limb tempobj,entityelement(en).RUA,ls,ls,ls

  endif
 endcase

 case 14
  if limb exist(tempobj,entityprofile(en).spine)
  scale limb tempobj,entityprofile(en).spine,ls,ls,ls

  endif
 endcase
 case 15
  if limb exist(tempobj,entityprofile(en).spine2)
  scale limb tempobj,entityprofile(en).spine2,ls,ls,ls

  endif
 endcase
 case 16
  if limb exist(tempobj,entityelement(en).SP3)
  scale limb tempobj,entityelement(en).SP3,ls,ls,ls

  endif
 endcase
case 17
  if limb exist(tempobj,entityelement(en).NECK)
  scale limb tempobj,entityelement(en).NECK,ls,ls,ls

  endif

endcase
 endselect
endif
endif
endfunction

_create_blood:
 decalid=entitydecal(entityelement(damagede).bankindex,1)
 if decalid>0
  distx#=tdamagex#-entityelement(damagede).x
  disty#=tdamagey#-entityelement(damagede).y
  distz#=tdamagez#-entityelement(damagede).z
  bldist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))

  rem direction from player to entity
  tix#=entityelement(damagede).x-tdamagex# : tiy#=entityelement(damagede).y-tdamagey# : tiz#=entityelement(damagede).z-tdamagez#
  tdd#=sqrt(abs(tix#*tix#)+abs(tiy#*tiy#)+abs(tiz#*tiz#))
  tix#=tix#/tdd# : tiy#=tiy#/tdd# : tiz#=tiz#/tdd#
  rem find point of impact
  if nocalcpoi=0
   tix#=tix#*(bldist#-10.0)
   tiy#=tiy#*(bldist#-10.0)
   tiz#=tiz#*(bldist#-10.0)
  else
   tix#=1
   tiy#=1
   tiz#=1
  endif

  rem create a splat decal
  decalscalemodx=0 : rem FPSCV101 - fix
  if middlebody=1
   decaly=((entityelement(damagede).y+(object size y(entityelement(damagede).obj)/2))-rnd(6))+tiy#
  else
   decaly=tdamagey#+tiy#
  endif
  decalorient=0 : decalx=tdamagex#+tix# : decalz=tdamagez#+tiz#

  originatore=-1 : gosub _decalelement_create
 endif
 middlebody=0
return

createdestroy_physics_e:
 if entityelement(createdestroye).obj<=0 then return
 if object exist(entityelement(createdestroye).obj)=0 then return

 tempe=e : e=createdestroye
 tempobj=obj : obj=entityelement(e).obj
 select createdestroymode
  case 1:
   entityelement(e).collisionactive=0
   if entityelement(e).eleprof.physics<>0
    gosub _ode_switchoffe
   else
    set object collision off obj
   endif
  endcase
  case 2:
   rem entity collision solid
   entityelement(e).collisionactive=1
   rem activate object collision
   if entityelement(e).eleprof.physics<>0
    gosub _ode_setupewithphysics
    gosub _ode_ensureeisnotpenetrated
   else
    set object collision on obj
   endif
   rem ensure plr is pushed out of entity influence
   tdx#=mex#-entityelement(e).x
   tdz#=mez#-entityelement(e).z
   tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
   if tdd#<30.0
    tda#=atanfull(tdx#,tdz#)
    camforcex#=newxvalue(entityelement(e).x,tda#,30.0)-camerapositionx
    camforcez#=newzvalue(entityelement(e).z,tda#,30.0)-camerapositionz
   endif
   rem ensure ALL entities are pushed out of entity influence (this is why second door zoomed away)
   for te=1 to entityelementlist
    if entityelement(te).active=1 and entityelement(te).eleprof.physics<=2
     if entityelement(te).eleprof.isimmobile=0
      tdx#=entityelement(te).x-entityelement(e).x
      tdz#=entityelement(te).z-entityelement(e).z
      tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
      if tdd#<30.0
       rem TE-entity within solid entity
       tda#=atanfull(tdx#,tdz#)
       entityelement(te).mover.dx=newxvalue(entityelement(e).x,tda#,30.0)
       entityelement(te).mover.dz=newzvalue(entityelement(e).z,tda#,30.0)
       entityelement(te).mover.dy=entityelement(e).y
       entityelement(te).mover.moved=1
       entityelement(te).mover.run=0
      endif
     endif
    endif
   next te
  endcase
 endselect
 e=tempe
 obj=tempobj
return

_flashlight_control:

if light exist(3)=0
make light 3
set spot light 3,0,180
hide light 3
endif


flashred=flashlightred
flashgreen=flashlightgreen
flashblue=flashlightblue
flashrange=flashlightrange


if flashlighton<>0

set light range 3,flashrange
color light 3,rgb(flashred,flashgreen,flashblue)

position light 3,object position x(physicsplayerborble),object position y(physicsplayerborble),object position z(physicsplayerborble)
rotate light 3, camera angle x(), camera angle y(), camera angle z()
show light 3

else
hide light 3
endif

return

_stickyflakplacement:

         x1#=flakelement(f).xpos
         y1#=flakelement(f).ypos
         z1#=flakelement(f).zpos
         position object hudbankoffset+3,x1#,y1#,z1#
         tca#=rnd(360000.0)/1000.0
         tcx#=cos(tca#) : tcy#=sin(tca#)
         tcm#=rnd(trayaccuracy#*1000.0)/1000.0 : tcx#=tcx#*tcm# : tcy#=tcy#*tcm#
         rotate object hudbankoffset+3, camera angle x()+tcy#,camera angle y()+tcx#,camera angle z()

         move object hudbankoffset+3,50
         disable object zdepth hudbankoffset+3
         x2#=object position x(hudbankoffset+3)
         y2#=object position y(hudbankoffset+3)
         z2#=object position z(hudbankoffset+3)
   `
   `
   rem raycast to surface (bullets path)
   dstwallhit#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
   if dstwallhit#>0
      flakelement(f).xpos=checklist fvalue a(6)
      flakelement(f).ypos=checklist fvalue b(6)
      flakelement(f).zpos=checklist fvalue c(6)
      position object tobj,flakelement(f).xpos,flakelement(f).ypos,flakelement(f).zpos
   endif

return

_killentity:

rem deactivate and hide entity (beenkilled used by spawner)
      entityelement(e).beenkilled=1
      entityelement(e).active=0
      rem FPGC - 140809 - also reset AI script (so saveload removes entity completely on reload)
      entityelement(e).ai.libindex=entityelement(e).ai.libinit
      if obj>0
       if entityelement(e).eleprof.physics<>0
        gosub _ode_switchoffe
       else
        set object collision off obj
       endif
       hide object obj:entityelement(e).ishidden=2
      endif
      rem stop any looping sound
      gosub _ai_stopentsounds
      rem clear entity from col map
      tx=entityelement(e).x/25
      ty=entityelement(e).y/100
      tz=entityelement(e).z/-25
      if tx>=0 and ty>=0 and tz>=0
       if tx<=viscolx and ty<=viscoly and tz<=viscolz
        if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
       endif
      endif

    return

















